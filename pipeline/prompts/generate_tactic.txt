You are an expert Lean 4 developer specializing in metaprogramming and tactic development.

## Task
Generate a Lean 4 tactic based on the following specification.

## Tactic Specification:
{specification}

## Configuration:
- Use Mathlib: {use_mathlib}

## Lean 4 Tactic Programming Guide

Reference: https://github.com/mirefek/lean-tactic-programming-guide

### Core Concepts

A proof in Lean is a term with holes called metavariables. Most tactic steps fill one hole by assigning a metavariable, continuing until all goals are closed.

### Key Data Structures

- `Lean.Expr`: Represents Lean expressions, types, and proofs
- `Qq` library: Provides convenient notation for building expressions
- `MVarId`: Metavariable identifier (represents a goal)
- `FVarId`: Free variable identifier (local hypotheses)
- `TacticM`: The tactic monad

### Basic Imperative Programming

```lean
def myCode : Lean.Elab.Tactic.TacticM Unit := do
  Lean.logInfo "Running tactic"
  let goal ← getMainGoal
  -- do something with goal
```

### Tactic Implementation Examples

```lean
import Lean
import Qq

open Lean Meta Elab.Tactic Qq

-- Close a goal of type True
def runTrivial : TacticM Unit := do
  let goal : MVarId ← getMainGoal
  try
    goal.assignIfDefEq q(True.intro)
  catch _ =>
    let goalType ← goal.getType
    throwError "tactic runTrivial failed, goal has type `{{goalType}}` not `True`"

-- Search local context for matching assumption
def runAssumption : TacticM Unit :=
  withMainContext do
    let goal ← getMainGoal
    let ctx ← getLCtx
    for (decl : LocalDecl) in ctx do
      if decl.kind != .default then continue
      try
        goal.assignIfDefEq (Expr.fvar decl.fvarId)
        return
      catch _ =>
        pure ()
    throwError "Assumption not found"

-- Split And goal into two subgoals
def runConstructor : TacticM Unit := do
  withMainContext do
    let goal ← getMainGoal
    let goalType ← goal.getType
    let_expr And a b := goalType | throwError "Goal not of form `_ ∧ _`"
    let left ← mkFreshExprSyntheticOpaqueMVar a (tag := `left)
    let right ← mkFreshExprSyntheticOpaqueMVar b (tag := `right)
    goal.assign (← mkAppM ``And.intro #[left, right])
    replaceMainGoal [left.mvarId!, right.mvarId!]

-- Introduce a forall/implication
def runIntro (name : Name) : TacticM Unit :=
  withMainContext do
    let goal ← getMainGoal
    let lctx ← getLCtx
    let .forallE _ type body c ← goal.getType
      | throwError "Goal not of form `_ → _` or `∀ _, _`"
    let fvarId : FVarId ← mkFreshFVarId
    let lctx' := lctx.mkLocalDecl fvarId name type c
    let fvar : Expr := .fvar fvarId
    let body := body.instantiate1 fvar
    withLCtx lctx' (← getLocalInstances) do
      let newMVar ← mkFreshExprSyntheticOpaqueMVar body
      let newVal ← mkLambdaFVars #[fvar] newMVar
      goal.assign newVal
      replaceMainGoal [newMVar.mvarId!]
```

### Syntax and Elaboration

Three ways to define tactic syntax:

```lean
-- 1. Simple macro (delegates to existing tactics)
macro "my_trivial" : tactic => `(tactic| exact True.intro)
macro "my_constructor" : tactic => `(tactic| apply And.intro)

-- 2. Direct elab (custom implementation)
elab "my_assumption" : tactic => runAssumption

elab "my_intro" a:ident : tactic => do
  let aName : Name := a.getId
  runIntro aName

-- 3. Separate syntax and elaboration rules
syntax "my_intro'" ident : tactic

elab_rules : tactic
| `(tactic| my_intro' $h:ident) => runIntro h.getId
```

### Working with Terms and Types

```lean
-- Elaborate a term from syntax
elab "my_check" e:term : tactic => do
  withMainContext do
    let e : Expr ← elabTerm e none
    let t ← inferType e
    Lean.logInfo m!"{{e}} : {{t}}"

-- Run another tactic
elab "my_wrapper" : tactic => do
  evalTactic (← `(tactic| simp))
```

### Common Patterns

```lean
-- Get goal type and match against structure
withMainContext do
  let goal ← getMainGoal
  let goalType ← goal.getType
  -- Pattern match on goalType

-- Iterate over local context
let ctx ← getLCtx
for decl in ctx do
  let fvarType ← inferType (Expr.fvar decl.fvarId)
  -- do something with each hypothesis

-- Create new goals
let newGoal ← mkFreshExprSyntheticOpaqueMVar targetType
replaceMainGoal [newGoal.mvarId!]

-- Assign proof term to goal
goal.assign proofExpr

-- IMPORTANT: For recursive helper functions in tactics, use `partial` to avoid termination issues:
partial def helper (args : ...) : TacticM ... := do
  -- recursive implementation
```

{mathlib_section}

## Requirements
1. The tactic must compile without errors
2. Include proper imports: `import Lean` and optionally `import Qq`
3. Use `open Lean Meta Elab.Tactic` for convenience
4. Add a doc comment explaining what the tactic does
5. Do NOT include test theorems - tests will be generated separately

## Output Format

The file MUST follow this exact structure:

```lean
import Lean
open Lean Meta Elab.Tactic

/-!
# Tactic: tactic_name

## Mathematical Specification
[Copy the Mathematical Specification from the analysis here verbatim]

## Algorithm
[Copy the Algorithm description from the analysis here]
-/

/-- Brief description of what the tactic does. -/
def tactic_name : TacticM Unit := do
  -- Implementation here
  ...
```

**IMPORTANT:**
- Always include the module doc comment (`/-! ... -/`) with the Mathematical Specification and Algorithm from the analysis
- This specification serves as the formal contract for what the tactic should prove

**CRITICAL RESTRICTIONS - MUST FOLLOW:**
- Define the tactic as a `def tactic_name : TacticM Unit` function
- Do NOT define `run_tac` or any other custom tactic syntax (no `syntax`, `elab`, `macro`)
- Do NOT include any test theorems or examples
- The file should end after the tactic definition - nothing else
- For recursive helper functions, use `partial def` to avoid termination issues

Return ONLY the Lean 4 code, starting with imports. Do not include any markdown code blocks or explanations outside the code.
