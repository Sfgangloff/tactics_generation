{
  "Sigma": {
    "name": "Sigma",
    "type": "structure",
    "signature": "Sigma",
    "docstring": "Dependent pairs, in which the second element's type depends on the value of the first element. The type `Sigma β` is typically written `Σ a : α, β a` or `(a : α) × β a`. Although its values are pairs, `Sigma` is sometimes known as the *dependent sum type*, since it is the type level version of an indexed summation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Core.lean",
    "line_number": 228,
    "source": "core"
  },
  "PSigma": {
    "name": "PSigma",
    "type": "structure",
    "signature": "PSigma",
    "docstring": "Fully universe-polymorphic dependent pairs, in which the second element's type depends on the value of the first element and both types are allowed to be propositions. The type `PSigma β` is typically written `Σ' a : α, β a` or `(a : α) ×' β a`. In practice, this generality leads to universe level constraints that are difficult to solve, so `PSigma` is rarely used in manually-written code. It is usually only used in automation that constructs pairs of arbitrary types. To pair a value with a proof that a predicate holds for it, use `Subtype`. To demonstrate that a value exists that satisfies a predicate, use `Exists`. A dependent pair with a proposition as its first component is not typically useful due to proof irrelevance: there's no point in depending on a specific proof because all proofs are equal anyway.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Core.lean",
    "line_number": 263,
    "source": "core"
  },
  "Sum": {
    "name": "Sum",
    "type": "inductive",
    "signature": "Sum",
    "docstring": "The disjoint union of types `α` and `β`, ordinarily written `α ⊕ β`. An element of `α ⊕ β` is either an `a : α` wrapped in `Sum.inl` or a `b : β` wrapped in `Sum.inr`. `α ⊕ β` is not equivalent to the set-theoretic union of `α` and `β` because its values include an indication of which of the two types was chosen. The union of a singleton set with itself contains one element, while `Unit ⊕ Unit` contains distinct values `inl ()` and `inr ()`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Core.lean",
    "line_number": 174,
    "source": "core"
  },
  "Decidable.or_not_self": {
    "name": "Decidable.or_not_self",
    "type": "abbrev",
    "signature": "Decidable.or_not_self",
    "docstring": "Excluded middle. Added as alias for Decidable.em",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/PropLemmas.lean",
    "line_number": 433,
    "source": "core"
  },
  "Decidable.not_and_iff_or_not_not": {
    "name": "Decidable.not_and_iff_or_not_not",
    "type": "abbrev",
    "signature": "Decidable.not_and_iff_or_not_not",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/PropLemmas.lean",
    "line_number": 547,
    "source": "core"
  },
  "Decidable.or_iff_not_and_not": {
    "name": "Decidable.or_iff_not_and_not",
    "type": "abbrev",
    "signature": "Decidable.or_iff_not_and_not",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/PropLemmas.lean",
    "line_number": 561,
    "source": "core"
  },
  "Decidable.and_iff_not_or_not": {
    "name": "Decidable.and_iff_not_or_not",
    "type": "abbrev",
    "signature": "Decidable.and_iff_not_or_not",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/PropLemmas.lean",
    "line_number": 568,
    "source": "core"
  },
  "Nat.add": {
    "name": "Nat.add",
    "type": "def",
    "signature": "Nat.add : (@& Nat) → (@& Nat) → Nat",
    "docstring": "Addition of natural numbers, typically used via the `+` operator. This function is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1689,
    "source": "core"
  },
  "Nat.mul": {
    "name": "Nat.mul",
    "type": "def",
    "signature": "Nat.mul : (@& Nat) → (@& Nat) → Nat",
    "docstring": "Multiplication of natural numbers, usually accessed via the `*` operator. This function is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1708,
    "source": "core"
  },
  "Nat.pow": {
    "name": "Nat.pow",
    "type": "def",
    "signature": "Nat.pow : (@& Nat) → Nat",
    "docstring": "The power operation on natural numbers, usually accessed via the `^` operator. This function is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1723,
    "source": "core"
  },
  "Nat.beq": {
    "name": "Nat.beq",
    "type": "def",
    "signature": "Nat.beq : (@& Nat) → (@& Nat) → Bool",
    "docstring": "Boolean equality of natural numbers, usually accessed via the `==` operator. This function is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1737,
    "source": "core"
  },
  "Nat.decEq": {
    "name": "Nat.decEq",
    "type": "def",
    "signature": "Nat.decEq : Decidable (Eq n m)",
    "docstring": "A decision procedure for equality of natural numbers, usually accessed via the `DecidableEq Nat` instance. This function is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model. Examples: * `Nat.decEq 5 5 = isTrue rfl` * `(if 3 = 4 then \"yes\" else \"no\") = \"no\"` * `show 12 = 12 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1773,
    "source": "core"
  },
  "Nat.ble": {
    "name": "Nat.ble",
    "type": "def",
    "signature": "Nat.ble : @& Nat → @& Nat → Bool",
    "docstring": "The Boolean less-than-or-equal-to comparison on natural numbers. This function is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model. Examples: * `Nat.ble 2 5 = true` * `Nat.ble 5 2 = false` * `Nat.ble 5 5 = true`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1793,
    "source": "core"
  },
  "Nat.lt": {
    "name": "Nat.lt",
    "type": "def",
    "signature": "Nat.lt : Prop",
    "docstring": "Strict inequality of natural numbers, usually accessed via the `<` operator. It is defined as `n < m = n + 1 ≤ m`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1816,
    "source": "core"
  },
  "Nat.pred": {
    "name": "Nat.pred",
    "type": "def",
    "signature": "Nat.pred : (@& Nat) → Nat",
    "docstring": "The predecessor of a natural number is one less than it. The predecessor of `0` is defined to be `0`. This definition is overridden in the compiler with an efficient implementation. This definition is the logical model.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1871,
    "source": "core"
  },
  "Nat.sub": {
    "name": "Nat.sub",
    "type": "def",
    "signature": "Nat.sub : (@& Nat) → (@& Nat) → Nat",
    "docstring": "Subtraction of natural numbers, truncated at `0`. Usually used via the `-` operator. If a result would be less than zero, then the result is zero. This definition is overridden in both the kernel and the compiler to efficiently evaluate using the arbitrary-precision arithmetic library. The definition provided here is the logical model. Examples: * `5 - 3 = 2` * `8 - 2 = 6` * `8 - 8 = 0` * `8 - 20 = 0`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1996,
    "source": "core"
  },
  "System.Platform.numBits": {
    "name": "System.Platform.numBits",
    "type": "def",
    "signature": "System.Platform.numBits : Nat",
    "docstring": "The word size of the current platform, which may be 64 or 32 bits.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2017,
    "source": "core"
  },
  "BitVec.decEq": {
    "name": "BitVec.decEq",
    "type": "def",
    "signature": "BitVec.decEq : Decidable (Eq x y)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2092,
    "source": "core"
  },
  "BitVec.toNat": {
    "name": "BitVec.toNat",
    "type": "def",
    "signature": "BitVec.toNat : Nat",
    "docstring": "Return the underlying `Nat` that represents a bitvector. This is O(1) because `BitVec` is a (zero-cost) wrapper around a `Nat`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2112,
    "source": "core"
  },
  "UInt8.ofNatLT": {
    "name": "UInt8.ofNatLT",
    "type": "def",
    "signature": "UInt8.ofNatLT : UInt8 where",
    "docstring": "Converts a natural number to an 8-bit unsigned integer. Requires a proof that the number is small enough to be representable without overflow; it must be smaller than `2^8`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2151,
    "source": "core"
  },
  "UInt8.decEq": {
    "name": "UInt8.decEq",
    "type": "def",
    "signature": "UInt8.decEq : Decidable (Eq a b)",
    "docstring": "Decides whether two 8-bit unsigned integers are equal. Usually accessed via the `DecidableEq UInt8` instance. This function is overridden at runtime with an efficient implementation. Examples: * `UInt8.decEq 123 123 = .isTrue rfl` * `(if (6 : UInt8) = 7 then \"yes\" else \"no\") = \"no\"` * `show (7 : UInt8) = 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2167,
    "source": "core"
  },
  "UInt16.ofNatLT": {
    "name": "UInt16.ofNatLT",
    "type": "def",
    "signature": "UInt16.ofNatLT : UInt16 where",
    "docstring": "Converts a natural number to a 16-bit unsigned integer. Requires a proof that the number is small enough to be representable without overflow; it must be smaller than `2^16`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2208,
    "source": "core"
  },
  "UInt16.decEq": {
    "name": "UInt16.decEq",
    "type": "def",
    "signature": "UInt16.decEq : Decidable (Eq a b)",
    "docstring": "Decides whether two 16-bit unsigned integers are equal. Usually accessed via the `DecidableEq UInt16` instance. This function is overridden at runtime with an efficient implementation. Examples: * `UInt16.decEq 123 123 = .isTrue rfl` * `(if (6 : UInt16) = 7 then \"yes\" else \"no\") = \"no\"` * `show (7 : UInt16) = 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2225,
    "source": "core"
  },
  "UInt32.ofNatLT": {
    "name": "UInt32.ofNatLT",
    "type": "def",
    "signature": "UInt32.ofNatLT : UInt32 where",
    "docstring": "Converts a natural number to a 32-bit unsigned integer. Requires a proof that the number is small enough to be representable without overflow; it must be smaller than `2^32`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2266,
    "source": "core"
  },
  "UInt32.toNat": {
    "name": "UInt32.toNat",
    "type": "def",
    "signature": "UInt32.toNat : Nat",
    "docstring": "Converts a 32-bit unsigned integer to an arbitrary-precision natural number. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2275,
    "source": "core"
  },
  "UInt32.decEq": {
    "name": "UInt32.decEq",
    "type": "def",
    "signature": "UInt32.decEq : Decidable (Eq a b)",
    "docstring": "Decides whether two 32-bit unsigned integers are equal. Usually accessed via the `DecidableEq UInt32` instance. This function is overridden at runtime with an efficient implementation. Examples: * `UInt32.decEq 123 123 = .isTrue rfl` * `(if (6 : UInt32) = 7 then \"yes\" else \"no\") = \"no\"` * `show (7 : UInt32) = 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2290,
    "source": "core"
  },
  "UInt32.decLt": {
    "name": "UInt32.decLt",
    "type": "def",
    "signature": "UInt32.decLt : Decidable (LT.lt a b)",
    "docstring": "Decides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the `DecidableLT UInt32` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (6 : UInt32) < 7 then \"yes\" else \"no\") = \"yes\"` * `(if (5 : UInt32) < 5 then \"yes\" else \"no\") = \"no\"` * `show ¬((7 : UInt32) < 7) by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2318,
    "source": "core"
  },
  "UInt32.decLe": {
    "name": "UInt32.decLe",
    "type": "def",
    "signature": "UInt32.decLe : Decidable (LE.le a b)",
    "docstring": "Decides whether one 32-bit signed integer is less than or equal to another. Usually accessed via the `DecidableLE UInt32` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (15 : UInt32) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `(if (15 : UInt32) ≤ 5 then \"yes\" else \"no\") = \"no\"` * `(if (5 : UInt32) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `show (7 : UInt32) ≤ 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2334,
    "source": "core"
  },
  "UInt64.ofNatLT": {
    "name": "UInt64.ofNatLT",
    "type": "def",
    "signature": "UInt64.ofNatLT : UInt64 where",
    "docstring": "Converts a natural number to a 64-bit unsigned integer. Requires a proof that the number is small enough to be representable without overflow; it must be smaller than `2^64`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2371,
    "source": "core"
  },
  "UInt64.decEq": {
    "name": "UInt64.decEq",
    "type": "def",
    "signature": "UInt64.decEq : Decidable (Eq a b)",
    "docstring": "Decides whether two 64-bit unsigned integers are equal. Usually accessed via the `DecidableEq UInt64` instance. This function is overridden at runtime with an efficient implementation. Examples: * `UInt64.decEq 123 123 = .isTrue rfl` * `(if (6 : UInt64) = 7 then \"yes\" else \"no\") = \"no\"` * `show (7 : UInt64) = 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2388,
    "source": "core"
  },
  "USize.ofNatLT": {
    "name": "USize.ofNatLT",
    "type": "def",
    "signature": "USize.ofNatLT : USize where",
    "docstring": "Converts a natural number to a `USize`. Requires a proof that the number is small enough to be representable without overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2442,
    "source": "core"
  },
  "USize.decEq": {
    "name": "USize.decEq",
    "type": "def",
    "signature": "USize.decEq : Decidable (Eq a b)",
    "docstring": "Decides whether two word-sized unsigned integers are equal. Usually accessed via the `DecidableEq USize` instance. This function is overridden at runtime with an efficient implementation. Examples: * `USize.decEq 123 123 = .isTrue rfl` * `(if (6 : USize) = 7 then \"yes\" else \"no\") = \"no\"` * `show (7 : USize) = 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2458,
    "source": "core"
  },
  "Char.ofNatAux": {
    "name": "Char.ofNatAux",
    "type": "def",
    "signature": "Char.ofNatAux : Char",
    "docstring": "Pack a `Nat` encoding a valid codepoint into a `Char`. This function is overridden with a native implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2503,
    "source": "core"
  },
  "Char.ofNat": {
    "name": "Char.ofNat",
    "type": "def",
    "signature": "Char.ofNat : Char",
    "docstring": "Converts a `Nat` into a `Char`. If the `Nat` does not encode a valid Unicode scalar value, `'\\0'` is returned instead.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2511,
    "source": "core"
  },
  "Char.utf8Size": {
    "name": "Char.utf8Size",
    "type": "def",
    "signature": "Char.utf8Size : Nat",
    "docstring": "Returns the number of bytes required to encode this `Char` in UTF-8.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2535,
    "source": "core"
  },
  "List.length": {
    "name": "List.length",
    "type": "def",
    "signature": "List.length : List α → Nat",
    "docstring": "The length of a list. This function is overridden in the compiler to `lengthTR`, which uses constant stack space. Examples: * `([] : List String).length = 0` * `[\"green\", \"brown\"].length = 2`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2637,
    "source": "core"
  },
  "List.lengthTRAux": {
    "name": "List.lengthTRAux",
    "type": "def",
    "signature": "List.lengthTRAux : List α → Nat → Nat",
    "docstring": "Auxiliary function for `List.lengthTR`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2642,
    "source": "core"
  },
  "List.lengthTR": {
    "name": "List.lengthTR",
    "type": "def",
    "signature": "List.lengthTR : Nat",
    "docstring": "The length of a list. This is a tail-recursive version of `List.length`, used to implement `List.length` without running out of stack space. Examples: * `([] : List String).lengthTR = 0` * `[\"green\", \"brown\"].lengthTR = 2`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2656,
    "source": "core"
  },
  "String.decEq": {
    "name": "String.decEq",
    "type": "def",
    "signature": "String.decEq : Decidable (Eq s₁ s₂)",
    "docstring": "Decides whether two strings are equal. Normally used via the `DecidableEq String` instance and the `=` operator. At runtime, this function is overridden with an efficient native implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2740,
    "source": "core"
  },
  "String.utf8ByteSize": {
    "name": "String.utf8ByteSize",
    "type": "def",
    "signature": "String.utf8ByteSize : (@& String) → Nat",
    "docstring": "The number of bytes used by the string's UTF-8 encoding. At runtime, this function takes constant time because the byte length of strings is cached.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2805,
    "source": "core"
  },
  "Array.extract": {
    "name": "Array.extract",
    "type": "def",
    "signature": "Array.extract : Array α",
    "docstring": "Returns the slice of `as` from indices `start` to `stop` (exclusive). The resulting array has size `(min stop as.size) - start`. If `start` is greater or equal to `stop`, the result is empty. If `stop` is greater than the size of `as`, the size is used instead. Examples: * `#[0, 1, 2, 3, 4].extract 1 3 = #[1, 2]` * `#[0, 1, 2, 3, 4].extract 1 30 = #[1, 2, 3, 4]` * `#[0, 1, 2, 3, 4].extract 0 0 = #[]` * `#[0, 1, 2, 3, 4].extract 2 1 = #[]` * `#[0, 1, 2, 3, 4].extract 2 2 = #[]` * `#[0, 1, 2, 3, 4].extract 2 3 = #[2]` * `#[0, 1, 2, 3, 4].extract 2 4 = #[2, 3]`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3125,
    "source": "core"
  },
  "ReaderT": {
    "name": "ReaderT",
    "type": "def",
    "signature": "ReaderT : Type (max u v)",
    "docstring": "Adds the ability to access a read-only value of type `ρ` to a monad. The value can be locally overridden by `withReader`, but it cannot be mutated. Actions in the resulting monad are functions that take the local value as a parameter, returning ordinary actions in `m`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3547,
    "source": "core"
  },
  "Nat.not_lt_zero": {
    "name": "Nat.not_lt_zero",
    "type": "theorem",
    "signature": "Nat.not_lt_zero : Not (LT.lt n 0)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1825,
    "source": "core"
  },
  "Nat.succ_le_succ": {
    "name": "Nat.succ_le_succ",
    "type": "theorem",
    "signature": "Nat.succ_le_succ : LE.le n m → LE.le (succ n) (succ m)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1832,
    "source": "core"
  },
  "Nat.zero_lt_succ": {
    "name": "Nat.zero_lt_succ",
    "type": "theorem",
    "signature": "Nat.zero_lt_succ : LT.lt 0 (succ n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1836,
    "source": "core"
  },
  "Nat.le_step": {
    "name": "Nat.le_step",
    "type": "theorem",
    "signature": "Nat.le_step : LE.le n (succ m)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1839,
    "source": "core"
  },
  "Nat.le_succ": {
    "name": "Nat.le_succ",
    "type": "theorem",
    "signature": "Nat.le_succ : LE.le n (succ n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1849,
    "source": "core"
  },
  "Nat.le_refl": {
    "name": "Nat.le_refl",
    "type": "theorem",
    "signature": "Nat.le_refl : LE.le n n",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1855,
    "source": "core"
  },
  "Nat.succ_pos": {
    "name": "Nat.succ_pos",
    "type": "theorem",
    "signature": "Nat.succ_pos : LT.lt 0 (succ n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1858,
    "source": "core"
  },
  "Nat.lt_or_ge": {
    "name": "Nat.lt_or_ge",
    "type": "theorem",
    "signature": "Nat.lt_or_ge : Or (LT.lt n m) (GE.ge n m)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1897,
    "source": "core"
  },
  "Nat.lt_irrefl": {
    "name": "Nat.lt_irrefl",
    "type": "theorem",
    "signature": "Nat.lt_irrefl : Not (LT.lt n n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1912,
    "source": "core"
  },
  "Nat.le_of_ble_eq_true": {
    "name": "Nat.le_of_ble_eq_true",
    "type": "theorem",
    "signature": "Nat.le_of_ble_eq_true : LE.le n m",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1928,
    "source": "core"
  },
  "Nat.ble_eq_true_of_le": {
    "name": "Nat.ble_eq_true_of_le",
    "type": "theorem",
    "signature": "Nat.ble_eq_true_of_le : Eq (Nat.ble n m) true",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1941,
    "source": "core"
  },
  "Nat.not_le_of_not_ble_eq_true": {
    "name": "Nat.not_le_of_not_ble_eq_true",
    "type": "theorem",
    "signature": "Nat.not_le_of_not_ble_eq_true : Not (LE.le n m)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1946,
    "source": "core"
  },
  "System.Platform.numBits_eq": {
    "name": "System.Platform.numBits_eq",
    "type": "theorem",
    "signature": "System.Platform.numBits_eq : Or (Eq numBits 32) (Eq numBits 64)",
    "docstring": "The word size of the current platform may be 64 or 32 bits.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2023,
    "source": "core"
  },
  "USize.size_eq": {
    "name": "USize.size_eq",
    "type": "theorem",
    "signature": "USize.size_eq : Or (Eq USize.size 4294967296) (Eq USize.size 18446744073709551616)",
    "docstring": "The number of distinct values representable by `USize`, that is, `2^System.Platform.numBits`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2402,
    "source": "core"
  },
  "USize.size_pos": {
    "name": "USize.size_pos",
    "type": "theorem",
    "signature": "USize.size_pos : LT.lt 0 USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2408,
    "source": "core"
  },
  "Prod": {
    "name": "Prod",
    "type": "structure",
    "signature": "Prod",
    "docstring": "The product type, usually written `α × β`. Product types are also called pair or tuple types. Elements of this type are pairs in which the first element is an `α` and the second element is a `β`. Products nest to the right, so `(x, y, z) : α × β × γ` is equivalent to `(x, (y, z)) : α × (β × γ)`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 506,
    "source": "core"
  },
  "Subtype": {
    "name": "Subtype",
    "type": "structure",
    "signature": "Subtype",
    "docstring": "All the elements of a type that satisfy a predicate. `Subtype p`, usually written `{ x : α // p x }` or `{ x // p x }`, contains all elements `x : α` for which `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the predicate. In run-time code, `{ x : α // p x }` is represented identically to `α`. There is a coercion from `{ x : α // p x }` to `α`, so elements of a subtype may be used where the underlying type is expected. Examples: * `{ n : Nat // n % 2 = 0 }` is the type of even numbers. * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s. * Given `xs : List α`, `List { x : α // x ∈ xs }` is the type of lists in which all elements are contained in `xs`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 624,
    "source": "core"
  },
  "Fin": {
    "name": "Fin",
    "type": "structure",
    "signature": "Fin",
    "docstring": "Natural numbers less than some upper bound. In particular, a `Fin n` is a natural number `i` with the constraint that `i < n`. It is the canonical type with `n` elements.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2033,
    "source": "core"
  },
  "BitVec": {
    "name": "BitVec",
    "type": "structure",
    "signature": "BitVec",
    "docstring": "A bitvector of the specified width. This is represented as the underlying `Nat` number in both the runtime and the kernel, inheriting all the special support for `Nat`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2076,
    "source": "core"
  },
  "UInt8": {
    "name": "UInt8",
    "type": "structure",
    "signature": "UInt8",
    "docstring": "Unsigned 8-bit integers. This type has special support in the compiler so it can be represented by an unboxed 8-bit value rather than wrapping a `BitVec 8`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2131,
    "source": "core"
  },
  "UInt16": {
    "name": "UInt16",
    "type": "structure",
    "signature": "UInt16",
    "docstring": "Unsigned 16-bit integers. This type has special support in the compiler so it can be represented by an unboxed 16-bit value rather than wrapping a `BitVec 16`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2188,
    "source": "core"
  },
  "UInt32": {
    "name": "UInt32",
    "type": "structure",
    "signature": "UInt32",
    "docstring": "Unsigned 32-bit integers. This type has special support in the compiler so it can be represented by an unboxed 32-bit value rather than wrapping a `BitVec 32`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2246,
    "source": "core"
  },
  "UInt64": {
    "name": "UInt64",
    "type": "structure",
    "signature": "UInt64",
    "docstring": "Unsigned 64-bit integers. This type has special support in the compiler so it can be represented by an unboxed 64-bit value rather than wrapping a `BitVec 64`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2351,
    "source": "core"
  },
  "USize": {
    "name": "USize",
    "type": "structure",
    "signature": "USize",
    "docstring": "Unsigned integers that are the size of a word on the platform's architecture. On a 32-bit architecture, `USize` is equivalent to `UInt32`. On a 64-bit machine, it is equivalent to `UInt64`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2420,
    "source": "core"
  },
  "Char": {
    "name": "Char",
    "type": "structure",
    "signature": "Char",
    "docstring": "Characters are Unicode [scalar values](http://www.unicode.org/glossary/#unicode_scalar_value).",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2487,
    "source": "core"
  },
  "String": {
    "name": "String",
    "type": "structure",
    "signature": "String",
    "docstring": "A string is a sequence of Unicode code points. At runtime, strings are represented by [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) of bytes using the UTF-8 encoding. Both the size in bytes (`String.utf8ByteSize`) and in characters (`String.length`) are cached and take constant time. Many operations on strings perform in-place modifications when the reference to the string is unique.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2722,
    "source": "core"
  },
  "String.Pos": {
    "name": "String.Pos",
    "type": "structure",
    "signature": "String.Pos",
    "docstring": "A byte position in a `String`, according to its UTF-8 encoding. Character positions (counting the Unicode code points rather than bytes) are represented by plain `Nat`s. Indexing a `String` by a `String.Pos` takes constant time, while character positions need to be translated internally to byte positions, which takes linear time. A byte position `p` is *valid* for a string `s` if `0 ≤ p ≤ s.endPos` and `p` lies on a UTF-8 character boundary.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2757,
    "source": "core"
  },
  "Substring": {
    "name": "Substring",
    "type": "structure",
    "signature": "Substring",
    "docstring": "A region or slice of some underlying string. A substring contains an string together with the start and end byte positions of a region of interest. Actually extracting a substring requires copying and memory allocation, while many substrings of the same underlying string may exist with very little overhead, and they are more convenient than tracking the bounds by hand. Using its constructor explicitly, it is possible to construct a `Substring` in which one or both of the positions is invalid for the string. Many operations will return unexpected or confusing results if the start and stop positions are not valid. Instead, it's better to use API functions that ensure the validity of the positions in a substring to create and manipulate them.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2782,
    "source": "core"
  },
  "Array": {
    "name": "Array",
    "type": "structure",
    "signature": "Array",
    "docstring": "`Array α` is the type of [dynamic arrays](https://en.wikipedia.org/wiki/Dynamic_array) with elements from `α`. This type has special support in the runtime. Arrays perform best when unshared. As long as there is never more than one reference to an array, all updates will be performed _destructively_. This results in performance comparable to mutable arrays in imperative programming languages. An array has a size and a capacity. The size is the number of elements present in the array, while the capacity is the amount of memory currently allocated for elements. The size is accessible via `Array.size`, but the capacity is not observable from Lean code. `Array.emptyWithCapacity n` creates an array which is equal to `#[]`, but internally allocates an array of capacity `n`. When the size exceeds the capacity, allocation is required to grow the array. From the point of view of proofs, `Array α` is just a wrapper around `List α`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2940,
    "source": "core"
  },
  "Inhabited": {
    "name": "Inhabited",
    "type": "class",
    "signature": "Inhabited",
    "docstring": "`Inhabited α` is a typeclass that says that `α` has a designated element, called `(default : α)`. This is sometimes referred to as a \"pointed type\". This class is used by functions that need to return a value of the type when called \"out of domain\". For example, `Array.get! arr i : α` returns a value of type `α` when `arr : Array α`, but if `i` is not in range of the array, it reports a panic message, but this does not halt the program, so it must still return a value of type `α` (and in fact this is required for logical consistency), so in this case it returns `default`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 734,
    "source": "core"
  },
  "BEq": {
    "name": "BEq",
    "type": "class",
    "signature": "BEq",
    "docstring": "`BEq α` is a typeclass for supplying a boolean-valued equality relation on `α`, notated as `a == b`. Unlike `DecidableEq α` (which uses `a = b`), this is `Bool` valued instead of `Prop` valued, and it also does not have any axioms like being reflexive or agreeing with `=`. It is mainly intended for programming applications. See `LawfulBEq` for a version that requires that `==` and `=` coincide. Typically we prefer to put the \"more variable\" term on the left, and the \"more constant\" term on the right.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1006,
    "source": "core"
  },
  "LE": {
    "name": "LE",
    "type": "class",
    "signature": "LE",
    "docstring": "`LE α` is the typeclass which supports the notation `x ≤ y` where `x y : α`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1211,
    "source": "core"
  },
  "LT": {
    "name": "LT",
    "type": "class",
    "signature": "LT",
    "docstring": "`LT α` is the typeclass which supports the notation `x < y` where `x y : α`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1216,
    "source": "core"
  },
  "Functor": {
    "name": "Functor",
    "type": "class",
    "signature": "Functor",
    "docstring": "A functor in the sense used in functional programming, which means a function `f : Type u → Type v` has a way of mapping a function over its contents. This `map` operator is written `<$>`, and overloaded via `Functor` instances. This `map` function should respect identity and function composition. In other words, for all terms `v : f α`, it should be the case that: * `id <$> v = v` * For all functions `h : β → γ` and `g : α → β`, `(h ∘ g) <$> v = h <$> g <$> v` While all `Functor` instances should live up to these requirements, they are not required to _prove_ that they do. Proofs may be required or provided via the `LawfulFunctor` class. Assuming that instances are lawful, this definition corresponds to the category-theoretic notion of [functor](https://en.wikipedia.org/wiki/Functor) in the special case where the category is the category of types and functions between them.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3189,
    "source": "core"
  },
  "Applicative": {
    "name": "Applicative",
    "type": "class",
    "signature": "Applicative",
    "docstring": "An [applicative functor](lean-manual://section/monads-and-do) is more powerful than a `Functor`, but less powerful than a `Monad`. Applicative functors capture sequencing of effects with the `<*>` operator, overloaded as `seq`, but not data-dependent effects. The results of earlier computations cannot be used to control later effects. Applicative functors should satisfy four laws. Instances of `Applicative` are not required to prove that they satisfy these laws, which are part of the `LawfulApplicative` class.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3282,
    "source": "core"
  },
  "Monad": {
    "name": "Monad",
    "type": "class",
    "signature": "Monad",
    "docstring": "[Monads](https://en.wikipedia.org/wiki/Monad_(functional_programming)) are an abstraction of sequential control flow and side effects used in functional programming. Monads allow both sequencing of effects and data-dependent effects: the values that result from an early step may influence the effects carried out in a later step. The `Monad` API may be used directly. However, it is most commonly accessed through [`do`-notation](lean-manual://section/do-notation). Most `Monad` instances provide implementations of `pure` and `bind`, and use default implementations for the other methods inherited from `Applicative`. Monads should satisfy certain laws, but instances are not required to prove this. An instance of `LawfulMonad` expresses that a given monad's operations are lawful.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3301,
    "source": "core"
  },
  "MonadLift": {
    "name": "MonadLift",
    "type": "class",
    "signature": "MonadLift",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3332,
    "source": "core"
  },
  "MonadExcept": {
    "name": "MonadExcept",
    "type": "class",
    "signature": "MonadExcept",
    "docstring": "Exception monads provide the ability to throw errors and handle errors. In this class, `ε` is an `outParam`, which means that it is inferred from `m`. `MonadExceptOf ε` provides the same operations, but allows `ε` to influence instance synthesis. `MonadExcept.tryCatch` is used to desugar `try ... catch ...` steps inside `do`-blocks when the handlers do not have exception type annotations.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3499,
    "source": "core"
  },
  "Hashable": {
    "name": "Hashable",
    "type": "class",
    "signature": "Hashable",
    "docstring": "Types that can be hashed into a `UInt64`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 4073,
    "source": "core"
  },
  "Empty": {
    "name": "Empty",
    "type": "inductive",
    "signature": "Empty : Type",
    "docstring": "The empty type. It has no constructors. Use `Empty.elim` in contexts where a value of type `Empty` is in scope.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 204,
    "source": "core"
  },
  "Bool": {
    "name": "Bool",
    "type": "inductive",
    "signature": "Bool : Type",
    "docstring": "The Boolean values, `true` and `false`. Logically speaking, this is equivalent to `Prop` (the type of propositions). The distinction is important for programming: both propositions and their proofs are erased in the code generator, while `Bool` corresponds to the Boolean type in most programming languages and carries precisely one bit of run-time information.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 599,
    "source": "core"
  },
  "Nat": {
    "name": "Nat",
    "type": "inductive",
    "signature": "Nat",
    "docstring": "The natural numbers, starting at zero. This type is special-cased by both the kernel and the compiler, and overridden with an efficient implementation. Both use a fast arbitrary-precision arithmetic library (usually [GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1168,
    "source": "core"
  },
  "Nat.le": {
    "name": "Nat.le",
    "type": "inductive",
    "signature": "Nat.le : Nat → Prop",
    "docstring": "Non-strict, or weak, inequality of natural numbers, usually accessed via the `≤` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 1802,
    "source": "core"
  },
  "Option": {
    "name": "Option",
    "type": "inductive",
    "signature": "Option",
    "docstring": "Optional values, which are either `some` around a value from the underlying type or `none`. `Option` can represent nullable types or computations that might fail. In the codomain of a function type, it can also represent partiality.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2547,
    "source": "core"
  },
  "List": {
    "name": "List",
    "type": "inductive",
    "signature": "List",
    "docstring": "Linked lists: ordered lists, in which each element has a reference to the next element. Most operations on linked lists take time proportional to the length of the list, because each element must be traversed to find the next element. `List α` is isomorphic to `Array α`, but they are useful for different things: * `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`. * `List α` works well as a persistent data structure, when many copies of the tail are shared. When the value is not shared, `Array α` will have better performance because it can do destructive updates.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 2601,
    "source": "core"
  },
  "Except": {
    "name": "Except",
    "type": "inductive",
    "signature": "Except",
    "docstring": "`Except ε α` is a type which represents either an error of type `ε` or a successful result with a value of type `α`. `Except ε : Type u → Type v` is a `Monad` that represents computations that may throw exceptions: the `pure` operation is `Except.ok` and the `bind` operation returns the first encountered `Except.error`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 3442,
    "source": "core"
  },
  "String.hash": {
    "name": "String.hash",
    "type": "opaque",
    "signature": "String.hash : UInt64",
    "docstring": "Computes a hash for strings.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Prelude.lean",
    "line_number": 4089,
    "source": "core"
  },
  "IO.RealWorld": {
    "name": "IO.RealWorld",
    "type": "def",
    "signature": "IO.RealWorld : Type",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IO.lean",
    "line_number": 25,
    "source": "core"
  },
  "BaseIO.toEIO": {
    "name": "BaseIO.toEIO",
    "type": "def",
    "signature": "BaseIO.toEIO : EIO ε α",
    "docstring": "Runs a `BaseIO` action, which cannot throw an exception, in any other `EIO` monad. This function is usually used implicitly via [automatic monadic lifting](lean-manual://section/lifting-monads) rather being than called explicitly.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IO.lean",
    "line_number": 63,
    "source": "core"
  },
  "EIO.toBaseIO": {
    "name": "EIO.toBaseIO",
    "type": "def",
    "signature": "EIO.toBaseIO : BaseIO (Except ε α)",
    "docstring": "Converts an `EIO ε` action that might throw an exception of type `ε` into an exception-free `BaseIO` action that returns an `Except` value.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IO.lean",
    "line_number": 74,
    "source": "core"
  },
  "EIO.catchExceptions": {
    "name": "EIO.catchExceptions",
    "type": "def",
    "signature": "EIO.catchExceptions : BaseIO α",
    "docstring": "Handles any exception that might be thrown by an `EIO ε` action, transforming it into an exception-free `BaseIO` action.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IO.lean",
    "line_number": 84,
    "source": "core"
  },
  "EIO.ofExcept": {
    "name": "EIO.ofExcept",
    "type": "def",
    "signature": "EIO.ofExcept : EIO ε α",
    "docstring": "Converts an `Except ε` action into an `EIO ε` action. If the `Except ε` action throws an exception, then the resulting `EIO ε` action throws the same exception. Otherwise, the value is returned.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IO.lean",
    "line_number": 95,
    "source": "core"
  },
  "IO.initializing": {
    "name": "IO.initializing",
    "type": "opaque",
    "signature": "IO.initializing : BaseIO Bool",
    "docstring": "Returns `true` if and only if it is invoked during initialization. Programs can execute `IO` actions during an initialization phase that occurs before the `main` function is executed. The attribute `@[init <action>]` specifies which IO action is executed to set the value of an opaque constant.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IO.lean",
    "line_number": 193,
    "source": "core"
  },
  "FilePath": {
    "name": "FilePath",
    "type": "structure",
    "signature": "FilePath",
    "docstring": "A path on the file system. Paths consist of a sequence of directories followed by the name of a file or directory. They are delimited by a platform-dependent separator character (see `System.FilePath.pathSeparator`).",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/FilePath.lean",
    "line_number": 21,
    "source": "core"
  },
  "IO.userError": {
    "name": "IO.userError",
    "type": "def",
    "signature": "IO.userError : IO.Error",
    "docstring": "Constructs an `IO.Error` from a string. `IO.Error` is the type of exceptions thrown by the `IO` monad.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IOError.lean",
    "line_number": 148,
    "source": "core"
  },
  "IO.Error": {
    "name": "IO.Error",
    "type": "inductive",
    "signature": "IO.Error",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/System/IOError.lean",
    "line_number": 21,
    "source": "core"
  },
  "UInt8.toFloat32": {
    "name": "UInt8.toFloat32",
    "type": "opaque",
    "signature": "UInt8.toFloat32 : Float32",
    "docstring": "Obtains the `Float32` whose value is the same as the given `UInt8`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float32.lean",
    "line_number": 253,
    "source": "core"
  },
  "UInt16.toFloat32": {
    "name": "UInt16.toFloat32",
    "type": "opaque",
    "signature": "UInt16.toFloat32 : Float32",
    "docstring": "Obtains the `Float32` whose value is the same as the given `UInt16`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float32.lean",
    "line_number": 255,
    "source": "core"
  },
  "UInt32.toFloat32": {
    "name": "UInt32.toFloat32",
    "type": "opaque",
    "signature": "UInt32.toFloat32 : Float32",
    "docstring": "Obtains a `Float32` whose value is near the given `UInt32`. It will be exactly the value of the given `UInt32` if such a `Float32` exists. If no such `Float32` exists, the returned value will either be the smallest `Float32` that is larger than the given value, or the largest `Float32` that is smaller than the given value. This function is opaque in the kernel, but is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float32.lean",
    "line_number": 266,
    "source": "core"
  },
  "UInt64.toFloat32": {
    "name": "UInt64.toFloat32",
    "type": "opaque",
    "signature": "UInt64.toFloat32 : Float32",
    "docstring": "Obtains a `Float32` whose value is near the given `UInt64`. It will be exactly the value of the given `UInt64` if such a `Float32` exists. If no such `Float32` exists, the returned value will either be the smallest `Float32` that is larger than the given value, or the largest `Float32` that is smaller than the given value. This function is opaque in the kernel, but is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float32.lean",
    "line_number": 277,
    "source": "core"
  },
  "USize.toFloat32": {
    "name": "USize.toFloat32",
    "type": "opaque",
    "signature": "USize.toFloat32 : Float32",
    "docstring": "Obtains a `Float32` whose value is near the given `USize`. It will be exactly the value of the given `USize` if such a `Float32` exists. If no such `Float32` exists, the returned value will either be the smallest `Float32` that is larger than the given value, or the largest `Float32` that is smaller than the given value. This function is opaque in the kernel, but is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float32.lean",
    "line_number": 287,
    "source": "core"
  },
  "Float.toFloat32": {
    "name": "Float.toFloat32",
    "type": "opaque",
    "signature": "Float.toFloat32 : Float → Float32",
    "docstring": "Converts a 64-bit floating-point number to a 32-bit floating-point number. This may lose precision. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float32.lean",
    "line_number": 513,
    "source": "core"
  },
  "Float.lt": {
    "name": "Float.lt",
    "type": "def",
    "signature": "Float.lt : Float → Float → Prop",
    "docstring": "Strict inequality of floating-point numbers. Typically used via the `<` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 92,
    "source": "core"
  },
  "Float.le": {
    "name": "Float.le",
    "type": "def",
    "signature": "Float.le : Float → Float → Prop",
    "docstring": "Non-strict inequality of floating-point numbers. Typically used via the `≤` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 99,
    "source": "core"
  },
  "Float.repr": {
    "name": "Float.repr",
    "type": "def",
    "signature": "Float.repr : Std.Format",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 292,
    "source": "core"
  },
  "Float": {
    "name": "Float",
    "type": "structure",
    "signature": "Float",
    "docstring": "64-bit floating-point numbers. `Float` corresponds to the IEEE 754 *binary64* format (`double` in C or `f64` in Rust). Floating-point numbers are a finite representation of a subset of the real numbers, extended with extra “sentinel” values that represent undefined and infinite results as well as separate positive and negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations on the real numbers by rounding the results to numbers that are representable, propagating error and infinite values. Floating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number). Their special values are: * `NaN`, which denotes a class of “not a number” values that result from operations such as dividing zero by zero, and * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero values by zero.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 48,
    "source": "core"
  },
  "Float.add": {
    "name": "Float.add",
    "type": "opaque",
    "signature": "Float.add : Float → Float → Float",
    "docstring": "Adds two 64-bit floating-point numbers according to IEEE 754. Typically used via the `+` operator. This function does not reduce in the kernel. It is compiled to the C addition operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 58,
    "source": "core"
  },
  "Float.sub": {
    "name": "Float.sub",
    "type": "opaque",
    "signature": "Float.sub : Float → Float → Float",
    "docstring": "Subtracts 64-bit floating-point numbers according to IEEE 754. Typically used via the `-` operator. This function does not reduce in the kernel. It is compiled to the C subtraction operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 64,
    "source": "core"
  },
  "Float.mul": {
    "name": "Float.mul",
    "type": "opaque",
    "signature": "Float.mul : Float → Float → Float",
    "docstring": "Multiplies 64-bit floating-point numbers according to IEEE 754. Typically used via the `*` operator. This function does not reduce in the kernel. It is compiled to the C multiplication operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 70,
    "source": "core"
  },
  "Float.div": {
    "name": "Float.div",
    "type": "opaque",
    "signature": "Float.div : Float → Float → Float",
    "docstring": "Divides 64-bit floating-point numbers according to IEEE 754. Typically used via the `/` operator. In Lean, division by zero typically yields zero. For `Float`, it instead yields either `Inf`, `-Inf`, or `NaN`. This function does not reduce in the kernel. It is compiled to the C division operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 79,
    "source": "core"
  },
  "Float.neg": {
    "name": "Float.neg",
    "type": "opaque",
    "signature": "Float.neg : Float → Float",
    "docstring": "Negates 64-bit floating-point numbers according to IEEE 754. Typically used via the `-` prefix operator. This function does not reduce in the kernel. It is compiled to the C negation operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 86,
    "source": "core"
  },
  "Float.ofBits": {
    "name": "Float.ofBits",
    "type": "opaque",
    "signature": "Float.ofBits : UInt64 → Float",
    "docstring": "Bit-for-bit conversion from `UInt64`. Interprets a `UInt64` as a `Float`, ignoring the numeric value and treating the `UInt64`'s bit pattern as a `Float`. `Float`s and `UInt64`s have the same endianness on all supported platforms. IEEE 754 very precisely specifies the bit layout of floats. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 111,
    "source": "core"
  },
  "Float.toBits": {
    "name": "Float.toBits",
    "type": "opaque",
    "signature": "Float.toBits : Float → UInt64",
    "docstring": "Bit-for-bit conversion to `UInt64`. Interprets a `Float` as a `UInt64`, ignoring the numeric value and treating the `Float`'s bit pattern as a `UInt64`. `Float`s and `UInt64`s have the same endianness on all supported platforms. IEEE 754 very precisely specifies the bit layout of floats. This function is distinct from `Float.toUInt64`, which attempts to preserve the numeric value rather than reinterpreting the bit pattern.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 123,
    "source": "core"
  },
  "Float.beq": {
    "name": "Float.beq",
    "type": "opaque",
    "signature": "Float.beq : Bool",
    "docstring": "Checks whether two floating-point numbers are equal according to IEEE 754. Floating-point equality does not correspond with propositional equality. In particular, it is not reflexive since `NaN != NaN`, and it is not a congruence because `0.0 == -0.0`, but `1.0 / 0.0 != 1.0 / -0.0`. This function does not reduce in the kernel. It is compiled to the C equality operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 142,
    "source": "core"
  },
  "Float.decLt": {
    "name": "Float.decLt",
    "type": "opaque",
    "signature": "Float.decLt : Decidable (a < b)",
    "docstring": "Compares two floating point numbers for strict inequality. This function does not reduce in the kernel. It is compiled to the C inequality operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 151,
    "source": "core"
  },
  "Float.decLe": {
    "name": "Float.decLe",
    "type": "opaque",
    "signature": "Float.decLe : Decidable (a ≤ b)",
    "docstring": "Compares two floating point numbers for non-strict inequality. This function does not reduce in the kernel. It is compiled to the C inequality operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 160,
    "source": "core"
  },
  "Float.toString": {
    "name": "Float.toString",
    "type": "opaque",
    "signature": "Float.toString : Float → String",
    "docstring": "Converts a floating-point number to a string. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 171,
    "source": "core"
  },
  "Float.toUInt8": {
    "name": "Float.toUInt8",
    "type": "opaque",
    "signature": "Float.toUInt8 : Float → UInt8",
    "docstring": "Converts a floating-point number to an 8-bit unsigned integer. If the given `Float` is non-negative, truncates the value to a positive integer, rounding down and clamping to the range of `UInt8`. Returns `0` if the `Float` is negative or `NaN`, and returns the largest `UInt8` value (i.e. `UInt8.size - 1`) if the float is larger than it. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 182,
    "source": "core"
  },
  "Float.toUInt16": {
    "name": "Float.toUInt16",
    "type": "opaque",
    "signature": "Float.toUInt16 : Float → UInt16",
    "docstring": "Converts a floating-point number to a 16-bit unsigned integer. If the given `Float` is non-negative, truncates the value to a positive integer, rounding down and clamping to the range of `UInt16`. Returns `0` if the `Float` is negative or `NaN`, and returns the largest `UInt16` value (i.e. `UInt16.size - 1`) if the float is larger than it. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 192,
    "source": "core"
  },
  "Float.toUInt32": {
    "name": "Float.toUInt32",
    "type": "opaque",
    "signature": "Float.toUInt32 : Float → UInt32",
    "docstring": "Converts a floating-point number to a 32-bit unsigned integer. If the given `Float` is non-negative, truncates the value to a positive integer, rounding down and clamping to the range of `UInt32`. Returns `0` if the `Float` is negative or `NaN`, and returns the largest `UInt32` value (i.e. `UInt32.size - 1`) if the float is larger than it. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 202,
    "source": "core"
  },
  "Float.toUInt64": {
    "name": "Float.toUInt64",
    "type": "opaque",
    "signature": "Float.toUInt64 : Float → UInt64",
    "docstring": "Converts a floating-point number to a 64-bit unsigned integer. If the given `Float` is non-negative, truncates the value to a positive integer, rounding down and clamping to the range of `UInt64`. Returns `0` if the `Float` is negative or `NaN`, and returns the largest `UInt64` value (i.e. `UInt64.size - 1`) if the float is larger than it. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 212,
    "source": "core"
  },
  "Float.toUSize": {
    "name": "Float.toUSize",
    "type": "opaque",
    "signature": "Float.toUSize : Float → USize",
    "docstring": "Converts a floating-point number to a word-sized unsigned integer. If the given `Float` is non-negative, truncates the value to a positive integer, rounding down and clamping to the range of `USize`. Returns `0` if the `Float` is negative or `NaN`, and returns the largest `USize` value (i.e. `USize.size - 1`) if the float is larger than it. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 222,
    "source": "core"
  },
  "Float.isNaN": {
    "name": "Float.isNaN",
    "type": "opaque",
    "signature": "Float.isNaN : Float → Bool",
    "docstring": "Checks whether a floating point number is `NaN` (“not a number”) value. `NaN` values result from operations that might otherwise be errors, such as dividing zero by zero. This function does not reduce in the kernel. It is compiled to the C operator `isnan`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 231,
    "source": "core"
  },
  "Float.isFinite": {
    "name": "Float.isFinite",
    "type": "opaque",
    "signature": "Float.isFinite : Float → Bool",
    "docstring": "Checks whether a floating-point number is finite, that is, whether it is normal, subnormal, or zero, but not infinite or `NaN`. This function does not reduce in the kernel. It is compiled to the C operator `isfinite`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 239,
    "source": "core"
  },
  "Float.isInf": {
    "name": "Float.isInf",
    "type": "opaque",
    "signature": "Float.isInf : Float → Bool",
    "docstring": "Checks whether a floating-point number is a positive or negative infinite number, but not a finite number or `NaN`. This function does not reduce in the kernel. It is compiled to the C operator `isinf`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 247,
    "source": "core"
  },
  "Float.frExp": {
    "name": "Float.frExp",
    "type": "opaque",
    "signature": "Float.frExp : Float → Float × Int",
    "docstring": "Splits the given float `x` into a significand/exponent pair `(s, i)` such that `x = s * 2^i` where `s ∈ (-1;-0.5] ∪ [0.5; 1)`. Returns an undefined value if `x` is not finite. This function does not reduce in the kernel. It is implemented in compiled code by the C function `frexp`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 256,
    "source": "core"
  },
  "UInt8.toFloat": {
    "name": "UInt8.toFloat",
    "type": "opaque",
    "signature": "UInt8.toFloat : Float",
    "docstring": "Obtains the `Float` whose value is the same as the given `UInt8`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 262,
    "source": "core"
  },
  "UInt16.toFloat": {
    "name": "UInt16.toFloat",
    "type": "opaque",
    "signature": "UInt16.toFloat : Float",
    "docstring": "Obtains the `Float` whose value is the same as the given `UInt16`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 264,
    "source": "core"
  },
  "UInt32.toFloat": {
    "name": "UInt32.toFloat",
    "type": "opaque",
    "signature": "UInt32.toFloat : Float",
    "docstring": "Obtains the `Float` whose value is the same as the given `UInt32`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 266,
    "source": "core"
  },
  "UInt64.toFloat": {
    "name": "UInt64.toFloat",
    "type": "opaque",
    "signature": "UInt64.toFloat : Float",
    "docstring": "Obtains a `Float` whose value is near the given `UInt64`. It will be exactly the value of the given `UInt64` if such a `Float` exists. If no such `Float` exists, the returned value will either be the smallest `Float` that is larger than the given value, or the largest `Float` that is smaller than the given value. This function is opaque in the kernel, but is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 277,
    "source": "core"
  },
  "USize.toFloat": {
    "name": "USize.toFloat",
    "type": "opaque",
    "signature": "USize.toFloat : Float",
    "docstring": "Obtains a `Float` whose value is near the given `USize`. It will be exactly the value of the given `USize` if such a `Float` exists. If no such `Float` exists, the returned value will either be the smallest `Float` that is larger than the given value, or the largest `Float` that is smaller than the given value. This function is opaque in the kernel, but is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 288,
    "source": "core"
  },
  "Float.sin": {
    "name": "Float.sin",
    "type": "opaque",
    "signature": "Float.sin : Float → Float",
    "docstring": "Computes the sine of a floating-point number in radians. This function does not reduce in the kernel. It is implemented in compiled code by the C function `sin`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 307,
    "source": "core"
  },
  "Float.cos": {
    "name": "Float.cos",
    "type": "opaque",
    "signature": "Float.cos : Float → Float",
    "docstring": "Computes the cosine of a floating-point number in radians. This function does not reduce in the kernel. It is implemented in compiled code by the C function `cos`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 314,
    "source": "core"
  },
  "Float.tan": {
    "name": "Float.tan",
    "type": "opaque",
    "signature": "Float.tan : Float → Float",
    "docstring": "Computes the tangent of a floating-point number in radians. This function does not reduce in the kernel. It is implemented in compiled code by the C function `tan`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 321,
    "source": "core"
  },
  "Float.asin": {
    "name": "Float.asin",
    "type": "opaque",
    "signature": "Float.asin : Float → Float",
    "docstring": "Computes the arc sine (inverse sine) of a floating-point number in radians. This function does not reduce in the kernel. It is implemented in compiled code by the C function `asin`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 328,
    "source": "core"
  },
  "Float.acos": {
    "name": "Float.acos",
    "type": "opaque",
    "signature": "Float.acos : Float → Float",
    "docstring": "Computes the arc cosine (inverse cosine) of a floating-point number in radians. This function does not reduce in the kernel. It is implemented in compiled code by the C function `acos`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 335,
    "source": "core"
  },
  "Float.atan": {
    "name": "Float.atan",
    "type": "opaque",
    "signature": "Float.atan : Float → Float",
    "docstring": "Computes the arc tangent (inverse tangent) of a floating-point number in radians. This function does not reduce in the kernel. It is implemented in compiled code by the C function `atan`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 342,
    "source": "core"
  },
  "Float.atan2": {
    "name": "Float.atan2",
    "type": "opaque",
    "signature": "Float.atan2 : Float",
    "docstring": "Computes the arc tangent (inverse tangent) of `y / x` in radians, in the range `-π`–`π`. The signs of the arguments determine the quadrant of the result. This function does not reduce in the kernel. It is implemented in compiled code by the C function `atan2`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 350,
    "source": "core"
  },
  "Float.sinh": {
    "name": "Float.sinh",
    "type": "opaque",
    "signature": "Float.sinh : Float → Float",
    "docstring": "Computes the hyperbolic sine of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `sinh`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 357,
    "source": "core"
  },
  "Float.cosh": {
    "name": "Float.cosh",
    "type": "opaque",
    "signature": "Float.cosh : Float → Float",
    "docstring": "Computes the hyperbolic cosine of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `cosh`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 364,
    "source": "core"
  },
  "Float.tanh": {
    "name": "Float.tanh",
    "type": "opaque",
    "signature": "Float.tanh : Float → Float",
    "docstring": "Computes the hyperbolic tangent of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `tanh`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 371,
    "source": "core"
  },
  "Float.asinh": {
    "name": "Float.asinh",
    "type": "opaque",
    "signature": "Float.asinh : Float → Float",
    "docstring": "Computes the hyperbolic arc sine (inverse sine) of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `asinh`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 378,
    "source": "core"
  },
  "Float.acosh": {
    "name": "Float.acosh",
    "type": "opaque",
    "signature": "Float.acosh : Float → Float",
    "docstring": "Computes the hyperbolic arc cosine (inverse cosine) of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `acosh`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 385,
    "source": "core"
  },
  "Float.atanh": {
    "name": "Float.atanh",
    "type": "opaque",
    "signature": "Float.atanh : Float → Float",
    "docstring": "Computes the hyperbolic arc tangent (inverse tangent) of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `atanh`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 392,
    "source": "core"
  },
  "Float.exp": {
    "name": "Float.exp",
    "type": "opaque",
    "signature": "Float.exp : Float",
    "docstring": "Computes the exponential `e^x` of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `exp`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 399,
    "source": "core"
  },
  "Float.exp2": {
    "name": "Float.exp2",
    "type": "opaque",
    "signature": "Float.exp2 : Float",
    "docstring": "Computes the base-2 exponential `2^x` of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `exp2`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 406,
    "source": "core"
  },
  "Float.log": {
    "name": "Float.log",
    "type": "opaque",
    "signature": "Float.log : Float",
    "docstring": "Computes the natural logarithm `ln x` of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `log`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 413,
    "source": "core"
  },
  "Float.log2": {
    "name": "Float.log2",
    "type": "opaque",
    "signature": "Float.log2 : Float → Float",
    "docstring": "Computes the base-2 logarithm of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `log2`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 420,
    "source": "core"
  },
  "Float.log10": {
    "name": "Float.log10",
    "type": "opaque",
    "signature": "Float.log10 : Float → Float",
    "docstring": "Computes the base-10 logarithm of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `log10`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 427,
    "source": "core"
  },
  "Float.pow": {
    "name": "Float.pow",
    "type": "opaque",
    "signature": "Float.pow : Float → Float → Float",
    "docstring": "Raises one floating-point number to the power of another. Typically used via the `^` operator. This function does not reduce in the kernel. It is implemented in compiled code by the C function `pow`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 434,
    "source": "core"
  },
  "Float.sqrt": {
    "name": "Float.sqrt",
    "type": "opaque",
    "signature": "Float.sqrt : Float → Float",
    "docstring": "Computes the square root of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `sqrt`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 441,
    "source": "core"
  },
  "Float.cbrt": {
    "name": "Float.cbrt",
    "type": "opaque",
    "signature": "Float.cbrt : Float → Float",
    "docstring": "Computes the cube root of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `cbrt`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 448,
    "source": "core"
  },
  "Float.ceil": {
    "name": "Float.ceil",
    "type": "opaque",
    "signature": "Float.ceil : Float → Float",
    "docstring": "Computes the ceiling of a floating-point number, which is the smallest integer that's no smaller than the given number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `ceil`. Examples: * `Float.ceil 1.5 = 2` * `Float.ceil (-1.5) = (-1)`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 460,
    "source": "core"
  },
  "Float.floor": {
    "name": "Float.floor",
    "type": "opaque",
    "signature": "Float.floor : Float → Float",
    "docstring": "Computes the floor of a floating-point number, which is the largest integer that's no larger than the given number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `floor`. Examples: * `Float.floor 1.5 = 1` * `Float.floor (-1.5) = (-2)`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 472,
    "source": "core"
  },
  "Float.round": {
    "name": "Float.round",
    "type": "opaque",
    "signature": "Float.round : Float → Float",
    "docstring": "Rounds to the nearest integer, rounding away from zero at half-way points. This function does not reduce in the kernel. It is implemented in compiled code by the C function `round`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 479,
    "source": "core"
  },
  "Float.abs": {
    "name": "Float.abs",
    "type": "opaque",
    "signature": "Float.abs : Float → Float",
    "docstring": "Computes the absolute value of a floating-point number. This function does not reduce in the kernel. It is implemented in compiled code by the C function `fabs`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 486,
    "source": "core"
  },
  "Float.scaleB": {
    "name": "Float.scaleB",
    "type": "opaque",
    "signature": "Float.scaleB : Float",
    "docstring": "Efficiently computes `x * 2^i`. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Float.lean",
    "line_number": 499,
    "source": "core"
  },
  "Bool.repr": {
    "name": "Bool.repr",
    "type": "def",
    "signature": "Bool.repr : Bool → Nat → Format",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 57,
    "source": "core"
  },
  "Repr.addAppParen": {
    "name": "Repr.addAppParen",
    "type": "def",
    "signature": "Repr.addAppParen : Format",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 64,
    "source": "core"
  },
  "Decidable.repr": {
    "name": "Decidable.repr",
    "type": "def",
    "signature": "Decidable.repr : Decidable p → Nat → Format",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 70,
    "source": "core"
  },
  "Int.repr": {
    "name": "Int.repr",
    "type": "def",
    "signature": "Int.repr : Int → String",
    "docstring": "Returns the decimal string representation of an integer.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 335,
    "source": "core"
  },
  "Char.quoteCore": {
    "name": "Char.quoteCore",
    "type": "def",
    "signature": "Char.quoteCore : String",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 344,
    "source": "core"
  },
  "Char.quote": {
    "name": "Char.quote",
    "type": "def",
    "signature": "Char.quote : String",
    "docstring": "Quotes the character to its representation as a character literal, surrounded by single quotes and escaped as necessary. Examples: * `'L'.quote = \"'L'\"` * `'\"'.quote = \"'\\\\\\\"'\"`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 367,
    "source": "core"
  },
  "Char.repr": {
    "name": "Char.repr",
    "type": "def",
    "signature": "Char.repr : String",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 372,
    "source": "core"
  },
  "String.quote": {
    "name": "String.quote",
    "type": "def",
    "signature": "String.quote : String",
    "docstring": "Converts a string to its corresponding Lean string literal syntax. Double quotes are added to each end, and internal characters are escaped as needed. Examples: * `\"abc\".quote = \"\\\"abc\\\"\"` * `\"\\\"\".quote = \"\\\"\\\\\\\"\\\"\"`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 384,
    "source": "core"
  },
  "Repr": {
    "name": "Repr",
    "type": "class",
    "signature": "Repr",
    "docstring": "A typeclass that specifies the standard way of turning values of some type into `Format`. When rendered this `Format` should be as close as possible to something that can be parsed as the input value.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Repr.lean",
    "line_number": 20,
    "source": "core"
  },
  "Float.ofBinaryScientific": {
    "name": "Float.ofBinaryScientific",
    "type": "def",
    "signature": "Float.ofBinaryScientific : Float",
    "docstring": "Computes `m * 2^e`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/OfScientific.lean",
    "line_number": 35,
    "source": "core"
  },
  "Float.ofNat": {
    "name": "Float.ofNat",
    "type": "def",
    "signature": "Float.ofNat : Float",
    "docstring": "Converts a natural number into the closest-possible 64-bit floating-point number, or an infinite floating-point value if the range of `Float` is exceeded.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/OfScientific.lean",
    "line_number": 71,
    "source": "core"
  },
  "Float.ofInt": {
    "name": "Float.ofInt",
    "type": "def",
    "signature": "Float.ofInt : Int → Float",
    "docstring": "Converts an integer into the closest-possible 64-bit floating-point number, or positive or negative infinite floating-point value if the range of `Float` is exceeded.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/OfScientific.lean",
    "line_number": 78,
    "source": "core"
  },
  "Float.ofScientific": {
    "name": "Float.ofScientific",
    "type": "opaque",
    "signature": "Float.ofScientific : Float",
    "docstring": "Constructs a `Float` from the given mantissa, sign, and exponent values. This function is part of the implementation of the `OfScientific Float` instance that is used to interpret floating-point literals.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/OfScientific.lean",
    "line_number": 47,
    "source": "core"
  },
  "Ord": {
    "name": "Ord",
    "type": "class",
    "signature": "Ord",
    "docstring": "`Ord α` provides a computable total order on `α`, in terms of the `compare : α → α → Ordering` function. Typically instances will be transitive, reflexive, and antisymmetric, but this is not enforced by the typeclass. There is a derive handler, so appending `deriving Ord` to an inductive type or structure will attempt to create an `Ord` instance.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Ord.lean",
    "line_number": 442,
    "source": "core"
  },
  "Ordering": {
    "name": "Ordering",
    "type": "inductive",
    "signature": "Ordering",
    "docstring": "The result of a comparison according to a total order. The relationship between the compared items may be: * `Ordering.lt`: less than * `Ordering.eq`: equal * `Ordering.gt`: greater than",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Ord.lean",
    "line_number": 22,
    "source": "core"
  },
  "IO.setRandSeed": {
    "name": "IO.setRandSeed",
    "type": "def",
    "signature": "IO.setRandSeed : BaseIO Unit",
    "docstring": "Seeds the random number generator state used by `IO.rand`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Random.lean",
    "line_number": 128,
    "source": "core"
  },
  "IO.rand": {
    "name": "IO.rand",
    "type": "def",
    "signature": "IO.rand : BaseIO Nat",
    "docstring": "Returns a pseudorandom number between `lo` and `hi`, using and updating a saved random generator state. This state can be seeded using `IO.setRandSeed`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Random.lean",
    "line_number": 137,
    "source": "core"
  },
  "Alternative": {
    "name": "Alternative",
    "type": "class",
    "signature": "Alternative",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Control/Basic.lean",
    "line_number": 101,
    "source": "core"
  },
  "MonadControl": {
    "name": "MonadControl",
    "type": "class",
    "signature": "MonadControl",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Control/Basic.lean",
    "line_number": 308,
    "source": "core"
  },
  "StateM": {
    "name": "StateM",
    "type": "def",
    "signature": "StateM : Type u",
    "docstring": "A tuple-based state monad. Actions in `StateM σ` are functions that take an initial state and return a value paired with a final state.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Control/State.lean",
    "line_number": 51,
    "source": "core"
  },
  "Nat.le_ro": {
    "name": "Nat.le_ro",
    "type": "theorem",
    "signature": "Nat.le_ro : u ≤ w → w ≤ v + k → u ≤ v + k",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 17,
    "source": "core"
  },
  "Nat.le_lo": {
    "name": "Nat.le_lo",
    "type": "theorem",
    "signature": "Nat.le_lo : u ≤ w → w + k ≤ v → u + k ≤ v",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 19,
    "source": "core"
  },
  "Nat.lo_le": {
    "name": "Nat.lo_le",
    "type": "theorem",
    "signature": "Nat.lo_le : u + k ≤ w → w ≤ v → u + k ≤ v",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 21,
    "source": "core"
  },
  "Nat.lo_lo": {
    "name": "Nat.lo_lo",
    "type": "theorem",
    "signature": "Nat.lo_lo : u + k₁ ≤ w → w + k₂ ≤ v → u + (k₁ + k₂) ≤ v",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 23,
    "source": "core"
  },
  "Nat.lo_ro_2": {
    "name": "Nat.lo_ro_2",
    "type": "theorem",
    "signature": "Nat.lo_ro_2 : u + k₁ ≤ w → w ≤ v + k₂ → u ≤ v + (k₂ - k₁)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 27,
    "source": "core"
  },
  "Nat.ro_le": {
    "name": "Nat.ro_le",
    "type": "theorem",
    "signature": "Nat.ro_le : u ≤ w + k → w ≤ v → u ≤ v + k",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 29,
    "source": "core"
  },
  "Nat.ro_lo_1": {
    "name": "Nat.ro_lo_1",
    "type": "theorem",
    "signature": "Nat.ro_lo_1 : u ≤ w + k₁ → w + k₂ ≤ v → u ≤ v + (k₁ - k₂)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 31,
    "source": "core"
  },
  "Nat.ro_ro": {
    "name": "Nat.ro_ro",
    "type": "theorem",
    "signature": "Nat.ro_ro : u ≤ w + k₁ → w ≤ v + k₂ → u ≤ v + (k₁ + k₂)",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 35,
    "source": "core"
  },
  "Nat.le_offset": {
    "name": "Nat.le_offset",
    "type": "theorem",
    "signature": "Nat.le_offset : k ≤ a + k",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Grind/Offset.lean",
    "line_number": 92,
    "source": "core"
  },
  "UInt8.size_lt_usizeSize": {
    "name": "UInt8.size_lt_usizeSize",
    "type": "theorem",
    "signature": "UInt8.size_lt_usizeSize : UInt8.size < USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 362,
    "source": "core"
  },
  "UInt8.size_le_usizeSize": {
    "name": "UInt8.size_le_usizeSize",
    "type": "theorem",
    "signature": "UInt8.size_le_usizeSize : UInt8.size ≤ USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 365,
    "source": "core"
  },
  "UInt16.size_lt_usizeSize": {
    "name": "UInt16.size_lt_usizeSize",
    "type": "theorem",
    "signature": "UInt16.size_lt_usizeSize : UInt16.size < USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 367,
    "source": "core"
  },
  "UInt16.size_le_usizeSize": {
    "name": "UInt16.size_le_usizeSize",
    "type": "theorem",
    "signature": "UInt16.size_le_usizeSize : UInt16.size ≤ USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 369,
    "source": "core"
  },
  "UInt32.size_le_usizeSize": {
    "name": "UInt32.size_le_usizeSize",
    "type": "theorem",
    "signature": "UInt32.size_le_usizeSize : UInt32.size ≤ USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 371,
    "source": "core"
  },
  "USize.toNat_lt_two_pow_numBits": {
    "name": "USize.toNat_lt_two_pow_numBits",
    "type": "theorem",
    "signature": "USize.toNat_lt_two_pow_numBits : n.toNat < 2 ^ System.Platform.numBits",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 374,
    "source": "core"
  },
  "USize.size_le_uint64Size": {
    "name": "USize.size_le_uint64Size",
    "type": "theorem",
    "signature": "USize.size_le_uint64Size : USize.size ≤ UInt64.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 376,
    "source": "core"
  },
  "UInt8.toNat_lt_usizeSize": {
    "name": "UInt8.toNat_lt_usizeSize",
    "type": "theorem",
    "signature": "UInt8.toNat_lt_usizeSize : n.toNat < USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 378,
    "source": "core"
  },
  "UInt16.toNat_lt_usizeSize": {
    "name": "UInt16.toNat_lt_usizeSize",
    "type": "theorem",
    "signature": "UInt16.toNat_lt_usizeSize : n.toNat < USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 381,
    "source": "core"
  },
  "UInt32.toNat_lt_usizeSize": {
    "name": "UInt32.toNat_lt_usizeSize",
    "type": "theorem",
    "signature": "UInt32.toNat_lt_usizeSize : n.toNat < USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 383,
    "source": "core"
  },
  "UInt8.size_dvd_usizeSize": {
    "name": "UInt8.size_dvd_usizeSize",
    "type": "theorem",
    "signature": "UInt8.size_dvd_usizeSize : UInt8.size ∣ USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 385,
    "source": "core"
  },
  "UInt16.size_dvd_usizeSize": {
    "name": "UInt16.size_dvd_usizeSize",
    "type": "theorem",
    "signature": "UInt16.size_dvd_usizeSize : UInt16.size ∣ USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 387,
    "source": "core"
  },
  "UInt32.size_dvd_usizeSize": {
    "name": "UInt32.size_dvd_usizeSize",
    "type": "theorem",
    "signature": "UInt32.size_dvd_usizeSize : UInt32.size ∣ USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 388,
    "source": "core"
  },
  "USize.size_dvd_uInt64Size": {
    "name": "USize.size_dvd_uInt64Size",
    "type": "theorem",
    "signature": "USize.size_dvd_uInt64Size : USize.size ∣ UInt64.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 389,
    "source": "core"
  },
  "UInt8.lt_or_le": {
    "name": "UInt8.lt_or_le",
    "type": "theorem",
    "signature": "UInt8.lt_or_le : a < b ∨ b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3042,
    "source": "core"
  },
  "UInt16.lt_or_le": {
    "name": "UInt16.lt_or_le",
    "type": "theorem",
    "signature": "UInt16.lt_or_le : a < b ∨ b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3045,
    "source": "core"
  },
  "UInt32.lt_or_le": {
    "name": "UInt32.lt_or_le",
    "type": "theorem",
    "signature": "UInt32.lt_or_le : a < b ∨ b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3047,
    "source": "core"
  },
  "UInt64.lt_or_le": {
    "name": "UInt64.lt_or_le",
    "type": "theorem",
    "signature": "UInt64.lt_or_le : a < b ∨ b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3049,
    "source": "core"
  },
  "USize.lt_or_le": {
    "name": "USize.lt_or_le",
    "type": "theorem",
    "signature": "USize.lt_or_le : a < b ∨ b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3051,
    "source": "core"
  },
  "UInt8.le_or_lt": {
    "name": "UInt8.le_or_lt",
    "type": "theorem",
    "signature": "UInt8.le_or_lt : a ≤ b ∨ b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3053,
    "source": "core"
  },
  "UInt16.le_or_lt": {
    "name": "UInt16.le_or_lt",
    "type": "theorem",
    "signature": "UInt16.le_or_lt : a ≤ b ∨ b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3055,
    "source": "core"
  },
  "UInt32.le_or_lt": {
    "name": "UInt32.le_or_lt",
    "type": "theorem",
    "signature": "UInt32.le_or_lt : a ≤ b ∨ b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3056,
    "source": "core"
  },
  "UInt64.le_or_lt": {
    "name": "UInt64.le_or_lt",
    "type": "theorem",
    "signature": "UInt64.le_or_lt : a ≤ b ∨ b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3057,
    "source": "core"
  },
  "USize.le_or_lt": {
    "name": "USize.le_or_lt",
    "type": "theorem",
    "signature": "USize.le_or_lt : a ≤ b ∨ b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Lemmas.lean",
    "line_number": 3058,
    "source": "core"
  },
  "UInt8.toFin": {
    "name": "UInt8.toFin",
    "type": "def",
    "signature": "UInt8.toFin : Fin UInt8.size",
    "docstring": "Converts a `UInt8` into the corresponding `Fin UInt8.size`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 26,
    "source": "core"
  },
  "UInt8.val": {
    "name": "UInt8.val",
    "type": "def",
    "signature": "UInt8.val : Fin UInt8.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 28,
    "source": "core"
  },
  "UInt8.ofNat": {
    "name": "UInt8.ofNat",
    "type": "def",
    "signature": "UInt8.ofNat : UInt8",
    "docstring": "Converts a natural number to an 8-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `UInt8.ofNat 5 = 5` * `UInt8.ofNat 255 = 255` * `UInt8.ofNat 256 = 0` * `UInt8.ofNat 259 = 3` * `UInt8.ofNat 32770 = 2`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 43,
    "source": "core"
  },
  "UInt8.ofNatTruncate": {
    "name": "UInt8.ofNatTruncate",
    "type": "def",
    "signature": "UInt8.ofNatTruncate : UInt8",
    "docstring": "Converts a natural number to an 8-bit unsigned integer, returning the largest representable value if the number is too large. Returns `2^8 - 1` for natural numbers greater than or equal to `2^8`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 51,
    "source": "core"
  },
  "UInt8.toNat": {
    "name": "UInt8.toNat",
    "type": "def",
    "signature": "UInt8.toNat : Nat",
    "docstring": "Converts an 8-bit unsigned integer to an arbitrary-precision natural number. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 77,
    "source": "core"
  },
  "UInt16.toFin": {
    "name": "UInt16.toFin",
    "type": "def",
    "signature": "UInt16.toFin : Fin UInt16.size",
    "docstring": "Converts a `UInt16` into the corresponding `Fin UInt16.size`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 82,
    "source": "core"
  },
  "UInt16.val": {
    "name": "UInt16.val",
    "type": "def",
    "signature": "UInt16.val : Fin UInt16.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 84,
    "source": "core"
  },
  "UInt16.ofNat": {
    "name": "UInt16.ofNat",
    "type": "def",
    "signature": "UInt16.ofNat : UInt16",
    "docstring": "Converts a natural number to a 16-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `UInt16.ofNat 5 = 5` * `UInt16.ofNat 255 = 255` * `UInt16.ofNat 32770 = 32770` * `UInt16.ofNat 65537 = 1`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 98,
    "source": "core"
  },
  "UInt16.ofNatTruncate": {
    "name": "UInt16.ofNatTruncate",
    "type": "def",
    "signature": "UInt16.ofNatTruncate : UInt16",
    "docstring": "Converts a natural number to a 16-bit unsigned integer, returning the largest representable value if the number is too large. Returns `2^16 - 1` for natural numbers greater than or equal to `2^16`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 105,
    "source": "core"
  },
  "UInt16.toNat": {
    "name": "UInt16.toNat",
    "type": "def",
    "signature": "UInt16.toNat : Nat",
    "docstring": "Converts a 16-bit unsigned integer to an arbitrary-precision natural number. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 130,
    "source": "core"
  },
  "UInt16.toUInt8": {
    "name": "UInt16.toUInt8",
    "type": "def",
    "signature": "UInt16.toUInt8 : UInt8",
    "docstring": "Converts 16-bit unsigned integers to 8-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 137,
    "source": "core"
  },
  "UInt8.toUInt16": {
    "name": "UInt8.toUInt16",
    "type": "def",
    "signature": "UInt8.toUInt16 : UInt16",
    "docstring": "Converts 8-bit unsigned integers to 16-bit unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 144,
    "source": "core"
  },
  "UInt32.toFin": {
    "name": "UInt32.toFin",
    "type": "def",
    "signature": "UInt32.toFin : Fin UInt32.size",
    "docstring": "Converts a `UInt32` into the corresponding `Fin UInt32.size`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 149,
    "source": "core"
  },
  "UInt32.val": {
    "name": "UInt32.val",
    "type": "def",
    "signature": "UInt32.val : Fin UInt32.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 151,
    "source": "core"
  },
  "UInt32.ofNat": {
    "name": "UInt32.ofNat",
    "type": "def",
    "signature": "UInt32.ofNat : UInt32",
    "docstring": "Converts a natural number to a 32-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `UInt32.ofNat 5 = 5` * `UInt32.ofNat 65539 = 65539` * `UInt32.ofNat 4_294_967_299 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 164,
    "source": "core"
  },
  "UInt32.ofNatTruncate": {
    "name": "UInt32.ofNatTruncate",
    "type": "def",
    "signature": "UInt32.ofNatTruncate : UInt32",
    "docstring": "Converts a natural number to a 32-bit unsigned integer, returning the largest representable value if the number is too large. Returns `2^32 - 1` for natural numbers greater than or equal to `2^32`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 173,
    "source": "core"
  },
  "UInt32.toUInt8": {
    "name": "UInt32.toUInt8",
    "type": "def",
    "signature": "UInt32.toUInt8 : UInt8",
    "docstring": "Converts a 32-bit unsigned integer to an 8-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 196,
    "source": "core"
  },
  "UInt32.toUInt16": {
    "name": "UInt32.toUInt16",
    "type": "def",
    "signature": "UInt32.toUInt16 : UInt16",
    "docstring": "Converts 32-bit unsigned integers to 16-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 203,
    "source": "core"
  },
  "UInt8.toUInt32": {
    "name": "UInt8.toUInt32",
    "type": "def",
    "signature": "UInt8.toUInt32 : UInt32",
    "docstring": "Converts 8-bit unsigned integers to 32-bit unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 210,
    "source": "core"
  },
  "UInt16.toUInt32": {
    "name": "UInt16.toUInt32",
    "type": "def",
    "signature": "UInt16.toUInt32 : UInt32",
    "docstring": "Converts 16-bit unsigned integers to 32-bit unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 217,
    "source": "core"
  },
  "UInt64.toFin": {
    "name": "UInt64.toFin",
    "type": "def",
    "signature": "UInt64.toFin : Fin UInt64.size",
    "docstring": "Converts a `UInt64` into the corresponding `Fin UInt64.size`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 240,
    "source": "core"
  },
  "UInt64.val": {
    "name": "UInt64.val",
    "type": "def",
    "signature": "UInt64.val : Fin UInt64.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 242,
    "source": "core"
  },
  "UInt64.ofNat": {
    "name": "UInt64.ofNat",
    "type": "def",
    "signature": "UInt64.ofNat : UInt64",
    "docstring": "Converts a natural number to a 64-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `UInt64.ofNat 5 = 5` * `UInt64.ofNat 65539 = 65539` * `UInt64.ofNat 4_294_967_299 = 4_294_967_299` * `UInt64.ofNat 18_446_744_073_709_551_620 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 255,
    "source": "core"
  },
  "UInt64.ofNatTruncate": {
    "name": "UInt64.ofNatTruncate",
    "type": "def",
    "signature": "UInt64.ofNatTruncate : UInt64",
    "docstring": "Converts a natural number to a 64-bit unsigned integer, returning the largest representable value if the number is too large. Returns `2^64 - 1` for natural numbers greater than or equal to `2^64`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 262,
    "source": "core"
  },
  "UInt64.toNat": {
    "name": "UInt64.toNat",
    "type": "def",
    "signature": "UInt64.toNat : Nat",
    "docstring": "Converts a 64-bit unsigned integer to an arbitrary-precision natural number. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 285,
    "source": "core"
  },
  "UInt64.toUInt8": {
    "name": "UInt64.toUInt8",
    "type": "def",
    "signature": "UInt64.toUInt8 : UInt8",
    "docstring": "Converts 64-bit unsigned integers to 8-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 292,
    "source": "core"
  },
  "UInt64.toUInt16": {
    "name": "UInt64.toUInt16",
    "type": "def",
    "signature": "UInt64.toUInt16 : UInt16",
    "docstring": "Converts 64-bit unsigned integers to 16-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 299,
    "source": "core"
  },
  "UInt64.toUInt32": {
    "name": "UInt64.toUInt32",
    "type": "def",
    "signature": "UInt64.toUInt32 : UInt32",
    "docstring": "Converts 64-bit unsigned integers to 32-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 306,
    "source": "core"
  },
  "UInt8.toUInt64": {
    "name": "UInt8.toUInt64",
    "type": "def",
    "signature": "UInt8.toUInt64 : UInt64",
    "docstring": "Converts 8-bit unsigned integers to 64-bit unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 313,
    "source": "core"
  },
  "UInt16.toUInt64": {
    "name": "UInt16.toUInt64",
    "type": "def",
    "signature": "UInt16.toUInt64 : UInt64",
    "docstring": "Converts 16-bit unsigned integers to 64-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 320,
    "source": "core"
  },
  "UInt32.toUInt64": {
    "name": "UInt32.toUInt64",
    "type": "def",
    "signature": "UInt32.toUInt64 : UInt64",
    "docstring": "Converts 32-bit unsigned integers to 64-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 327,
    "source": "core"
  },
  "USize.toFin": {
    "name": "USize.toFin",
    "type": "def",
    "signature": "USize.toFin : Fin USize.size",
    "docstring": "Converts a `USize` into the corresponding `Fin USize.size`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 340,
    "source": "core"
  },
  "USize.val": {
    "name": "USize.val",
    "type": "def",
    "signature": "USize.val : Fin USize.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 342,
    "source": "core"
  },
  "USize.ofNat": {
    "name": "USize.ofNat",
    "type": "def",
    "signature": "USize.ofNat : USize",
    "docstring": "Converts an arbitrary-precision natural number to an unsigned word-sized integer, wrapping around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 350,
    "source": "core"
  },
  "USize.ofNatTruncate": {
    "name": "USize.ofNatTruncate",
    "type": "def",
    "signature": "USize.ofNatTruncate : USize",
    "docstring": "Converts a natural number to `USize`, returning the largest representable value if the number is too large. Returns `USize.size - 1`, which is `2^64 - 1` or `2^32 - 1` depending on the platform, for natural numbers greater than or equal to `USize.size`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 358,
    "source": "core"
  },
  "USize.toNat": {
    "name": "USize.toNat",
    "type": "def",
    "signature": "USize.toNat : Nat",
    "docstring": "Converts a word-sized unsigned integer to an arbitrary-precision natural number. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 370,
    "source": "core"
  },
  "USize.add": {
    "name": "USize.add",
    "type": "def",
    "signature": "USize.add : USize",
    "docstring": "Adds two word-sized unsigned integers, wrapping around on overflow. Usually accessed via the `+` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 378,
    "source": "core"
  },
  "USize.sub": {
    "name": "USize.sub",
    "type": "def",
    "signature": "USize.sub : USize",
    "docstring": "Subtracts one word-sized-bit unsigned integer from another, wrapping around on underflow. Usually accessed via the `-` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 386,
    "source": "core"
  },
  "USize.lt": {
    "name": "USize.lt",
    "type": "def",
    "signature": "USize.lt : Prop",
    "docstring": "Strict inequality of word-sized unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `<` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 392,
    "source": "core"
  },
  "USize.le": {
    "name": "USize.le",
    "type": "def",
    "signature": "USize.le : Prop",
    "docstring": "Non-strict inequality of word-sized unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `≤` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 397,
    "source": "core"
  },
  "USize.decLt": {
    "name": "USize.decLt",
    "type": "def",
    "signature": "USize.decLt : Decidable (a < b)",
    "docstring": "Decides whether one word-sized unsigned integer is strictly less than another. Usually accessed via the `DecidableLT USize` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (6 : USize) < 7 then \"yes\" else \"no\") = \"yes\"` * `(if (5 : USize) < 5 then \"yes\" else \"no\") = \"no\"` * `show ¬((7 : USize) < 7) by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 418,
    "source": "core"
  },
  "USize.decLe": {
    "name": "USize.decLe",
    "type": "def",
    "signature": "USize.decLe : Decidable (a ≤ b)",
    "docstring": "Decides whether one word-sized unsigned integer is less than or equal to another. Usually accessed via the `DecidableLE USize` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (15 : USize) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `(if (15 : USize) ≤ 5 then \"yes\" else \"no\") = \"no\"` * `(if (5 : USize) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `show (7 : USize) ≤ 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 434,
    "source": "core"
  },
  "Nat.toUInt8": {
    "name": "Nat.toUInt8",
    "type": "abbrev",
    "signature": "Nat.toUInt8",
    "docstring": "Converts a natural number to an 8-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `Nat.toUInt8 5 = 5` * `Nat.toUInt8 255 = 255` * `Nat.toUInt8 256 = 0` * `Nat.toUInt8 259 = 3` * `Nat.toUInt8 32770 = 2`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 69,
    "source": "core"
  },
  "Nat.toUInt16": {
    "name": "Nat.toUInt16",
    "type": "abbrev",
    "signature": "Nat.toUInt16",
    "docstring": "Converts a natural number to a 16-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `Nat.toUInt16 5 = 5` * `Nat.toUInt16 255 = 255` * `Nat.toUInt16 32770 = 32770` * `Nat.toUInt16 65537 = 1`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 122,
    "source": "core"
  },
  "Nat.toUInt32": {
    "name": "Nat.toUInt32",
    "type": "abbrev",
    "signature": "Nat.toUInt32",
    "docstring": "Converts a natural number to a 32-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `Nat.toUInt32 5 = 5` * `Nat.toUInt32 65_539 = 65_539` * `Nat.toUInt32 4_294_967_299 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 188,
    "source": "core"
  },
  "Nat.toUInt64": {
    "name": "Nat.toUInt64",
    "type": "abbrev",
    "signature": "Nat.toUInt64",
    "docstring": "Converts a natural number to a 64-bit unsigned integer, wrapping on overflow. This function is overridden at runtime with an efficient implementation. Examples: * `Nat.toUInt64 5 = 5` * `Nat.toUInt64 65539 = 65539` * `Nat.toUInt64 4_294_967_299 = 4_294_967_299` * `Nat.toUInt64 18_446_744_073_709_551_620 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/BasicAux.lean",
    "line_number": 278,
    "source": "core"
  },
  "UInt8.log2": {
    "name": "UInt8.log2",
    "type": "def",
    "signature": "UInt8.log2 : UInt8",
    "docstring": "Base-two logarithm of 8-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`. This function is overridden at runtime with an efficient implementation. This definition is the logical model. Examples: * `UInt8.log2 0 = 0` * `UInt8.log2 1 = 0` * `UInt8.log2 2 = 1` * `UInt8.log2 4 = 2` * `UInt8.log2 7 = 2` * `UInt8.log2 8 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Log2.lean",
    "line_number": 26,
    "source": "core"
  },
  "UInt16.log2": {
    "name": "UInt16.log2",
    "type": "def",
    "signature": "UInt16.log2 : UInt16",
    "docstring": "Base-two logarithm of 16-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`. This function is overridden at runtime with an efficient implementation. This definition is the logical model. Examples: * `UInt16.log2 0 = 0` * `UInt16.log2 1 = 0` * `UInt16.log2 2 = 1` * `UInt16.log2 4 = 2` * `UInt16.log2 7 = 2` * `UInt16.log2 8 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Log2.lean",
    "line_number": 43,
    "source": "core"
  },
  "UInt32.log2": {
    "name": "UInt32.log2",
    "type": "def",
    "signature": "UInt32.log2 : UInt32",
    "docstring": "Base-two logarithm of 32-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`. This function is overridden at runtime with an efficient implementation. This definition is the logical model. Examples: * `UInt32.log2 0 = 0` * `UInt32.log2 1 = 0` * `UInt32.log2 2 = 1` * `UInt32.log2 4 = 2` * `UInt32.log2 7 = 2` * `UInt32.log2 8 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Log2.lean",
    "line_number": 60,
    "source": "core"
  },
  "UInt64.log2": {
    "name": "UInt64.log2",
    "type": "def",
    "signature": "UInt64.log2 : UInt64",
    "docstring": "Base-two logarithm of 64-bit unsigned integers. Returns `⌊max 0 (log₂ a)⌋`. This function is overridden at runtime with an efficient implementation. This definition is the logical model. Examples: * `UInt64.log2 0 = 0` * `UInt64.log2 1 = 0` * `UInt64.log2 2 = 1` * `UInt64.log2 4 = 2` * `UInt64.log2 7 = 2` * `UInt64.log2 8 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Log2.lean",
    "line_number": 77,
    "source": "core"
  },
  "USize.log2": {
    "name": "USize.log2",
    "type": "def",
    "signature": "USize.log2 : USize",
    "docstring": "Base-two logarithm of word-sized unsigned integers. Returns `⌊max 0 (log₂ a)⌋`. This function is overridden at runtime with an efficient implementation. This definition is the logical model. Examples: * `USize.log2 0 = 0` * `USize.log2 1 = 0` * `USize.log2 2 = 1` * `USize.log2 4 = 2` * `USize.log2 7 = 2` * `USize.log2 8 = 3`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Log2.lean",
    "line_number": 94,
    "source": "core"
  },
  "UInt8.mk": {
    "name": "UInt8.mk",
    "type": "def",
    "signature": "UInt8.mk : UInt8",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 19,
    "source": "core"
  },
  "UInt8.ofNatCore": {
    "name": "UInt8.ofNatCore",
    "type": "def",
    "signature": "UInt8.ofNatCore : UInt8",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 22,
    "source": "core"
  },
  "UInt8.ofInt": {
    "name": "UInt8.ofInt",
    "type": "def",
    "signature": "UInt8.ofInt : UInt8",
    "docstring": "Converts an `Int` to a `UInt8` by taking the (non-negative remainder of the division by `2 ^ 8`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 26,
    "source": "core"
  },
  "UInt8.add": {
    "name": "UInt8.add",
    "type": "def",
    "signature": "UInt8.add : UInt8",
    "docstring": "Adds two 8-bit unsigned integers, wrapping around on overflow. Usually accessed via the `+` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 35,
    "source": "core"
  },
  "UInt8.sub": {
    "name": "UInt8.sub",
    "type": "def",
    "signature": "UInt8.sub : UInt8",
    "docstring": "Subtracts one 8-bit unsigned integer from another, wrapping around on underflow. Usually accessed via the `-` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 43,
    "source": "core"
  },
  "UInt8.mul": {
    "name": "UInt8.mul",
    "type": "def",
    "signature": "UInt8.mul : UInt8",
    "docstring": "Multiplies two 8-bit unsigned integers, wrapping around on overflow. Usually accessed via the `*` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 51,
    "source": "core"
  },
  "UInt8.div": {
    "name": "UInt8.div",
    "type": "def",
    "signature": "UInt8.div : UInt8",
    "docstring": "Unsigned division for 8-bit unsigned integers, discarding the remainder. Usually accessed via the `/` operator. This operation is sometimes called “floor division.” Division by zero is defined to be zero. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 61,
    "source": "core"
  },
  "UInt8.pow": {
    "name": "UInt8.pow",
    "type": "def",
    "signature": "UInt8.pow : UInt8",
    "docstring": "The power operation, raising an 8-bit unsigned integer to a natural number power, wrapping around on overflow. Usually accessed via the `^` operator. This function is currently *not* overridden at runtime with an efficient implementation, and should be used with caution. See https://github.com/leanprover/lean4/issues/7887.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 69,
    "source": "core"
  },
  "UInt8.mod": {
    "name": "UInt8.mod",
    "type": "def",
    "signature": "UInt8.mod : UInt8",
    "docstring": "The modulo operator for 8-bit unsigned integers, which computes the remainder when dividing one integer by another. Usually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather than an error. This function is overridden at runtime with an efficient implementation. Examples: * `UInt8.mod 5 2 = 1` * `UInt8.mod 4 2 = 0` * `UInt8.mod 4 0 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 87,
    "source": "core"
  },
  "UInt8.modn": {
    "name": "UInt8.modn",
    "type": "def",
    "signature": "UInt8.modn : UInt8",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 92,
    "source": "core"
  },
  "UInt8.land": {
    "name": "UInt8.land",
    "type": "def",
    "signature": "UInt8.land : UInt8",
    "docstring": "Bitwise and for 8-bit unsigned integers. Usually accessed via the `&&&` operator. Each bit of the resulting integer is set if the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 101,
    "source": "core"
  },
  "UInt8.lor": {
    "name": "UInt8.lor",
    "type": "def",
    "signature": "UInt8.lor : UInt8",
    "docstring": "Bitwise or for 8-bit unsigned integers. Usually accessed via the `|||` operator. Each bit of the resulting integer is set if at least one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 111,
    "source": "core"
  },
  "UInt8.xor": {
    "name": "UInt8.xor",
    "type": "def",
    "signature": "UInt8.xor : UInt8",
    "docstring": "Bitwise exclusive or for 8-bit unsigned integers. Usually accessed via the `^^^` operator. Each bit of the resulting integer is set if exactly one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 121,
    "source": "core"
  },
  "UInt8.shiftLeft": {
    "name": "UInt8.shiftLeft",
    "type": "def",
    "signature": "UInt8.shiftLeft : UInt8",
    "docstring": "Bitwise left shift for 8-bit unsigned integers. Usually accessed via the `<<<` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 128,
    "source": "core"
  },
  "UInt8.shiftRight": {
    "name": "UInt8.shiftRight",
    "type": "def",
    "signature": "UInt8.shiftRight : UInt8",
    "docstring": "Bitwise right shift for 8-bit unsigned integers. Usually accessed via the `>>>` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 135,
    "source": "core"
  },
  "UInt8.lt": {
    "name": "UInt8.lt",
    "type": "def",
    "signature": "UInt8.lt : Prop",
    "docstring": "Strict inequality of 8-bit unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `<` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 140,
    "source": "core"
  },
  "UInt8.le": {
    "name": "UInt8.le",
    "type": "def",
    "signature": "UInt8.le : Prop",
    "docstring": "Non-strict inequality of 8-bit unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `≤` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 145,
    "source": "core"
  },
  "UInt8.complement": {
    "name": "UInt8.complement",
    "type": "def",
    "signature": "UInt8.complement : UInt8",
    "docstring": "Bitwise complement, also known as bitwise negation, for 8-bit unsigned integers. Usually accessed via the `~~~` prefix operator. Each bit of the resulting integer is the opposite of the corresponding bit of the input integer. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 169,
    "source": "core"
  },
  "UInt8.neg": {
    "name": "UInt8.neg",
    "type": "def",
    "signature": "UInt8.neg : UInt8",
    "docstring": "Negation of 8-bit unsigned integers, computed modulo `UInt8.size`. `UInt8.neg a` is equivalent to `255 - a + 1`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 178,
    "source": "core"
  },
  "Bool.toUInt8": {
    "name": "Bool.toUInt8",
    "type": "def",
    "signature": "Bool.toUInt8 : UInt8",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 192,
    "source": "core"
  },
  "UInt8.decLt": {
    "name": "UInt8.decLt",
    "type": "def",
    "signature": "UInt8.decLt : Decidable (a < b)",
    "docstring": "Decides whether one 8-bit unsigned integer is strictly less than another. Usually accessed via the `DecidableLT UInt8` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (6 : UInt8) < 7 then \"yes\" else \"no\") = \"yes\"` * `(if (5 : UInt8) < 5 then \"yes\" else \"no\") = \"no\"` * `show ¬((7 : UInt8) < 7) by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 206,
    "source": "core"
  },
  "UInt8.decLe": {
    "name": "UInt8.decLe",
    "type": "def",
    "signature": "UInt8.decLe : Decidable (a ≤ b)",
    "docstring": "Decides whether one 8-bit unsigned integer is less than or equal to another. Usually accessed via the `DecidableLE UInt8` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (15 : UInt8) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `(if (15 : UInt8) ≤ 5 then \"yes\" else \"no\") = \"no\"` * `(if (5 : UInt8) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `show (7 : UInt8) ≤ 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 222,
    "source": "core"
  },
  "UInt16.mk": {
    "name": "UInt16.mk",
    "type": "def",
    "signature": "UInt16.mk : UInt16",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 233,
    "source": "core"
  },
  "UInt16.ofNatCore": {
    "name": "UInt16.ofNatCore",
    "type": "def",
    "signature": "UInt16.ofNatCore : UInt16",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 236,
    "source": "core"
  },
  "UInt16.ofInt": {
    "name": "UInt16.ofInt",
    "type": "def",
    "signature": "UInt16.ofInt : UInt16",
    "docstring": "Converts an `Int` to a `UInt16` by taking the (non-negative remainder of the division by `2 ^ 16`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 240,
    "source": "core"
  },
  "UInt16.add": {
    "name": "UInt16.add",
    "type": "def",
    "signature": "UInt16.add : UInt16",
    "docstring": "Adds two 16-bit unsigned integers, wrapping around on overflow. Usually accessed via the `+` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 249,
    "source": "core"
  },
  "UInt16.sub": {
    "name": "UInt16.sub",
    "type": "def",
    "signature": "UInt16.sub : UInt16",
    "docstring": "Subtracts one 16-bit unsigned integer from another, wrapping around on underflow. Usually accessed via the `-` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 257,
    "source": "core"
  },
  "UInt16.mul": {
    "name": "UInt16.mul",
    "type": "def",
    "signature": "UInt16.mul : UInt16",
    "docstring": "Multiplies two 16-bit unsigned integers, wrapping around on overflow. Usually accessed via the `*` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 265,
    "source": "core"
  },
  "UInt16.div": {
    "name": "UInt16.div",
    "type": "def",
    "signature": "UInt16.div : UInt16",
    "docstring": "Unsigned division for 16-bit unsigned integers, discarding the remainder. Usually accessed via the `/` operator. This operation is sometimes called “floor division.” Division by zero is defined to be zero. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 275,
    "source": "core"
  },
  "UInt16.pow": {
    "name": "UInt16.pow",
    "type": "def",
    "signature": "UInt16.pow : UInt16",
    "docstring": "The power operation, raising a 16-bit unsigned integer to a natural number power, wrapping around on overflow. Usually accessed via the `^` operator. This function is currently *not* overridden at runtime with an efficient implementation, and should be used with caution. See https://github.com/leanprover/lean4/issues/7887.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 283,
    "source": "core"
  },
  "UInt16.mod": {
    "name": "UInt16.mod",
    "type": "def",
    "signature": "UInt16.mod : UInt16",
    "docstring": "The modulo operator for 16-bit unsigned integers, which computes the remainder when dividing one integer by another. Usually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather than an error. This function is overridden at runtime with an efficient implementation. Examples: * `UInt16.mod 5 2 = 1` * `UInt16.mod 4 2 = 0` * `UInt16.mod 4 0 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 301,
    "source": "core"
  },
  "UInt16.modn": {
    "name": "UInt16.modn",
    "type": "def",
    "signature": "UInt16.modn : UInt16",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 306,
    "source": "core"
  },
  "UInt16.land": {
    "name": "UInt16.land",
    "type": "def",
    "signature": "UInt16.land : UInt16",
    "docstring": "Bitwise and for 16-bit unsigned integers. Usually accessed via the `&&&` operator. Each bit of the resulting integer is set if the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 315,
    "source": "core"
  },
  "UInt16.lor": {
    "name": "UInt16.lor",
    "type": "def",
    "signature": "UInt16.lor : UInt16",
    "docstring": "Bitwise or for 16-bit unsigned integers. Usually accessed via the `|||` operator. Each bit of the resulting integer is set if at least one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 325,
    "source": "core"
  },
  "UInt16.xor": {
    "name": "UInt16.xor",
    "type": "def",
    "signature": "UInt16.xor : UInt16",
    "docstring": "Bitwise exclusive or for 16-bit unsigned integers. Usually accessed via the `^^^` operator. Each bit of the resulting integer is set if exactly one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 335,
    "source": "core"
  },
  "UInt16.shiftLeft": {
    "name": "UInt16.shiftLeft",
    "type": "def",
    "signature": "UInt16.shiftLeft : UInt16",
    "docstring": "Bitwise left shift for 16-bit unsigned integers. Usually accessed via the `<<<` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 342,
    "source": "core"
  },
  "UInt16.shiftRight": {
    "name": "UInt16.shiftRight",
    "type": "def",
    "signature": "UInt16.shiftRight : UInt16",
    "docstring": "Bitwise right shift for 16-bit unsigned integers. Usually accessed via the `>>>` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 349,
    "source": "core"
  },
  "UInt16.lt": {
    "name": "UInt16.lt",
    "type": "def",
    "signature": "UInt16.lt : Prop",
    "docstring": "Strict inequality of 16-bit unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `<` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 354,
    "source": "core"
  },
  "UInt16.le": {
    "name": "UInt16.le",
    "type": "def",
    "signature": "UInt16.le : Prop",
    "docstring": "Non-strict inequality of 16-bit unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `≤` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 359,
    "source": "core"
  },
  "UInt16.complement": {
    "name": "UInt16.complement",
    "type": "def",
    "signature": "UInt16.complement : UInt16",
    "docstring": "Bitwise complement, also known as bitwise negation, for 16-bit unsigned integers. Usually accessed via the `~~~` prefix operator. Each bit of the resulting integer is the opposite of the corresponding bit of the input integer. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 383,
    "source": "core"
  },
  "UInt16.neg": {
    "name": "UInt16.neg",
    "type": "def",
    "signature": "UInt16.neg : UInt16",
    "docstring": "Negation of 16-bit unsigned integers, computed modulo `UInt16.size`. `UInt16.neg a` is equivalent to `65_535 - a + 1`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 392,
    "source": "core"
  },
  "Bool.toUInt16": {
    "name": "Bool.toUInt16",
    "type": "def",
    "signature": "Bool.toUInt16 : UInt16",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 406,
    "source": "core"
  },
  "UInt16.decLt": {
    "name": "UInt16.decLt",
    "type": "def",
    "signature": "UInt16.decLt : Decidable (a < b)",
    "docstring": "Decides whether one 16-bit unsigned integer is strictly less than another. Usually accessed via the `DecidableLT UInt16` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (6 : UInt16) < 7 then \"yes\" else \"no\") = \"yes\"` * `(if (5 : UInt16) < 5 then \"yes\" else \"no\") = \"no\"` * `show ¬((7 : UInt16) < 7) by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 421,
    "source": "core"
  },
  "UInt16.decLe": {
    "name": "UInt16.decLe",
    "type": "def",
    "signature": "UInt16.decLe : Decidable (a ≤ b)",
    "docstring": "Decides whether one 16-bit unsigned integer is less than or equal to another. Usually accessed via the `DecidableLE UInt16` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (15 : UInt16) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `(if (15 : UInt16) ≤ 5 then \"yes\" else \"no\") = \"no\"` * `(if (5 : UInt16) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `show (7 : UInt16) ≤ 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 438,
    "source": "core"
  },
  "UInt32.mk": {
    "name": "UInt32.mk",
    "type": "def",
    "signature": "UInt32.mk : UInt32",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 449,
    "source": "core"
  },
  "UInt32.ofNatCore": {
    "name": "UInt32.ofNatCore",
    "type": "def",
    "signature": "UInt32.ofNatCore : UInt32",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 452,
    "source": "core"
  },
  "UInt32.ofInt": {
    "name": "UInt32.ofInt",
    "type": "def",
    "signature": "UInt32.ofInt : UInt32",
    "docstring": "Converts an `Int` to a `UInt32` by taking the (non-negative remainder of the division by `2 ^ 32`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 456,
    "source": "core"
  },
  "UInt32.add": {
    "name": "UInt32.add",
    "type": "def",
    "signature": "UInt32.add : UInt32",
    "docstring": "Adds two 32-bit unsigned integers, wrapping around on overflow. Usually accessed via the `+` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 465,
    "source": "core"
  },
  "UInt32.sub": {
    "name": "UInt32.sub",
    "type": "def",
    "signature": "UInt32.sub : UInt32",
    "docstring": "Subtracts one 32-bit unsigned integer from another, wrapping around on underflow. Usually accessed via the `-` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 473,
    "source": "core"
  },
  "UInt32.mul": {
    "name": "UInt32.mul",
    "type": "def",
    "signature": "UInt32.mul : UInt32",
    "docstring": "Multiplies two 32-bit unsigned integers, wrapping around on overflow. Usually accessed via the `*` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 481,
    "source": "core"
  },
  "UInt32.div": {
    "name": "UInt32.div",
    "type": "def",
    "signature": "UInt32.div : UInt32",
    "docstring": "Unsigned division for 32-bit unsigned integers, discarding the remainder. Usually accessed via the `/` operator. This operation is sometimes called “floor division.” Division by zero is defined to be zero. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 491,
    "source": "core"
  },
  "UInt32.pow": {
    "name": "UInt32.pow",
    "type": "def",
    "signature": "UInt32.pow : UInt32",
    "docstring": "The power operation, raising a 32-bit unsigned integer to a natural number power, wrapping around on overflow. Usually accessed via the `^` operator. This function is currently *not* overridden at runtime with an efficient implementation, and should be used with caution. See https://github.com/leanprover/lean4/issues/7887.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 499,
    "source": "core"
  },
  "UInt32.mod": {
    "name": "UInt32.mod",
    "type": "def",
    "signature": "UInt32.mod : UInt32",
    "docstring": "The modulo operator for 32-bit unsigned integers, which computes the remainder when dividing one integer by another. Usually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather than an error. This function is overridden at runtime with an efficient implementation. Examples: * `UInt32.mod 5 2 = 1` * `UInt32.mod 4 2 = 0` * `UInt32.mod 4 0 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 517,
    "source": "core"
  },
  "UInt32.modn": {
    "name": "UInt32.modn",
    "type": "def",
    "signature": "UInt32.modn : UInt32",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 522,
    "source": "core"
  },
  "UInt32.land": {
    "name": "UInt32.land",
    "type": "def",
    "signature": "UInt32.land : UInt32",
    "docstring": "Bitwise and for 32-bit unsigned integers. Usually accessed via the `&&&` operator. Each bit of the resulting integer is set if the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 531,
    "source": "core"
  },
  "UInt32.lor": {
    "name": "UInt32.lor",
    "type": "def",
    "signature": "UInt32.lor : UInt32",
    "docstring": "Bitwise or for 32-bit unsigned integers. Usually accessed via the `|||` operator. Each bit of the resulting integer is set if at least one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 541,
    "source": "core"
  },
  "UInt32.xor": {
    "name": "UInt32.xor",
    "type": "def",
    "signature": "UInt32.xor : UInt32",
    "docstring": "Bitwise exclusive or for 32-bit unsigned integers. Usually accessed via the `^^^` operator. Each bit of the resulting integer is set if exactly one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 551,
    "source": "core"
  },
  "UInt32.shiftLeft": {
    "name": "UInt32.shiftLeft",
    "type": "def",
    "signature": "UInt32.shiftLeft : UInt32",
    "docstring": "Bitwise left shift for 32-bit unsigned integers. Usually accessed via the `<<<` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 558,
    "source": "core"
  },
  "UInt32.shiftRight": {
    "name": "UInt32.shiftRight",
    "type": "def",
    "signature": "UInt32.shiftRight : UInt32",
    "docstring": "Bitwise right shift for 32-bit unsigned integers. Usually accessed via the `>>>` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 565,
    "source": "core"
  },
  "UInt32.complement": {
    "name": "UInt32.complement",
    "type": "def",
    "signature": "UInt32.complement : UInt32",
    "docstring": "Bitwise complement, also known as bitwise negation, for 32-bit unsigned integers. Usually accessed via the `~~~` prefix operator. Each bit of the resulting integer is the opposite of the corresponding bit of the input integer. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 600,
    "source": "core"
  },
  "UInt32.neg": {
    "name": "UInt32.neg",
    "type": "def",
    "signature": "UInt32.neg : UInt32",
    "docstring": "Negation of 32-bit unsigned integers, computed modulo `UInt32.size`. `UInt32.neg a` is equivalent to `429_4967_295 - a + 1`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 609,
    "source": "core"
  },
  "Bool.toUInt32": {
    "name": "Bool.toUInt32",
    "type": "def",
    "signature": "Bool.toUInt32 : UInt32",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 623,
    "source": "core"
  },
  "UInt64.mk": {
    "name": "UInt64.mk",
    "type": "def",
    "signature": "UInt64.mk : UInt64",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 628,
    "source": "core"
  },
  "UInt64.ofNatCore": {
    "name": "UInt64.ofNatCore",
    "type": "def",
    "signature": "UInt64.ofNatCore : UInt64",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 631,
    "source": "core"
  },
  "UInt64.ofInt": {
    "name": "UInt64.ofInt",
    "type": "def",
    "signature": "UInt64.ofInt : UInt64",
    "docstring": "Converts an `Int` to a `UInt64` by taking the (non-negative remainder of the division by `2 ^ 64`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 635,
    "source": "core"
  },
  "UInt64.add": {
    "name": "UInt64.add",
    "type": "def",
    "signature": "UInt64.add : UInt64",
    "docstring": "Adds two 64-bit unsigned integers, wrapping around on overflow. Usually accessed via the `+` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 644,
    "source": "core"
  },
  "UInt64.sub": {
    "name": "UInt64.sub",
    "type": "def",
    "signature": "UInt64.sub : UInt64",
    "docstring": "Subtracts one 64-bit unsigned integer from another, wrapping around on underflow. Usually accessed via the `-` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 652,
    "source": "core"
  },
  "UInt64.mul": {
    "name": "UInt64.mul",
    "type": "def",
    "signature": "UInt64.mul : UInt64",
    "docstring": "Multiplies two 64-bit unsigned integers, wrapping around on overflow. Usually accessed via the `*` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 660,
    "source": "core"
  },
  "UInt64.div": {
    "name": "UInt64.div",
    "type": "def",
    "signature": "UInt64.div : UInt64",
    "docstring": "Unsigned division for 64-bit unsigned integers, discarding the remainder. Usually accessed via the `/` operator. This operation is sometimes called “floor division.” Division by zero is defined to be zero. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 670,
    "source": "core"
  },
  "UInt64.pow": {
    "name": "UInt64.pow",
    "type": "def",
    "signature": "UInt64.pow : UInt64",
    "docstring": "The power operation, raising a 64-bit unsigned integer to a natural number power, wrapping around on overflow. Usually accessed via the `^` operator. This function is currently *not* overridden at runtime with an efficient implementation, and should be used with caution. See https://github.com/leanprover/lean4/issues/7887.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 678,
    "source": "core"
  },
  "UInt64.mod": {
    "name": "UInt64.mod",
    "type": "def",
    "signature": "UInt64.mod : UInt64",
    "docstring": "The modulo operator for 64-bit unsigned integers, which computes the remainder when dividing one integer by another. Usually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather than an error. This function is overridden at runtime with an efficient implementation. Examples: * `UInt64.mod 5 2 = 1` * `UInt64.mod 4 2 = 0` * `UInt64.mod 4 0 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 696,
    "source": "core"
  },
  "UInt64.modn": {
    "name": "UInt64.modn",
    "type": "def",
    "signature": "UInt64.modn : UInt64",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 701,
    "source": "core"
  },
  "UInt64.land": {
    "name": "UInt64.land",
    "type": "def",
    "signature": "UInt64.land : UInt64",
    "docstring": "Bitwise and for 64-bit unsigned integers. Usually accessed via the `&&&` operator. Each bit of the resulting integer is set if the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 710,
    "source": "core"
  },
  "UInt64.lor": {
    "name": "UInt64.lor",
    "type": "def",
    "signature": "UInt64.lor : UInt64",
    "docstring": "Bitwise or for 64-bit unsigned integers. Usually accessed via the `|||` operator. Each bit of the resulting integer is set if at least one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 720,
    "source": "core"
  },
  "UInt64.xor": {
    "name": "UInt64.xor",
    "type": "def",
    "signature": "UInt64.xor : UInt64",
    "docstring": "Bitwise exclusive or for 64-bit unsigned integers. Usually accessed via the `^^^` operator. Each bit of the resulting integer is set if exactly one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 730,
    "source": "core"
  },
  "UInt64.shiftLeft": {
    "name": "UInt64.shiftLeft",
    "type": "def",
    "signature": "UInt64.shiftLeft : UInt64",
    "docstring": "Bitwise left shift for 64-bit unsigned integers. Usually accessed via the `<<<` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 737,
    "source": "core"
  },
  "UInt64.shiftRight": {
    "name": "UInt64.shiftRight",
    "type": "def",
    "signature": "UInt64.shiftRight : UInt64",
    "docstring": "Bitwise right shift for 64-bit unsigned integers. Usually accessed via the `>>>` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 744,
    "source": "core"
  },
  "UInt64.lt": {
    "name": "UInt64.lt",
    "type": "def",
    "signature": "UInt64.lt : Prop",
    "docstring": "Strict inequality of 64-bit unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `<` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 749,
    "source": "core"
  },
  "UInt64.le": {
    "name": "UInt64.le",
    "type": "def",
    "signature": "UInt64.le : Prop",
    "docstring": "Non-strict inequality of 64-bit unsigned integers, defined as inequality of the corresponding natural numbers. Usually accessed via the `≤` operator.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 754,
    "source": "core"
  },
  "UInt64.complement": {
    "name": "UInt64.complement",
    "type": "def",
    "signature": "UInt64.complement : UInt64",
    "docstring": "Bitwise complement, also known as bitwise negation, for 64-bit unsigned integers. Usually accessed via the `~~~` prefix operator. Each bit of the resulting integer is the opposite of the corresponding bit of the input integer. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 778,
    "source": "core"
  },
  "UInt64.neg": {
    "name": "UInt64.neg",
    "type": "def",
    "signature": "UInt64.neg : UInt64",
    "docstring": "Negation of 64-bit unsigned integers, computed modulo `UInt64.size`. `UInt64.neg a` is equivalent to `18_446_744_073_709_551_615 - a + 1`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 787,
    "source": "core"
  },
  "Bool.toUInt64": {
    "name": "Bool.toUInt64",
    "type": "def",
    "signature": "Bool.toUInt64 : UInt64",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 801,
    "source": "core"
  },
  "UInt64.decLt": {
    "name": "UInt64.decLt",
    "type": "def",
    "signature": "UInt64.decLt : Decidable (a < b)",
    "docstring": "Decides whether one 64-bit unsigned integer is strictly less than another. Usually accessed via the `DecidableLT UInt64` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (6 : UInt64) < 7 then \"yes\" else \"no\") = \"yes\"` * `(if (5 : UInt64) < 5 then \"yes\" else \"no\") = \"no\"` * `show ¬((7 : UInt64) < 7) by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 815,
    "source": "core"
  },
  "UInt64.decLe": {
    "name": "UInt64.decLe",
    "type": "def",
    "signature": "UInt64.decLe : Decidable (a ≤ b)",
    "docstring": "Decides whether one 64-bit unsigned integer is less than or equal to another. Usually accessed via the `DecidableLE UInt64` instance. This function is overridden at runtime with an efficient implementation. Examples: * `(if (15 : UInt64) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `(if (15 : UInt64) ≤ 5 then \"yes\" else \"no\") = \"no\"` * `(if (5 : UInt64) ≤ 15 then \"yes\" else \"no\") = \"yes\"` * `show (7 : UInt64) ≤ 7 by decide`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 831,
    "source": "core"
  },
  "USize.mk": {
    "name": "USize.mk",
    "type": "def",
    "signature": "USize.mk : USize",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 842,
    "source": "core"
  },
  "USize.ofNatCore": {
    "name": "USize.ofNatCore",
    "type": "def",
    "signature": "USize.ofNatCore : USize",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 845,
    "source": "core"
  },
  "USize.ofInt": {
    "name": "USize.ofInt",
    "type": "def",
    "signature": "USize.ofInt : USize",
    "docstring": "Converts an `Int` to a `USize` by taking the (non-negative remainder of the division by `2 ^ numBits`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 849,
    "source": "core"
  },
  "USize.mul": {
    "name": "USize.mul",
    "type": "def",
    "signature": "USize.mul : USize",
    "docstring": "Multiplies two word-sized unsigned integers, wrapping around on overflow. Usually accessed via the `*` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 869,
    "source": "core"
  },
  "USize.div": {
    "name": "USize.div",
    "type": "def",
    "signature": "USize.div : USize",
    "docstring": "Unsigned division for word-sized unsigned integers, discarding the remainder. Usually accessed via the `/` operator. This operation is sometimes called “floor division.” Division by zero is defined to be zero. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 879,
    "source": "core"
  },
  "USize.pow": {
    "name": "USize.pow",
    "type": "def",
    "signature": "USize.pow : USize",
    "docstring": "The power operation, raising a word-sized unsigned integer to a natural number power, wrapping around on overflow. Usually accessed via the `^` operator. This function is currently *not* overridden at runtime with an efficient implementation, and should be used with caution. See https://github.com/leanprover/lean4/issues/7887.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 887,
    "source": "core"
  },
  "USize.mod": {
    "name": "USize.mod",
    "type": "def",
    "signature": "USize.mod : USize",
    "docstring": "The modulo operator for word-sized unsigned integers, which computes the remainder when dividing one integer by another. Usually accessed via the `%` operator. When the divisor is `0`, the result is the dividend rather than an error. This function is overridden at runtime with an efficient implementation. Examples: * `USize.mod 5 2 = 1` * `USize.mod 4 2 = 0` * `USize.mod 4 0 = 4`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 905,
    "source": "core"
  },
  "USize.modn": {
    "name": "USize.modn",
    "type": "def",
    "signature": "USize.modn : USize",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 910,
    "source": "core"
  },
  "USize.land": {
    "name": "USize.land",
    "type": "def",
    "signature": "USize.land : USize",
    "docstring": "Bitwise and for word-sized unsigned integers. Usually accessed via the `&&&` operator. Each bit of the resulting integer is set if the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 919,
    "source": "core"
  },
  "USize.lor": {
    "name": "USize.lor",
    "type": "def",
    "signature": "USize.lor : USize",
    "docstring": "Bitwise or for word-sized unsigned integers. Usually accessed via the `|||` operator. Each bit of the resulting integer is set if at least one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 929,
    "source": "core"
  },
  "USize.xor": {
    "name": "USize.xor",
    "type": "def",
    "signature": "USize.xor : USize",
    "docstring": "Bitwise exclusive or for word-sized unsigned integers. Usually accessed via the `^^^` operator. Each bit of the resulting integer is set if exactly one of the corresponding bits of both input integers are set. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 939,
    "source": "core"
  },
  "USize.shiftLeft": {
    "name": "USize.shiftLeft",
    "type": "def",
    "signature": "USize.shiftLeft : USize",
    "docstring": "Bitwise left shift for word-sized unsigned integers. Usually accessed via the `<<<` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 946,
    "source": "core"
  },
  "USize.shiftRight": {
    "name": "USize.shiftRight",
    "type": "def",
    "signature": "USize.shiftRight : USize",
    "docstring": "Bitwise right shift for word-sized unsigned integers. Usually accessed via the `>>>` operator. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 953,
    "source": "core"
  },
  "USize.ofNat32": {
    "name": "USize.ofNat32",
    "type": "def",
    "signature": "USize.ofNat32 : USize",
    "docstring": "Converts a natural number to a `USize`. Overflow is impossible on any supported platform because `USize.size` is either `2^32` or `2^64`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 961,
    "source": "core"
  },
  "UInt8.toUSize": {
    "name": "UInt8.toUSize",
    "type": "def",
    "signature": "UInt8.toUSize : USize",
    "docstring": "Converts 8-bit unsigned integers to word-sized unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 969,
    "source": "core"
  },
  "USize.toUInt8": {
    "name": "USize.toUInt8",
    "type": "def",
    "signature": "USize.toUInt8 : UInt8",
    "docstring": "Converts word-sized unsigned integers to 8-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 977,
    "source": "core"
  },
  "UInt16.toUSize": {
    "name": "UInt16.toUSize",
    "type": "def",
    "signature": "UInt16.toUSize : USize",
    "docstring": "Converts 16-bit unsigned integers to word-sized unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 984,
    "source": "core"
  },
  "USize.toUInt16": {
    "name": "USize.toUInt16",
    "type": "def",
    "signature": "USize.toUInt16 : UInt16",
    "docstring": "Converts word-sized unsigned integers to 16-bit unsigned integers. Wraps around on overflow. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 992,
    "source": "core"
  },
  "UInt32.toUSize": {
    "name": "UInt32.toUSize",
    "type": "def",
    "signature": "UInt32.toUSize : USize",
    "docstring": "Converts 32-bit unsigned integers to word-sized unsigned integers. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 999,
    "source": "core"
  },
  "USize.toUInt32": {
    "name": "USize.toUInt32",
    "type": "def",
    "signature": "USize.toUInt32 : UInt32",
    "docstring": "Converts word-sized unsigned integers to 32-bit unsigned integers. Wraps around on overflow, which might occur on 64-bit architectures. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 1007,
    "source": "core"
  },
  "UInt64.toUSize": {
    "name": "UInt64.toUSize",
    "type": "def",
    "signature": "UInt64.toUSize : USize",
    "docstring": "Converts 64-bit unsigned integers to word-sized unsigned integers. On 32-bit machines, this may overflow, which results in the value wrapping around (that is, it is reduced modulo `USize.size`). This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 1015,
    "source": "core"
  },
  "USize.toUInt64": {
    "name": "USize.toUInt64",
    "type": "def",
    "signature": "USize.toUInt64 : UInt64",
    "docstring": "Converts word-sized unsigned integers to 32-bit unsigned integers. This cannot overflow because `USize.size` is either `2^32` or `2^64`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 1023,
    "source": "core"
  },
  "USize.complement": {
    "name": "USize.complement",
    "type": "def",
    "signature": "USize.complement : USize",
    "docstring": "Bitwise complement, also known as bitwise negation, for word-sized unsigned integers. Usually accessed via the `~~~` prefix operator. Each bit of the resulting integer is the opposite of the corresponding bit of the input integer. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 1044,
    "source": "core"
  },
  "USize.neg": {
    "name": "USize.neg",
    "type": "def",
    "signature": "USize.neg : USize",
    "docstring": "Negation of word-sized unsigned integers, computed modulo `USize.size`. This function is overridden at runtime with an efficient implementation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 1051,
    "source": "core"
  },
  "Bool.toUSize": {
    "name": "Bool.toUSize",
    "type": "def",
    "signature": "Bool.toUSize : USize",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/UInt/Basic.lean",
    "line_number": 1065,
    "source": "core"
  },
  "Fin.log2": {
    "name": "Fin.log2",
    "type": "def",
    "signature": "Fin.log2 : Fin m",
    "docstring": "Logarithm base 2 for bounded numbers. The resulting value is the same as that computed by `Nat.log2`. In particular, the result for `0` is `0`. Examples: * `(8 : Fin 10).log2 = (3 : Fin 10)` * `(7 : Fin 10).log2 = (2 : Fin 10)` * `(4 : Fin 10).log2 = (2 : Fin 10)` * `(3 : Fin 10).log2 = (1 : Fin 10)` * `(1 : Fin 10).log2 = (0 : Fin 10)` * `(0 : Fin 10).log2 = (0 : Fin 10)`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Fin/Log2.lean",
    "line_number": 27,
    "source": "core"
  },
  "Array.set": {
    "name": "Array.set",
    "type": "def",
    "signature": "Array.set : Array α where",
    "docstring": "Replaces the element at a given index in an array. No bounds check is performed, but the function requires a proof that the index is in bounds. This proof can usually be omitted, and will be synthesized automatically. The array is modified in-place if there are no other references to it. Examples: * `#[0, 1, 2].set 1 5 = #[0, 5, 2]` * `#[\"orange\", \"apple\"].set 1 \"grape\" = #[\"orange\", \"grape\"]`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Array/Set.lean",
    "line_number": 28,
    "source": "core"
  },
  "BitVec.repr": {
    "name": "BitVec.repr",
    "type": "def",
    "signature": "BitVec.repr : Std.Format",
    "docstring": "`BitVec` representation.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/BitVec/Basic.lean",
    "line_number": 205,
    "source": "core"
  },
  "List.toFloatArray": {
    "name": "List.toFloatArray",
    "type": "def",
    "signature": "List.toFloatArray : FloatArray",
    "docstring": "Converts a list of floats into a `FloatArray`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/FloatArray/Basic.lean",
    "line_number": 175,
    "source": "core"
  },
  "List.toByteArray": {
    "name": "List.toByteArray",
    "type": "def",
    "signature": "List.toByteArray : ByteArray",
    "docstring": "Converts a list of bytes into a `ByteArray`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/ByteArray/Basic.lean",
    "line_number": 346,
    "source": "core"
  },
  "ByteArray": {
    "name": "ByteArray",
    "type": "structure",
    "signature": "ByteArray",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/ByteArray/Basic.lean",
    "line_number": 15,
    "source": "core"
  },
  "Int": {
    "name": "Int",
    "type": "inductive",
    "signature": "Int : Type",
    "docstring": "The integers. This type is special-cased by the compiler and overridden with an efficient implementation. The runtime has a special representation for `Int` that stores “small” signed numbers directly, while larger numbers use a fast arbitrary-precision arithmetic library (usually [GMP](https://gmplib.org/)). A “small number” is an integer that can be encoded with one fewer bits than the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit architectures).",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Int/Basic.lean",
    "line_number": 42,
    "source": "core"
  },
  "List.toArrayAux": {
    "name": "List.toArrayAux",
    "type": "def",
    "signature": "List.toArrayAux : List α → Array α → Array α",
    "docstring": "Auxiliary definition for `List.toArray`. `List.toArrayAux as r = r ++ as.toArray`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/List/ToArrayImpl.lean",
    "line_number": 19,
    "source": "core"
  },
  "List.toArrayImpl": {
    "name": "List.toArrayImpl",
    "type": "def",
    "signature": "List.toArrayImpl : Array α",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/List/ToArrayImpl.lean",
    "line_number": 33,
    "source": "core"
  },
  "String.toFormat": {
    "name": "String.toFormat",
    "type": "def",
    "signature": "String.toFormat : Std.Format",
    "docstring": "Converts a string to a pretty-printer document, replacing newlines in the string with `Std.Format.line`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/Format/Instances.lean",
    "line_number": 48,
    "source": "core"
  },
  "String.isInt": {
    "name": "String.isInt",
    "type": "def",
    "signature": "String.isInt : Bool",
    "docstring": "Checks whether the string can be interpreted as the decimal representation of an integer. A string can be interpreted as a decimal integer if it only consists of at least one decimal digit and optionally `-` in front. Leading `+` characters are not allowed. Use `String.toInt?` or `String.toInt!` to convert such a string to an integer. Examples: * `\"\".isInt = false` * `\"-\".isInt = false` * `\"0\".isInt = true` * `\"-0\".isInt = true` * `\"5\".isInt = true` * `\"587\".isInt = true` * `\"-587\".isInt = true` * `\"+587\".isInt = false` * `\" 5\".isInt = false` * `\"2-3\".isInt = false` * `\"0xff\".isInt = false`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/ToString/Basic.lean",
    "line_number": 190,
    "source": "core"
  },
  "ToString": {
    "name": "ToString",
    "type": "class",
    "signature": "ToString",
    "docstring": "Types that can be converted into a string for display. There is no expectation that the resulting string can be parsed back to the original data (see `Repr` for a similar class with this expectation).",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/ToString/Basic.lean",
    "line_number": 22,
    "source": "core"
  },
  "List.asString": {
    "name": "List.asString",
    "type": "def",
    "signature": "List.asString : String",
    "docstring": "Creates a string that contains the characters in a list, in order. Examples: * `['L', '∃', '∀', 'N'].asString = \"L∃∀N\"` * `[].asString = \"\"` * `['a', 'a', 'a'].asString = \"aaa\"`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/String/Basic.lean",
    "line_number": 22,
    "source": "core"
  },
  "Float.toInt8": {
    "name": "Float.toInt8",
    "type": "opaque",
    "signature": "Float.toInt8 : Float → Int8",
    "docstring": "Truncates a floating-point number to the nearest 8-bit signed integer, rounding towards zero. If the `Float` is larger than the maximum value for `Int8` (including `Inf`), returns the maximum value of `Int8` (i.e. `Int8.maxValue`). If it is smaller than the minimum value for `Int8` (including `-Inf`), returns the minimum value of `Int8` (i.e. `Int8.minValue`). If it is `NaN`, returns `0`. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Float.lean",
    "line_number": 23,
    "source": "core"
  },
  "Float.toInt16": {
    "name": "Float.toInt16",
    "type": "opaque",
    "signature": "Float.toInt16 : Float → Int16",
    "docstring": "Truncates a floating-point number to the nearest 16-bit signed integer, rounding towards zero. If the `Float` is larger than the maximum value for `Int16` (including `Inf`), returns the maximum value of `Int16` (i.e. `Int16.maxValue`). If it is smaller than the minimum value for `Int16` (including `-Inf`), returns the minimum value of `Int16` (i.e. `Int16.minValue`). If it is `NaN`, returns `0`. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Float.lean",
    "line_number": 34,
    "source": "core"
  },
  "Float.toInt32": {
    "name": "Float.toInt32",
    "type": "opaque",
    "signature": "Float.toInt32 : Float → Int32",
    "docstring": "Truncates a floating-point number to the nearest 32-bit signed integer, rounding towards zero. If the `Float` is larger than the maximum value for `Int32` (including `Inf`), returns the maximum value of `Int32` (i.e. `Int32.maxValue`). If it is smaller than the minimum value for `Int32` (including `-Inf`), returns the minimum value of `Int32` (i.e. `Int32.minValue`). If it is `NaN`, returns `0`. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Float.lean",
    "line_number": 45,
    "source": "core"
  },
  "Float.toInt64": {
    "name": "Float.toInt64",
    "type": "opaque",
    "signature": "Float.toInt64 : Float → Int64",
    "docstring": "Truncates a floating-point number to the nearest 64-bit signed integer, rounding towards zero. If the `Float` is larger than the maximum value for `Int64` (including `Inf`), returns the maximum value of `Int64` (i.e. `Int64.maxValue`). If it is smaller than the minimum value for `Int64` (including `-Inf`), returns the minimum value of `Int64` (i.e. `Int64.minValue`). If it is `NaN`, returns `0`. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Float.lean",
    "line_number": 56,
    "source": "core"
  },
  "Float.toISize": {
    "name": "Float.toISize",
    "type": "opaque",
    "signature": "Float.toISize : Float → ISize",
    "docstring": "Truncates a floating-point number to the nearest word-sized signed integer, rounding towards zero. If the `Float` is larger than the maximum value for `ISize` (including `Inf`), returns the maximum value of `ISize` (i.e. `ISize.maxValue`). If it is smaller than the minimum value for `ISize` (including `-Inf`), returns the minimum value of `ISize` (i.e. `ISize.minValue`). If it is `NaN`, returns `0`. This function does not reduce in the kernel.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Float.lean",
    "line_number": 67,
    "source": "core"
  },
  "Bool.toInt8": {
    "name": "Bool.toInt8",
    "type": "def",
    "signature": "Bool.toInt8 : Int8",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 399,
    "source": "core"
  },
  "Bool.toInt16": {
    "name": "Bool.toInt16",
    "type": "def",
    "signature": "Bool.toInt16 : Int16",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 770,
    "source": "core"
  },
  "Bool.toInt32": {
    "name": "Bool.toInt32",
    "type": "def",
    "signature": "Bool.toInt32 : Int32",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 1157,
    "source": "core"
  },
  "Bool.toInt64": {
    "name": "Bool.toInt64",
    "type": "def",
    "signature": "Bool.toInt64 : Int64",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 1564,
    "source": "core"
  },
  "Bool.toISize": {
    "name": "Bool.toISize",
    "type": "def",
    "signature": "Bool.toISize : ISize",
    "docstring": "Converts `true` to `1` and `false` to `0`.",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 1956,
    "source": "core"
  },
  "Int.toInt8": {
    "name": "Int.toInt8",
    "type": "abbrev",
    "signature": "Int.toInt8",
    "docstring": "Converts an arbitrary-precision integer to an 8-bit integer, wrapping on overflow or underflow. Examples: * `Int.toInt8 48 = 48` * `Int.toInt8 (-115) = -115` * `Int.toInt8 (-129) = 127` * `Int.toInt8 (128) = -128`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 134,
    "source": "core"
  },
  "Nat.toInt8": {
    "name": "Nat.toInt8",
    "type": "abbrev",
    "signature": "Nat.toInt8",
    "docstring": "Converts a natural number to an 8-bit signed integer, wrapping around to negative numbers on overflow. Examples: * `Nat.toInt8 53 = 53` * `Nat.toInt8 127 = 127` * `Nat.toInt8 128 = -128` * `Nat.toInt8 255 = -1`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 145,
    "source": "core"
  },
  "Int.toInt16": {
    "name": "Int.toInt16",
    "type": "abbrev",
    "signature": "Int.toInt16",
    "docstring": "Converts an arbitrary-precision integer to a 16-bit integer, wrapping on overflow or underflow. Examples: * `Int.toInt16 48 = 48` * `Int.toInt16 (-129) = -129` * `Int.toInt16 (128) = 128` * `Int.toInt16 70000 = 4464` * `Int.toInt16 (-40000) = 25536`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 489,
    "source": "core"
  },
  "Nat.toInt16": {
    "name": "Nat.toInt16",
    "type": "abbrev",
    "signature": "Nat.toInt16",
    "docstring": "Converts a natural number to a 16-bit signed integer, wrapping around to negative numbers on overflow. Examples: * `Nat.toInt16 127 = 127` * `Nat.toInt16 32767 = 32767` * `Nat.toInt16 32768 = -32768` * `Nat.toInt16 32770 = -32766`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 500,
    "source": "core"
  },
  "Int.toInt32": {
    "name": "Int.toInt32",
    "type": "abbrev",
    "signature": "Int.toInt32",
    "docstring": "Converts an arbitrary-precision integer to a 32-bit integer, wrapping on overflow or underflow. Examples: * `Int.toInt32 48 = 48` * `Int.toInt32 (-129) = -129` * `Int.toInt32 70000 = 70000` * `Int.toInt32 (-40000) = -40000` * `Int.toInt32 2147483648 = -2147483648` * `Int.toInt32 (-2147483649) = 2147483647`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 862,
    "source": "core"
  },
  "Nat.toInt32": {
    "name": "Nat.toInt32",
    "type": "abbrev",
    "signature": "Nat.toInt32",
    "docstring": "Converts a natural number to a 32-bit signed integer, wrapping around to negative numbers on overflow. Examples: * `Nat.toInt32 127 = 127` * `Nat.toInt32 32770 = 32770` * `Nat.toInt32 2_147_483_647 = 2_147_483_647` * `Nat.toInt32 2_147_483_648 = -2_147_483_648`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 873,
    "source": "core"
  },
  "Int.toInt64": {
    "name": "Int.toInt64",
    "type": "abbrev",
    "signature": "Int.toInt64",
    "docstring": "Converts an arbitrary-precision integer to a 64-bit integer, wrapping on overflow or underflow. This function is overridden at runtime with an efficient implementation. Examples: * `Int.toInt64 48 = 48` * `Int.toInt64 (-40_000) = -40_000` * `Int.toInt64 2_147_483_648 = 2_147_483_648` * `Int.toInt64 (-2_147_483_649) = -2_147_483_649` * `Int.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808` * `Int.toInt64 (-9_223_372_036_854_775_809) = 9_223_372_036_854_775_807`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 1253,
    "source": "core"
  },
  "Nat.toInt64": {
    "name": "Nat.toInt64",
    "type": "abbrev",
    "signature": "Nat.toInt64",
    "docstring": "Converts a natural number to a 64-bit signed integer, wrapping around to negative numbers on overflow. Examples: * `Nat.toInt64 127 = 127` * `Nat.toInt64 2_147_483_648 = 2_147_483_648` * `Nat.toInt64 9_223_372_036_854_775_807 = 9_223_372_036_854_775_807` * `Nat.toInt64 9_223_372_036_854_775_808 = -9_223_372_036_854_775_808` * `Nat.toInt64 18_446_744_073_709_551_618 = 0`",
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 1265,
    "source": "core"
  },
  "Int.toISize": {
    "name": "Int.toISize",
    "type": "abbrev",
    "signature": "Int.toISize",
    "docstring": null,
    "file_path": "Users/silveregangloff/.elan/toolchains/leanprover--lean4---v4.21.0/src/lean/Init/Data/SInt/Basic.lean",
    "line_number": 1633,
    "source": "core"
  },
  "subsingleton_of_forall_eq": {
    "name": "subsingleton_of_forall_eq",
    "type": "theorem",
    "signature": "subsingleton_of_forall_eq : Subsingleton α",
    "docstring": "If all points are equal to a given point `x`, then `α` is a subsingleton.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Logic.lean",
    "line_number": 112,
    "source": "batteries",
    "description": "If all points are equal to a given point `x`, then `α` is a subsingleton."
  },
  "log2p1": {
    "name": "log2p1",
    "type": "def",
    "signature": "log2p1 : Nat → Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/WF.lean",
    "line_number": 24,
    "source": "batteries",
    "description": "Calculates the logarithm base 2 of a natural number plus one, returning a natural number."
  },
  "otherWF": {
    "name": "otherWF",
    "type": "def",
    "signature": "otherWF : WellFounded Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/WF.lean",
    "line_number": 99,
    "source": "batteries",
    "description": "A well-founded relation on natural numbers, ensuring that every non-empty subset has a minimal element."
  },
  "AliasInfo.name": {
    "name": "AliasInfo.name",
    "type": "def",
    "signature": "AliasInfo.name : AliasInfo → Name",
    "docstring": "The name underlying an alias target",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "The name underlying an alias target"
  },
  "AliasInfo.toString": {
    "name": "AliasInfo.toString",
    "type": "def",
    "signature": "AliasInfo.toString : AliasInfo → String",
    "docstring": "The docstring for an alias.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "The docstring for an alias."
  },
  "setDeprecatedTarget": {
    "name": "setDeprecatedTarget",
    "type": "def",
    "signature": "setDeprecatedTarget : Array Attribute × Bool",
    "docstring": "Updates the `deprecated` declaration to point to `target` if no target is provided.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 67,
    "source": "batteries",
    "description": "Updates the `deprecated` declaration to point to `target` if no target is provided."
  },
  "mkIffMpApp": {
    "name": "mkIffMpApp",
    "type": "def",
    "signature": "mkIffMpApp : MetaM Expr",
    "docstring": "Given a possibly forall-quantified iff expression `prf`, produce a value for one of the implication directions (determined by `mp`).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 142,
    "source": "batteries",
    "description": "Given a possibly forall-quantified iff expression `prf`, produce a value for one of the implication directions (determined by `mp`)."
  },
  "addSide": {
    "name": "addSide",
    "type": "def",
    "signature": "addSide : TermElabM Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 148,
    "source": "batteries",
    "description": "Adds a side effect in the term elaboration monad, typically for managing state or context during elaboration."
  },
  "AliasInfo": {
    "name": "AliasInfo",
    "type": "inductive",
    "signature": "AliasInfo",
    "docstring": "An alias can be in one of three forms",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 29,
    "source": "batteries",
    "description": "An alias can be in one of three forms"
  },
  "State": {
    "name": "State",
    "type": "structure",
    "signature": "State",
    "docstring": "Collects the result of a `CollectOpaques` query.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintOpaques.lean",
    "line_number": 18,
    "source": "batteries",
    "description": "Collects the result of a `CollectOpaques` query."
  },
  "M": {
    "name": "M",
    "type": "abbrev",
    "signature": "M",
    "docstring": "The monad used by `CollectOpaques`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintOpaques.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "The monad used by `CollectOpaques`."
  },
  "definitions": {
    "name": "definitions",
    "type": "opaque",
    "signature": "definitions : `System.Platform.getNumBits` and `UInt64.toUSize`. Thus `Std.HashMap.insert`",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintOpaques.lean",
    "line_number": 61,
    "source": "batteries"
  },
  "splitGoalsAndGetNth": {
    "name": "splitGoalsAndGetNth",
    "type": "def",
    "signature": "splitGoalsAndGetNth : TacticM (MVarId × List MVarId × List MVarId)",
    "docstring": "If the current goals are `g₁ ⋯ gᵢ ⋯ gₙ`, `splitGoalsAndGetNth i` returns `(gᵢ, [g₁, ⋯, gᵢ₋₁], [gᵢ₊₁, ⋯, gₙ])`. If `reverse` is passed as `true`, the `i`-th goal is picked by counting backwards. For instance, `splitGoalsAndGetNth 1 true` puts the last goal in the first component of the returned term.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PermuteGoals.lean",
    "line_number": 36,
    "source": "batteries",
    "description": "If the current goals are `g₁ ⋯ gᵢ ⋯ gₙ`, `splitGoalsAndGetNth i` returns `(gᵢ, [g₁, ⋯, gᵢ₋₁], [gᵢ₊₁, ⋯, gₙ])`. If `reverse` is passed as `true`, the `i`-th goal is picked by counting backwards. For instance, `splitGoalsAndGetNth 1 true` puts the last goal in the first component of the returned term."
  },
  "Congr.Config": {
    "name": "Congr.Config",
    "type": "structure",
    "signature": "Congr.Config",
    "docstring": "Configuration options for `congr` & `rcongr`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Congr.lean",
    "line_number": 21,
    "source": "batteries",
    "description": "Configuration options for `congr` & `rcongr`"
  },
  "filterTag": {
    "name": "filterTag",
    "type": "def",
    "signature": "filterTag : TacticM (List MVarId)",
    "docstring": "Filter the `mvarIds` by tag. Returns those `MVarId`s that have `tag` either as its user name, as a suffix of its user name, or as a prefix of its user name. The results are sorted in this order. This is like `Lean.Elab.Tactic.findTag?` but it returns all results rather than just the first.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Case.lean",
    "line_number": 84,
    "source": "batteries",
    "description": "Filter the `mvarIds` by tag. Returns those `MVarId`s that have `tag` either as its user name, as a suffix of its user name, or as a prefix of its user name. The results are sorted in this order. This is like `Lean.Elab.Tactic.findTag?` but it returns all results rather than just the first."
  },
  "processCasePattBody": {
    "name": "processCasePattBody",
    "type": "def",
    "signature": "processCasePattBody : TacticM (Term ⊕ (Syntax × TSyntax ``Parser.Tactic.tacticSeq))",
    "docstring": "Given a `casePattBody`, either give a synthetic hole or a tactic sequence (along with the syntax for the `=>`). Converts holes into synthetic holes since they are processed with `elabTermWithHoles`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Case.lean",
    "line_number": 141,
    "source": "batteries",
    "description": "Given a `casePattBody`, either give a synthetic hole or a tactic sequence (along with the syntax for the `=>`). Converts holes into synthetic holes since they are processed with `elabTermWithHoles`."
  },
  "Lean.MVarId.assignIfDefEq": {
    "name": "Lean.MVarId.assignIfDefEq",
    "type": "def",
    "signature": "Lean.MVarId.assignIfDefEq : MetaM Unit",
    "docstring": "`MetaM` version of `Lean.Elab.Tactic.evalExact`: add `mvarId := x` to the metavariable assignment. This method wraps `Lean.MVarId.assign`, checking whether `mvarId` is already assigned, and whether the expression has the right type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Exact.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "`MetaM` version of `Lean.Elab.Tactic.evalExact`: add `mvarId := x` to the metavariable assignment. This method wraps `Lean.MVarId.assign`, checking whether `mvarId` is already assigned, and whether the expression has the right type."
  },
  "mkState": {
    "name": "mkState",
    "type": "def",
    "signature": "mkState : State",
    "docstring": "Constructs the initial state, marking the constants in `cs`. The result of `collect` will say whether a given declaration depends transitively on one of these constants. If `otherAxiom` is true, any axiom not specified in `cs` will also be tracked.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintDependents.lean",
    "line_number": 42,
    "source": "batteries",
    "description": "Constructs the initial state, marking the constants in `cs`. The result of `collect` will say whether a given declaration depends transitively on one of these constants. If `otherAxiom` is true, any axiom not specified in `cs` will also be tracked."
  },
  "getExplicitRelArgCore": {
    "name": "getExplicitRelArgCore",
    "type": "def",
    "signature": "getExplicitRelArgCore : MetaM (Expr × Expr)",
    "docstring": "refining `tgt ← mkAppM' rel #[x, z]` dropping more arguments if possible",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Trans.lean",
    "line_number": 82,
    "source": "batteries",
    "description": "refining `tgt ← mkAppM' rel #[x, z]` dropping more arguments if possible"
  },
  "getRel": {
    "name": "getRel",
    "type": "def",
    "signature": "getRel : MetaM (Option (TransRelation × Expr × Expr))",
    "docstring": "Finds an explicit binary relation in the argument, if possible.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Trans.lean",
    "line_number": 106,
    "source": "batteries",
    "description": "Finds an explicit binary relation in the argument, if possible."
  },
  "TransRelation": {
    "name": "TransRelation",
    "type": "inductive",
    "signature": "TransRelation",
    "docstring": "Internal definition for `trans` tactic. Either a binary relation or a non-dependent arrow.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Trans.lean",
    "line_number": 99,
    "source": "batteries",
    "description": "Internal definition for `trans` tactic. Either a binary relation or a non-dependent arrow."
  },
  "checkLangLemmaCmd": {
    "name": "checkLangLemmaCmd",
    "type": "def",
    "signature": "checkLangLemmaCmd : Bool",
    "docstring": "Check whether `lang.lemmaCmd` option is enabled",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lemma.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Check whether `lang.lemmaCmd` option is enabled"
  },
  "takeNameSuffix": {
    "name": "takeNameSuffix",
    "type": "def",
    "signature": "takeNameSuffix : Name × Name",
    "docstring": "`takeNameSuffix n name` returns a pair `(pre, suf)` where `suf` contains the last `n` components of the name and `pre` contains the rest.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 49,
    "source": "batteries",
    "description": "`takeNameSuffix n name` returns a pair `(pre, suf)` where `suf` contains the last `n` components of the name and `pre` contains the rest."
  },
  "lexNameLt": {
    "name": "lexNameLt",
    "type": "def",
    "signature": "lexNameLt : Name -> Name -> Bool",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 72,
    "source": "batteries",
    "description": "Compares two names lexicographically and returns true if the first name is less than the second."
  },
  "matchingConstants": {
    "name": "matchingConstants",
    "type": "def",
    "signature": "matchingConstants : MetaM (Array MessageData)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 80,
    "source": "batteries",
    "description": "Retrieves an array of MessageData within the MetaM monad, typically used for handling meta-programming tasks."
  },
  "PrintPrefixConfig": {
    "name": "PrintPrefixConfig",
    "type": "structure",
    "signature": "PrintPrefixConfig",
    "docstring": "Options to control `#print prefix` command and `getMatchingConstants`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "Options to control `#print prefix` command and `getMatchingConstants`."
  },
  "Environment.declsInModuleIdx": {
    "name": "Environment.declsInModuleIdx",
    "type": "def",
    "signature": "Environment.declsInModuleIdx : List Name",
    "docstring": "Get the list of declarations in a module (referenced by index).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/OpenPrivate.lean",
    "line_number": 36,
    "source": "batteries",
    "description": "Get the list of declarations in a module (referenced by index)."
  },
  "elabHelpOption": {
    "name": "elabHelpOption",
    "type": "def",
    "signature": "elabHelpOption : CommandElabM Unit",
    "docstring": "The command `#help option` shows all options that have been defined in the current environment. Each option has a format like: ``` option pp.all : Bool := false (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing ``` This says that `pp.all` is an option which can be set to a `Bool` value, and the default value is `false`. If an option has been modified from the default using e.g. `set_option pp.all true`, it will appear as a `(currently: true)` note next to the option. The form `#help option id` will show only options that begin with `id`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 53,
    "source": "batteries",
    "description": "The command `#help option` shows all options that have been defined in the current environment. Each option has a format like: ``` option pp.all : Bool := false (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing ``` This says that `pp.all` is an option which can be set to a `Bool` value, and the default value is `false`. If an option has been modified from the default using e.g. `set_option pp.all true`, it will appear as a `(currently: true)` note next to the option. The form `#help option id` will show only options that begin with `id`."
  },
  "elabHelpAttr": {
    "name": "elabHelpAttr",
    "type": "def",
    "signature": "elabHelpAttr : CommandElabM Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 100,
    "source": "batteries",
    "description": "Provides elaboration assistance for attributes in Lean, typically used in command elaboration contexts."
  },
  "elabHelpCats": {
    "name": "elabHelpCats",
    "type": "def",
    "signature": "elabHelpCats : CommandElabM Unit",
    "docstring": "The command `#help cats` shows all syntax categories that have been defined in the current environment. Each syntax has a format like: ``` category command [Lean.Parser.initFn✝] ``` The name of the syntax category in this case is `command`, and `Lean.Parser.initFn✝` is the name of the declaration that introduced it. (It is often an anonymous declaration like this, but you can click to go to the definition.) It also shows the doc string if available. The form `#help cats id` will show only syntax categories that begin with `id`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 183,
    "source": "batteries",
    "description": "The command `#help cats` shows all syntax categories that have been defined in the current environment. Each syntax has a format like: ``` category command [Lean.Parser.initFn✝] ``` The name of the syntax category in this case is `command`, and `Lean.Parser.initFn✝` is the name of the declaration that introduced it. (It is often an anonymous declaration like this, but you can click to go to the definition.) It also shows the doc string if available. The form `#help cats id` will show only syntax categories that begin with `id`."
  },
  "elabHelpCat": {
    "name": "elabHelpCat",
    "type": "def",
    "signature": "elabHelpCat : CommandElabM Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 225,
    "source": "batteries",
    "description": "Provides elaboration assistance in the command elaboration monad, returning no value."
  },
  "inf": {
    "name": "inf",
    "type": "def",
    "signature": "inf : Float",
    "docstring": "The floating point value \"positive infinity\", also used to represent numerical computations which produce finite values outside of the representable range of `Float`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 16,
    "source": "batteries",
    "description": "The floating point value \"positive infinity\", also used to represent numerical computations which produce finite values outside of the representable range of `Float`."
  },
  "nan": {
    "name": "nan",
    "type": "def",
    "signature": "nan : Float",
    "docstring": "The floating point value \"not a number\", used to represent erroneous numerical computations such as `0 / 0`. Using `nan` in any float operation will return `nan`, and all comparisons involving `nan` return `false`, including in particular `nan == nan`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "The floating point value \"not a number\", used to represent erroneous numerical computations such as `0 / 0`. Using `nan` in any float operation will return `nan`, and all comparisons involving `nan` return `false`, including in particular `nan == nan`."
  },
  "toRatParts": {
    "name": "toRatParts",
    "type": "def",
    "signature": "toRatParts : Option (Int × Int)",
    "docstring": "Returns `v, exp` integers such that `f = v * 2^exp`. (`e` is not minimal, but `v.abs` will be at most `2^53 - 1`.) Returns `none` when `f` is not finite (i.e. `inf`, `-inf` or a `nan`).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Returns `v, exp` integers such that `f = v * 2^exp`. (`e` is not minimal, but `v.abs` will be at most `2^53 - 1`.) Returns `none` when `f` is not finite (i.e. `inf`, `-inf` or a `nan`)."
  },
  "toStringFull": {
    "name": "toStringFull",
    "type": "def",
    "signature": "toStringFull : String",
    "docstring": "Converts `f` to a string, including all decimal digits.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 60,
    "source": "batteries",
    "description": "Converts `f` to a string, including all decimal digits."
  },
  "Nat.divFloat": {
    "name": "Nat.divFloat",
    "type": "def",
    "signature": "Nat.divFloat : Float",
    "docstring": "Divide two natural numbers, to produce a correctly rounded (nearest-ties-to-even) `Float` result.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 83,
    "source": "batteries",
    "description": "Divide two natural numbers, to produce a correctly rounded (nearest-ties-to-even) `Float` result."
  },
  "Int.divFloat": {
    "name": "Int.divFloat",
    "type": "def",
    "signature": "Int.divFloat : Float",
    "docstring": "Divide two integers, to produce a correctly rounded (nearest-ties-to-even) `Float` result.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 101,
    "source": "batteries",
    "description": "Divide two integers, to produce a correctly rounded (nearest-ties-to-even) `Float` result."
  },
  "mergeWith": {
    "name": "mergeWith",
    "type": "def",
    "signature": "mergeWith : HashMap α β",
    "docstring": "`O(|other|)` amortized. Merge two `HashMap`s. The values of keys which appear in both maps are combined using `f`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/HashMap.lean",
    "line_number": 32,
    "source": "batteries",
    "description": "`O(|other|)` amortized. Merge two `HashMap`s. The values of keys which appear in both maps are combined using `f`."
  },
  "emoji": {
    "name": "emoji",
    "type": "def",
    "signature": "emoji : Except ε α → String",
    "docstring": "Visualize an `Except` using a checkmark or a cross.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Except.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Visualize an `Except` using a checkmark or a cross."
  },
  "any": {
    "name": "any",
    "type": "def",
    "signature": "any : Bool",
    "docstring": "Returns `true` if `f` returns `true` for any element of the set.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Returns `true` if `f` returns `true` for any element of the set."
  },
  "all": {
    "name": "all",
    "type": "def",
    "signature": "all : Bool",
    "docstring": "Returns `true` if `f` returns `true` for all elements of the set.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "Returns `true` if `f` returns `true` for all elements of the set."
  },
  "merge": {
    "name": "merge",
    "type": "def",
    "signature": "merge : PersistentHashSet α",
    "docstring": "Merge two `PersistentHashSet`s.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean",
    "line_number": 90,
    "source": "batteries",
    "description": "Merge two `PersistentHashSet`s."
  },
  "Lean.TagAttribute.getDecls": {
    "name": "Lean.TagAttribute.getDecls",
    "type": "def",
    "signature": "Lean.TagAttribute.getDecls : Array Name",
    "docstring": "Get the list of declarations tagged with the tag attribute `attr`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/TagAttribute.lean",
    "line_number": 13,
    "source": "batteries",
    "description": "Get the list of declarations tagged with the tag attribute `attr`."
  },
  "registerNameMapExtension": {
    "name": "registerNameMapExtension",
    "type": "def",
    "signature": "registerNameMapExtension : IO (NameMapExtension α)",
    "docstring": "Registers a new extension with the given name and type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Registers a new extension with the given name and type."
  },
  "registerNameMapAttribute": {
    "name": "registerNameMapAttribute",
    "type": "def",
    "signature": "registerNameMapAttribute : IO (NameMapExtension α)",
    "docstring": "Similar to `registerParametricAttribute` except that attributes do not have to be assigned in the same file as the declaration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean",
    "line_number": 59,
    "source": "batteries",
    "description": "Similar to `registerParametricAttribute` except that attributes do not have to be assigned in the same file as the declaration."
  },
  "NameMapAttributeImpl": {
    "name": "NameMapAttributeImpl",
    "type": "structure",
    "signature": "NameMapAttributeImpl",
    "docstring": "The inputs to `registerNameMapAttribute`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "The inputs to `registerNameMapAttribute`."
  },
  "ofList": {
    "name": "ofList",
    "type": "def",
    "signature": "ofList : PersistentHashMap α β",
    "docstring": "Builds a `PersistentHashMap` from a list of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "Builds a `PersistentHashMap` from a list of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences."
  },
  "ofListWith": {
    "name": "ofListWith",
    "type": "def",
    "signature": "ofListWith : PersistentHashMap α β",
    "docstring": "Variant of `ofList` which accepts a function that combines values of duplicated keys.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "Variant of `ofList` which accepts a function that combines values of duplicated keys."
  },
  "ofArray": {
    "name": "ofArray",
    "type": "def",
    "signature": "ofArray : PersistentHashMap α β",
    "docstring": "Builds a `PersistentHashMap` from an array of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 38,
    "source": "batteries",
    "description": "Builds a `PersistentHashMap` from an array of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences."
  },
  "ofArrayWith": {
    "name": "ofArrayWith",
    "type": "def",
    "signature": "ofArrayWith : PersistentHashMap α β",
    "docstring": "Variant of `ofArray` which accepts a function that combines values of duplicated keys.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "Variant of `ofArray` which accepts a function that combines values of duplicated keys."
  },
  "toSyntax": {
    "name": "toSyntax",
    "type": "def",
    "signature": "toSyntax : TermElabM Syntax.Term",
    "docstring": "Converts an `Expr` into a `Syntax`, by creating a fresh metavariable assigned to the expr and returning a named metavariable syntax `?a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Expr.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "Converts an `Expr` into a `Syntax`, by creating a fresh metavariable assigned to the expr and returning a named metavariable syntax `?a`."
  },
  "hasTag": {
    "name": "hasTag",
    "type": "def",
    "signature": "hasTag : Bool",
    "docstring": "Does declaration `decl` have the tag `attr`?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 55,
    "source": "batteries",
    "description": "Does declaration `decl` have the tag `attr`?"
  },
  "getDecls": {
    "name": "getDecls",
    "type": "def",
    "signature": "getDecls : Array Name",
    "docstring": "Get the list of declarations tagged with the tag attribute `attr`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 62,
    "source": "batteries",
    "description": "Get the list of declarations tagged with the tag attribute `attr`."
  },
  "TagAttributeExtra": {
    "name": "TagAttributeExtra",
    "type": "structure",
    "signature": "TagAttributeExtra",
    "docstring": "`TagAttributeExtra` works around a limitation of `TagAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 31,
    "source": "batteries",
    "description": "`TagAttributeExtra` works around a limitation of `TagAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal."
  },
  "ParametricAttributeExtra": {
    "name": "ParametricAttributeExtra",
    "type": "structure",
    "signature": "ParametricAttributeExtra",
    "docstring": "`ParametricAttributeExtra` works around a limitation of `ParametricAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 80,
    "source": "batteries",
    "description": "`ParametricAttributeExtra` works around a limitation of `ParametricAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal."
  },
  "Lean.findLineStart": {
    "name": "Lean.findLineStart",
    "type": "def",
    "signature": "Lean.findLineStart : String.Pos.Raw",
    "docstring": "Return the beginning of the line contatining character `pos`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Position.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Return the beginning of the line contatining character `pos`."
  },
  "Lean.findIndentAndIsStart": {
    "name": "Lean.findIndentAndIsStart",
    "type": "def",
    "signature": "Lean.findIndentAndIsStart : Nat × Bool",
    "docstring": "Return the indentation (number of leading spaces) of the line containing `pos`, and whether `pos` is the first non-whitespace character in the line.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Position.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Return the indentation (number of leading spaces) of the line containing `pos`, and whether `pos` is the first non-whitespace character in the line."
  },
  "Cache.mk": {
    "name": "Cache.mk",
    "type": "def",
    "signature": "Cache.mk : IO (Cache α)",
    "docstring": "Creates a cache with an initialization function.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "Creates a cache with an initialization function."
  },
  "DeclCache.get": {
    "name": "DeclCache.get",
    "type": "def",
    "signature": "DeclCache.get : MetaM α",
    "docstring": "Access the cache. Calling this function for the first time will initialize the cache with the function provided in the constructor.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 128,
    "source": "batteries",
    "description": "Access the cache. Calling this function for the first time will initialize the cache with the function provided in the constructor."
  },
  "DiscrTreeCache.getMatch": {
    "name": "DiscrTreeCache.getMatch",
    "type": "def",
    "signature": "DiscrTreeCache.getMatch : MetaM (Array α)",
    "docstring": "Get matches from both the discrimination tree for declarations in the current file, and for the imports. Note that if you are calling this multiple times with the same environment, it will rebuild the discrimination tree for the current file multiple times, and it would be more efficient to call `c.get` once, and then call `DiscrTree.getMatch` multiple times.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 170,
    "source": "batteries",
    "description": "Get matches from both the discrimination tree for declarations in the current file, and for the imports. Note that if you are calling this multiple times with the same environment, it will rebuild the discrimination tree for the current file multiple times, and it would be more efficient to call `c.get` once, and then call `DiscrTree.getMatch` multiple times."
  },
  "DeclCache": {
    "name": "DeclCache",
    "type": "structure",
    "signature": "DeclCache",
    "docstring": "Cached fold over the environment's declarations, where a given function is applied to `α` for every constant.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 83,
    "source": "batteries",
    "description": "Cached fold over the environment's declarations, where a given function is applied to `α` for every constant."
  },
  "elabProofWanted": {
    "name": "elabProofWanted",
    "type": "def",
    "signature": "elabProofWanted : CommandElab",
    "docstring": "Elaborate a `proof_wanted` declaration. The declaration is translated to an axiom during elaboration, but it's then removed from the environment.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/ProofWanted.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Elaborate a `proof_wanted` declaration. The declaration is translated to an axiom during elaboration, but it's then removed from the environment."
  },
  "panicWith": {
    "name": "panicWith",
    "type": "def",
    "signature": "panicWith : α",
    "docstring": "Panic with a specific default value `v`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Panic.lean",
    "line_number": 13,
    "source": "batteries",
    "description": "Panic with a specific default value `v`."
  },
  "getLinterUnnecessarySeqFocus": {
    "name": "getLinterUnnecessarySeqFocus",
    "type": "def",
    "signature": "getLinterUnnecessarySeqFocus : Bool",
    "docstring": "Gets the value of the `linter.unnecessarySeqFocus` option.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnnecessarySeqFocus.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "Gets the value of the `linter.unnecessarySeqFocus` option."
  },
  "unnecessarySeqFocusLinter": {
    "name": "unnecessarySeqFocusLinter",
    "type": "def",
    "signature": "unnecessarySeqFocusLinter : Linter where run",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnnecessarySeqFocus.lean",
    "line_number": 155,
    "source": "batteries",
    "description": "A linter that detects and reports unnecessary use of `Seq.focus` in Lean code, helping to improve code clarity."
  },
  "Entry": {
    "name": "Entry",
    "type": "structure",
    "signature": "Entry",
    "docstring": "The information we record for each `<;>` node appearing in the syntax.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnnecessarySeqFocus.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "The information we record for each `<;>` node appearing in the syntax."
  },
  "getLinterUnreachableTactic": {
    "name": "getLinterUnreachableTactic",
    "type": "def",
    "signature": "getLinterUnreachableTactic : Bool",
    "docstring": "Gets the value of the `linter.unreachableTactic` option.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Gets the value of the `linter.unreachableTactic` option."
  },
  "isIgnoreTacticKind": {
    "name": "isIgnoreTacticKind",
    "type": "def",
    "signature": "isIgnoreTacticKind : Bool",
    "docstring": "Is this a syntax kind that contains intentionally unevaluated tactic subterms?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 55,
    "source": "batteries",
    "description": "Is this a syntax kind that contains intentionally unevaluated tactic subterms?"
  },
  "addIgnoreTacticKind": {
    "name": "addIgnoreTacticKind",
    "type": "def",
    "signature": "addIgnoreTacticKind : IO Unit",
    "docstring": "Adds a new syntax kind whose children will be ignored by the `unreachableTactic` linter. This should be called from an `initialize` block.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 64,
    "source": "batteries",
    "description": "Adds a new syntax kind whose children will be ignored by the `unreachableTactic` linter. This should be called from an `initialize` block."
  },
  "unreachableTacticLinter": {
    "name": "unreachableTacticLinter",
    "type": "def",
    "signature": "unreachableTacticLinter : Linter where run",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 96,
    "source": "batteries",
    "description": "A linter that checks for unreachable tactics in Lean proofs, helping to identify and remove redundant code."
  },
  "ge_trans": {
    "name": "ge_trans",
    "type": "theorem",
    "signature": "ge_trans : cmp x z ≠ .lt",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 73,
    "source": "batteries",
    "description": "Proves that if x is greater than or equal to y and y is greater than or equal to z, then x is also greater than or equal to z."
  },
  "OrientedCmp": {
    "name": "OrientedCmp",
    "type": "class",
    "signature": "OrientedCmp",
    "docstring": "`OrientedCmp cmp` asserts that `cmp` is determined by the relation `cmp x y = .lt`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`OrientedCmp cmp` asserts that `cmp` is determined by the relation `cmp x y = .lt`."
  },
  "TransCmp": {
    "name": "TransCmp",
    "type": "class",
    "signature": "TransCmp",
    "docstring": "`TransCmp cmp` asserts that `cmp` induces a transitive relation.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 62,
    "source": "batteries",
    "description": "`TransCmp cmp` asserts that `cmp` induces a transitive relation."
  },
  "BEqCmp": {
    "name": "BEqCmp",
    "type": "class",
    "signature": "BEqCmp",
    "docstring": "`BEqCmp cmp` asserts that `cmp x y = .eq` and `x == y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "`BEqCmp cmp` asserts that `cmp x y = .eq` and `x == y` coincide."
  },
  "LTCmp": {
    "name": "LTCmp",
    "type": "class",
    "signature": "LTCmp",
    "docstring": "`LTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 138,
    "source": "batteries",
    "description": "`LTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide."
  },
  "LECmp": {
    "name": "LECmp",
    "type": "class",
    "signature": "LECmp",
    "docstring": "`LECmp cmp` asserts that `cmp x y ≠ .gt` and `x ≤ y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 150,
    "source": "batteries",
    "description": "`LECmp cmp` asserts that `cmp x y ≠ .gt` and `x ≤ y` coincide."
  },
  "LawfulCmp": {
    "name": "LawfulCmp",
    "type": "class",
    "signature": "LawfulCmp",
    "docstring": "`LawfulCmp cmp` asserts that the `LE`, `LT`, `BEq` instances are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 163,
    "source": "batteries",
    "description": "`LawfulCmp cmp` asserts that the `LE`, `LT`, `BEq` instances are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry)."
  },
  "le_iff_ge": {
    "name": "le_iff_ge",
    "type": "theorem",
    "signature": "le_iff_ge : cmp x y ≠ .gt ↔ cmp y x ≠ .lt",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 41,
    "source": "batteries",
    "description": "Proves that the comparison of two values is equivalent when their order is reversed, indicating non-greater and non-less relationships."
  },
  "le_trans": {
    "name": "le_trans",
    "type": "theorem",
    "signature": "le_trans : cmp x y ≠ .gt → cmp y z ≠ .gt → cmp x z ≠ .gt",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 49,
    "source": "batteries",
    "description": "Proves that if x is less than or equal to y and y is less than or equal to z, then x is less than or equal to z."
  },
  "TotalBLE": {
    "name": "TotalBLE",
    "type": "class",
    "signature": "TotalBLE",
    "docstring": "`TotalBLE le` asserts that `le` has a total order, that is, `le a b ∨ le b a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`TotalBLE le` asserts that `le` has a total order, that is, `le a b ∨ le b a`."
  },
  "LawfulLTCmp": {
    "name": "LawfulLTCmp",
    "type": "class",
    "signature": "LawfulLTCmp",
    "docstring": "`LawfulLTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 71,
    "source": "batteries",
    "description": "`LawfulLTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide."
  },
  "LawfulLECmp": {
    "name": "LawfulLECmp",
    "type": "class",
    "signature": "LawfulLECmp",
    "docstring": "`LawfulLECmp cmp` asserts that `(cmp x y).isLE` and `x ≤ y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "`LawfulLECmp cmp` asserts that `(cmp x y).isLE` and `x ≤ y` coincide."
  },
  "LawfulBCmp": {
    "name": "LawfulBCmp",
    "type": "class",
    "signature": "LawfulBCmp",
    "docstring": "`LawfulBCmp cmp` asserts that the `LE`, `LT`, `BEq` are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 94,
    "source": "batteries",
    "description": "`LawfulBCmp cmp` asserts that the `LE`, `LT`, `BEq` are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry)."
  },
  "SatisfiesM_EStateM_eq": {
    "name": "SatisfiesM_EStateM_eq",
    "type": "theorem",
    "signature": "SatisfiesM_EStateM_eq : SatisfiesM (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/SatisfiesM.lean",
    "line_number": 173,
    "source": "batteries",
    "description": "Proves the equivalence of two monadic computations in the context of the state monad."
  },
  "MonadSatisfying": {
    "name": "MonadSatisfying",
    "type": "class",
    "signature": "MonadSatisfying",
    "docstring": "If a monad has `MonadSatisfying m`, then we can lift a `h : SatisfiesM (m := m) p x` predicate to monadic value `satisfying x p : m { x // p x }`. Reader, state, and exception monads have `MonadSatisfying` instances if the base monad does.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/SatisfiesM.lean",
    "line_number": 224,
    "source": "batteries",
    "description": "If a monad has `MonadSatisfying m`, then we can lift a `h : SatisfiesM (m := m) p x` predicate to monadic value `satisfying x p : m { x // p x }`. Reader, state, and exception monads have `MonadSatisfying` instances if the base monad does."
  },
  "RatCast": {
    "name": "RatCast",
    "type": "class",
    "signature": "RatCast",
    "docstring": "Type class for the canonical homomorphism `Rat → K`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/RatCast.lean",
    "line_number": 11,
    "source": "batteries",
    "description": "Type class for the canonical homomorphism `Rat → K`."
  },
  "deprecatedCodeActionProvider": {
    "name": "deprecatedCodeActionProvider",
    "type": "def",
    "signature": "deprecatedCodeActionProvider : CodeActionProvider",
    "docstring": "A code action which applies replacements for `@[deprecated]` definitions.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Deprecated.lean",
    "line_number": 32,
    "source": "batteries",
    "description": "A code action which applies replacements for `@[deprecated]` definitions."
  },
  "mkTacticCodeAction": {
    "name": "mkTacticCodeAction",
    "type": "def",
    "signature": "mkTacticCodeAction : ImportM TacticCodeAction",
    "docstring": "Read a tactic code action from a declaration of the right type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Read a tactic code action from a declaration of the right type."
  },
  "mkTacticSeqCodeAction": {
    "name": "mkTacticSeqCodeAction",
    "type": "def",
    "signature": "mkTacticSeqCodeAction : ImportM TacticSeqCodeAction",
    "docstring": "Read a tacticSeq code action from a declaration of the right type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Read a tacticSeq code action from a declaration of the right type."
  },
  "TacticCodeActionEntry": {
    "name": "TacticCodeActionEntry",
    "type": "structure",
    "signature": "TacticCodeActionEntry",
    "docstring": "An entry in the tactic code actions extension, containing the attribute arguments.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 49,
    "source": "batteries",
    "description": "An entry in the tactic code actions extension, containing the attribute arguments."
  },
  "TacticCodeActions": {
    "name": "TacticCodeActions",
    "type": "structure",
    "signature": "TacticCodeActions",
    "docstring": "The state of the tactic code actions extension.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 57,
    "source": "batteries",
    "description": "The state of the tactic code actions extension."
  },
  "TacticCodeAction": {
    "name": "TacticCodeAction",
    "type": "abbrev",
    "signature": "TacticCodeAction",
    "docstring": "A tactic code action extension.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "A tactic code action extension."
  },
  "TacticSeqCodeAction": {
    "name": "TacticSeqCodeAction",
    "type": "abbrev",
    "signature": "TacticSeqCodeAction",
    "docstring": "A tactic code action extension.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "A tactic code action extension."
  },
  "getExplicitArgs": {
    "name": "getExplicitArgs",
    "type": "def",
    "signature": "getExplicitArgs : Expr → Array Name → Array Name",
    "docstring": "Returns the explicit arguments given a type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 130,
    "source": "batteries",
    "description": "Returns the explicit arguments given a type."
  },
  "foo": {
    "name": "foo",
    "type": "def",
    "signature": "foo : Expr → Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 139,
    "source": "batteries",
    "description": "Processes an expression and performs an action without returning a value."
  },
  "removeAfterDoneAction": {
    "name": "removeAfterDoneAction",
    "type": "def",
    "signature": "removeAfterDoneAction : TacticCodeAction",
    "docstring": "The \"Remove tactics after 'no goals'\" code action deletes any tactics following a completed proof. ``` example : True := by trivial trivial -- <- remove this, proof is already done rfl ``` is transformed to ``` example : True := by trivial ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 222,
    "source": "batteries",
    "description": "The \"Remove tactics after 'no goals'\" code action deletes any tactics following a completed proof. ``` example : True := by trivial trivial -- <- remove this, proof is already done rfl ``` is transformed to ``` example : True := by trivial ```"
  },
  "getElimExprNames": {
    "name": "getElimExprNames",
    "type": "def",
    "signature": "getElimExprNames : MetaM (Array (Name × Array Name))",
    "docstring": "Similar to `getElimExprInfo`, but returns the names of binders instead of just the numbers; intended for code actions which need to name the binders.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 244,
    "source": "batteries",
    "description": "Similar to `getElimExprInfo`, but returns the names of binders instead of just the numbers; intended for code actions which need to name the binders."
  },
  "casesExpand": {
    "name": "casesExpand",
    "type": "def",
    "signature": "casesExpand : TacticCodeAction",
    "docstring": "Invoking tactic code action \"Generate an explicit pattern match for 'induction'\" in the following: ```lean example (x : Nat) : x = x := by induction x ``` produces: ```lean example (x : Nat) : x = x := by induction x with | zero => sorry | succ n ih => sorry ``` It also works for `cases`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 292,
    "source": "batteries",
    "description": "Invoking tactic code action \"Generate an explicit pattern match for 'induction'\" in the following: ```lean example (x : Nat) : x = x := by induction x ``` produces: ```lean example (x : Nat) : x = x := by induction x with | zero => sorry | succ n ih => sorry ``` It also works for `cases`."
  },
  "addSubgoalsSeqAction": {
    "name": "addSubgoalsSeqAction",
    "type": "def",
    "signature": "addSubgoalsSeqAction : TacticSeqCodeAction",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 435,
    "source": "batteries",
    "description": "Defines a tactic sequence action that adds subgoals to the current proof context."
  },
  "addSubgoalsAction": {
    "name": "addSubgoalsAction",
    "type": "def",
    "signature": "addSubgoalsAction : TacticCodeAction",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 441,
    "source": "batteries",
    "description": "Creates a tactic code action that adds subgoals during proof development."
  },
  "isMatchTerm": {
    "name": "isMatchTerm",
    "type": "def",
    "signature": "isMatchTerm : Info → Bool",
    "docstring": "Filter for the info-nodes to find the match-nodes.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 14,
    "source": "batteries",
    "description": "Filter for the info-nodes to find the match-nodes."
  },
  "pattern_from_constructor": {
    "name": "pattern_from_constructor",
    "type": "def",
    "signature": "pattern_from_constructor : Option String",
    "docstring": "From a constructor-name e.g. 'Option.some' construct the corresponding match pattern, e.g. '.some val'. We implement special cases for Nat and List, Option and Bool to e.g. produce 'n + 1' instead of 'Nat.succ n'.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "From a constructor-name e.g. 'Option.some' construct the corresponding match pattern, e.g. '.some val'. We implement special cases for Nat and List, Option and Bool to e.g. produce 'n + 1' instead of 'Nat.succ n'."
  },
  "myfun2": {
    "name": "myfun2",
    "type": "def",
    "signature": "myfun2 : Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 89,
    "source": "batteries",
    "description": "Defines a constant of type Nat, representing a natural number value."
  },
  "myfun3": {
    "name": "myfun3",
    "type": "def",
    "signature": "myfun3 : Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 101,
    "source": "batteries",
    "description": "Defines a function that returns a natural number."
  },
  "matchExpand": {
    "name": "matchExpand",
    "type": "def",
    "signature": "matchExpand : CommandCodeAction",
    "docstring": "Invoking tactic code action \"Generate a list of alternatives for this match.\" in the following: ```lean def myfun2 (n : Nat) : Nat := match n ``` produces: ```lean def myfun2 (n : Nat) : Nat := match n with | 0 => _ | n + 1 => _ ``` Also has support for multiple discriminants, e.g. ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with ``` can be expanded into ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with | none, 0 => _ | none, n_2 + 1 => _ | some val_1, 0 => _ | some val_1, n_2 + 1 => _ ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 115,
    "source": "batteries",
    "description": "Invoking tactic code action \"Generate a list of alternatives for this match.\" in the following: ```lean def myfun2 (n : Nat) : Nat := match n ``` produces: ```lean def myfun2 (n : Nat) : Nat := match n with | 0 => _ | n + 1 => _ ``` Also has support for multiple discriminants, e.g. ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with ``` can be expanded into ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with | none, 0 => _ | none, n_2 + 1 => _ | some val_1, 0 => _ | some val_1, n_2 + 1 => _ ```"
  },
  "testBit": {
    "name": "testBit",
    "type": "def",
    "signature": "testBit : Int → Nat → Bool",
    "docstring": "`testBit m n` returns whether the `(n+1)` least significant bit is `1` or `0`, using the two's complement convention for negative `m`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Int.lean",
    "line_number": 18,
    "source": "batteries",
    "description": "`testBit m n` returns whether the `(n+1)` least significant bit is `1` or `0`, using the two's complement convention for negative `m`."
  },
  "map": {
    "name": "map",
    "type": "def",
    "signature": "map : FloatArray",
    "docstring": "`map f a` applies the function `f` to each element of the array.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/FloatArray.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "`map f a` applies the function `f` to each element of the array."
  },
  "foldl": {
    "name": "foldl",
    "type": "def",
    "signature": "foldl : β",
    "docstring": "Folds a function over a `ByteSubarray` from left to right.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Folds a function over a `ByteSubarray` from left to right."
  },
  "toByteArray": {
    "name": "toByteArray",
    "type": "def",
    "signature": "toByteArray : ByteArray",
    "docstring": "`O(n)`. Extract a `ByteSubarray` to a `ByteArray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 113,
    "source": "batteries",
    "description": "`O(n)`. Extract a `ByteSubarray` to a `ByteArray`."
  },
  "get": {
    "name": "get",
    "type": "def",
    "signature": "get : UInt8",
    "docstring": "`O(1)`. Get the element at index `i` from the start of a `ByteSubarray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 118,
    "source": "batteries",
    "description": "`O(1)`. Get the element at index `i` from the start of a `ByteSubarray`."
  },
  "pop": {
    "name": "pop",
    "type": "def",
    "signature": "pop : ByteSubarray",
    "docstring": "`O(1)`. Pop the last element of a `ByteSubarray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 130,
    "source": "batteries",
    "description": "`O(1)`. Pop the last element of a `ByteSubarray`."
  },
  "popFront": {
    "name": "popFront",
    "type": "def",
    "signature": "popFront : ByteSubarray",
    "docstring": "`O(1)`. Pop the first element of a `ByteSubarray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 140,
    "source": "batteries",
    "description": "`O(1)`. Pop the first element of a `ByteSubarray`."
  },
  "ByteArray.toByteSubarray": {
    "name": "ByteArray.toByteSubarray",
    "type": "def",
    "signature": "ByteArray.toByteSubarray : Batteries.ByteSubarray where",
    "docstring": "`O(1)`. Coerce a byte array into a byte slice.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 183,
    "source": "batteries",
    "description": "`O(1)`. Coerce a byte array into a byte slice."
  },
  "ByteSubarray": {
    "name": "ByteSubarray",
    "type": "structure",
    "signature": "ByteSubarray",
    "docstring": "A subarray of a `ByteArray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 69,
    "source": "batteries",
    "description": "A subarray of a `ByteArray`."
  },
  "Heap.size": {
    "name": "Heap.size",
    "type": "def",
    "signature": "Heap.size : Heap α → Nat",
    "docstring": "`O(n)`. The number of elements in the heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "`O(n)`. The number of elements in the heap."
  },
  "Heap.singleton": {
    "name": "Heap.singleton",
    "type": "def",
    "signature": "Heap.singleton : Heap α",
    "docstring": "A node containing a single element `a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 38,
    "source": "batteries",
    "description": "A node containing a single element `a`."
  },
  "Heap.isEmpty": {
    "name": "Heap.isEmpty",
    "type": "def",
    "signature": "Heap.isEmpty : Heap α → Bool",
    "docstring": "`O(1)`. Is the heap empty?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 41,
    "source": "batteries",
    "description": "`O(1)`. Is the heap empty?"
  },
  "Heap.toListUnordered": {
    "name": "Heap.toListUnordered",
    "type": "def",
    "signature": "Heap.toListUnordered : List α",
    "docstring": "`O(n)`. Convert the heap to a list in arbitrary order.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 204,
    "source": "batteries",
    "description": "`O(n)`. Convert the heap to a list in arbitrary order."
  },
  "Heap.toArrayUnordered": {
    "name": "Heap.toArrayUnordered",
    "type": "def",
    "signature": "Heap.toArrayUnordered : Array α",
    "docstring": "`O(n)`. Convert the heap to an array in arbitrary order.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 208,
    "source": "batteries",
    "description": "`O(n)`. Convert the heap to an array in arbitrary order."
  },
  "Heap.NodeWF": {
    "name": "Heap.NodeWF",
    "type": "def",
    "signature": "Heap.NodeWF : Heap α → Prop",
    "docstring": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 217,
    "source": "batteries",
    "description": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved)"
  },
  "Heap.noSibling_merge": {
    "name": "Heap.noSibling_merge",
    "type": "theorem",
    "signature": "Heap.noSibling_merge : (s₁.merge le s₂).NoSibling",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 93,
    "source": "batteries",
    "description": "Proves that merging two heaps results in a heap that maintains the no-sibling property."
  },
  "Heap.noSibling_combine": {
    "name": "Heap.noSibling_combine",
    "type": "theorem",
    "signature": "Heap.noSibling_combine : (s.combine le).NoSibling",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 98,
    "source": "batteries",
    "description": "Proves that the combination operation in a heap does not create sibling nodes."
  },
  "Heap.noSibling_tail": {
    "name": "Heap.noSibling_tail",
    "type": "theorem",
    "signature": "Heap.noSibling_tail : (s.tail le).NoSibling",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 116,
    "source": "batteries",
    "description": "Proves that the tail of a heap does not have a sibling, ensuring structural integrity in heap representation."
  },
  "Heap.WF.singleton": {
    "name": "Heap.WF.singleton",
    "type": "theorem",
    "signature": "Heap.WF.singleton : (Heap.singleton a).WF le",
    "docstring": "There is exactly one tree and it is a `le`-min-heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 232,
    "source": "batteries",
    "description": "There is exactly one tree and it is a `le`-min-heap."
  },
  "Heap.WF.merge_node": {
    "name": "Heap.WF.merge_node",
    "type": "theorem",
    "signature": "Heap.WF.merge_node : (merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 234,
    "source": "batteries",
    "description": "Proves that merging two nodes in a heap maintains the well-formed property with respect to the given order."
  },
  "Heap.WF.merge": {
    "name": "Heap.WF.merge",
    "type": "theorem",
    "signature": "Heap.WF.merge : (merge le s₁ s₂).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 241,
    "source": "batteries",
    "description": "Proves that merging two well-formed heaps preserves the well-formedness property."
  },
  "Heap.WF.combine": {
    "name": "Heap.WF.combine",
    "type": "theorem",
    "signature": "Heap.WF.combine : (combine le s).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 249,
    "source": "batteries",
    "description": "Proves that combining two well-formed heaps maintains the well-formed property under the given order."
  },
  "Heap.WF.tail": {
    "name": "Heap.WF.tail",
    "type": "theorem",
    "signature": "Heap.WF.tail : (s.tail le).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 265,
    "source": "batteries",
    "description": "Proves that the tail of a well-formed heap maintains the well-formed property under a given relation."
  },
  "Heap": {
    "name": "Heap",
    "type": "inductive",
    "signature": "Heap",
    "docstring": "A `Heap` is the nodes of the pairing heap. Each node have two pointers: `child` going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 24,
    "source": "batteries",
    "description": "A `Heap` is the nodes of the pairing heap. Each node have two pointers: `child` going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it."
  },
  "Heap.NoSibling": {
    "name": "Heap.NoSibling",
    "type": "inductive",
    "signature": "Heap.NoSibling : Heap α → Prop",
    "docstring": "A predicate says there is no more than one tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 82,
    "source": "batteries",
    "description": "A predicate says there is no more than one tree."
  },
  "Heap.WF": {
    "name": "Heap.WF",
    "type": "inductive",
    "signature": "Heap.WF : Heap α → Prop",
    "docstring": "The well formedness predicate for a pairing heap. It asserts that: * There is no more than one tree. * It is a `le`-min-heap (if `le` is well-behaved)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 227,
    "source": "batteries",
    "description": "The well formedness predicate for a pairing heap. It asserts that: * There is no more than one tree. * It is a `le`-min-heap (if `le` is well-behaved)"
  },
  "maxChild": {
    "name": "maxChild",
    "type": "def",
    "signature": "maxChild : Option (Fin sz)",
    "docstring": "`O(1)`. Get data array for a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 18,
    "source": "batteries",
    "description": "`O(1)`. Get data array for a `BinaryHeap`."
  },
  "heapifyDown": {
    "name": "heapifyDown",
    "type": "def",
    "signature": "heapifyDown : Vector α sz",
    "docstring": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` down to restore the max-heap property.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` down to restore the max-heap property."
  },
  "mkHeap": {
    "name": "mkHeap",
    "type": "def",
    "signature": "mkHeap : Vector α sz",
    "docstring": "Core operation for binary heaps, expressed directly on arrays. Construct a heap from an unsorted array, by heapifying all the elements.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 54,
    "source": "batteries",
    "description": "Core operation for binary heaps, expressed directly on arrays. Construct a heap from an unsorted array, by heapifying all the elements."
  },
  "heapifyUp": {
    "name": "heapifyUp",
    "type": "def",
    "signature": "heapifyUp : Vector α sz",
    "docstring": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` up to restore the max-heap property.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 66,
    "source": "batteries",
    "description": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` up to restore the max-heap property."
  },
  "empty": {
    "name": "empty",
    "type": "def",
    "signature": "empty : BinaryHeap α lt",
    "docstring": "`O(1)`. Build a new empty heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 77,
    "source": "batteries",
    "description": "`O(1)`. Build a new empty heap."
  },
  "singleton": {
    "name": "singleton",
    "type": "def",
    "signature": "singleton : BinaryHeap α lt",
    "docstring": "`O(1)`. Build a one-element heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 83,
    "source": "batteries",
    "description": "`O(1)`. Build a one-element heap."
  },
  "size": {
    "name": "size",
    "type": "def",
    "signature": "size : Nat",
    "docstring": "`O(1)`. Get the number of elements in a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 86,
    "source": "batteries",
    "description": "`O(1)`. Get the number of elements in a `BinaryHeap`."
  },
  "vector": {
    "name": "vector",
    "type": "def",
    "signature": "vector : Vector α self.size",
    "docstring": "`O(1)`. Get data vector of a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 89,
    "source": "batteries",
    "description": "`O(1)`. Get data vector of a `BinaryHeap`."
  },
  "insert": {
    "name": "insert",
    "type": "def",
    "signature": "insert : BinaryHeap α lt where",
    "docstring": "`O(log n)`. Insert an element into a `BinaryHeap`, preserving the max-heap property.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 95,
    "source": "batteries",
    "description": "`O(log n)`. Insert an element into a `BinaryHeap`, preserving the max-heap property."
  },
  "max": {
    "name": "max",
    "type": "def",
    "signature": "max : Option α",
    "docstring": "`O(1)`. Get the maximum element in a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 103,
    "source": "batteries",
    "description": "`O(1)`. Get the maximum element in a `BinaryHeap`."
  },
  "popMax": {
    "name": "popMax",
    "type": "def",
    "signature": "popMax : BinaryHeap α lt",
    "docstring": "`O(log n)`. Remove the maximum element from a `BinaryHeap`. Call `max` first to actually retrieve the maximum element.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 107,
    "source": "batteries",
    "description": "`O(log n)`. Remove the maximum element from a `BinaryHeap`. Call `max` first to actually retrieve the maximum element."
  },
  "extractMax": {
    "name": "extractMax",
    "type": "def",
    "signature": "extractMax : Option α × BinaryHeap α lt",
    "docstring": "`O(log n)`. Return and remove the maximum element from a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "`O(log n)`. Return and remove the maximum element from a `BinaryHeap`."
  },
  "insertExtractMax": {
    "name": "insertExtractMax",
    "type": "def",
    "signature": "insertExtractMax : α × BinaryHeap α lt",
    "docstring": "`O(log n)`. Equivalent to `extractMax (self.insert x)`, except that extraction cannot fail.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 135,
    "source": "batteries",
    "description": "`O(log n)`. Equivalent to `extractMax (self.insert x)`, except that extraction cannot fail."
  },
  "replaceMax": {
    "name": "replaceMax",
    "type": "def",
    "signature": "replaceMax : Option α × BinaryHeap α lt",
    "docstring": "`O(log n)`. Equivalent to `(self.max, self.popMax.insert x)`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 145,
    "source": "batteries",
    "description": "`O(log n)`. Equivalent to `(self.max, self.popMax.insert x)`."
  },
  "decreaseKey": {
    "name": "decreaseKey",
    "type": "def",
    "signature": "decreaseKey : BinaryHeap α lt where",
    "docstring": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `x ≤ self.get i`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `x ≤ self.get i`."
  },
  "increaseKey": {
    "name": "increaseKey",
    "type": "def",
    "signature": "increaseKey : BinaryHeap α lt where",
    "docstring": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `self.get i ≤ x`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 157,
    "source": "batteries",
    "description": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `self.get i ≤ x`."
  },
  "Batteries.Vector.toBinaryHeap": {
    "name": "Batteries.Vector.toBinaryHeap",
    "type": "def",
    "signature": "Batteries.Vector.toBinaryHeap : Batteries.BinaryHeap α lt where",
    "docstring": "`O(n)`. Convert an unsorted vector to a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 163,
    "source": "batteries",
    "description": "`O(n)`. Convert an unsorted vector to a `BinaryHeap`."
  },
  "Array.toBinaryHeap": {
    "name": "Array.toBinaryHeap",
    "type": "def",
    "signature": "Array.toBinaryHeap : Batteries.BinaryHeap α lt where",
    "docstring": "`O(n)`. Convert an unsorted array to a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 169,
    "source": "batteries",
    "description": "`O(n)`. Convert an unsorted array to a `BinaryHeap`."
  },
  "BinaryHeap": {
    "name": "BinaryHeap",
    "type": "structure",
    "signature": "BinaryHeap",
    "docstring": "A max-heap data structure.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 13,
    "source": "batteries",
    "description": "A max-heap data structure."
  },
  "isEmpty": {
    "name": "isEmpty",
    "type": "def",
    "signature": "isEmpty : AssocList α β → Bool",
    "docstring": "`O(1)`. Is the list empty?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 43,
    "source": "batteries",
    "description": "`O(1)`. Is the list empty?"
  },
  "length": {
    "name": "length",
    "type": "def",
    "signature": "length : Nat",
    "docstring": "The number of entries in an `AssocList`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "The number of entries in an `AssocList`."
  },
  "toListTR": {
    "name": "toListTR",
    "type": "def",
    "signature": "toListTR : List (α × β)",
    "docstring": "Optimized version of `toList`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 80,
    "source": "batteries",
    "description": "Optimized version of `toList`."
  },
  "All": {
    "name": "All",
    "type": "def",
    "signature": "All : Prop",
    "docstring": "Returns true if every entry in the list satisfies `p`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 166,
    "source": "batteries",
    "description": "Returns true if every entry in the list satisfies `p`."
  },
  "AssocList": {
    "name": "AssocList",
    "type": "inductive",
    "signature": "AssocList",
    "docstring": "`AssocList α β` is \"the same as\" `List (α × β)`, but flattening the structure leads to one fewer pointer indirection (in the current code generator). It is mainly intended as a component of `HashMap`, but it can also be used as a plain key-value map.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "`AssocList α β` is \"the same as\" `List (α × β)`, but flattening the structure leads to one fewer pointer indirection (in the current code generator). It is mainly intended as a component of `HashMap`, but it can also be used as a plain key-value map."
  },
  "AlternativeMonad": {
    "name": "AlternativeMonad",
    "type": "class",
    "signature": "AlternativeMonad",
    "docstring": "`AlternativeMonad m` means that `m` has both a `Monad` and `Alternative` instance, which both share the same underlying `Applicative` instance. The main example is `Option`, but many monad transformers also preserve or add this structure.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/AlternativeMonad.lean",
    "line_number": 50,
    "source": "batteries",
    "description": "`AlternativeMonad m` means that `m` has both a `Monad` and `Alternative` instance, which both share the same underlying `Applicative` instance. The main example is `Option`, but many monad transformers also preserve or add this structure."
  },
  "LawfulAlternative": {
    "name": "LawfulAlternative",
    "type": "class",
    "signature": "LawfulAlternative",
    "docstring": "`LawfulAlternative m` means that the `failure` operation on `m` behaves naturally with respect to `map`, `seq`, and `orElse` operators.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/AlternativeMonad.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "`LawfulAlternative m` means that the `failure` operation on `m` behaves naturally with respect to `map`, `seq`, and `orElse` operators."
  },
  "LawfulAlternativeLift": {
    "name": "LawfulAlternativeLift",
    "type": "class",
    "signature": "LawfulAlternativeLift",
    "docstring": "Type-class for monad lifts that preserve the `Alternative` operations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/AlternativeMonad.lean",
    "line_number": 114,
    "source": "batteries",
    "description": "Type-class for monad lifts that preserve the `Alternative` operations."
  },
  "get_bind_get": {
    "name": "get_bind_get",
    "type": "theorem",
    "signature": "get_bind_get : (do let _ ← get (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 82,
    "source": "batteries",
    "description": "Proves that retrieving a value from a monadic context after binding it yields the same result as directly getting the value."
  },
  "modifyGetThe_eq": {
    "name": "modifyGetThe_eq",
    "type": "theorem",
    "signature": "modifyGetThe_eq : modifyGetThe σ (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Proves that modifying a state with a function preserves the equality of the state when accessed through a specific lens."
  },
  "modify_eq": {
    "name": "modify_eq",
    "type": "theorem",
    "signature": "modify_eq : modify (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 114,
    "source": "batteries",
    "description": "Proves that modifying a monadic value results in an equivalent state transformation."
  },
  "modifyThe_eq": {
    "name": "modifyThe_eq",
    "type": "theorem",
    "signature": "modifyThe_eq : modifyThe σ (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 117,
    "source": "batteries",
    "description": "Proves that modifying a state with a function yields an equivalent state under certain conditions."
  },
  "getModify_eq": {
    "name": "getModify_eq",
    "type": "theorem",
    "signature": "getModify_eq : getModify (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 120,
    "source": "batteries",
    "description": "Proves that retrieving a value after modifying a map with a specific key yields the modified value."
  },
  "modify_bind_get": {
    "name": "modify_bind_get",
    "type": "theorem",
    "signature": "modify_bind_get : (do modify (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 171,
    "source": "batteries",
    "description": "Proves that modifying a state monad and then retrieving the state yields the same result as directly retrieving the state after the modification."
  },
  "LawfulMonadStateOf": {
    "name": "LawfulMonadStateOf",
    "type": "class",
    "signature": "LawfulMonadStateOf",
    "docstring": "Class for well behaved state monads, extending the base `MonadState` type. Requires that `modifyGet` is equal to the same definition with only `get` and `set`, that `get` is idempotent if the result isn't used, and that `get` after `set` returns exactly the value that was previously `set`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 48,
    "source": "batteries",
    "description": "Class for well behaved state monads, extending the base `MonadState` type. Requires that `modifyGet` is equal to the same definition with only `get` and `set`, that `get` is idempotent if the result isn't used, and that `get` after `set` returns exactly the value that was previously `set`."
  },
  "isAutoDecl": {
    "name": "isAutoDecl",
    "type": "def",
    "signature": "isAutoDecl : CoreM Bool",
    "docstring": "Returns true if `decl` is an automatically generated declaration. Also returns true if `decl` is an internal name or created during macro expansion.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Returns true if `decl` is an automatically generated declaration. Also returns true if `decl` is an internal name or created during macro expansion."
  },
  "getLinter": {
    "name": "getLinter",
    "type": "def",
    "signature": "getLinter : CoreM NamedLinter",
    "docstring": "Gets a linter by declaration name.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "Gets a linter by declaration name."
  },
  "Linter": {
    "name": "Linter",
    "type": "structure",
    "signature": "Linter",
    "docstring": "A linting test for the `#lint` command.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 60,
    "source": "batteries",
    "description": "A linting test for the `#lint` command."
  },
  "NamedLinter": {
    "name": "NamedLinter",
    "type": "structure",
    "signature": "NamedLinter",
    "docstring": "A `NamedLinter` is a linter associated to a particular declaration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 72,
    "source": "batteries",
    "description": "A `NamedLinter` is a linter associated to a particular declaration."
  },
  "isCondition": {
    "name": "isCondition",
    "type": "def",
    "signature": "isCondition : MetaM Bool",
    "docstring": "Is this hypothesis a condition that might turn into a `simp` side-goal? i.e. is it a proposition that isn't marked as instance implicit?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 40,
    "source": "batteries",
    "description": "Is this hypothesis a condition that might turn into a `simp` side-goal? i.e. is it a proposition that isn't marked as instance implicit?"
  },
  "withSimpTheoremInfos": {
    "name": "withSimpTheoremInfos",
    "type": "def",
    "signature": "withSimpTheoremInfos : MetaM (Array α)",
    "docstring": "Runs the continuation on all the simp theorems encoded in the given type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 46,
    "source": "batteries",
    "description": "Runs the continuation on all the simp theorems encoded in the given type."
  },
  "isSimpEq": {
    "name": "isSimpEq",
    "type": "def",
    "signature": "isSimpEq : MetaM Bool",
    "docstring": "Checks whether two expressions are equal for the simplifier. That is, they are reducibly-definitional equal, and they have the same head symbol.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "Checks whether two expressions are equal for the simplifier. That is, they are reducibly-definitional equal, and they have the same head symbol."
  },
  "checkAllSimpTheoremInfos": {
    "name": "checkAllSimpTheoremInfos",
    "type": "def",
    "signature": "checkAllSimpTheoremInfos : MetaM (Option MessageData)",
    "docstring": "Constructs a message from all the simp theorems encoded in the given type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 63,
    "source": "batteries",
    "description": "Constructs a message from all the simp theorems encoded in the given type."
  },
  "isSimpTheorem": {
    "name": "isSimpTheorem",
    "type": "def",
    "signature": "isSimpTheorem : MetaM Bool",
    "docstring": "Returns true if this is a `@[simp]` declaration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 72,
    "source": "batteries",
    "description": "Returns true if this is a `@[simp]` declaration."
  },
  "decorateError": {
    "name": "decorateError",
    "type": "def",
    "signature": "decorateError : MetaM α",
    "docstring": "Add message `msg` to any errors thrown inside `k`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 86,
    "source": "batteries",
    "description": "Add message `msg` to any errors thrown inside `k`."
  },
  "formatLemmas": {
    "name": "formatLemmas",
    "type": "def",
    "signature": "formatLemmas : MetaM MessageData",
    "docstring": "Render the list of simp lemmas.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 90,
    "source": "batteries",
    "description": "Render the list of simp lemmas."
  },
  "SimpTheoremInfo": {
    "name": "SimpTheoremInfo",
    "type": "structure",
    "signature": "SimpTheoremInfo",
    "docstring": "The data associated to a simp theorem.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 30,
    "source": "batteries",
    "description": "The data associated to a simp theorem."
  },
  "getChecks": {
    "name": "getChecks",
    "type": "def",
    "signature": "getChecks : CoreM (Array NamedLinter)",
    "docstring": "`getChecks slow runOnly runAlways` produces a list of linters. `runOnly` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, only these linters are run (regardless of the default configuration). `runAlways` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, these linters are always run (regardless of their configuration). Specifying a linter in `runAlways` but not `runOnly` is an error. Otherwise, it uses all enabled linters in the environment tagged with `@[env_linter]`. If `slow` is false, it only uses the fast default tests.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 78,
    "source": "batteries",
    "description": "`getChecks slow runOnly runAlways` produces a list of linters. `runOnly` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, only these linters are run (regardless of the default configuration). `runAlways` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, these linters are always run (regardless of their configuration). Specifying a linter in `runAlways` but not `runOnly` is an error. Otherwise, it uses all enabled linters in the environment tagged with `@[env_linter]`. If `slow` is false, it only uses the fast default tests."
  },
  "lintCore": {
    "name": "lintCore",
    "type": "def",
    "signature": "lintCore : CoreM (Array (NamedLinter × Std.HashMap Name MessageData))",
    "docstring": "Runs all the specified linters on all the specified declarations in parallel, producing a list of results.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 98,
    "source": "batteries",
    "description": "Runs all the specified linters on all the specified declarations in parallel, producing a list of results."
  },
  "sortResults": {
    "name": "sortResults",
    "type": "def",
    "signature": "sortResults : CoreM <| Array (Name × α)",
    "docstring": "Sorts a map with declaration keys as names by line number.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 123,
    "source": "batteries",
    "description": "Sorts a map with declaration keys as names by line number."
  },
  "groupedByFilename": {
    "name": "groupedByFilename",
    "type": "def",
    "signature": "groupedByFilename : CoreM MessageData",
    "docstring": "Formats a map of linter warnings grouped by filename with `-- filename` comments. The first `drop_fn_chars` characters are stripped from the filename.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 152,
    "source": "batteries",
    "description": "Formats a map of linter warnings grouped by filename with `-- filename` comments. The first `drop_fn_chars` characters are stripped from the filename."
  },
  "getDeclsInCurrModule": {
    "name": "getDeclsInCurrModule",
    "type": "def",
    "signature": "getDeclsInCurrModule : CoreM (Array Name)",
    "docstring": "Get the list of declarations in the current module.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 206,
    "source": "batteries",
    "description": "Get the list of declarations in the current module."
  },
  "getAllDecls": {
    "name": "getAllDecls",
    "type": "def",
    "signature": "getAllDecls : CoreM (Array Name)",
    "docstring": "Get the list of all declarations in the environment.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 210,
    "source": "batteries",
    "description": "Get the list of all declarations in the environment."
  },
  "getDeclsInPackage": {
    "name": "getDeclsInPackage",
    "type": "def",
    "signature": "getDeclsInPackage : CoreM (Array Name)",
    "docstring": "Get the list of all declarations in the specified package.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 214,
    "source": "batteries",
    "description": "Get the list of all declarations in the specified package."
  },
  "LintVerbosity": {
    "name": "LintVerbosity",
    "type": "inductive",
    "signature": "LintVerbosity",
    "docstring": "Verbosity for the linter output.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 61,
    "source": "batteries",
    "description": "Verbosity for the linter output."
  },
  "univParamsGrouped": {
    "name": "univParamsGrouped",
    "type": "def",
    "signature": "univParamsGrouped : Std.HashSet (Array Name)",
    "docstring": "`univParamsGrouped e` computes for each `level` `u` of `e` the parameters that occur in `u`, and returns the corresponding set of lists of parameters. In pseudo-mathematical form, this returns `{{p : parameter | p ∈ u} | (u : level) ∈ e}` FIXME: We use `Array Name` instead of `HashSet Name`, since `HashSet` does not have an equality instance. It will ignore `nm₀.proof_i` declarations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Misc.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "`univParamsGrouped e` computes for each `level` `u` of `e` the parameters that occur in `u`, and returns the corresponding set of lists of parameters. In pseudo-mathematical form, this returns `{{p : parameter | p ∈ u} | (u : level) ∈ e}` FIXME: We use `Array Name` instead of `HashSet Name`, since `HashSet` does not have an equality instance. It will ignore `nm₀.proof_i` declarations."
  },
  "findUnusedHaves": {
    "name": "findUnusedHaves",
    "type": "def",
    "signature": "findUnusedHaves : MetaM (Array MessageData)",
    "docstring": "Return a list of unused `let_fun` terms in an expression that introduce proofs.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Misc.lean",
    "line_number": 238,
    "source": "batteries",
    "description": "Return a list of unused `let_fun` terms in an expression that introduce proofs."
  },
  "runMetaM": {
    "name": "runMetaM",
    "type": "def",
    "signature": "runMetaM : MetaM (α × Meta.SavedState)",
    "docstring": "Run the action `x` in state `s`. Returns the result of `x` and the state after `x` was executed. The global state remains unchanged.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/SavedState.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Run the action `x` in state `s`. Returns the result of `x` and the state after `x` was executed. The global state remains unchanged."
  },
  "getIntroducedExprMVars": {
    "name": "getIntroducedExprMVars",
    "type": "def",
    "signature": "getIntroducedExprMVars : MetaM (Array MVarId)",
    "docstring": "Returns the mvars that are not declared in `preState`, but declared and unassigned in `postState`. Delayed-assigned mvars are considered assigned.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/SavedState.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Returns the mvars that are not declared in `preState`, but declared and unassigned in `postState`. Delayed-assigned mvars are considered assigned."
  },
  "getAssignedExprMVars": {
    "name": "getAssignedExprMVars",
    "type": "def",
    "signature": "getAssignedExprMVars : MetaM (Array MVarId)",
    "docstring": "Returns the mvars that are declared but unassigned in `preState`, and assigned in `postState`. Delayed-assigned mvars are considered assigned.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/SavedState.lean",
    "line_number": 47,
    "source": "batteries",
    "description": "Returns the mvars that are declared but unassigned in `preState`, and assigned in `postState`. Delayed-assigned mvars are considered assigned."
  },
  "isExprMVarDeclared": {
    "name": "isExprMVarDeclared",
    "type": "def",
    "signature": "isExprMVarDeclared : Bool",
    "docstring": "Check whether a metavariable is declared in the given `MetavarContext`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 64,
    "source": "batteries",
    "description": "Check whether a metavariable is declared in the given `MetavarContext`."
  },
  "eraseExprMVarAssignment": {
    "name": "eraseExprMVarAssignment",
    "type": "def",
    "signature": "eraseExprMVarAssignment : MetavarContext",
    "docstring": "Erase any assignment or delayed assignment of the given metavariable.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 70,
    "source": "batteries",
    "description": "Erase any assignment or delayed assignment of the given metavariable."
  },
  "unassignedExprMVars": {
    "name": "unassignedExprMVars",
    "type": "def",
    "signature": "unassignedExprMVars : Array MVarId",
    "docstring": "Obtain all unassigned metavariables from the given `MetavarContext`. If `includeDelayed` is `true`, delayed-assigned metavariables are considered unassigned.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 81,
    "source": "batteries",
    "description": "Obtain all unassigned metavariables from the given `MetavarContext`. If `includeDelayed` is `true`, delayed-assigned metavariables are considered unassigned."
  },
  "synthInstance": {
    "name": "synthInstance",
    "type": "def",
    "signature": "synthInstance : MetaM Unit",
    "docstring": "Solve a goal by synthesizing an instance.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 109,
    "source": "batteries",
    "description": "Solve a goal by synthesizing an instance."
  },
  "getTypeCleanup": {
    "name": "getTypeCleanup",
    "type": "def",
    "signature": "getTypeCleanup : MetaM Expr",
    "docstring": "Get the type the given metavariable after instantiating metavariables and cleaning up annotations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 114,
    "source": "batteries",
    "description": "Get the type the given metavariable after instantiating metavariables and cleaning up annotations."
  },
  "mkEqSymm": {
    "name": "mkEqSymm",
    "type": "def",
    "signature": "mkEqSymm : MetaM Simp.Result",
    "docstring": "Flip the proof in a `Simp.Result`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Simp.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "Flip the proof in a `Simp.Result`."
  },
  "mkCast": {
    "name": "mkCast",
    "type": "def",
    "signature": "mkCast : MetaM Expr",
    "docstring": "Construct the `Expr` `cast h e`, from a `Simp.Result` with proof `h`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Simp.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Construct the `Expr` `cast h e`, from a `Simp.Result` with proof `h`."
  },
  "Lean.LocalContext.inaccessibleFVars": {
    "name": "Lean.LocalContext.inaccessibleFVars",
    "type": "def",
    "signature": "Lean.LocalContext.inaccessibleFVars : Array LocalDecl",
    "docstring": "Obtain the inaccessible fvars from the given local context. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Inaccessible.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Obtain the inaccessible fvars from the given local context. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name."
  },
  "Lean.MVarId.renameInaccessibleFVars": {
    "name": "Lean.MVarId.renameInaccessibleFVars",
    "type": "def",
    "signature": "Lean.MVarId.renameInaccessibleFVars : MetaM (MVarId × Array FVarId)",
    "docstring": "Rename all inaccessible fvars. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name. This function gives all inaccessible fvars a unique, accessible user name. It returns the new goal and the fvars that were renamed.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Inaccessible.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "Rename all inaccessible fvars. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name. This function gives all inaccessible fvars a unique, accessible user name. It returns the new goal and the fvars that were renamed."
  },
  "parseIndexSuffix": {
    "name": "parseIndexSuffix",
    "type": "def",
    "signature": "parseIndexSuffix : Option Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 15,
    "source": "batteries",
    "description": "Parses an index suffix and returns an optional natural number if a valid suffix is found."
  },
  "matchUpToIndexSuffix": {
    "name": "matchUpToIndexSuffix",
    "type": "def",
    "signature": "matchUpToIndexSuffix : MatchUpToIndexSuffix",
    "docstring": "Succeeds if `n` is equal to `query`, except `n` may have an additional `_i` suffix for some natural number `i`. More specifically: - If `n = query`, the result is `exactMatch`. - If `n = query ++ \"_i\"` for some natural number `i`, the result is `suffixMatch i`. - Otherwise the result is `noMatch`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Succeeds if `n` is equal to `query`, except `n` may have an additional `_i` suffix for some natural number `i`. More specifically: - If `n = query`, the result is `exactMatch`. - If `n = query ++ \"_i\"` for some natural number `i`, the result is `suffixMatch i`. - Otherwise the result is `noMatch`."
  },
  "getUnusedUserNameIndex": {
    "name": "getUnusedUserNameIndex",
    "type": "def",
    "signature": "getUnusedUserNameIndex : Option Nat",
    "docstring": "Obtain the least natural number `i` such that `suggestion ++ \"_i\"` is an unused name in the given local context. If `suggestion` itself is unused, the result is `none`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 73,
    "source": "batteries",
    "description": "Obtain the least natural number `i` such that `suggestion ++ \"_i\"` is an unused name in the given local context. If `suggestion` itself is unused, the result is `none`."
  },
  "getUnusedUserName": {
    "name": "getUnusedUserName",
    "type": "def",
    "signature": "getUnusedUserName : Name",
    "docstring": "Obtain a name `n` such that `n` is unused in the given local context and `suggestion` is a prefix of `n`. This is similar to `getUnusedName` but uses a different algorithm which may or may not be faster.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 97,
    "source": "batteries",
    "description": "Obtain a name `n` such that `n` is unused in the given local context and `suggestion` is a prefix of `n`. This is similar to `getUnusedName` but uses a different algorithm which may or may not be faster."
  },
  "getUnusedUserNames": {
    "name": "getUnusedUserNames",
    "type": "def",
    "signature": "getUnusedUserNames : Array Name",
    "docstring": "Obtain `n` distinct names such that each name is unused in the given local context and `suggestion` is a prefix of each name.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 107,
    "source": "batteries",
    "description": "Obtain `n` distinct names such that each name is unused in the given local context and `suggestion` is a prefix of each name."
  },
  "MatchUpToIndexSuffix": {
    "name": "MatchUpToIndexSuffix",
    "type": "inductive",
    "signature": "MatchUpToIndexSuffix",
    "docstring": "Result type of `Lean.Name.matchUpToIndexSuffix`. See there for details.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "Result type of `Lean.Name.matchUpToIndexSuffix`. See there for details."
  },
  "cmp": {
    "name": "cmp",
    "type": "def",
    "signature": "cmp : Key → Key → Ordering",
    "docstring": "Compare two `Key`s. The ordering is total but otherwise arbitrary. (It uses `Name.quickCmp` internally.)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/DiscrTree.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "Compare two `Key`s. The ordering is total but otherwise arbitrary. (It uses `Name.quickCmp` internally.)"
  },
  "mergePreservingDuplicates": {
    "name": "mergePreservingDuplicates",
    "type": "def",
    "signature": "mergePreservingDuplicates : DiscrTree α",
    "docstring": "Merge two `DiscrTree`s. Duplicate values are preserved.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/DiscrTree.lean",
    "line_number": 58,
    "source": "batteries",
    "description": "Merge two `DiscrTree`s. Duplicate values are preserved."
  },
  "List.waitAll": {
    "name": "List.waitAll",
    "type": "def",
    "signature": "List.waitAll : Task (List α)",
    "docstring": "Given a list of tasks, create the task returning the list of results, by waiting for each.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/System/IO.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Given a list of tasks, create the task returning the list of results, by waiting for each."
  },
  "HeapNode.singleton": {
    "name": "HeapNode.singleton",
    "type": "def",
    "signature": "HeapNode.singleton : HeapNode α",
    "docstring": "A node containing a single element `a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 47,
    "source": "batteries",
    "description": "A node containing a single element `a`."
  },
  "HeapNode.rank": {
    "name": "HeapNode.rank",
    "type": "def",
    "signature": "HeapNode.rank : HeapNode α → Nat",
    "docstring": "`O(log n)`. The rank, or the number of trees in the forest. It is also the depth of the forest.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 53,
    "source": "batteries",
    "description": "`O(log n)`. The rank, or the number of trees in the forest. It is also the depth of the forest."
  },
  "Heap.rankGT": {
    "name": "Heap.rankGT",
    "type": "def",
    "signature": "Heap.rankGT : Heap α → Nat → Prop",
    "docstring": "`O(1)`. Auxiliary for `Heap.merge`: Is the minimum rank in `Heap` strictly larger than `n`?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 106,
    "source": "batteries",
    "description": "`O(1)`. Auxiliary for `Heap.merge`: Is the minimum rank in `Heap` strictly larger than `n`?"
  },
  "HeapNode.toHeap": {
    "name": "HeapNode.toHeap",
    "type": "def",
    "signature": "HeapNode.toHeap : Heap α",
    "docstring": "`O(log n)`. Convert a `HeapNode` to a `Heap` by reversing the order of the nodes along the `sibling` spine.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 152,
    "source": "batteries",
    "description": "`O(log n)`. Convert a `HeapNode` to a `Heap` by reversing the order of the nodes along the `sibling` spine."
  },
  "Heap.deleteMin": {
    "name": "Heap.deleteMin",
    "type": "def",
    "signature": "Heap.deleteMin : Heap α → Option (α × Heap α)",
    "docstring": "`O(log n)`. Find and remove the the minimum element from the binomial heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 196,
    "source": "batteries",
    "description": "`O(log n)`. Find and remove the the minimum element from the binomial heap."
  },
  "FindMin.HasSize": {
    "name": "FindMin.HasSize",
    "type": "def",
    "signature": "FindMin.HasSize : Prop",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 226,
    "source": "batteries",
    "description": "A property that asserts the existence of a minimum element in a structure with a defined size."
  },
  "HeapNode.WF": {
    "name": "HeapNode.WF",
    "type": "def",
    "signature": "HeapNode.WF : HeapNode α → Nat → Prop",
    "docstring": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved) * When interpreting `child` and `sibling` as left and right children of a binary tree, it is a perfect binary tree with depth `r`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 336,
    "source": "batteries",
    "description": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved) * When interpreting `child` and `sibling` as left and right children of a binary tree, it is a perfect binary tree with depth `r`"
  },
  "Heap.WF.nil": {
    "name": "Heap.WF.nil",
    "type": "theorem",
    "signature": "Heap.WF.nil : Heap.nil.WF le n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 349,
    "source": "batteries",
    "description": "Proves that the empty heap satisfies the well-formedness condition with respect to a given relation."
  },
  "Heap.WF.of_rankGT": {
    "name": "Heap.WF.of_rankGT",
    "type": "theorem",
    "signature": "Heap.WF.of_rankGT : s.WF le (n+1)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 353,
    "source": "batteries",
    "description": "Proves that if a heap has a rank greater than n, it satisfies the well-formedness condition with respect to the less-than-or-equal relation."
  },
  "Heap.WF.of_le": {
    "name": "Heap.WF.of_le",
    "type": "theorem",
    "signature": "Heap.WF.of_le : s.WF le n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 358,
    "source": "batteries",
    "description": "Proves that a heap is well-formed with respect to a given less-than-or-equal relation."
  },
  "Heap.rankGT.of_le": {
    "name": "Heap.rankGT.of_le",
    "type": "theorem",
    "signature": "Heap.rankGT.of_le : s.rankGT n'",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 363,
    "source": "batteries",
    "description": "Proves that if a heap's rank is less than or equal to a given value, then it satisfies the rank greater than condition."
  },
  "Heap.WF.rankGT": {
    "name": "Heap.WF.rankGT",
    "type": "theorem",
    "signature": "Heap.WF.rankGT : s.rankGT n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 368,
    "source": "batteries",
    "description": "Proves that the rank of a heap satisfies a specific property related to its structure and ordering."
  },
  "FindMin": {
    "name": "FindMin",
    "type": "structure",
    "signature": "FindMin",
    "docstring": "The return type of `FindMin`, which encodes various quantities needed to reconstruct the tree in `deleteMin`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 172,
    "source": "batteries",
    "description": "The return type of `FindMin`, which encodes various quantities needed to reconstruct the tree in `deleteMin`."
  },
  "FindMin.WF": {
    "name": "FindMin.WF",
    "type": "structure",
    "signature": "FindMin.WF",
    "docstring": "The well formedness predicate for a `FindMin` value. This is not actually a predicate, as it contains an additional data value `rank` corresponding to the rank of the returned node, which is omitted from `findMin`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 430,
    "source": "batteries",
    "description": "The well formedness predicate for a `FindMin` value. This is not actually a predicate, as it contains an additional data value `rank` corresponding to the rank of the returned node, which is omitted from `findMin`."
  },
  "HeapNode": {
    "name": "HeapNode",
    "type": "inductive",
    "signature": "HeapNode",
    "docstring": "A `HeapNode` is one of the internal nodes of the binomial heap. It is always a perfect binary tree, with the depth of the tree stored in the `Heap`. However the interpretation of the two pointers is different: we view the `child` as going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "A `HeapNode` is one of the internal nodes of the binomial heap. It is always a perfect binary tree, with the depth of the tree stored in the `Heap`. However the interpretation of the two pointers is different: we view the `child` as going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it."
  },
  "cons": {
    "name": "cons",
    "type": "def",
    "signature": "cons : α → DList α → DList α",
    "docstring": "`O(1)` (`apply` is `O(1)`). Prepend `a` on a `DList α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "`O(1)` (`apply` is `O(1)`). Prepend `a` on a `DList α`."
  },
  "append": {
    "name": "append",
    "type": "def",
    "signature": "append : DList α → DList α → DList α",
    "docstring": "`O(1)` (`apply` is `O(1)`). Append two `DList α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 58,
    "source": "batteries",
    "description": "`O(1)` (`apply` is `O(1)`). Append two `DList α`."
  },
  "push": {
    "name": "push",
    "type": "def",
    "signature": "push : DList α → α → DList α",
    "docstring": "`O(1)` (`apply` is `O(1)`). Append an element at the end of a `DList α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 68,
    "source": "batteries",
    "description": "`O(1)` (`apply` is `O(1)`). Append an element at the end of a `DList α`."
  },
  "ofThunk": {
    "name": "ofThunk",
    "type": "def",
    "signature": "ofThunk : DList α",
    "docstring": "Convert a lazily-evaluated `List` to a `DList`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 81,
    "source": "batteries",
    "description": "Convert a lazily-evaluated `List` to a `DList`"
  },
  "DList": {
    "name": "DList",
    "type": "structure",
    "signature": "DList",
    "docstring": "A difference List is a Function that, given a List, returns the original contents of the difference List prepended to the given List. This structure supports `O(1)` `append` and `push` operations on lists, making it useful for append-heavy uses such as logging and pretty printing.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "A difference List is a Function that, given a List, returns the original contents of the difference List prepended to the given List. This structure supports `O(1)` `append` and `push` operations on lists, making it useful for append-heavy uses such as logging and pretty printing."
  },
  "beqCaseInsensitiveAsciiOnly": {
    "name": "beqCaseInsensitiveAsciiOnly",
    "type": "def",
    "signature": "beqCaseInsensitiveAsciiOnly : Bool",
    "docstring": "Bool-valued comparison of two `Char`s for *ASCII*-case insensitive equality. ``` #eval beqCaseInsensitiveAsciiOnly 'a' 'A' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'a' -- true #eval beqCaseInsensitiveAsciiOnly '$' '$' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'b' -- false #eval beqCaseInsensitiveAsciiOnly 'γ' 'Γ' -- false #eval beqCaseInsensitiveAsciiOnly 'ä' 'Ä' -- false ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 175,
    "source": "batteries",
    "description": "Bool-valued comparison of two `Char`s for *ASCII*-case insensitive equality. ``` #eval beqCaseInsensitiveAsciiOnly 'a' 'A' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'a' -- true #eval beqCaseInsensitiveAsciiOnly '$' '$' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'b' -- false #eval beqCaseInsensitiveAsciiOnly 'γ' 'Γ' -- false #eval beqCaseInsensitiveAsciiOnly 'ä' 'Ä' -- false ```"
  },
  "beqCaseInsensitiveAsciiOnly.isSetoid": {
    "name": "beqCaseInsensitiveAsciiOnly.isSetoid",
    "type": "def",
    "signature": "beqCaseInsensitiveAsciiOnly.isSetoid : Setoid Char",
    "docstring": "Setoid structure on `Char` using `beqCaseInsensitiveAsciiOnly`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 186,
    "source": "batteries",
    "description": "Setoid structure on `Char` using `beqCaseInsensitiveAsciiOnly`"
  },
  "cmpCaseInsensitiveAsciiOnly": {
    "name": "cmpCaseInsensitiveAsciiOnly",
    "type": "def",
    "signature": "cmpCaseInsensitiveAsciiOnly : Ordering",
    "docstring": "ASCII-case insensitive implementation comparison returning an `Ordering`. Useful for sorting. ``` #eval cmpCaseInsensitiveAsciiOnly 'a' 'A' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'a' -- eq #eval cmpCaseInsensitiveAsciiOnly '$' '$' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'b' -- lt #eval cmpCaseInsensitiveAsciiOnly 'γ' 'Γ' -- gt #eval cmpCaseInsensitiveAsciiOnly 'ä' 'Ä' -- gt ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 201,
    "source": "batteries",
    "description": "ASCII-case insensitive implementation comparison returning an `Ordering`. Useful for sorting. ``` #eval cmpCaseInsensitiveAsciiOnly 'a' 'A' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'a' -- eq #eval cmpCaseInsensitiveAsciiOnly '$' '$' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'b' -- lt #eval cmpCaseInsensitiveAsciiOnly 'γ' 'Γ' -- gt #eval cmpCaseInsensitiveAsciiOnly 'ä' 'Ä' -- gt ```"
  },
  "beqCaseInsensitiveAsciiOnly.eqv": {
    "name": "beqCaseInsensitiveAsciiOnly.eqv",
    "type": "theorem",
    "signature": "beqCaseInsensitiveAsciiOnly.eqv : Equivalence (beqCaseInsensitiveAsciiOnly · ·)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 177,
    "source": "batteries",
    "description": "Proves that the case-insensitive ASCII equality function is an equivalence relation, satisfying reflexivity, symmetry, and transitivity."
  },
  "caseFoldAsciiOnly": {
    "name": "caseFoldAsciiOnly",
    "type": "abbrev",
    "signature": "caseFoldAsciiOnly",
    "docstring": "Case folding for ASCII characters only. Alphabetic ASCII characters are mapped to their lowercase form, all other characters are left unchanged. This agrees with the Unicode case folding algorithm for ASCII characters. ``` #eval caseFoldAsciiOnly 'A' == 'a' #eval caseFoldAsciiOnly 'a' == 'a' #eval caseFoldAsciiOnly 'À' == 'À' #eval caseFoldAsciiOnly 'à' == 'à' #eval caseFoldAsciiOnly '$' == '$' ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 161,
    "source": "batteries",
    "description": "Case folding for ASCII characters only. Alphabetic ASCII characters are mapped to their lowercase form, all other characters are left unchanged. This agrees with the Unicode case folding algorithm for ASCII characters. ``` #eval caseFoldAsciiOnly 'A' == 'a' #eval caseFoldAsciiOnly 'a' == 'a' #eval caseFoldAsciiOnly 'À' == 'À' #eval caseFoldAsciiOnly 'à' == 'à' #eval caseFoldAsciiOnly '$' == '$' ```"
  },
  "List.mem_finRange": {
    "name": "List.mem_finRange",
    "type": "theorem",
    "signature": "List.mem_finRange : x ∈ finRange n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 14,
    "source": "batteries",
    "description": "Proves that an element x belongs to the finite range of natural numbers from 0 to n-1."
  },
  "of_all_eq_true_aux": {
    "name": "of_all_eq_true_aux",
    "type": "theorem",
    "signature": "of_all_eq_true_aux : p (.ofNatAux n hn)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 76,
    "source": "batteries",
    "description": "Proves that a property holds for a natural number represented by a specific auxiliary function."
  },
  "eq_true_of_all_eq_true": {
    "name": "eq_true_of_all_eq_true",
    "type": "theorem",
    "signature": "eq_true_of_all_eq_true : p c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 87,
    "source": "batteries",
    "description": "Proves that if a proposition holds for all cases, then it is true."
  },
  "maxSurrogate": {
    "name": "maxSurrogate",
    "type": "abbrev",
    "signature": "maxSurrogate",
    "docstring": "Maximum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 46,
    "source": "batteries",
    "description": "Maximum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)"
  },
  "minSurrogate": {
    "name": "minSurrogate",
    "type": "abbrev",
    "signature": "minSurrogate",
    "docstring": "Minimum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 52,
    "source": "batteries",
    "description": "Minimum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)"
  },
  "count": {
    "name": "count",
    "type": "abbrev",
    "signature": "count",
    "docstring": "Number of valid character code points. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 58,
    "source": "batteries",
    "description": "Number of valid character code points. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)"
  },
  "clamp": {
    "name": "clamp",
    "type": "def",
    "signature": "clamp : Fin (m + 1)",
    "docstring": "`min n m` as an element of `Fin (m + 1)`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 15,
    "source": "batteries",
    "description": "`min n m` as an element of `Fin (m + 1)`"
  },
  "divNat": {
    "name": "divNat",
    "type": "def",
    "signature": "divNat : Fin m",
    "docstring": "Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 121,
    "source": "batteries",
    "description": "Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`."
  },
  "modNat": {
    "name": "modNat",
    "type": "def",
    "signature": "modNat : Fin n",
    "docstring": "Compute `i % n`, where `n` is a `Nat` and inferred the type of `i`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "Compute `i % n`, where `n` is a `Nat` and inferred the type of `i`."
  },
  "mkDivMod": {
    "name": "mkDivMod",
    "type": "def",
    "signature": "mkDivMod : Fin (m * n)",
    "docstring": "Compute the element of `Fin (m * n)` with quotient `i : Fin m` and remainder `j : Fin n` when divided by `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 132,
    "source": "batteries",
    "description": "Compute the element of `Fin (m * n)` with quotient `i : Fin m` and remainder `j : Fin n` when divided by `n`."
  },
  "ofTaskList": {
    "name": "ofTaskList",
    "type": "def",
    "signature": "ofTaskList : MLList BaseIO α",
    "docstring": "Give a list of tasks, return the monadic lazy list which returns the values as they become available.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/MLList/IO.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "Give a list of tasks, return the monadic lazy list which returns the values as they become available."
  },
  "MLList": {
    "name": "MLList",
    "type": "def",
    "signature": "MLList : Type u",
    "docstring": "A monadic lazy list, controlled by an arbitrary monad.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/MLList/Basic.lean",
    "line_number": 76,
    "source": "batteries",
    "description": "A monadic lazy list, controlled by an arbitrary monad."
  },
  "squash": {
    "name": "squash",
    "type": "def",
    "signature": "squash : (Unit → m (MLList m α)) → MLList m α",
    "docstring": "Lift a monadic lazy list inside the monad to a monadic lazy list.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/MLList/Basic.lean",
    "line_number": 92,
    "source": "batteries",
    "description": "Lift a monadic lazy list inside the monad to a monadic lazy list."
  },
  "Pairwise": {
    "name": "Pairwise",
    "type": "def",
    "signature": "Pairwise : Prop",
    "docstring": "`Pairwise R as` means that all the elements of the array `as` are `R`-related to all elements with larger indices. `Pairwise R #[1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3` For example `as.Pairwise (· ≠ ·)` asserts that `as` has no duplicates, `as.Pairwise (· < ·)` asserts that `as` is strictly sorted and `as.Pairwise (· ≤ ·)` asserts that `as` is weakly sorted.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`Pairwise R as` means that all the elements of the array `as` are `R`-related to all elements with larger indices. `Pairwise R #[1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3` For example `as.Pairwise (· ≠ ·)` asserts that `as` has no duplicates, `as.Pairwise (· < ·)` asserts that `as` is strictly sorted and `as.Pairwise (· ≤ ·)` asserts that `as` is weakly sorted."
  },
  "pairwise_empty": {
    "name": "pairwise_empty",
    "type": "theorem",
    "signature": "pairwise_empty : #[].Pairwise R",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 40,
    "source": "batteries",
    "description": "Proves that the empty list satisfies the pairwise condition for any relation R."
  },
  "pairwise_singleton": {
    "name": "pairwise_singleton",
    "type": "theorem",
    "signature": "pairwise_singleton : #[a].Pairwise R",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Proves that a singleton set satisfies the pairwise relation for any binary relation R."
  },
  "pairwise_pair": {
    "name": "pairwise_pair",
    "type": "theorem",
    "signature": "pairwise_pair : #[a, b].Pairwise R ↔ R a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 48,
    "source": "batteries",
    "description": "Establishes that a relation R holds for a pair of elements a and b if and only if the pairwise condition for R is satisfied."
  },
  "PrefixTable": {
    "name": "PrefixTable",
    "type": "structure",
    "signature": "PrefixTable",
    "docstring": "Prefix table for the Knuth-Morris-Pratt matching algorithm This is an array of the form `t = [(x₀,n₀), (x₁,n₁), (x₂, n₂), ...]` where for each `i`, `nᵢ` is the length of the longest proper prefix of `xs = [x₀,x₁,...,xᵢ]` which is also a suffix of `xs`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Match.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Prefix table for the Knuth-Morris-Pratt matching algorithm This is an array of the form `t = [(x₀,n₀), (x₁,n₁), (x₂, n₂), ...]` where for each `i`, `nᵢ` is the length of the longest proper prefix of `xs = [x₀,x₁,...,xᵢ]` which is also a suffix of `xs`."
  },
  "Matcher": {
    "name": "Matcher",
    "type": "structure",
    "signature": "Matcher",
    "docstring": "KMP matcher structure",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Match.lean",
    "line_number": 77,
    "source": "batteries",
    "description": "KMP matcher structure"
  },
  "Iterator": {
    "name": "Iterator",
    "type": "structure",
    "signature": "Iterator",
    "docstring": "Iterator transformer for KMP matcher.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Match.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Iterator transformer for KMP matcher."
  },
  "equiv_find": {
    "name": "equiv_find",
    "type": "theorem",
    "signature": "equiv_find : Equiv (self.find x).1 a b ↔ Equiv self a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Lemmas.lean",
    "line_number": 116,
    "source": "batteries",
    "description": "Proves the equivalence between finding an element in a structure and the equivalence of the structure itself."
  },
  "parentD": {
    "name": "parentD",
    "type": "def",
    "signature": "parentD : Nat",
    "docstring": "Parent of a union-find node, defaults to self when the node is a root",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 26,
    "source": "batteries",
    "description": "Parent of a union-find node, defaults to self when the node is a root"
  },
  "rankD": {
    "name": "rankD",
    "type": "def",
    "signature": "rankD : Nat",
    "docstring": "Rank of a union-find node, defaults to 0 when the node is a root",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 30,
    "source": "batteries",
    "description": "Rank of a union-find node, defaults to 0 when the node is a root"
  },
  "mkEmpty": {
    "name": "mkEmpty",
    "type": "def",
    "signature": "mkEmpty : UnionFind where",
    "docstring": "Create an empty union-find structure with specific capacity",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Create an empty union-find structure with specific capacity"
  },
  "root": {
    "name": "root",
    "type": "def",
    "signature": "root : Fin self.size",
    "docstring": "Root of a union-find node.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 175,
    "source": "batteries",
    "description": "Root of a union-find node."
  },
  "rootN": {
    "name": "rootN",
    "type": "def",
    "signature": "rootN : Fin n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 185,
    "source": "batteries",
    "description": "Represents the nth root of a natural number, where n is a finite natural number."
  },
  "rootD": {
    "name": "rootD",
    "type": "def",
    "signature": "rootD : Nat",
    "docstring": "Root of a union-find node. Returns input if index is out of bounds.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 193,
    "source": "batteries",
    "description": "Root of a union-find node. Returns input if index is out of bounds."
  },
  "findAux": {
    "name": "findAux",
    "type": "def",
    "signature": "findAux : FindAux self.size",
    "docstring": "Auxiliary function for find operation",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 267,
    "source": "batteries",
    "description": "Auxiliary function for find operation"
  },
  "findN": {
    "name": "findN",
    "type": "def",
    "signature": "findN : UnionFind × Fin n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 388,
    "source": "batteries",
    "description": "Finds the root of the set containing the element indexed by a finite number, using a union-find data structure."
  },
  "findD": {
    "name": "findD",
    "type": "def",
    "signature": "findD : UnionFind × Nat",
    "docstring": "Find root of a union-find node, updating the structure using path compression. Returns inputs unchanged when index is out of bounds.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 401,
    "source": "batteries",
    "description": "Find root of a union-find node, updating the structure using path compression. Returns inputs unchanged when index is out of bounds."
  },
  "linkAux": {
    "name": "linkAux",
    "type": "def",
    "signature": "linkAux : Array UFNode",
    "docstring": "Link two union-find nodes",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 439,
    "source": "batteries",
    "description": "Link two union-find nodes"
  },
  "link": {
    "name": "link",
    "type": "def",
    "signature": "link : UnionFind where",
    "docstring": "Link a union-find node to a root node.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 492,
    "source": "batteries",
    "description": "Link a union-find node to a root node."
  },
  "linkN": {
    "name": "linkN",
    "type": "def",
    "signature": "linkN : UnionFind",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 524,
    "source": "batteries",
    "description": "Represents a union-find data structure for efficiently managing and merging disjoint sets."
  },
  "union": {
    "name": "union",
    "type": "def",
    "signature": "union : UnionFind",
    "docstring": "Link two union-find nodes, uniting their respective classes.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 535,
    "source": "batteries",
    "description": "Link two union-find nodes, uniting their respective classes."
  },
  "unionN": {
    "name": "unionN",
    "type": "def",
    "signature": "unionN : UnionFind",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 546,
    "source": "batteries",
    "description": "Creates a union-find data structure for efficiently managing and merging disjoint sets."
  },
  "checkEquiv": {
    "name": "checkEquiv",
    "type": "def",
    "signature": "checkEquiv : UnionFind × Bool",
    "docstring": "Check whether two union-find nodes are equivalent, updating structure using path compression.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 558,
    "source": "batteries",
    "description": "Check whether two union-find nodes are equivalent, updating structure using path compression."
  },
  "checkEquivN": {
    "name": "checkEquivN",
    "type": "def",
    "signature": "checkEquivN : UnionFind × Bool",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 564,
    "source": "batteries",
    "description": "Checks the equivalence of elements in a union-find structure, returning a boolean indicating if they are in the same set."
  },
  "checkEquivD": {
    "name": "checkEquivD",
    "type": "def",
    "signature": "checkEquivD : UnionFind × Bool",
    "docstring": "Check whether two union-find nodes are equivalent with path compression, returns `x == y` if either index is out of bounds",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 577,
    "source": "batteries",
    "description": "Check whether two union-find nodes are equivalent with path compression, returns `x == y` if either index is out of bounds"
  },
  "Equiv": {
    "name": "Equiv",
    "type": "def",
    "signature": "Equiv : Prop",
    "docstring": "Equivalence relation from a `UnionFind` structure",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 583,
    "source": "batteries",
    "description": "Equivalence relation from a `UnionFind` structure"
  },
  "lt_of_parentD": {
    "name": "lt_of_parentD",
    "type": "theorem",
    "signature": "lt_of_parentD : parentD arr i ≠ i → i < arr.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "If the parent of an index in an array is not itself, then that index is less than the size of the array."
  },
  "parent_lt": {
    "name": "parent_lt",
    "type": "theorem",
    "signature": "parent_lt : self.parent i < self.size ↔ i < self.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 126,
    "source": "batteries",
    "description": "Proves that the parent index of a node is less than the size of the structure if and only if the node index is also less than the size."
  },
  "rankD_lt_rankMax": {
    "name": "rankD_lt_rankMax",
    "type": "theorem",
    "signature": "rankD_lt_rankMax : rankD self.arr i < self.rankMax",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 149,
    "source": "batteries",
    "description": "Proves that the rank of an array at index `i` is less than the maximum rank of the array."
  },
  "lt_rankMax": {
    "name": "lt_rankMax",
    "type": "theorem",
    "signature": "lt_rankMax : self.rank i < self.rankMax",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "Proves that the rank of an element is always less than the maximum rank in a given structure."
  },
  "UFNode": {
    "name": "UFNode",
    "type": "structure",
    "signature": "UFNode",
    "docstring": "Union-find node type",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Union-find node type"
  },
  "using": {
    "name": "using",
    "type": "structure",
    "signature": "using",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "A structure that provides a way to manage resources or contexts, often used for resource management in Lean."
  },
  "UnionFind": {
    "name": "UnionFind",
    "type": "structure",
    "signature": "UnionFind",
    "docstring": "### Union-find data structure The `UnionFind` structure is an implementation of disjoint-set data structure that uses path compression to make the primary operations run in amortized nearly linear time. The nodes of a `UnionFind` structure `s` are natural numbers smaller than `s.size`. The structure associates with a canonical representative from its equivalence class. The structure can be extended using the `push` operation and equivalence classes can be updated using the `union` operation. The main operations for `UnionFind` are: * `empty`/`mkEmpty` are used to create a new empty structure. * `size` returns the size of the data structure. * `push` adds a new node to a structure, unlinked to any other node. * `union` links two nodes of the data structure, joining their equivalence classes, and performs path compression. * `find` returns the canonical representative of a node and updates the data structure using path compression. * `root` returns the canonical representative of a node without altering the data structure. * `checkEquiv` checks whether two nodes have the same canonical representative and updates the structure using path compression. Most use cases should prefer `find` over `root` to benefit from the speedup from path-compression. The main operations use `Fin s.size` to represent nodes of the union-find structure. Some alternatives are provided: * `unionN`, `findN`, `rootN`, `checkEquivN` use `Fin n` with a proof that `n = s.size`. * `union!`, `find!`, `root!`, `checkEquiv!` use `Nat` and panic when the indices are out of bounds. * `findD`, `rootD`, `checkEquivD` use `Nat` and treat out of bound indices as isolated nodes. The noncomputable relation `UnionFind.Equiv` is provided to use the equivalence relation from a `UnionFind` structure in the context of proofs.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 97,
    "source": "batteries",
    "description": "### Union-find data structure The `UnionFind` structure is an implementation of disjoint-set data structure that uses path compression to make the primary operations run in amortized nearly linear time. The nodes of a `UnionFind` structure `s` are natural numbers smaller than `s.size`. The structure associates with a canonical representative from its equivalence class. The structure can be extended using the `push` operation and equivalence classes can be updated using the `union` operation. The main operations for `UnionFind` are: * `empty`/`mkEmpty` are used to create a new empty structure. * `size` returns the size of the data structure. * `push` adds a new node to a structure, unlinked to any other node. * `union` links two nodes of the data structure, joining their equivalence classes, and performs path compression. * `find` returns the canonical representative of a node and updates the data structure using path compression. * `root` returns the canonical representative of a node without altering the data structure. * `checkEquiv` checks whether two nodes have the same canonical representative and updates the structure using path compression. Most use cases should prefer `find` over `root` to benefit from the speedup from path-compression. The main operations use `Fin s.size` to represent nodes of the union-find structure. Some alternatives are provided: * `unionN`, `findN`, `rootN`, `checkEquivN` use `Fin n` with a proof that `n = s.size`. * `union!`, `find!`, `root!`, `checkEquiv!` use `Nat` and panic when the indices are out of bounds. * `findD`, `rootD`, `checkEquivD` use `Nat` and treat out of bound indices as isolated nodes. The noncomputable relation `UnionFind.Equiv` is provided to use the equivalence relation from a `UnionFind` structure in the context of proofs."
  },
  "FindAux": {
    "name": "FindAux",
    "type": "structure",
    "signature": "FindAux",
    "docstring": "Auxiliary data structure for find operation",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 258,
    "source": "batteries",
    "description": "Auxiliary data structure for find operation"
  },
  "lt_sum_ge": {
    "name": "lt_sum_ge",
    "type": "def",
    "signature": "lt_sum_ge : a < b ⊕' b ≤ a",
    "docstring": "Strong case analysis on `a < b ∨ b ≤ a`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Lemmas.lean",
    "line_number": 146,
    "source": "batteries",
    "description": "Strong case analysis on `a < b ∨ b ≤ a`"
  },
  "ofBits_lt_two_pow": {
    "name": "ofBits_lt_two_pow",
    "type": "theorem",
    "signature": "ofBits_lt_two_pow : ofBits f < 2 ^ n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Lemmas.lean",
    "line_number": 175,
    "source": "batteries",
    "description": "Proves that the value represented by the bit representation `f` is less than `2` raised to the power of `n`."
  },
  "isDigit_of_mem_toDigitsCore": {
    "name": "isDigit_of_mem_toDigitsCore",
    "type": "theorem",
    "signature": "isDigit_of_mem_toDigitsCore : c.isDigit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Digits.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "Proves that an element is a digit if it belongs to the set of digits generated by the toDigitsCore function."
  },
  "isDigit_of_mem_toDigits": {
    "name": "isDigit_of_mem_toDigits",
    "type": "theorem",
    "signature": "isDigit_of_mem_toDigits : c.isDigit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Digits.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Proves that if a character is a member of the set of digits, then it is classified as a digit."
  },
  "sqrt": {
    "name": "sqrt",
    "type": "def",
    "signature": "sqrt : Nat",
    "docstring": "Integer square root function. Implemented via Newton's method.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Basic.lean",
    "line_number": 95,
    "source": "batteries",
    "description": "Integer square root function. Implemented via Newton's method."
  },
  "avg_le_left": {
    "name": "avg_le_left",
    "type": "theorem",
    "signature": "avg_le_left : avg a b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Proves that the average of two numbers is less than or equal to the first number."
  },
  "avg_le_right": {
    "name": "avg_le_right",
    "type": "theorem",
    "signature": "avg_le_right : avg a b ≤ b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 22,
    "source": "batteries",
    "description": "Proves that the average of two numbers is less than or equal to the larger number."
  },
  "avg_lt_left": {
    "name": "avg_lt_left",
    "type": "theorem",
    "signature": "avg_lt_left : avg a b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "Proves that the average of two numbers is less than the first number if the second number is less than the first."
  },
  "avg_lt_right": {
    "name": "avg_lt_right",
    "type": "theorem",
    "signature": "avg_lt_right : avg a b < b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Proves that the average of two numbers a and b is less than b when a is less than b."
  },
  "le_avg_left": {
    "name": "le_avg_left",
    "type": "theorem",
    "signature": "le_avg_left : a ≤ avg a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 31,
    "source": "batteries",
    "description": "Proves that a number is less than or equal to the average of itself and another number."
  },
  "le_avg_right": {
    "name": "le_avg_right",
    "type": "theorem",
    "signature": "le_avg_right : b ≤ avg a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Proves that a number is less than or equal to the average of itself and another number."
  },
  "le_add_one_of_avg_eq_left": {
    "name": "le_add_one_of_avg_eq_left",
    "type": "theorem",
    "signature": "le_add_one_of_avg_eq_left : b ≤ a + 1",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Proves that if the average of two numbers equals the left number, then the second number is less than or equal to the left number plus one."
  },
  "le_add_one_of_avg_eq_right": {
    "name": "le_add_one_of_avg_eq_right",
    "type": "theorem",
    "signature": "le_add_one_of_avg_eq_right : a ≤ b + 1",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 46,
    "source": "batteries",
    "description": "Proves that if the average of two numbers equals the right number, then the first number is less than or equal to the right number plus one."
  },
  "toFloat": {
    "name": "toFloat",
    "type": "def",
    "signature": "toFloat : Float",
    "docstring": "Convert this rational number to a `Float` value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Rat/Float.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Convert this rational number to a `Float` value."
  },
  "_root_.Float.toRat0": {
    "name": "_root_.Float.toRat0",
    "type": "def",
    "signature": "_root_.Float.toRat0 : Rat",
    "docstring": "Convert this floating point number to a rational value, mapping non-finite values (`inf`, `-inf`, `nan`) to 0.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Rat/Float.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Convert this floating point number to a rational value, mapping non-finite values (`inf`, `-inf`, `nan`) to 0."
  },
  "sumEven": {
    "name": "sumEven",
    "type": "def",
    "signature": "sumEven : Except String Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 209,
    "source": "batteries",
    "description": "Calculates the sum of all even natural numbers, returning either the result or an error message."
  },
  "checkEven": {
    "name": "checkEven",
    "type": "def",
    "signature": "checkEven : Except String Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 261,
    "source": "batteries",
    "description": "Checks if a condition is met and returns either an error message or a success indication."
  },
  "toList": {
    "name": "toList",
    "type": "def",
    "signature": "toList : List (α × β)",
    "docstring": "Converts the map into a list of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toList ~ [(\"one\", 1), (\"two\", 2)] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 278,
    "source": "batteries",
    "description": "Converts the map into a list of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toList ~ [(\"one\", 1), (\"two\", 2)] ```"
  },
  "toArray": {
    "name": "toArray",
    "type": "def",
    "signature": "toArray : Array (α × β)",
    "docstring": "Converts the map into an array of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toArray.data ~ #[(\"one\", 1), (\"two\", 2)].data ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 287,
    "source": "batteries",
    "description": "Converts the map into an array of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toArray.data ~ #[(\"one\", 1), (\"two\", 2)].data ```"
  },
  "numBuckets": {
    "name": "numBuckets",
    "type": "def",
    "signature": "numBuckets : Nat",
    "docstring": "The number of buckets in the hash map.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 290,
    "source": "batteries",
    "description": "The number of buckets in the hash map."
  },
  "_root_.Batteries.HashMap": {
    "name": "_root_.Batteries.HashMap",
    "type": "structure",
    "signature": "_root_.Batteries.HashMap",
    "docstring": "`HashMap α β` is a key-value map which stores elements in an array using a hash function to find the values. This allows it to have very good performance for lookups (average `O(1)` for a perfectly random hash function), but it is not a persistent data structure, meaning that one should take care to use the map linearly when performing updates. Copies are `O(n)`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 59,
    "source": "batteries",
    "description": "`HashMap α β` is a key-value map which stores elements in an array using a hash function to find the values. This allows it to have very good performance for lookups (average `O(1)` for a perfectly random hash function), but it is not a persistent data structure, meaning that one should take care to use the map linearly when performing updates. Copies are `O(n)`."
  },
  "disjoint_symm": {
    "name": "disjoint_symm",
    "type": "theorem",
    "signature": "disjoint_symm : Disjoint l₂ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 147,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint, then their order can be reversed while maintaining disjointness."
  },
  "disjoint_comm": {
    "name": "disjoint_comm",
    "type": "theorem",
    "signature": "disjoint_comm : Disjoint l₁ l₂ ↔ Disjoint l₂ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 149,
    "source": "batteries",
    "description": "Proves that the disjointness of two lists is symmetric; if one list is disjoint from another, the reverse is also true."
  },
  "disjoint_left": {
    "name": "disjoint_left",
    "type": "theorem",
    "signature": "disjoint_left : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 151,
    "source": "batteries",
    "description": "Proves that two lists are disjoint if and only if no element of the first list is present in the second list."
  },
  "disjoint_right": {
    "name": "disjoint_right",
    "type": "theorem",
    "signature": "disjoint_right : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₂ → a ∉ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "Proves that two lists are disjoint if and only if no element of the second list is present in the first list."
  },
  "disjoint_iff_ne": {
    "name": "disjoint_iff_ne",
    "type": "theorem",
    "signature": "disjoint_iff_ne : Disjoint l₁ l₂ ↔ ∀ a ∈ l₁, ∀ b ∈ l₂, a ≠ b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 155,
    "source": "batteries",
    "description": "States that two lists are disjoint if and only if all elements in one list are different from all elements in the other list."
  },
  "disjoint_of_subset_left": {
    "name": "disjoint_of_subset_left",
    "type": "theorem",
    "signature": "disjoint_of_subset_left : Disjoint l₁ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 158,
    "source": "batteries",
    "description": "Proves that if one list is a subset of another, then the two lists are disjoint."
  },
  "disjoint_of_subset_right": {
    "name": "disjoint_of_subset_right",
    "type": "theorem",
    "signature": "disjoint_of_subset_right : Disjoint l₁ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 161,
    "source": "batteries",
    "description": "Proves that if one list is a subset of another, then the two lists are disjoint."
  },
  "disjoint_of_disjoint_append_left_left": {
    "name": "disjoint_of_disjoint_append_left_left",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_left_left : Disjoint l₁ l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 192,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint and one is appended to the left of another, the result remains disjoint from the first list."
  },
  "disjoint_of_disjoint_append_left_right": {
    "name": "disjoint_of_disjoint_append_left_right",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_left_right : Disjoint l₂ l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 195,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint when appended, then each list is disjoint from the other."
  },
  "disjoint_of_disjoint_append_right_left": {
    "name": "disjoint_of_disjoint_append_right_left",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_right_left : Disjoint l l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 198,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint, appending one list to the other maintains their disjoint property."
  },
  "disjoint_of_disjoint_append_right_right": {
    "name": "disjoint_of_disjoint_append_right_right",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_right_right : Disjoint l l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 201,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint and one is appended to the right of the other, the resulting lists remain disjoint."
  },
  "diff_subset": {
    "name": "diff_subset",
    "type": "theorem",
    "signature": "diff_subset : l₁.diff l₂ ⊆ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 300,
    "source": "batteries",
    "description": "Proves that the difference of two lists is a subset of the first list."
  },
  "rel_of_isChain_cons_cons": {
    "name": "rel_of_isChain_cons_cons",
    "type": "theorem",
    "signature": "rel_of_isChain_cons_cons : R a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 354,
    "source": "batteries",
    "description": "Proves that if a relation holds for a chain of elements, it also holds for the first two elements of that chain."
  },
  "isChain_of_isChain_cons": {
    "name": "isChain_of_isChain_cons",
    "type": "theorem",
    "signature": "isChain_of_isChain_cons : IsChain R l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 366,
    "source": "batteries",
    "description": "Proves that if a list is a chain under a relation R, then it satisfies the properties of being a chain."
  },
  "isChain_of_isChain_cons_cons": {
    "name": "isChain_of_isChain_cons_cons",
    "type": "theorem",
    "signature": "isChain_of_isChain_cons_cons : IsChain R l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 372,
    "source": "batteries",
    "description": "Proves that a list is a chain if it can be constructed by consing elements to an existing chain."
  },
  "toArrayMap": {
    "name": "toArrayMap",
    "type": "def",
    "signature": "toArrayMap : Array β",
    "docstring": "This function is provided as a more efficient runtime alternative to `(l.map f).toArray`. (It avoids the intermediate memory allocation of creating an intermediate list first.) For verification purposes, we immediately simplify it to that form.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/ArrayMap.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "This function is provided as a more efficient runtime alternative to `(l.map f).toArray`. (It avoids the intermediate memory allocation of creating an intermediate list first.) For verification purposes, we immediately simplify it to that form."
  },
  "Subperm.filter": {
    "name": "Subperm.filter",
    "type": "theorem",
    "signature": "Subperm.filter : filter p l <+~ filter p l'",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 70,
    "source": "batteries",
    "description": "Shows that filtering a list with a predicate preserves the subpermutation relation between the filtered lists."
  },
  "subperm_of_subset": {
    "name": "subperm_of_subset",
    "type": "theorem",
    "signature": "subperm_of_subset : l₁ <+~ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 140,
    "source": "batteries",
    "description": "Proves that if list l₁ is a subpermutation of list l₂, then l₁ is a subset of l₂."
  },
  "erase_subperm": {
    "name": "erase_subperm",
    "type": "theorem",
    "signature": "erase_subperm : l.erase a <+~ l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 180,
    "source": "batteries",
    "description": "Proves that removing an element from a list results in a subpermutation of the original list."
  },
  "Perm.union_left": {
    "name": "Perm.union_left",
    "type": "theorem",
    "signature": "Perm.union_left : l ∪ t₁ ~ l ∪ t₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 288,
    "source": "batteries",
    "description": "Proves that the union of a list with two permutations is equivalent, showing that the order of elements does not affect the union."
  },
  "Perm.insertP": {
    "name": "Perm.insertP",
    "type": "theorem",
    "signature": "Perm.insertP : insertP p a l₁ ~ insertP p a l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 319,
    "source": "batteries",
    "description": "Proves that inserting an element into two lists at the same position results in lists that are permutation-equivalent."
  },
  "splitAtD": {
    "name": "splitAtD",
    "type": "def",
    "signature": "splitAtD : List α × List α",
    "docstring": "Split a list at an index. Ensures the left list always has the specified length by right padding with the provided default element. ``` splitAtD 2 [a, b, c] x = ([a, b], [c]) splitAtD 4 [a, b, c] x = ([a, b, c, x], []) ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 98,
    "source": "batteries",
    "description": "Split a list at an index. Ensures the left list always has the specified length by right padding with the provided default element. ``` splitAtD 2 [a, b, c] x = ([a, b], [c]) splitAtD 4 [a, b, c] x = ([a, b, c, x], []) ```"
  },
  "splitOnP": {
    "name": "splitOnP",
    "type": "def",
    "signature": "splitOnP : List (List α)",
    "docstring": "Split a list at every element satisfying a predicate. The separators are not in the result. ``` [1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 112,
    "source": "batteries",
    "description": "Split a list at every element satisfying a predicate. The separators are not in the result. ``` [1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]] ```"
  },
  "takeD": {
    "name": "takeD",
    "type": "def",
    "signature": "takeD : Nat → List α → α → List α",
    "docstring": "Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l` elements `x`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 157,
    "source": "batteries",
    "description": "Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l` elements `x`."
  },
  "takeDTR": {
    "name": "takeDTR",
    "type": "def",
    "signature": "takeDTR : List α",
    "docstring": "Tail-recursive version of `takeD`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 169,
    "source": "batteries",
    "description": "Tail-recursive version of `takeD`."
  },
  "scanr": {
    "name": "scanr",
    "type": "def",
    "signature": "scanr : List β",
    "docstring": "Fold a function `f` over the list from the right, returning the list of partial results. ``` scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 214,
    "source": "batteries",
    "description": "Fold a function `f` over the list from the right, returning the list of partial results. ``` scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0] ```"
  },
  "initsTR": {
    "name": "initsTR",
    "type": "def",
    "signature": "initsTR : List (List α)",
    "docstring": "Tail-recursive version of `inits`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 279,
    "source": "batteries",
    "description": "Tail-recursive version of `inits`."
  },
  "tailsTR": {
    "name": "tailsTR",
    "type": "def",
    "signature": "tailsTR : List (List α)",
    "docstring": "Tail-recursive version of `tails`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 296,
    "source": "batteries",
    "description": "Tail-recursive version of `tails`."
  },
  "sublists": {
    "name": "sublists",
    "type": "def",
    "signature": "sublists : List (List α)",
    "docstring": "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'` for a different ordering. ``` sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 329,
    "source": "batteries",
    "description": "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'` for a different ordering. ``` sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] ```"
  },
  "sublistsFast": {
    "name": "sublistsFast",
    "type": "def",
    "signature": "sublistsFast : List (List α)",
    "docstring": "A version of `List.sublists` that has faster runtime performance but worse kernel performance",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 333,
    "source": "batteries",
    "description": "A version of `List.sublists` that has faster runtime performance but worse kernel performance"
  },
  "all₂": {
    "name": "all₂",
    "type": "def",
    "signature": "all₂ : List α → List β → Bool",
    "docstring": "Check for all elements `a`, `b`, where `a` and `b` are the nth element of the first and second List respectively, that `r a b = true`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 370,
    "source": "batteries",
    "description": "Check for all elements `a`, `b`, where `a` and `b` are the nth element of the first and second List respectively, that `r a b = true`."
  },
  "transpose": {
    "name": "transpose",
    "type": "def",
    "signature": "transpose : List (List α)",
    "docstring": "Transpose of a list of lists, treated as a matrix. ``` transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 399,
    "source": "batteries",
    "description": "Transpose of a list of lists, treated as a matrix. ``` transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]] ```"
  },
  "sectionsTR": {
    "name": "sectionsTR",
    "type": "def",
    "signature": "sectionsTR : List (List α)",
    "docstring": "Optimized version of `sections`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 431,
    "source": "batteries",
    "description": "Optimized version of `sections`."
  },
  "extractP": {
    "name": "extractP",
    "type": "def",
    "signature": "extractP : Option α × List α",
    "docstring": "`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate `p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 459,
    "source": "batteries",
    "description": "`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate `p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`."
  },
  "revzip": {
    "name": "revzip",
    "type": "def",
    "signature": "revzip : List (α × α)",
    "docstring": "`revzip l` returns a list of pairs of the elements of `l` paired with the elements of `l` in reverse order. ``` revzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 474,
    "source": "batteries",
    "description": "`revzip l` returns a list of pairs of the elements of `l` paired with the elements of `l` in reverse order. ``` revzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)] ```"
  },
  "product": {
    "name": "product",
    "type": "def",
    "signature": "product : List (α × β)",
    "docstring": "`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`. ``` product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 482,
    "source": "batteries",
    "description": "`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`. ``` product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)] ```"
  },
  "productTR": {
    "name": "productTR",
    "type": "def",
    "signature": "productTR : List (α × β)",
    "docstring": "Optimized version of `product`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 485,
    "source": "batteries",
    "description": "Optimized version of `product`."
  },
  "Disjoint": {
    "name": "Disjoint",
    "type": "def",
    "signature": "Disjoint : Prop",
    "docstring": "`Disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 514,
    "source": "batteries",
    "description": "`Disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common."
  },
  "takeWhile₂": {
    "name": "takeWhile₂",
    "type": "def",
    "signature": "takeWhile₂ : List α → List β → List α × List β",
    "docstring": "Returns the longest initial prefix of two lists such that they are pairwise related by `R`. ``` takeWhile₂ (· < ·) [1, 2, 4, 5] [5, 4, 3, 6] = ([1, 2], [5, 4]) ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 523,
    "source": "batteries",
    "description": "Returns the longest initial prefix of two lists such that they are pairwise related by `R`. ``` takeWhile₂ (· < ·) [1, 2, 4, 5] [5, 4, 3, 6] = ([1, 2], [5, 4]) ```"
  },
  "pwFilter": {
    "name": "pwFilter",
    "type": "def",
    "signature": "pwFilter : List α",
    "docstring": "`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`. `pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds a maximal increasing subsequence in `l`. For example, ``` pwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 558,
    "source": "batteries",
    "description": "`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`. `pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds a maximal increasing subsequence in `l`. For example, ``` pwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4] ```"
  },
  "Chain": {
    "name": "Chain",
    "type": "def",
    "signature": "Chain : (α → α → Prop) → α → List α → Prop",
    "docstring": "`Chain R a l` means that `R` holds between adjacent elements of `a::l`. ``` Chain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 592,
    "source": "batteries",
    "description": "`Chain R a l` means that `R` holds between adjacent elements of `a::l`. ``` Chain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d ```"
  },
  "zipWith₃": {
    "name": "zipWith₃",
    "type": "def",
    "signature": "zipWith₃ : List α → List β → List γ → List δ",
    "docstring": "Ternary version of `List.zipWith`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 955,
    "source": "batteries",
    "description": "Ternary version of `List.zipWith`."
  },
  "zipWith₄": {
    "name": "zipWith₄",
    "type": "def",
    "signature": "zipWith₄ : List α → List β → List γ → List δ → List ε",
    "docstring": "Quaternary version of `List.zipWith`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 960,
    "source": "batteries",
    "description": "Quaternary version of `List.zipWith`."
  },
  "zipWith₅": {
    "name": "zipWith₅",
    "type": "def",
    "signature": "zipWith₅ : List α → List β → List γ → List δ → List ε → List ζ",
    "docstring": "Quinary version of `List.zipWith`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 965,
    "source": "batteries",
    "description": "Quinary version of `List.zipWith`."
  },
  "Subperm": {
    "name": "Subperm",
    "type": "def",
    "signature": "Subperm : Prop",
    "docstring": "`Subperm l₁ l₂`, denoted `l₁ <+~ l₂`, means that `l₁` is a sublist of a permutation of `l₂`. This is an analogue of `l₁ ⊆ l₂` which respects multiplicities of elements, and is used for the `≤` relation on multisets.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 1009,
    "source": "batteries",
    "description": "`Subperm l₁ l₂`, denoted `l₁ <+~ l₂`, means that `l₁` is a sublist of a permutation of `l₂`. This is an analogue of `l₁ ⊆ l₂` which respects multiplicities of elements, and is used for the `≤` relation on multisets."
  },
  "insertP": {
    "name": "insertP",
    "type": "def",
    "signature": "insertP : List α",
    "docstring": "`O(|l|)`. Inserts `a` in `l` right before the first element such that `p` is true, or at the end of the list if `p` always false on `l`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 1023,
    "source": "batteries",
    "description": "`O(|l|)`. Inserts `a` in `l` right before the first element such that `p` is true, or at the end of the list if `p` always false on `l`."
  },
  "Forall₂": {
    "name": "Forall₂",
    "type": "inductive",
    "signature": "Forall₂ : List α → List β → Prop",
    "docstring": "`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length, and whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`, then `R a b` is satisfied.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 353,
    "source": "batteries",
    "description": "`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length, and whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`, then `R a b` is satisfied."
  },
  "IsChain": {
    "name": "IsChain",
    "type": "inductive",
    "signature": "IsChain : List α → Prop",
    "docstring": "`IsChain R l` means that `R` holds between adjacent elements of `l`. ``` IsChain R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 565,
    "source": "batteries",
    "description": "`IsChain R l` means that `R` holds between adjacent elements of `l`. ``` IsChain R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d ```"
  },
  "Valid": {
    "name": "Valid",
    "type": "def",
    "signature": "Valid : Prop",
    "docstring": "Validity for a string iterator.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 531,
    "source": "batteries",
    "description": "Validity for a string iterator."
  },
  "add_utf8Size_pos": {
    "name": "add_utf8Size_pos",
    "type": "theorem",
    "signature": "add_utf8Size_pos : 0 < i + Char.utf8Size c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 38,
    "source": "batteries",
    "description": "Proves that the sum of a non-negative integer and the UTF-8 size of a character is positive."
  },
  "ne_add_utf8Size_add_self": {
    "name": "ne_add_utf8Size_add_self",
    "type": "theorem",
    "signature": "ne_add_utf8Size_add_self : i ≠ n + Char.utf8Size c + i",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 41,
    "source": "batteries",
    "description": "Proves that adding the UTF-8 size of a character to an integer does not equal the original integer."
  },
  "ne_self_add_add_utf8Size": {
    "name": "ne_self_add_add_utf8Size",
    "type": "theorem",
    "signature": "ne_self_add_add_utf8Size : i ≠ i + (n + Char.utf8Size c)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Proves that a natural number is not equal to itself plus the size of a UTF-8 character."
  },
  "utf8Len_le_of_sublist": {
    "name": "utf8Len_le_of_sublist",
    "type": "theorem",
    "signature": "utf8Len_le_of_sublist : ∀ {cs₁ cs₂}, cs₁ <+ cs₂ → utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 81,
    "source": "batteries",
    "description": "If one list is a sublist of another, then the UTF-8 length of the first list is less than or equal to that of the second."
  },
  "utf8Len_le_of_infix": {
    "name": "utf8Len_le_of_infix",
    "type": "theorem",
    "signature": "utf8Len_le_of_infix : utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 85,
    "source": "batteries",
    "description": "Proves that the UTF-8 length of a list of characters is less than or equal to that of another list when one is an infix of the other."
  },
  "utf8Len_le_of_suffix": {
    "name": "utf8Len_le_of_suffix",
    "type": "theorem",
    "signature": "utf8Len_le_of_suffix : utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 88,
    "source": "batteries",
    "description": "Proves that the length of a UTF-8 encoded string is less than or equal to the length of its suffix."
  },
  "utf8Len_le_of_prefix": {
    "name": "utf8Len_le_of_prefix",
    "type": "theorem",
    "signature": "utf8Len_le_of_prefix : utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 91,
    "source": "batteries",
    "description": "If `cs₁` is a prefix of `cs₂`, then the length of `cs₁` in UTF-8 encoding is less than or equal to that of `cs₂`."
  },
  "lt_addChar": {
    "name": "lt_addChar",
    "type": "theorem",
    "signature": "lt_addChar : p < p + c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Proves that adding a character to a value p results in a value greater than p."
  },
  "Valid.le_endPos": {
    "name": "Valid.le_endPos",
    "type": "theorem",
    "signature": "Valid.le_endPos : ∀ {s p}, Valid s p → p ≤ endPos s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 139,
    "source": "batteries",
    "description": "Proves that if a state `s` is valid for position `p`, then `p` is less than or equal to the end position of `s`."
  },
  "findAux_of_valid": {
    "name": "findAux_of_valid",
    "type": "theorem",
    "signature": "findAux_of_valid : ∀ l m r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 320,
    "source": "batteries",
    "description": "Proves that the auxiliary function findAux behaves correctly when the input list is valid."
  },
  "revFindAux_of_valid": {
    "name": "revFindAux_of_valid",
    "type": "theorem",
    "signature": "revFindAux_of_valid : ∀ l r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 343,
    "source": "batteries",
    "description": "Proves that the auxiliary function `revFindAux` is valid for a given list and a result, ensuring correct behavior in its application."
  },
  "valid": {
    "name": "valid",
    "type": "theorem",
    "signature": "valid : ∀ {it}, ValidFor l r it → Valid it",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 542,
    "source": "batteries",
    "description": "Proves that if an item is valid for a list and a relation, then the item is valid."
  },
  "_root_.String.validFor_mkIterator": {
    "name": "_root_.String.validFor_mkIterator",
    "type": "theorem",
    "signature": "_root_.String.validFor_mkIterator : (mkIterator s).ValidFor [] s.data",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 560,
    "source": "batteries",
    "description": "Proves that the iterator created from a string is valid for the string's data."
  },
  "prev_nil": {
    "name": "prev_nil",
    "type": "theorem",
    "signature": "prev_nil : ∀ {it}, ValidFor [] r it → ValidFor [] r it.prev",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 598,
    "source": "batteries",
    "description": "Proves that if a list is valid for a relation, then its previous element is also valid for the same relation."
  },
  "hasNext": {
    "name": "hasNext",
    "type": "theorem",
    "signature": "hasNext : ∀ {it}, ValidFor l r it → (it.hasNext ↔ r ≠ [])",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 610,
    "source": "batteries",
    "description": "Proves that an iterator has a next element if and only if the right list is not empty."
  },
  "hasPrev": {
    "name": "hasPrev",
    "type": "theorem",
    "signature": "hasPrev : ∀ {it}, ValidFor l r it → (it.hasPrev ↔ l ≠ [])",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 613,
    "source": "batteries",
    "description": "Proves that an iterator has a previous element if and only if the list is not empty."
  },
  "toEnd": {
    "name": "toEnd",
    "type": "theorem",
    "signature": "toEnd : ValidFor (r.reverse ++ l) [] it.toEnd",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 628,
    "source": "batteries",
    "description": "Proves that appending a reversed list to another list results in a valid transformation to the end of the list."
  },
  "nextn": {
    "name": "nextn",
    "type": "theorem",
    "signature": "nextn : ∀ {it}, ValidFor l r it →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 652,
    "source": "batteries",
    "description": "Proves that a certain condition holds for the next element in a sequence given its validity in a list."
  },
  "prevn": {
    "name": "prevn",
    "type": "theorem",
    "signature": "prevn : ∀ {it}, ValidFor l r it →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 660,
    "source": "batteries",
    "description": "Proves a property related to the validity of a certain condition for indices in a list or sequence."
  },
  "validFor": {
    "name": "validFor",
    "type": "theorem",
    "signature": "validFor : ∀ {it}, Valid it → ∃ l r, ValidFor l r it",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 672,
    "source": "batteries",
    "description": "Proves that if an item is valid, then there exist left and right components that also satisfy the validity condition."
  },
  "_root_.String.valid_mkIterator": {
    "name": "_root_.String.valid_mkIterator",
    "type": "theorem",
    "signature": "_root_.String.valid_mkIterator : (mkIterator s).Valid",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 676,
    "source": "batteries",
    "description": "Proves that the iterator created from a string is valid, ensuring it can be used correctly for traversal."
  },
  "remainingBytes_le": {
    "name": "remainingBytes_le",
    "type": "theorem",
    "signature": "remainingBytes_le : ∀ {it}, Valid it → it.remainingBytes ≤ utf8ByteSize it.s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 678,
    "source": "batteries",
    "description": "Proves that the remaining bytes in a valid input are less than or equal to the UTF-8 byte size of its string representation."
  },
  "next": {
    "name": "next",
    "type": "theorem",
    "signature": "next : ∀ {it}, Valid it → it.hasNext → Valid it.next",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 683,
    "source": "batteries",
    "description": "Proves that if an iterator is valid and has a next element, then the next element is also valid."
  },
  "prev": {
    "name": "prev",
    "type": "theorem",
    "signature": "prev : ∀ {it}, Valid it → Valid it.prev",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 689,
    "source": "batteries",
    "description": "Proves that if a state is valid, then its predecessor state is also valid."
  },
  "setCurr": {
    "name": "setCurr",
    "type": "theorem",
    "signature": "setCurr : ∀ {it}, Valid it → Valid (it.setCurr c)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 695,
    "source": "batteries",
    "description": "Proves that setting the current element in a valid structure maintains its validity."
  },
  "offsetOfPosAux_of_valid": {
    "name": "offsetOfPosAux_of_valid",
    "type": "theorem",
    "signature": "offsetOfPosAux_of_valid : ∀ l m r n,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 717,
    "source": "batteries",
    "description": "Proves a property related to the validity of offsets in a data structure, involving parameters l, m, r, and n."
  },
  "foldlAux_of_valid": {
    "name": "foldlAux_of_valid",
    "type": "theorem",
    "signature": "foldlAux_of_valid : ∀ l m r a,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 732,
    "source": "batteries",
    "description": "Proves that a certain auxiliary function maintains validity when folding over a list with given parameters."
  },
  "anyAux_of_valid": {
    "name": "anyAux_of_valid",
    "type": "theorem",
    "signature": "anyAux_of_valid : ∀ l m r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 760,
    "source": "batteries",
    "description": "Proves a property related to the validity of a structure involving lists and auxiliary elements."
  },
  "any_iff": {
    "name": "any_iff",
    "type": "theorem",
    "signature": "any_iff : any s p ↔ ∃ c ∈ s.data, p c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 774,
    "source": "batteries",
    "description": "States that a predicate holds for any element in a set if and only if there exists at least one element in the set satisfying the predicate."
  },
  "all_iff": {
    "name": "all_iff",
    "type": "theorem",
    "signature": "all_iff : all s p ↔ ∀ c ∈ s.data, p c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 779,
    "source": "batteries",
    "description": "States that a property holds for all elements in a set if and only if it holds for every element in the set's data."
  },
  "contains_iff": {
    "name": "contains_iff",
    "type": "theorem",
    "signature": "contains_iff : contains s c ↔ c ∈ s.data",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 781,
    "source": "batteries",
    "description": "States that a set contains an element if and only if that element is in the set's data."
  },
  "takeWhileAux_of_valid": {
    "name": "takeWhileAux_of_valid",
    "type": "theorem",
    "signature": "takeWhileAux_of_valid : ∀ l m r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 805,
    "source": "batteries",
    "description": "Proves that the auxiliary function `takeWhileAux` maintains validity for a given list and its parameters."
  },
  "Valid_default": {
    "name": "Valid_default",
    "type": "theorem",
    "signature": "Valid_default : Valid default",
    "docstring": "The stop position of a substring is at least the start.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 848,
    "source": "batteries",
    "description": "The stop position of a substring is at least the start."
  },
  "of_eq": {
    "name": "of_eq",
    "type": "theorem",
    "signature": "of_eq : ∀ s,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 861,
    "source": "batteries",
    "description": "Proves that if two values are equal, they can be substituted for one another in any context."
  },
  "_root_.String.validFor_toSubstring": {
    "name": "_root_.String.validFor_toSubstring",
    "type": "theorem",
    "signature": "_root_.String.validFor_toSubstring : ValidFor [] s.data [] s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 870,
    "source": "batteries",
    "description": "Proves that a substring of a string is valid if the original string is valid and the substring is derived from it."
  },
  "toIterator": {
    "name": "toIterator",
    "type": "theorem",
    "signature": "toIterator : ∀ {s}, ValidFor l m r s → s.toIterator.ValidFor l.reverse (m ++ r)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 891,
    "source": "batteries",
    "description": "Proves that if a sequence is valid for certain parameters, its iterator is valid for the reversed left parameters and the concatenated middle and right parameters."
  },
  "drop": {
    "name": "drop",
    "type": "theorem",
    "signature": "drop : ∀ {s}, ValidFor l m r s → ∀ n, ValidFor (l ++ m.take n) (m.drop n) r (s.drop n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 955,
    "source": "batteries",
    "description": "Proves that if a sequence is valid, dropping elements from the middle preserves the validity of the modified sequence."
  },
  "take": {
    "name": "take",
    "type": "theorem",
    "signature": "take : ∀ {s}, ValidFor l m r s → ∀ n, ValidFor l (m.take n) (m.drop n ++ r) (s.take n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 967,
    "source": "batteries",
    "description": "Proves that taking the first n elements from a valid sequence maintains validity for the modified sequence."
  },
  "extract": {
    "name": "extract",
    "type": "theorem",
    "signature": "extract : ∀ {s}, ValidFor l m r s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 999,
    "source": "batteries",
    "description": "Proves a property related to the validity of a structure given certain parameters."
  },
  "contains": {
    "name": "contains",
    "type": "theorem",
    "signature": "contains : ∀ {s}, ValidFor l m r s → (s.contains c ↔ c ∈ m)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1021,
    "source": "batteries",
    "description": "Proves that an element is contained in a set if and only if it is part of a specified mapping, given the validity of certain conditions."
  },
  "takeWhile": {
    "name": "takeWhile",
    "type": "theorem",
    "signature": "takeWhile : ∀ {s}, ValidFor l m r s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1024,
    "source": "batteries",
    "description": "Proves that the takeWhile function correctly extracts elements from a sequence based on a specified predicate."
  },
  "dropWhile": {
    "name": "dropWhile",
    "type": "theorem",
    "signature": "dropWhile : ∀ {s}, ValidFor l m r s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1031,
    "source": "batteries",
    "description": "Proves that the dropWhile function maintains validity for a sequence after dropping elements that satisfy a given condition."
  },
  "_root_.String.valid_toSubstring": {
    "name": "_root_.String.valid_toSubstring",
    "type": "theorem",
    "signature": "_root_.String.valid_toSubstring : Valid s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1064,
    "source": "batteries",
    "description": "Proves that a valid string can be used to create a substring."
  },
  "toString_extract": {
    "name": "toString_extract",
    "type": "theorem",
    "signature": "toString_extract : ∀ {s}, Valid s → Valid ⟨s.toString, b, e⟩ →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1137,
    "source": "batteries",
    "description": "Proves that if a string is valid, then its string representation is also valid within a specified context."
  },
  "data_takeWhile": {
    "name": "data_takeWhile",
    "type": "theorem",
    "signature": "data_takeWhile : ∀ {s}, Valid s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1164,
    "source": "batteries",
    "description": "Proves that the function `data_takeWhile` correctly processes valid data structures based on a specified condition."
  },
  "data_dropWhile": {
    "name": "data_dropWhile",
    "type": "theorem",
    "signature": "data_dropWhile : ∀ {s}, Valid s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1171,
    "source": "batteries",
    "description": "Proves that the dropWhile function maintains validity for a given structure when applied to a valid sequence."
  },
  "ValidFor": {
    "name": "ValidFor",
    "type": "inductive",
    "signature": "ValidFor : Iterator → Prop",
    "docstring": "`it.ValidFor l r` means that `it` is a string iterator whose underlying string is `l.reverse ++ r`, and where the cursor is pointing at the end of `l.reverse`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 535,
    "source": "batteries",
    "description": "`it.ValidFor l r` means that `it` is a string iterator whose underlying string is `l.reverse ++ r`, and where the cursor is pointing at the end of `l.reverse`."
  },
  "toAsciiByteArray": {
    "name": "toAsciiByteArray",
    "type": "def",
    "signature": "toAsciiByteArray : ByteArray",
    "docstring": "Convert a string of assumed-ASCII characters into a byte array. (If any characters are non-ASCII they will be reduced modulo 256.) Note: if you just need the underlying `ByteArray` of a non-ASCII string, use `String.toUTF8`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Basic.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "Convert a string of assumed-ASCII characters into a byte array. (If any characters are non-ASCII they will be reduced modulo 256.) Note: if you just need the underlying `ByteArray` of a non-ASCII string, use `String.toUTF8`."
  },
  "mt19937": {
    "name": "mt19937",
    "type": "def",
    "signature": "mt19937 : Config where",
    "docstring": "32 bit Mersenne Twister (MT19937) configuration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Random/MersenneTwister.lean",
    "line_number": 139,
    "source": "batteries",
    "description": "32 bit Mersenne Twister (MT19937) configuration."
  },
  "mt19937_64": {
    "name": "mt19937_64",
    "type": "def",
    "signature": "mt19937_64 : Config where",
    "docstring": "64 bit Mersenne Twister (MT19937-64) configuration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Random/MersenneTwister.lean",
    "line_number": 151,
    "source": "batteries",
    "description": "64 bit Mersenne Twister (MT19937-64) configuration."
  },
  "Config": {
    "name": "Config",
    "type": "structure",
    "signature": "Config",
    "docstring": "Mersenne Twister configuration. Letters in parentheses correspond to variable names used by Matsumoto and Nishimura (1998) and Nishimura (2000).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Random/MersenneTwister.lean",
    "line_number": 54,
    "source": "batteries",
    "description": "Mersenne Twister configuration. Letters in parentheses correspond to variable names used by Matsumoto and Nishimura (1998) and Nishimura (2000)."
  },
  "depth": {
    "name": "depth",
    "type": "def",
    "signature": "depth : RBNode α → Nat",
    "docstring": "`O(n)`. `depth t` is the maximum number of nodes on any path to a leaf. It is an upper bound on most tree operations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`O(n)`. `depth t` is the maximum number of nodes on any path to a leaf. It is an upper bound on most tree operations."
  },
  "depthLB": {
    "name": "depthLB",
    "type": "def",
    "signature": "depthLB : RBColor → Nat → Nat",
    "docstring": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 40,
    "source": "batteries",
    "description": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthUB": {
    "name": "depthUB",
    "type": "def",
    "signature": "depthUB : RBColor → Nat → Nat",
    "docstring": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 52,
    "source": "batteries",
    "description": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthLB_le": {
    "name": "depthLB_le",
    "type": "theorem",
    "signature": "depthLB_le : ∀ c n, n ≤ depthLB c n",
    "docstring": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 43,
    "source": "batteries",
    "description": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthUB_le": {
    "name": "depthUB_le",
    "type": "theorem",
    "signature": "depthUB_le : ∀ c n, depthUB c n ≤ 2 * n + 1",
    "docstring": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 55,
    "source": "batteries",
    "description": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthUB_le_two_depthLB": {
    "name": "depthUB_le_two_depthLB",
    "type": "theorem",
    "signature": "depthUB_le_two_depthLB : ∀ c n, depthUB c n ≤ 2 * depthLB c n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 59,
    "source": "batteries",
    "description": "Proves that the upper bound of depth is at most twice the lower bound for any given context and natural number."
  },
  "Balanced.depth_le": {
    "name": "Balanced.depth_le",
    "type": "theorem",
    "signature": "Balanced.depth_le : @Balanced α t c n → t.depth ≤ depthUB c n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 63,
    "source": "batteries",
    "description": "Proves that the depth of a balanced tree is less than or equal to the upper bound on depth given its configuration parameters."
  },
  "Balanced.le_size": {
    "name": "Balanced.le_size",
    "type": "theorem",
    "signature": "Balanced.le_size : @Balanced α t c n → 2 ^ depthLB c n ≤ t.size + 1",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 69,
    "source": "batteries",
    "description": "Proves that the size of a balanced tree is at least \\(2^{\\text{depthLB}(c, n)} - 1\\), ensuring efficient space usage."
  },
  "Balanced.depth_bound": {
    "name": "Balanced.depth_bound",
    "type": "theorem",
    "signature": "Balanced.depth_bound : t.depth ≤ 2 * (t.size + 1).log2",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "Proves that the depth of a balanced tree is bounded by twice the logarithm of its size plus one."
  },
  "setRoot": {
    "name": "setRoot",
    "type": "def",
    "signature": "setRoot : RBNode α → RBNode α",
    "docstring": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 373,
    "source": "batteries",
    "description": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary."
  },
  "delRoot": {
    "name": "delRoot",
    "type": "def",
    "signature": "delRoot : RBNode α → RBNode α",
    "docstring": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 380,
    "source": "batteries",
    "description": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary."
  },
  "AllL": {
    "name": "AllL",
    "type": "def",
    "signature": "AllL : Path α → Prop",
    "docstring": "Asserts that `p` holds on all elements to the left of the hole.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 740,
    "source": "batteries",
    "description": "Asserts that `p` holds on all elements to the left of the hole."
  },
  "AllR": {
    "name": "AllR",
    "type": "def",
    "signature": "AllR : Path α → Prop",
    "docstring": "Asserts that `p` holds on all elements to the right of the hole.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 746,
    "source": "batteries",
    "description": "Asserts that `p` holds on all elements to the right of the hole."
  },
  "mem_toList_insert_self": {
    "name": "mem_toList_insert_self",
    "type": "theorem",
    "signature": "mem_toList_insert_self : v ∈ toList (t.insert v)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 922,
    "source": "batteries",
    "description": "Proves that an element inserted into a tree is included in the list representation of that tree."
  },
  "IsCut": {
    "name": "IsCut",
    "type": "class",
    "signature": "IsCut",
    "docstring": "A cut is like a homomorphism of orderings: it is a monotonic predicate with respect to `cmp`, but it can make things that are distinguished by `cmp` equal. This is sufficient for `find?` to locate an element on which `cut` returns `.eq`, but there may be other elements, not returned by `find?`, on which `cut` also returns `.eq`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 85,
    "source": "batteries",
    "description": "A cut is like a homomorphism of orderings: it is a monotonic predicate with respect to `cmp`, but it can make things that are distinguished by `cmp` equal. This is sufficient for `find?` to locate an element on which `cut` returns `.eq`, but there may be other elements, not returned by `find?`, on which `cut` also returns `.eq`."
  },
  "IsStrictCut": {
    "name": "IsStrictCut",
    "type": "class",
    "signature": "IsStrictCut",
    "docstring": "`IsStrictCut` upgrades the `IsCut` property to ensure that at most one element of the tree can match the cut, and hence `find?` will return the unique such element if one exists.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 122,
    "source": "batteries",
    "description": "`IsStrictCut` upgrades the `IsCut` property to ensure that at most one element of the tree can match the cut, and hence `find?` will return the unique such element if one exists."
  },
  "Any": {
    "name": "Any",
    "type": "def",
    "signature": "Any : RBNode α → Prop",
    "docstring": "Asserts that `p` holds on some element of the tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 188,
    "source": "batteries",
    "description": "Asserts that `p` holds on some element of the tree."
  },
  "EMem": {
    "name": "EMem",
    "type": "def",
    "signature": "EMem : Prop",
    "docstring": "True if `x` is an element of `t` \"exactly\", i.e. up to equality, not the `cmp` relation.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 199,
    "source": "batteries",
    "description": "True if `x` is an element of `t` \"exactly\", i.e. up to equality, not the `cmp` relation."
  },
  "MemP": {
    "name": "MemP",
    "type": "def",
    "signature": "MemP : Prop",
    "docstring": "True if the specified `cut` matches at least one element of of `t`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 205,
    "source": "batteries",
    "description": "True if the specified `cut` matches at least one element of of `t`."
  },
  "cmpLT": {
    "name": "cmpLT",
    "type": "def",
    "signature": "cmpLT : Prop",
    "docstring": "We say that `x < y` under the comparator `cmp` if `cmp x y = .lt`. * In order to avoid assuming the comparator is always lawful, we use a local `∀ [Std.TransCmp cmp]` binder in the relation so that the ordering properties of the tree only need to hold if the comparator is lawful. * The `Nonempty` wrapper is a no-op because this is already a proposition, but it prevents the `[Std.TransCmp cmp]` binder from being introduced when we don't want it.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 244,
    "source": "batteries",
    "description": "We say that `x < y` under the comparator `cmp` if `cmp x y = .lt`. * In order to avoid assuming the comparator is always lawful, we use a local `∀ [Std.TransCmp cmp]` binder in the relation so that the ordering properties of the tree only need to hold if the comparator is lawful. * The `Nonempty` wrapper is a no-op because this is already a proposition, but it prevents the `[Std.TransCmp cmp]` binder from being introduced when we don't want it."
  },
  "cmpEq": {
    "name": "cmpEq",
    "type": "def",
    "signature": "cmpEq : Prop",
    "docstring": "We say that `x ≈ y` under the comparator `cmp` if `cmp x y = .eq`. See also `cmpLT`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 253,
    "source": "batteries",
    "description": "We say that `x ≈ y` under the comparator `cmp` if `cmp x y = .eq`. See also `cmpLT`."
  },
  "setBlack": {
    "name": "setBlack",
    "type": "def",
    "signature": "setBlack : RBNode α → RBNode α",
    "docstring": "Changes the color of the root to `black`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 296,
    "source": "batteries",
    "description": "Changes the color of the root to `black`."
  },
  "setRed": {
    "name": "setRed",
    "type": "def",
    "signature": "setRed : RBNode α → RBNode α",
    "docstring": "Recolor the root of the tree to `red` if possible.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 339,
    "source": "batteries",
    "description": "Recolor the root of the tree to `red` if possible."
  },
  "balLeft": {
    "name": "balLeft",
    "type": "def",
    "signature": "balLeft : RBNode α",
    "docstring": "Rebalancing a tree which has shrunk on the left.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 344,
    "source": "batteries",
    "description": "Rebalancing a tree which has shrunk on the left."
  },
  "balRight": {
    "name": "balRight",
    "type": "def",
    "signature": "balRight : RBNode α",
    "docstring": "Rebalancing a tree which has shrunk on the right.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 353,
    "source": "batteries",
    "description": "Rebalancing a tree which has shrunk on the right."
  },
  "Path.fill": {
    "name": "Path.fill",
    "type": "def",
    "signature": "Path.fill : Path α → RBNode α → RBNode α",
    "docstring": "Fills the `Path` with a subtree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 467,
    "source": "batteries",
    "description": "Fills the `Path` with a subtree."
  },
  "Path.ins": {
    "name": "Path.ins",
    "type": "def",
    "signature": "Path.ins : Path α → RBNode α → RBNode α",
    "docstring": "This function does the second part of `RBNode.ins`, which unwinds the stack and rebuilds the tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 488,
    "source": "batteries",
    "description": "This function does the second part of `RBNode.ins`, which unwinds the stack and rebuilds the tree."
  },
  "Path.insert": {
    "name": "Path.insert",
    "type": "def",
    "signature": "Path.insert : RBNode α",
    "docstring": "`path.insert t v` inserts element `v` into the tree, assuming that `(t, path)` was the result of a previous `zoom` operation (so either the root of `t` is equivalent to `v` or it is empty).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 506,
    "source": "batteries",
    "description": "`path.insert t v` inserts element `v` into the tree, assuming that `(t, path)` was the result of a previous `zoom` operation (so either the root of `t` is equivalent to `v` or it is empty)."
  },
  "Path.del": {
    "name": "Path.del",
    "type": "def",
    "signature": "Path.del : Path α → RBNode α → RBColor → RBNode α",
    "docstring": "`path.del t c` does the second part of `RBNode.del`, which unwinds the stack and rebuilds the tree. The `c` argument is the color of the node before the deletion (we used `t₀.isBlack` for this in `RBNode.del` but the original tree is no longer available in this formulation).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 517,
    "source": "batteries",
    "description": "`path.del t c` does the second part of `RBNode.del`, which unwinds the stack and rebuilds the tree. The `c` argument is the color of the node before the deletion (we used `t₀.isBlack` for this in `RBNode.del` but the original tree is no longer available in this formulation)."
  },
  "Path.erase": {
    "name": "Path.erase",
    "type": "def",
    "signature": "Path.erase : RBNode α",
    "docstring": "`path.erase t v` removes the root element of `t` from the tree, assuming that `(t, path)` was the result of a previous `zoom` operation.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 528,
    "source": "batteries",
    "description": "`path.erase t v` removes the root element of `t` from the tree, assuming that `(t, path)` was the result of a previous `zoom` operation."
  },
  "Ordered": {
    "name": "Ordered",
    "type": "def",
    "signature": "Ordered : RBNode α → Prop",
    "docstring": "The ordering invariant of a red-black tree, which is a binary search tree. This says that every element of a left subtree is less than the root, and every element in the right subtree is greater than the root, where the less than relation `x < y` is understood to mean `cmp x y = .lt`. Because we do not assume that `cmp` is lawful when stating this property, we write it in such a way that if `cmp` is not lawful then the condition holds trivially. That way we can prove the ordering invariants without assuming `cmp` is lawful.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 576,
    "source": "batteries",
    "description": "The ordering invariant of a red-black tree, which is a binary search tree. This says that every element of a left subtree is less than the root, and every element in the right subtree is greater than the root, where the less than relation `x < y` is understood to mean `cmp x y = .lt`. Because we do not assume that `cmp` is lawful when stating this property, we write it in such a way that if `cmp` is not lawful then the condition holds trivially. That way we can prove the ordering invariants without assuming `cmp` is lawful."
  },
  "RBSet": {
    "name": "RBSet",
    "type": "def",
    "signature": "RBSet : Type u",
    "docstring": "An `RBSet` is a self-balancing binary search tree. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 630,
    "source": "batteries",
    "description": "An `RBSet` is a self-balancing binary search tree. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior."
  },
  "Mem": {
    "name": "Mem",
    "type": "def",
    "signature": "Mem : Prop",
    "docstring": "True if `x` is equivalent to an element of `t`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 774,
    "source": "batteries",
    "description": "True if `x` is equivalent to an element of `t`."
  },
  "filter": {
    "name": "filter",
    "type": "def",
    "signature": "filter : RBSet α cmp",
    "docstring": "`O(n * log n)`. Constructs the set of all elements satisfying `p`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 883,
    "source": "batteries",
    "description": "`O(n * log n)`. Constructs the set of all elements satisfying `p`."
  },
  "sdiff": {
    "name": "sdiff",
    "type": "def",
    "signature": "sdiff : RBSet α cmp",
    "docstring": "`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 896,
    "source": "batteries",
    "description": "`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`."
  },
  "RBMap": {
    "name": "RBMap",
    "type": "def",
    "signature": "RBMap : Type (max u v)",
    "docstring": "An `RBMap` is a self-balancing binary search tree, used to store a key-value map. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 909,
    "source": "batteries",
    "description": "An `RBMap` is a self-balancing binary search tree, used to store a key-value map. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior."
  },
  "Keys.toStream": {
    "name": "Keys.toStream",
    "type": "def",
    "signature": "Keys.toStream : Keys.Stream α β",
    "docstring": "A stream over the iterator.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 990,
    "source": "batteries",
    "description": "A stream over the iterator."
  },
  "Values.toStream": {
    "name": "Values.toStream",
    "type": "def",
    "signature": "Values.toStream : Values.Stream α β",
    "docstring": "A stream over the iterator.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 1039,
    "source": "batteries",
    "description": "A stream over the iterator."
  },
  "ModifyWF": {
    "name": "ModifyWF",
    "type": "class",
    "signature": "ModifyWF",
    "docstring": "The predicate asserting that the result of `modifyP` is safe to construct.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 820,
    "source": "batteries",
    "description": "The predicate asserting that the result of `modifyP` is safe to construct."
  },
  "AlterWF": {
    "name": "AlterWF",
    "type": "class",
    "signature": "AlterWF",
    "docstring": "The predicate asserting that the result of `alterP` is safe to construct.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 836,
    "source": "batteries",
    "description": "The predicate asserting that the result of `alterP` is safe to construct."
  },
  "RBColor": {
    "name": "RBColor",
    "type": "inductive",
    "signature": "RBColor",
    "docstring": "In a red-black tree, every node has a color which is either \"red\" or \"black\" (this particular choice of colors is conventional). A nil node is considered black.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "In a red-black tree, every node has a color which is either \"red\" or \"black\" (this particular choice of colors is conventional). A nil node is considered black."
  },
  "RBNode": {
    "name": "RBNode",
    "type": "inductive",
    "signature": "RBNode",
    "docstring": "A red-black tree. (This is an internal implementation detail of the `RBSet` type, which includes the invariants of the tree.) This is a binary search tree augmented with a \"color\" field which is either red or black for each node and used to implement the re-balancing operations. See: [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "A red-black tree. (This is an internal implementation detail of the `RBSet` type, which includes the invariants of the tree.) This is a binary search tree augmented with a \"color\" field which is either red or black for each node and used to implement the re-balancing operations. See: [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)"
  },
  "Stream": {
    "name": "Stream",
    "type": "inductive",
    "signature": "Stream",
    "docstring": "An auxiliary data structure (an iterator) over an `RBNode` which lazily pulls elements from the left.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "An auxiliary data structure (an iterator) over an `RBNode` which lazily pulls elements from the left."
  },
  "Path": {
    "name": "Path",
    "type": "inductive",
    "signature": "Path",
    "docstring": "A `RBNode.Path α` is a \"cursor\" into an `RBNode` which represents the path from the root to a subtree. Note that the path goes from the target subtree up to the root, which is reversed from the normal way data is stored in the tree. See [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)) for more information.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 458,
    "source": "batteries",
    "description": "A `RBNode.Path α` is a \"cursor\" into an `RBNode` which represents the path from the root to a subtree. Note that the path goes from the target subtree up to the root, which is reversed from the normal way data is stored in the tree. See [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)) for more information."
  },
  "Balanced": {
    "name": "Balanced",
    "type": "inductive",
    "signature": "Balanced : RBNode α → RBColor → Nat → Prop",
    "docstring": "The red-black balance invariant. `Balanced t c n` says that the color of the root node is `c`, and the black-height (the number of black nodes on any path from the root) of the tree is `n`. Additionally, every red node must have black children.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 595,
    "source": "batteries",
    "description": "The red-black balance invariant. `Balanced t c n` says that the color of the root node is `c`, and the black-height (the number of black nodes on any path from the root) of the tree is `n`. Additionally, every red node must have black children."
  },
  "WF": {
    "name": "WF",
    "type": "inductive",
    "signature": "WF : RBNode α → Prop",
    "docstring": "The well-formedness invariant for a red-black tree. The first constructor is the real invariant, and the others allow us to \"cheat\" in this file and define `insert` and `erase`, which have more complex proofs that are delayed to `Batteries.Data.RBMap.Lemmas`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 610,
    "source": "batteries",
    "description": "The well-formedness invariant for a red-black tree. The first constructor is the real invariant, and the others allow us to \"cheat\" in this file and define `insert` and `erase`, which have more complex proofs that are delayed to `Batteries.Data.RBMap.Lemmas`."
  },
  "OnRoot": {
    "name": "OnRoot",
    "type": "def",
    "signature": "OnRoot : RBNode α → Prop",
    "docstring": "Asserts that property `p` holds on the root of the tree, if any.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 29,
    "source": "batteries",
    "description": "Asserts that property `p` holds on the root of the tree, if any."
  },
  "Zoomed": {
    "name": "Zoomed",
    "type": "def",
    "signature": "Zoomed : Path α → Prop",
    "docstring": "The property of a path returned by `t.zoom cut`. Each of the parents visited along the path have the appropriate ordering relation to the cut.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 136,
    "source": "batteries",
    "description": "The property of a path returned by `t.zoom cut`. Each of the parents visited along the path have the appropriate ordering relation to the cut."
  },
  "RootOrdered": {
    "name": "RootOrdered",
    "type": "def",
    "signature": "RootOrdered : Path α → α → Prop",
    "docstring": "`path.RootOrdered cmp v` is true if `v` would be able to fit into the hole without violating the ordering invariant.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 155,
    "source": "batteries",
    "description": "`path.RootOrdered cmp v` is true if `v` would be able to fit into the hole without violating the ordering invariant."
  },
  "modify": {
    "name": "modify",
    "type": "def",
    "signature": "modify : RBMap α β cmp",
    "docstring": "`O(log n)`. In-place replace the corresponding to key `k`. This takes the element out of the tree while `f` runs, so it uses the element linearly if `t` is unshared.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 347,
    "source": "batteries",
    "description": "`O(log n)`. In-place replace the corresponding to key `k`. This takes the element out of the tree while `f` runs, so it uses the element linearly if `t` is unshared."
  },
  "alter.adapt": {
    "name": "alter.adapt",
    "type": "def",
    "signature": "alter.adapt : Option (α × β) → Option (α × β)",
    "docstring": "Auxiliary definition for `alter`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 352,
    "source": "batteries",
    "description": "Auxiliary definition for `alter`."
  },
  "_root_.Batteries.RBNode.Balanced.zoom": {
    "name": "_root_.Batteries.RBNode.Balanced.zoom",
    "type": "theorem",
    "signature": "_root_.Batteries.RBNode.Balanced.zoom : t.Balanced c n → path.Balanced c₀ n₀ c n →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "Proves that a balanced red-black tree can be transformed into a balanced path while preserving its properties."
  },
  "DelProp": {
    "name": "DelProp",
    "type": "def",
    "signature": "DelProp : Prop",
    "docstring": "The invariant of the `del` function. * If the input tree is black, then the result of deletion is a red-red tree with black-height lowered by 1. * If the input tree is red or nil, then the result of deletion is a balanced tree with some color and the same black-height.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 444,
    "source": "batteries",
    "description": "The invariant of the `del` function. * If the input tree is black, then the result of deletion is a red-red tree with black-height lowered by 1. * If the input tree is red or nil, then the result of deletion is a balanced tree with some color and the same black-height."
  },
  "mapVal": {
    "name": "mapVal",
    "type": "def",
    "signature": "mapVal : RBMap α γ cmp",
    "docstring": "`O(n)`. Map a function on the values in the map.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 594,
    "source": "batteries",
    "description": "`O(n)`. Map a function on the values in the map."
  },
  "cmpLT.flip": {
    "name": "cmpLT.flip",
    "type": "theorem",
    "signature": "cmpLT.flip : cmpLT (flip cmp) y x",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Proves that flipping the comparison function `cmp` reverses the order of comparison for two elements `x` and `y`."
  },
  "cmpLT.trans": {
    "name": "cmpLT.trans",
    "type": "theorem",
    "signature": "cmpLT.trans : cmpLT cmp x z",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 36,
    "source": "batteries",
    "description": "Proves that if x is less than y and y is less than z, then x is less than z in a comparison context."
  },
  "cmpEq.lt_congr_left": {
    "name": "cmpEq.lt_congr_left",
    "type": "theorem",
    "signature": "cmpEq.lt_congr_left : cmpLT cmp x z ↔ cmpLT cmp y z",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "If two comparisons are equal, then the left side of the comparison can be changed without affecting the result."
  },
  "cmpEq.lt_congr_right": {
    "name": "cmpEq.lt_congr_right",
    "type": "theorem",
    "signature": "cmpEq.lt_congr_right : cmpLT cmp x y ↔ cmpLT cmp x z",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 48,
    "source": "batteries",
    "description": "If two comparisons are equal, then the result of comparing one element with two others is equivalent, preserving the order."
  },
  "Balanced.setBlack": {
    "name": "Balanced.setBlack",
    "type": "theorem",
    "signature": "Balanced.setBlack : t.Balanced c n → ∃ n', (setBlack t).Balanced black n'",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 116,
    "source": "batteries",
    "description": "Proves that setting a node to black in a balanced tree results in another balanced tree with a potentially different size."
  },
  "Ordered.insert": {
    "name": "Ordered.insert",
    "type": "theorem",
    "signature": "Ordered.insert : (insert cmp t v).Ordered cmp",
    "docstring": "The `insert` function preserves the ordering invariants.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 167,
    "source": "batteries",
    "description": "The `insert` function preserves the ordering invariants."
  },
  "RedRed.of_false": {
    "name": "RedRed.of_false",
    "type": "theorem",
    "signature": "RedRed.of_false : RedRed p t n → ∃ c, Balanced t c n",
    "docstring": "When `p` is false, the red-red case is impossible so the tree is balanced.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 185,
    "source": "batteries",
    "description": "When `p` is false, the red-red case is impossible so the tree is balanced."
  },
  "RedRed.of_red": {
    "name": "RedRed.of_red",
    "type": "theorem",
    "signature": "RedRed.of_red : RedRed p (node red a x b) n →",
    "docstring": "A `red` node with the red-red invariant has balanced children.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 190,
    "source": "batteries",
    "description": "A `red` node with the red-red invariant has balanced children."
  },
  "RedRed.imp": {
    "name": "RedRed.imp",
    "type": "theorem",
    "signature": "RedRed.imp : RedRed p t n → RedRed q t n",
    "docstring": "The red-red invariant is monotonic in `p`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 195,
    "source": "batteries",
    "description": "The red-red invariant is monotonic in `p`."
  },
  "RedRed.reverse": {
    "name": "RedRed.reverse",
    "type": "theorem",
    "signature": "RedRed.reverse : RedRed p t n → RedRed p t.reverse n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 198,
    "source": "batteries",
    "description": "Proves that reversing a RedRed tree maintains its RedRed properties."
  },
  "RedRed.setBlack": {
    "name": "RedRed.setBlack",
    "type": "theorem",
    "signature": "RedRed.setBlack : t.RedRed p n → ∃ n', (setBlack t).Balanced black n'",
    "docstring": "If `t` has the red-red invariant, then setting the root to black yields a balanced tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 204,
    "source": "batteries",
    "description": "If `t` has the red-red invariant, then setting the root to black yields a balanced tree."
  },
  "All.balLeft": {
    "name": "All.balLeft",
    "type": "theorem",
    "signature": "All.balLeft : (balLeft l v r).All p",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 298,
    "source": "batteries",
    "description": "Proves that if a tree is balanced to the left with a value and two subtrees, then all elements in the tree satisfy property p."
  },
  "All.balRight": {
    "name": "All.balRight",
    "type": "theorem",
    "signature": "All.balRight : (balRight l v r).All p",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 332,
    "source": "batteries",
    "description": "Proves that if a binary tree is balanced to the right, then all elements in the tree satisfy a given property p."
  },
  "All.append": {
    "name": "All.append",
    "type": "theorem",
    "signature": "All.append : (append l r).All p",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 352,
    "source": "batteries",
    "description": "Proves that if a property holds for all elements in two lists, it also holds for the concatenated list."
  },
  "IsMonotone": {
    "name": "IsMonotone",
    "type": "class",
    "signature": "IsMonotone",
    "docstring": "The property of a map function `f` which ensures the `map` operation is valid.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 536,
    "source": "batteries",
    "description": "The property of a map function `f` which ensures the `map` operation is valid."
  },
  "RedRed": {
    "name": "RedRed",
    "type": "inductive",
    "signature": "RedRed : RBNode α → Nat → Prop",
    "docstring": "The red-red invariant is a weakening of the red-black balance invariant which allows the root to be red with red children, but does not allow any other violations. It occurs as a temporary condition in the `insert` and `erase` functions. The `p` parameter allows the `.redred` case to be dependent on an additional condition. If it is false, then this is equivalent to the usual red-black invariant.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 178,
    "source": "batteries",
    "description": "The red-red invariant is a weakening of the red-black balance invariant which allows the root to be red with red children, but does not allow any other violations. It occurs as a temporary condition in the `insert` and `erase` functions. The `p` parameter allows the `.redred` case to be dependent on an additional condition. If it is false, then this is equivalent to the usual red-black invariant."
  },
  "nil": {
    "name": "nil",
    "type": "def",
    "signature": "nil : Nondet m α",
    "docstring": "The empty nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 64,
    "source": "batteries",
    "description": "The empty nondeterministic value."
  },
  "singletonM": {
    "name": "singletonM",
    "type": "def",
    "signature": "singletonM : Nondet m α",
    "docstring": "Convert any value in the monad to the singleton nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 89,
    "source": "batteries",
    "description": "Convert any value in the monad to the singleton nondeterministic value."
  },
  "ofListM": {
    "name": "ofListM",
    "type": "def",
    "signature": "ofListM : Nondet m α",
    "docstring": "Lift a list of monadic values to a nondeterministic value. We ensure that each monadic value is evaluated with the same backtrackable state.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Lift a list of monadic values to a nondeterministic value. We ensure that each monadic value is evaluated with the same backtrackable state."
  },
  "mapM": {
    "name": "mapM",
    "type": "def",
    "signature": "mapM : Nondet m β",
    "docstring": "Apply a function which returns values in the monad to every alternative of a `Nondet m α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 127,
    "source": "batteries",
    "description": "Apply a function which returns values in the monad to every alternative of a `Nondet m α`."
  },
  "ofOptionM": {
    "name": "ofOptionM",
    "type": "def",
    "signature": "ofOptionM : Nondet m α",
    "docstring": "Convert a monadic optional value to a nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 135,
    "source": "batteries",
    "description": "Convert a monadic optional value to a nondeterministic value."
  },
  "ofOption": {
    "name": "ofOption",
    "type": "def",
    "signature": "ofOption : Nondet m α",
    "docstring": "Convert an optional value to a nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 141,
    "source": "batteries",
    "description": "Convert an optional value to a nondeterministic value."
  },
  "filterMapM": {
    "name": "filterMapM",
    "type": "def",
    "signature": "filterMapM : Nondet m β",
    "docstring": "Filter and map a nondeterministic value using a monadic function which may return `none`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 144,
    "source": "batteries",
    "description": "Filter and map a nondeterministic value using a monadic function which may return `none`."
  },
  "filterMap": {
    "name": "filterMap",
    "type": "def",
    "signature": "filterMap : Nondet m β",
    "docstring": "Filter and map a nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 148,
    "source": "batteries",
    "description": "Filter and map a nondeterministic value."
  },
  "filterM": {
    "name": "filterM",
    "type": "def",
    "signature": "filterM : Nondet m α",
    "docstring": "Filter a nondeterministic value using a monadic predicate.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 152,
    "source": "batteries",
    "description": "Filter a nondeterministic value using a monadic predicate."
  },
  "head": {
    "name": "head",
    "type": "def",
    "signature": "head : m α",
    "docstring": "Find the first alternative in a nondeterministic value, as a monadic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 194,
    "source": "batteries",
    "description": "Find the first alternative in a nondeterministic value, as a monadic value."
  },
  "firstM": {
    "name": "firstM",
    "type": "def",
    "signature": "firstM : m β",
    "docstring": "Find the value of a monadic function on the first alternative in a nondeterministic value where the function succeeds.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 203,
    "source": "batteries",
    "description": "Find the value of a monadic function on the first alternative in a nondeterministic value where the function succeeds."
  },
  "Nondet": {
    "name": "Nondet",
    "type": "structure",
    "signature": "Nondet",
    "docstring": "`Nondet m α` is variation on `MLList m α` suitable for use with backtrackable monads `m`. We think of `Nondet m α` as a nondeterministic value in `α`, with the possible alternatives stored in a monadic lazy list. Along with each `a : α` we store the backtrackable state, and ensure that monadic operations on alternatives run with the appropriate state. Operations on the nondeterministic value via `bind`, `mapM`, and `filterMapM` run with the appropriate backtrackable state, and are responsible for updating the state themselves (typically this doesn't need to be done explicitly, but just happens as a side effect in the monad `m`).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 50,
    "source": "batteries",
    "description": "`Nondet m α` is variation on `MLList m α` suitable for use with backtrackable monads `m`. We think of `Nondet m α` as a nondeterministic value in `α`, with the possible alternatives stored in a monadic lazy list. Along with each `a : α` we store the backtrackable state, and ensure that monadic operations on alternatives run with the appropriate state. Operations on the nondeterministic value via `bind`, `mapM`, and `filterMapM` run with the appropriate backtrackable state, and are responsible for updating the state themselves (typically this doesn't need to be done explicitly, but just happens as a side effect in the monad `m`)."
  }
}