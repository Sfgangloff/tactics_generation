{"task_id": 1, "status": "ok", "input_item": {"text": "Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].", "code": "R = 3\r\nC = 3\r\ndef min_cost(cost, m, n): \r\n\ttc = [[0 for x in range(C)] for x in range(R)] \r\n\ttc[0][0] = cost[0][0] \r\n\tfor i in range(1, m+1): \r\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \r\n\tfor j in range(1, n+1): \r\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \r\n\tfor i in range(1, m+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \r\n\treturn tc[m][n]", "task_id": 1, "test_setup_code": "", "test_list": ["assert min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2) == 8", "assert min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2) == 12", "assert min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2) == 16"], "challenge_test_list": []}, "lean_result": {"task_id": 1, "lean_module_name": "Task1", "lean_code": "import Batteries\nopen Std\n\nnamespace Task1\n\n/--\nPreconditions:\n- `m < cost.size`, `n < cost[0]!.size`\n- All rows in `cost` have at least `n+1` elements.\n- Uses dynamic R, C inferred from `cost`.\n- Returns the minimal path cost from (0,0) to (m,n) moving right/down/diag.\n-/\ndef min_cost (cost : Array (Array Nat)) (m n : Nat) : Nat := Id.run do\n  let R := cost.size\n  let C := if R == 0 then 0 else (cost[0]!).size\n  -- build tc as R x C zero matrix\n  let mut tc : Array (Array Nat) := #[]\n  for _ in [:R] do\n    let mut row : Array Nat := #[]\n    for _ in [:C] do\n      row := row.push 0\n    tc := tc.push row\n  -- tc[0][0] = cost[0][0]\n  let mut row0 := tc[0]!\n  row0 := row0.set! 0 ((cost[0]!)[0]!)\n  tc := tc.set! 0 row0\n  -- first column\n  for i in [1:m+1] do\n    let prev := (tc[i-1]!)[0]!\n    let s := prev + (cost[i]!)[0]!\n    let mut rowi := tc[i]!\n    rowi := rowi.set! 0 s\n    tc := tc.set! i rowi\n  -- first row\n  for j in [1:n+1] do\n    let prev := (tc[0]!)[j-1]!\n    let s := prev + (cost[0]!)[j]!\n    let mut r0 := tc[0]!\n    r0 := r0.set! j s\n    tc := tc.set! 0 r0\n  -- rest of the table\n  for i in [1:m+1] do\n    for j in [1:n+1] do\n      let a := (tc[i-1]!)[j-1]!\n      let b := (tc[i-1]!)[j]!\n      let c := (tc[i]!)[j-1]!\n      let mn1 := if a ≤ b then a else b\n      let mn := if mn1 ≤ c then mn1 else c\n      let s := mn + (cost[i]!)[j]!\n      let mut rowi := tc[i]!\n      rowi := rowi.set! j s\n      tc := tc.set! i rowi\n  return (tc[m]!)[n]!\n\nend Task1\n", "lean_tests": "import Batteries\nopen Std\nopen Task1\n\n#guard min_cost (#[(#[(1:Nat), 2, 3]), (#[(4:Nat), 8, 2]), (#[(1:Nat), 5, 3])]) 2 2 == (8:Nat)\n#guard min_cost (#[(#[(2:Nat), 3, 4]), (#[(5:Nat), 9, 3]), (#[(2:Nat), 6, 4])]) 2 2 == (12:Nat)\n#guard min_cost (#[(#[(3:Nat), 4, 5]), (#[(6:Nat), 10, 4]), (#[(3:Nat), 7, 5])]) 2 2 == (16:Nat)\n", "notes": "Used Id.run with mutable variables and for-loops to mirror Python's DP table fill. Arrays are used for both the input matrix and the DP table; updates via Array.set! and reads via arr[i]!. Early return at the end returns the desired cell. Loops use [start:stop] ranges to model inclusive Python ranges."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task1.lean"}
{"task_id": 2, "status": "ok", "input_item": {"text": "Write a function to find the similar elements from the given two tuple lists.", "code": "def similar_elements(test_tup1, test_tup2):\r\n  res = tuple(set(test_tup1) & set(test_tup2))\r\n  return (res) ", "task_id": 2, "test_setup_code": "", "test_list": ["assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)", "assert similar_elements((1, 2, 3, 4),(5, 4, 3, 7)) == (3, 4)", "assert similar_elements((11, 12, 14, 13),(17, 15, 14, 13)) == (13, 14)"], "challenge_test_list": []}, "lean_result": {"task_id": 2, "lean_module_name": "Task2", "lean_code": "import Batteries\nopen Std\n\nnamespace Task2\n\n-- Build the intersection of two tuples (arrays) as a HashSet (set semantics)\n-- Python behavior used sets; order is unspecified, so we return a HashSet Nat.\ndef similar_elements (test_tup1 : Array Nat) (test_tup2 : Array Nat) : Std.HashSet Nat := Id.run do\n  let mut s1 : Std.HashSet Nat := {}\n  for x in test_tup1 do\n    s1 := s1.insert x\n  let mut res : Std.HashSet Nat := Std.HashSet.empty\n  for y in test_tup2 do\n    if s1.contains y then\n      res := res.insert y\n  return res\n\n-- Helper for tests: assert two HashSets are equal (unordered equality)\ndef assertHashSetEq (a b : Std.HashSet Nat) : Unit := Id.run do\n  if a.size != b.size then\n    panic! \"HashSet size mismatch\"\n  for x in a do\n    if ! b.contains x then\n      panic! \"Element missing in expected set\"\n  for x in b do\n    if ! a.contains x then\n      panic! \"Element missing in actual set\"\n  return ()\n\nend Task2\n", "lean_tests": "import Batteries\nopen Std\nopen Task2\n\n-- Tests adapted to set semantics (unordered): compare as HashSets\ndef tests : Unit := Id.run do\n  let r1 := similar_elements #[3, 4, 5, 6] #[5, 7, 4, 10]\n  assertHashSetEq r1 (Std.HashSet.ofList [4, 5])\n  let r2 := similar_elements #[1, 2, 3, 4] #[5, 4, 3, 7]\n  assertHashSetEq r2 (Std.HashSet.ofList [3, 4])\n  let r3 := similar_elements #[11, 12, 14, 13] #[17, 15, 14, 13]\n  assertHashSetEq r3 (Std.HashSet.ofList [13, 14])\n  return ()\n", "notes": "Set-like semantics were implemented using Std.HashSet as required. The function body uses Id.run do, mutable variables (let mut), and for loops with early returns. Tests compare HashSets for equality (order-independent) to match Python's set intersection behavior, avoiding any sorting."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task2.lean"}
{"task_id": 3, "status": "ok", "input_item": {"text": "Write a python function to identify non-prime numbers.", "code": "import math\r\ndef is_not_prime(n):\r\n    result = False\r\n    for i in range(2,int(math.sqrt(n)) + 1):\r\n        if n % i == 0:\r\n            result = True\r\n    return result", "task_id": 3, "test_setup_code": "", "test_list": ["assert is_not_prime(2) == False", "assert is_not_prime(10) == True", "assert is_not_prime(35) == True"], "challenge_test_list": []}, "lean_result": {"task_id": 3, "lean_module_name": "Task3", "lean_code": "import Batteries\nopen Std\n\nnamespace Task3\n\n/--\n  Identify non-prime numbers.\n  Mirrors Python's logic: checks divisors i from 2 upward, stopping when i*i > n.\n  For n = 0 or 1, returns false (as in the given Python function).\n-/\ndef is_not_prime (n : Nat) : Bool := Id.run do\n  let mut result := false\n  let mut i := 2\n  -- Use a bounded for-loop and break when i*i > n (emulating sqrt bound)\n  for _ in [:n] do\n    if i * i > n then\n      break\n    if n % i == 0 then\n      result := true\n    i := i + 1\n  return result\n\nend Task3\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task3\n\n#guard is_not_prime 2 == false\n#guard is_not_prime 10 == true\n#guard is_not_prime 35 == true\n", "notes": "Used Id.run do with mutable variables and a for loop. Emulated Python's sqrt bound by breaking when i*i > n. Used early break but no early return to mirror Python's behavior (which doesn't break upon finding a divisor). No lists or sets were needed."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task3.lean"}
{"task_id": 4, "status": "ok", "input_item": {"text": "Write a function to find the largest integers from a given list of numbers using heap queue algorithm.", "code": "import heapq as hq\r\ndef heap_queue_largest(nums,n):\r\n  largest_nums = hq.nlargest(n, nums)\r\n  return largest_nums", "task_id": 4, "test_setup_code": "", "test_list": ["assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]"], "challenge_test_list": []}, "lean_result": {"task_id": 4, "lean_module_name": "Task4", "lean_code": "import Batteries\nopen Std\n\ndef heapQueueLargest (nums : Array Nat) (n : Nat) : Array Nat := Id.run do\n  -- Adjust k to not exceed the size of nums\n  let mut k := n\n  if k > nums.size then\n    k := nums.size\n  let mut res : Array Nat := #[]\n  if k == 0 then\n    return res\n  let sz := nums.size\n  -- used marks which indices have already been selected as maxima\n  let mut used : Array Bool := Array.mkArray sz false\n  -- Repeat k times: each time pick the largest unused element\n  for _ in [:k] do\n    let mut found := false\n    let mut maxVal := 0\n    let mut maxIdx := 0\n    for i in [:sz] do\n      if used.get! i then\n        continue\n      if !found then\n        found := true\n        maxVal := nums.get! i\n        maxIdx := i\n      else\n        let v := nums.get! i\n        if v > maxVal then\n          maxVal := v\n          maxIdx := i\n    if !found then\n      break\n    res := res.push maxVal\n    used := used.set! maxIdx true\n  return res\n", "lean_tests": "#guard heapQueueLargest #[25, 35, 22, 85, 14, 65, 75, 22, 58] 3 == #[85, 75, 65]\n#guard heapQueueLargest #[25, 35, 22, 85, 14, 65, 75, 22, 58] 2 == #[85, 75]\n#guard heapQueueLargest #[25, 35, 22, 85, 14, 65, 75, 22, 58] 5 == #[85, 75, 65, 58, 35]\n", "notes": "Implemented n-largest selection imperatively without sorting or heap APIs. Uses Array for nums and a Boolean Array to mark used indices. For each of k iterations, it scans to find the current maximum among unused elements, pushes it to the result, and marks the index as used. The function body is wrapped in Id.run, uses let mut variables, for loops with continue and break, and returns early when appropriate."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task4.lean"}
{"task_id": 5, "status": "ok", "input_item": {"text": "Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.", "code": "def count_ways(n): \r\n\tA = [0] * (n + 1) \r\n\tB = [0] * (n + 1) \r\n\tA[0] = 1\r\n\tA[1] = 0\r\n\tB[0] = 0\r\n\tB[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \r\n\t\tB[i] = A[i - 1] + B[i - 2] \r\n\treturn A[n] ", "task_id": 5, "test_setup_code": "", "test_list": ["assert count_ways(2) == 3", "assert count_ways(8) == 153", "assert count_ways(12) == 2131"], "challenge_test_list": []}, "lean_result": {"task_id": 5, "lean_module_name": "Task5", "lean_code": "import Batteries\nopen Std\n\nnamespace Task5\n\n/--\n  Find the number of ways to tile a 3 × n board with 2 × 1 dominoes.\n  Preconditions: n is a natural number (0-based). Uses dynamic programming arrays A and B.\n-/\ndef count_ways (n : Nat) : Nat := Id.run do\n  let size := n + 1\n  let mut A : Array Nat := Array.mkArray size 0\n  let mut B : Array Nat := Array.mkArray size 0\n  -- Base cases\n  A := A.set! 0 1\n  if n >= 1 then\n    A := A.set! 1 0\n    B := B.set! 1 1\n  -- DP transitions\n  for i in [2 : n + 1] do\n    let ai2 := A.get! (i - 2)\n    let bi1 := B.get! (i - 1)\n    let ai1 := A.get! (i - 1)\n    let bi2 := B.get! (i - 2)\n    let newA := ai2 + 2 * bi1\n    let newB := ai1 + bi2\n    A := A.set! i newA\n    B := B.set! i newB\n  return A.get! n\n\nend Task5\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task5\n\n#guard count_ways 2 = 3\n#guard count_ways 8 = 153\n#guard count_ways 12 = 2131\n", "notes": "Implemented dynamic programming with two mutable Arrays (A and B) using Id.run and imperative constructs. Used Array.mkArray for initialization, set! and get! for indexed mutation and access, and a for-range loop [2 : n+1] to mirror Python's range(2, n+1). Returned early with return A.get! n. No recursion or sorting used."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task5.lean"}
{"task_id": 6, "status": "ok", "input_item": {"text": "Write a python function to check whether the two numbers differ at one bit position only or not.", "code": "def is_Power_Of_Two (x): \r\n    return x and (not(x & (x - 1))) \r\ndef differ_At_One_Bit_Pos(a,b): \r\n    return is_Power_Of_Two(a ^ b)", "task_id": 6, "test_setup_code": "", "test_list": ["assert differ_At_One_Bit_Pos(13,9) == True", "assert differ_At_One_Bit_Pos(15,8) == False", "assert differ_At_One_Bit_Pos(2,4) == False"], "challenge_test_list": []}, "lean_result": {"task_id": 6, "lean_module_name": "Task6", "lean_code": "import Batteries\nopen Std\n\ndef is_Power_Of_Two (x : Nat) : Bool := Id.run do\n  if x == 0 then\n    return false\n  let mut a := x\n  let mut b := x - 1\n  let mut c := a &&& b\n  if c == 0 then\n    return true\n  return false\n\ndef differ_At_One_Bit_Pos (a b : Nat) : Bool := Id.run do\n  let mut x := a ^^^ b\n  let mut res := is_Power_Of_Two x\n  return res\n", "lean_tests": "#eval (differ_At_One_Bit_Pos 13 9) = true\n#eval (differ_At_One_Bit_Pos 15 8) = false\n#eval (differ_At_One_Bit_Pos 2 4) = false\n", "notes": "Wrapped function bodies in Id.run do and used early returns. Used bitwise operators (&&& and ^^^) to mirror Python's & and ^. No loops or arrays were needed for this simple bitwise check, so imperative mutations are limited to local variables."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task6.lean"}
{"task_id": 7, "status": "ok", "input_item": {"text": "Write a function to find all words which are at least 4 characters long in a string by using regex.", "code": "import re\r\ndef find_char_long(text):\r\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))", "task_id": 7, "test_setup_code": "", "test_list": ["assert find_char_long('Please move back to stream') == ['Please', 'move', 'back', 'stream']", "assert find_char_long('Jing Eco and Tech') == ['Jing', 'Tech']", "assert find_char_long('Jhingai wulu road Zone 3') == ['Jhingai', 'wulu', 'road', 'Zone']"], "challenge_test_list": []}, "lean_result": {"task_id": 7, "lean_module_name": "Task7", "lean_code": "import Batteries\nopen Std\n\nnamespace Task7\n\n-- Find all words with length >= 4, where a word is [A-Za-z0-9_]+ (regex-like \\w)\n-- Mirrors regex: /\\b\\w{4,}\\b/\ndef findCharLong (text : String) : Array String := Id.run do\n  let mut res : Array String := #[]\n  let mut cur : String := \"\"\n  -- helper: ASCII word char predicate (A-Z, a-z, 0-9, _)\n  let isWordChar := fun (c : Char) =>\n    let n := c.toNat\n    (n >= 48 && n <= 57) || (n >= 65 && n <= 90) || (n >= 97 && n <= 122) || c == '_'\n  for c in text.data do\n    if isWordChar c then\n      cur := cur.push c\n    else\n      if cur.length >= 4 then\n        res := res.push cur\n      cur := \"\"\n  -- flush tail\n  if cur.length >= 4 then\n    res := res.push cur\n  return res\n\nend Task7\n", "lean_tests": "import Batteries\nopen Std\n\n-- Tests mirroring the Python asserts\n#eval (Task7.findCharLong \"Please move back to stream\") == #[\"Please\", \"move\", \"back\", \"stream\"]\n#eval (Task7.findCharLong \"Jing Eco and Tech\") == #[\"Jing\", \"Tech\"]\n#eval (Task7.findCharLong \"Jhingai wulu road Zone 3\") == #[\"Jhingai\", \"wulu\", \"road\", \"Zone\"]\n", "notes": "Implemented a regex-like scanner imperatively: used Id.run do, mutable variables (let mut), and a for loop over characters. Built results with Array.push and used String.push to accumulate current word. Word characters match [A-Za-z0-9_], approximating Python's \\w. Results returned as Array String and tests compare Arrays directly for Bool equality."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task7.lean"}
{"task_id": 8, "status": "ok", "input_item": {"text": "Write a function to find squares of individual elements in a list using lambda function.", "code": "def square_nums(nums):\r\n square_nums = list(map(lambda x: x ** 2, nums))\r\n return square_nums", "task_id": 8, "test_setup_code": "", "test_list": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "assert square_nums([10,20,30])==([100,400,900])", "assert square_nums([12,15])==([144,225])"], "challenge_test_list": []}, "lean_result": {"task_id": 8, "lean_module_name": "Task8", "lean_code": "import Batteries\nopen Std\n\ndef square_nums (nums : Array Nat) : Array Nat := Id.run do\n  -- Build result imperatively\n  let mut res : Array Nat := #[]\n  for x in nums do\n    res := res.push (x * x)\n  return res\n", "lean_tests": "#guard square_nums #[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = #[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n#guard square_nums #[10, 20, 30] = #[100, 400, 900]\n#guard square_nums #[12, 15] = #[144, 225]\n", "notes": "Uses Id.run with mutable Array and a for-loop pushing squared values. Returns the Array directly. Tests compare Arrays for exact equality."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task8.lean"}
{"task_id": 9, "status": "ok", "input_item": {"text": "Write a python function to find the minimum number of rotations required to get the same string.", "code": "def find_Rotations(str): \r\n    tmp = str + str\r\n    n = len(str) \r\n    for i in range(1,n + 1): \r\n        substring = tmp[i: i+n] \r\n        if (str == substring): \r\n            return i \r\n    return n ", "task_id": 9, "test_setup_code": "", "test_list": ["assert find_Rotations(\"aaaa\") == 1", "assert find_Rotations(\"ab\") == 2", "assert find_Rotations(\"abc\") == 3"], "challenge_test_list": []}, "lean_result": {"task_id": 9, "lean_module_name": "Task9", "lean_code": "import Batteries\nopen Std\n\nnamespace Task9\n\n-- Find the minimum number of rotations required to get the same string\n-- Uses String operations: length, drop, take, and concatenation.\n-- Mirrors Python loop: for i in range(1, n+1)\n-- If str == (str+str)[i:i+n] then return i, else return n\ndef find_Rotations (str : String) : Nat := Id.run do\n  let tmp := str ++ str\n  let n := str.length\n  for i in [:n] do\n    let j := i + 1\n    let substring := (tmp.drop j).take n\n    if str == substring then\n      return j\n  return n\n\nend Task9\n", "lean_tests": "#guard Task9.find_Rotations \"aaaa\" == 1\n#guard Task9.find_Rotations \"ab\" == 2\n#guard Task9.find_Rotations \"abc\" == 3\n", "notes": "Used Id.run with early return, a for-loop over [:n] to simulate range(1, n+1) via j = i+1, and String.drop/take for substring extraction. Kept imperative flow and avoided recursion or sorting."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task9.lean"}
{"task_id": 10, "status": "ok", "input_item": {"text": "Write a function to get the n smallest items from a dataset.", "code": "import heapq\r\ndef small_nnum(list1,n):\r\n  smallest=heapq.nsmallest(n,list1)\r\n  return smallest", "task_id": 10, "test_setup_code": "", "test_list": ["assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[10,20]", "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[10,20,20,40,50]", "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[10,20,20]"], "challenge_test_list": []}, "lean_result": {"task_id": 10, "lean_module_name": "Task10", "lean_code": "import Batteries\nopen Std\n\nnamespace Task10\n\n-- Get the n smallest items from the dataset, in ascending order.\n-- Preconditions: none; if n > list1.size, returns all elements sorted ascending.\ndef small_nnum (list1 : Array Nat) (n : Nat) : Array Nat := Id.run do\n  let mut remaining := list1\n  let mut result : Array Nat := #[]\n  for _ in [:n] do\n    if remaining.isEmpty then\n      break\n    -- remaining is non-empty here\n    let mut minVal := remaining[0]!\n    let mut minIdx := 0\n    for i in [:remaining.size] do\n      if remaining[i]! < minVal then\n        minVal := remaining[i]!\n        minIdx := i\n    result := result.push minVal\n    remaining := remaining.eraseIdx minIdx\n  return result\n\nend Task10\n", "lean_tests": "import Batteries\nopen Std\nopen Task10\n\n#guard small_nnum (#[10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100]) 2 == #[(10:Nat), 20]\n#guard small_nnum (#[10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100]) 5 == #[(10:Nat), 20, 20, 40, 50]\n#guard small_nnum (#[10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100]) 3 == #[(10:Nat), 20, 20]\n", "notes": "Implemented by repeatedly selecting the minimum element n times. Used Id.run, mutable variables (let mut), for loops with break when input is exhausted, Array operations (get!, push, eraseIdx). No sorting or heap APIs are used, mirroring Python's heapq.nsmallest behavior imperatively."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task10.lean"}
{"task_id": 11, "status": "ok", "input_item": {"text": "Write a python function to remove first and last occurrence of a given character from the string.", "code": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ", "task_id": 11, "test_setup_code": "", "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "challenge_test_list": ["assert remove_Occ(\"hellolloll\",\"l\") == \"helollol\"", "assert remove_Occ(\"\",\"l\") == \"\""]}, "lean_result": {"task_id": 11, "lean_module_name": "Task11", "lean_code": "import Batteries\nopen Std\n\nnamespace Task11\n\n/-- Remove first and last occurrence of a given character from the string.\n    Preconditions: none. Works with Unicode characters; indices count characters. -/\ndef removeOcc (s : String) (ch : Char) : String := Id.run do\n  let mut s := s\n  -- Remove first occurrence\n  let mut i := 0\n  for c in s.data do\n    if c == ch then\n      s := (s.take i) ++ (s.drop (i + 1))\n      break\n    i := i + 1\n  -- Remove last occurrence (scan forward and remember last index)\n  let mut lastIdx : Nat := 0\n  let mut found := false\n  let mut j := 0\n  for c in s.data do\n    if c == ch then\n      lastIdx := j\n      found := true\n    j := j + 1\n  if found then\n    s := (s.take lastIdx) ++ (s.drop (lastIdx + 1))\n  return s\n\nend Task11\n", "lean_tests": "open Std\nopen Task11\n\n#eval (let r := removeOcc \"hello\" 'l'; if r == \"heo\" then () else panic! \"assert 1 failed\")\n#eval (let r := removeOcc \"abcda\" 'a'; if r == \"bcd\" then () else panic! \"assert 2 failed\")\n#eval (let r := removeOcc \"PHP\" 'P'; if r == \"H\" then () else panic! \"assert 3 failed\")\n#eval (let r := removeOcc \"hellolloll\" 'l'; if r == \"helollol\" then () else panic! \"assert 4 failed\")\n#eval (let r := removeOcc \"\" 'l'; if r == \"\" then () else panic! \"assert 5 failed\")\n", "notes": "Used Id.run with mutable variables (let mut) and for loops. For strings, followed the constraint to iterate via s.data and used String.take/drop and concatenation for removals. First occurrence removed with a forward scan and break; last occurrence removed by scanning forward to record the last index, then slicing once. Early return style at the end."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task11.lean"}
{"task_id": 12, "status": "ok", "input_item": {"text": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "code": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result", "task_id": 12, "test_setup_code": "", "test_list": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "challenge_test_list": []}, "lean_result": {"task_id": 12, "lean_module_name": "Task12", "lean_code": "import Batteries\nopen Std\n\nnamespace Task12\n\n-- Sum of a row (array of Ints)\ndef rowSum (row : Array Int) : Int := Id.run do\n  let mut s : Int := 0\n  for x in row do\n    s := s + x\n  return s\n\n-- Sort matrix rows by ascending sum of their elements\n-- Preconditions: none (works for empty matrix and empty rows)\ndef sortMatrix (M : Array (Array Int)) : Array (Array Int) := Id.run do\n  let mut arr := M\n  -- Selection sort by row sum\n  for i in [:arr.size] do\n    let mut minIdx := i\n    let mut minSum := rowSum (arr.get! i)\n    for j in [i+1:arr.size] do\n      let s := rowSum (arr.get! j)\n      if s < minSum then\n        minSum := s\n        minIdx := j\n    if minIdx != i then\n      let tmp := arr.get! i\n      let vmin := arr.get! minIdx\n      arr := arr.set! i vmin\n      arr := arr.set! minIdx tmp\n  return arr\n\nend Task12\n", "lean_tests": "import Batteries\nopen Std\n\nnamespace Task12\n\n#eval\n  let m1 : Array (Array Int) := #[(#[(1 : Int), 2, 3]), (#[(2 : Int), 4, 5]), (#[(1 : Int), 1, 1])]\n  let e1 : Array (Array Int) := #[(#[(1 : Int), 1, 1]), (#[(1 : Int), 2, 3]), (#[(2 : Int), 4, 5])]\n  let m2 : Array (Array Int) := #[(#[(1 : Int), 2, 3]), (#[(-2 : Int), 4, -5]), (#[(1 : Int), -1, 1])]\n  let e2 : Array (Array Int) := #[(# [(-2 : Int), 4, -5]), (#[(1 : Int), -1, 1]), (#[(1 : Int), 2, 3])]\n  let m3 : Array (Array Int) := #[(#[(5 : Int), 8, 9]), (#[(6 : Int), 4, 3]), (#[(2 : Int), 1, 4])]\n  let e3 : Array (Array Int) := #[(#[(2 : Int), 1, 4]), (#[(6 : Int), 4, 3]), (#[(5 : Int), 8, 9])]\n  let ok1 := (sortMatrix m1) == e1\n  let ok2 := (sortMatrix m2) == e2\n  let ok3 := (sortMatrix m3) == e3\n  ok1 && ok2 && ok3\n\nend Task12\n", "notes": "Implemented selection sort imperatively over an Array (no sorting library calls). Functions are wrapped with Id.run, use let mut for mutation, and for loops for iteration. Row sums are computed via an imperative loop. Swapping uses Array.set! with temporary storage. Tests compare Arrays using == to mirror Python's asserts."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task12.lean"}
{"task_id": 13, "status": "error", "error": "TimeoutError('OpenAI call exceeded 120.0s')", "input_item": {"text": "Write a function to count the most common words in a dictionary.", "code": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n", "task_id": 13, "test_setup_code": "", "test_list": ["assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]", "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]", "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"], "challenge_test_list": []}}
{"task_id": 14, "status": "ok", "input_item": {"text": "Write a python function to find the volume of a triangular prism.", "code": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ", "task_id": 14, "test_setup_code": "", "test_list": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "challenge_test_list": []}, "lean_result": {"task_id": 14, "lean_module_name": "Task14", "lean_code": "import Batteries\nopen Std\n\nnamespace Task14\n\n-- Compute the volume of a triangular prism: (l * b * h) / 2\n-- Preconditions: l, b, h are nonnegative (Nat)\n def find_Volume (l b h : Nat) : Nat := Id.run do\n  let mut res := l\n  res := res * b\n  res := res * h\n  res := res / 2\n  return res\n\nend Task14\n", "lean_tests": "#guard Task14.find_Volume 10 8 6 == 240\n#guard Task14.find_Volume 3 2 2 == 6\n#guard Task14.find_Volume 1 2 1 == 1\n", "notes": "Used Id.run with mutable variable and early return to mirror Python's procedural style. Chose Nat for nonnegative dimensions and used Nat division by 2. No loops were required due to the simple arithmetic."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task14.lean"}
{"task_id": 15, "status": "ok", "input_item": {"text": "Write a function to split a string at lowercase letters.", "code": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))", "task_id": 15, "test_setup_code": "", "test_list": ["assert split_lowerstring(\"AbCd\")==['bC','d']", "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']", "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"], "challenge_test_list": []}, "lean_result": {"task_id": 15, "lean_module_name": "Task15", "lean_code": "import Batteries\nopen Std\n\nnamespace Task15\n\n-- Split a string at lowercase letters: find groups matching /[a-z][^a-z]*/\n-- ASCII lowercase check only, to mirror the Python regex [a-z].\ndef splitLowerstring (text : String) : Array String := Id.run do\n  let mut res : Array String := #[]\n  -- Convert String to Array Char for indexed access\n  let mut chars : Array Char := #[]\n  for c in text.data do\n    chars := chars.push c\n  let n := chars.size\n  let mut i : Nat := 0\n  -- Simulate a while loop using a for with manual index and breaks\n  for _ in [:n+1] do\n    if i >= n then break\n    let c := chars[i]!\n    let isLower := (Char.toNat c >= Char.toNat 'a') && (Char.toNat c <= Char.toNat 'z')\n    if !isLower then\n      i := i + 1\n      continue\n    -- Start of a token at a lowercase letter\n    let mut tokenChars : Array Char := #[]\n    tokenChars := tokenChars.push c\n    i := i + 1\n    -- Collect following non-lowercase chars\n    for _ in [:n+1] do\n      if i >= n then break\n      let c2 := chars[i]!\n      let isLower2 := (Char.toNat c2 >= Char.toNat 'a') && (Char.toNat c2 <= Char.toNat 'z')\n      if isLower2 then break\n      tokenChars := tokenChars.push c2\n      i := i + 1\n    -- Build String from tokenChars\n    let mut tokenStr : String := \"\"\n    for ch in tokenChars do\n      tokenStr := tokenStr.push ch\n    res := res.push tokenStr\n  return res\n\nend Task15\n", "lean_tests": "import Batteries\nopen Std\nopen Task15\n\n#guard (splitLowerstring \"AbCd\" == #[\"bC\", \"d\"])\n#guard (splitLowerstring \"Python\" == #[\"y\", \"t\", \"h\", \"o\", \"n\"])\n#guard (splitLowerstring \"Programming\" == #[\"r\", \"o\", \"g\", \"r\", \"a\", \"m\", \"m\", \"i\", \"n\", \"g\"])\n", "notes": "Implemented ASCII-lowercase regex behavior [a-z][^a-z]* imperatively: built an Array of characters from the input string, scanned with a mutable index, and used nested for loops with break/continue to simulate while loops. Used Array for efficient indexed access and String.push to assemble tokens. Returned Array String to mirror Python list semantics."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task15.lean"}
{"task_id": 16, "status": "error", "error": "TimeoutError('OpenAI call exceeded 120.0s')", "input_item": {"text": "Write a function to find sequences of lowercase letters joined with an underscore.", "code": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "task_id": 16, "test_setup_code": "", "test_list": ["assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')", "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')", "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"], "challenge_test_list": ["assert text_lowercase_underscore(\"aab-cbbbc\")==('Not matched!')"]}}
{"task_id": 17, "status": "ok", "input_item": {"text": "Write a function to find the perimeter of a square.", "code": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter", "task_id": 17, "test_setup_code": "", "test_list": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "challenge_test_list": []}, "lean_result": {"task_id": 17, "lean_module_name": "Task17", "lean_code": "import Batteries\nopen Std\n\nnamespace Task17\n\n/--\n  Compute the perimeter of a square with side length `a`.\n  Precondition: `a` is a nonnegative integer (Nat).\n-/\ndef square_perimeter (a : Nat) : Nat := Id.run do\n  let mut perimeter := 0\n  perimeter := 4 * a\n  return perimeter\n\nend Task17\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task17\n\n#guard square_perimeter 10 = 40\n#guard square_perimeter 5 = 20\n#guard square_perimeter 4 = 16\n", "notes": "Used Id.run do, a mutable variable (let mut), and an explicit return to mirror the imperative Python style. No loops were necessary for this simple arithmetic function."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task17.lean"}
{"task_id": 18, "status": "ok", "input_item": {"text": "Write a function to remove characters from the first string which are present in the second string.", "code": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ", "task_id": 18, "test_setup_code": "", "test_list": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "], "challenge_test_list": []}, "lean_result": {"task_id": 18, "lean_module_name": "Task18", "lean_code": "import Batteries\nopen Std\n\nnamespace Task18\n\n-- Remove characters from the first string which are present in the second string.\n-- Assumes ASCII for counting (0..255). Non-ASCII chars are treated as not present in the second string (kept).\ndef remove_dirty_chars (string : String) (second_string : String) : String := Id.run do\n  -- Build count array of size 256 for characters in second_string\n  let mut count : Array Nat := Array.mkArray 256 0\n  for c in second_string.data do\n    let idx := c.toNat\n    if idx < 256 then\n      let old := count.get! idx\n      count := count.set! idx (old + 1)\n  -- Convert first string to Array Char to allow indexed in-place style\n  let mut strArr : Array Char := #[]\n  for c in string.data do\n    strArr := strArr.push c\n  -- Two-index in-place filtering (like the Python code)\n  let mut resIndex : Nat := 0\n  for ipIndex in [:strArr.size] do\n    let c := strArr.get! ipIndex\n    let idx := c.toNat\n    let mut keep := true\n    if idx < 256 then\n      if count.get! idx == 0 then\n        keep := true\n      else\n        keep := false\n    if keep then\n      strArr := strArr.set! resIndex c\n      resIndex := resIndex + 1\n  -- Build the resulting string from the first resIndex characters\n  let mut resStr : String := \"\"\n  for i in [:resIndex] do\n    resStr := resStr.push (strArr.get! i)\n  return resStr\n\nend Task18\n", "lean_tests": "import Batteries\nopen Std\nopen Task18\n\n#eval\n  let r := remove_dirty_chars \"probasscurve\" \"pros\"\n  if r == \"bacuve\" then () else panic! s!\"expected 'bacuve', got {r}\"\n\n#eval\n  let r := remove_dirty_chars \"digitalindia\" \"talent\"\n  if r == \"digiidi\" then () else panic! s!\"expected 'digiidi', got {r}\"\n\n#eval\n  let r := remove_dirty_chars \"exoticmiles\" \"toxic\"\n  if r == \"emles\" then () else panic! s!\"expected 'emles', got {r}\"\n", "notes": "Implemented remove_dirty_chars in imperative style: used Id.run do, mutable variables with let mut, Array for the 256-char count and for the character buffer, and a for-loop to simulate the two-index in-place filtering from Python. Built the result string by pushing chars. Avoided any disallowed features and followed ASCII-bound checks for safe indexing."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task18.lean"}
{"task_id": 19, "status": "ok", "input_item": {"text": "Write a function to find whether a given array of integers contains any duplicate element.", "code": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ", "task_id": 19, "test_setup_code": "", "test_list": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "challenge_test_list": []}, "lean_result": {"task_id": 19, "lean_module_name": "Task19", "lean_code": "import Batteries\nopen Std\n\nnamespace Task19\n\ndef test_duplicate (arraynums : Array Nat) : Bool := Id.run do\n  let mut seen : Std.HashSet Nat := Std.HashSet.empty\n  for x in arraynums do\n    if seen.contains x then\n      return true\n    seen := seen.insert x\n  return false\n\nend Task19\n", "lean_tests": "#guard (Task19.test_duplicate #[1,2,3,4,5] == false)\n#guard (Task19.test_duplicate #[1,2,3,4,4] == true)\n#guard (Task19.test_duplicate #[1,1,2,2,3,3,4,4,5] == true)\n", "notes": "Used Std.HashSet to mirror Python's set semantics, built imperatively with a for loop. Early return when a duplicate is detected. Arrays are used for input. Chose Nat for integers since all provided test data are nonnegative."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task19.lean"}
{"task_id": 20, "status": "ok", "input_item": {"text": "Write a function to check if the given number is woodball or not.", "code": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False", "task_id": 20, "test_setup_code": "", "test_list": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "challenge_test_list": ["assert is_woodall(32212254719) == True", "assert is_woodall(32212254718) == False", "assert is_woodall(159) == True"]}, "lean_result": {"task_id": 20, "lean_module_name": "Task20", "lean_code": "import Batteries\nopen Std\n\ndef is_woodall (x : Nat) : Bool := Id.run do\n  if x % 2 == 0 then\n    return false\n  if x == 1 then\n    return true\n  let mut x := x + 1\n  let mut p := 0\n  -- The loop will run at most 'limit' times, but will break as soon as x becomes odd\n  let limit := x\n  for _ in [:limit] do\n    if x % 2 == 0 then\n      x := x / 2\n      p := p + 1\n      if p == x then\n        return true\n    else\n      break\n  return false\n", "lean_tests": "#guard is_woodall 383 = true\n#guard is_woodall 254 = false\n#guard is_woodall 200 = false\n#guard is_woodall 32212254719 = true\n#guard is_woodall 32212254718 = false\n#guard is_woodall 159 = true\n", "notes": "Used Id.run with mutable variables and a for-loop plus break to emulate Python's while-loop. Early returns mirror Python flow. Nat was used for nonnegative integers. No lists or sets were required."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task20.lean"}
{"task_id": 21, "status": "ok", "input_item": {"text": "Write a function to find m number of multiples of n.", "code": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)", "task_id": 21, "test_setup_code": "", "test_list": ["assert multiples_of_num(4,3)== [3,6,9,12]", "assert multiples_of_num(2,5)== [5,10]", "assert multiples_of_num(9,2)== [2,4,6,8,10,12,14,16,18]"], "challenge_test_list": []}, "lean_result": {"task_id": 21, "lean_module_name": "Task21", "lean_code": "import Batteries\nopen Std\n\nnamespace Task21\n\n-- Find the first m multiples of n: [n, 2n, ..., m*n]\n-- Assumes natural numbers (non-negative). Mirrors Python's range-based construction.\ndef multiples_of_num (m n : Nat) : Array Nat := Id.run do\n  let mut res : Array Nat := #[]\n  for i in [:m] do\n    let val := n * (i + 1)\n    res := res.push val\n  return res\n\nend Task21\n", "lean_tests": "import Batteries\nopen Std\nopen Task21\n\n#guard multiples_of_num 4 3 == #[3, 6, 9, 12]\n#guard multiples_of_num 2 5 == #[5, 10]\n#guard multiples_of_num 9 2 == #[2, 4, 6, 8, 10, 12, 14, 16, 18]\n", "notes": "Implemented imperatively with Id.run do, a mutable Array accumulator (let mut res), and a for loop over [:m] pushing n*(i+1). Used return at the end. Arrays are used to mirror Python lists efficiently, and tests compare Arrays directly with ==."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task21.lean"}
{"task_id": 22, "status": "ok", "input_item": {"text": "Write a function to find the first duplicate element in a given array of integers.", "code": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate", "task_id": 22, "test_setup_code": "", "test_list": ["assert find_first_duplicate(([1, 2, 3, 4, 4, 5]))==4", "assert find_first_duplicate([1, 2, 3, 4])==-1", "assert find_first_duplicate([1, 1, 2, 3, 3, 2, 2])==1"], "challenge_test_list": []}, "lean_result": {"task_id": 22, "lean_module_name": "Task22", "lean_code": "import Batteries\nopen Std\n\nnamespace Task22\n\n-- Find the first duplicate element in an array of integers.\n-- Returns -1 if no duplicate exists.\ndef find_first_duplicate (nums : Array Int) : Int := Id.run do\n  let mut numSet : Std.HashSet Int := {}\n  let mut noDuplicate : Int := -1\n  for i in [:nums.size] do\n    let v := nums[i]!\n    if numSet.contains v then\n      return v\n    else\n      numSet := numSet.insert v\n  return noDuplicate\n\nend Task22\n", "lean_tests": "import Batteries\nopen Std\n\nnamespace Task22\n\n#guard find_first_duplicate (#[1, 2, 3, 4, 4, 5] : Array Int) = (4 : Int)\n#guard find_first_duplicate (#[1, 2, 3, 4] : Array Int) = (-1 : Int)\n#guard find_first_duplicate (#[1, 1, 2, 3, 3, 2, 2] : Array Int) = (1 : Int)\n\nend Task22\n", "notes": "Used imperative style with Id.run, mutable variables via let mut, a for loop over indices, early return on detecting a duplicate, and Std.HashSet for set membership. Arrays are used for indexed access and updates are handled imperatively."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task22.lean"}
{"task_id": 23, "status": "ok", "input_item": {"text": "Write a python function to find the maximum sum of elements of list in a list of lists.", "code": "def maximum_Sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ", "task_id": 23, "test_setup_code": "", "test_list": ["assert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33", "assert maximum_Sum([[0,1,1],[1,1,2],[3,2,1]]) == 6", "assert maximum_Sum([[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]]) == 19"], "challenge_test_list": ["assert maximum_Sum([[0,-1,-1],[-1,-1,-2],[-3,-2,-1]]) == -2"]}, "lean_result": {"task_id": 23, "lean_module_name": "Task23", "lean_code": "import Batteries\nopen Std\n\ndef maximum_Sum (list1 : Array (Array Int)) : Int := Id.run do\n  let mut maxi : Int := (-100000)\n  for x in list1 do\n    let mut s : Int := 0\n    for y in x do\n      s := s + y\n    if s > maxi then\n      maxi := s\n  return maxi\n", "lean_tests": "#guard maximum_Sum (#[#[1,2,3], #[4,5,6], #[10,11,12], #[7,8,9]] : Array (Array Int)) == 33\n#guard maximum_Sum (#[#[0,1,1], #[1,1,2], #[3,2,1]] : Array (Array Int)) == 6\n#guard maximum_Sum (#[#[0,1,3], #[1,2,1], #[9,8,2], #[0,1,0], #[6,4,8]] : Array (Array Int)) == 19\n#guard maximum_Sum (#[#[0,-1,-1], #[-1,-1,-2], #[-3,-2,-1]] : Array (Array Int)) == (-2)\n", "notes": "Used Id.run with mutable variables and nested for-loops to mirror Python's imperative style. Arrays are used for lists. Updated the running maximum via an if-check (avoiding max). Early return at the end of the imperative block."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task23.lean"}
{"task_id": 24, "status": "ok", "input_item": {"text": "Write a function to convert the given binary number to its decimal equivalent.", "code": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)", "task_id": 24, "test_setup_code": "", "test_list": ["assert binary_to_decimal(100) == 4", "assert binary_to_decimal(1011) == 11", "assert binary_to_decimal(1101101) == 109"], "challenge_test_list": []}, "lean_result": {"task_id": 24, "lean_module_name": "Task24", "lean_code": "import Batteries\nopen Std\n\nnamespace Task24\n\n-- Convert a nonnegative integer whose decimal digits are a binary number into its decimal value.\n-- Preconditions: `binary` is a Nat whose digits are only 0 or 1.\ndef binary_to_decimal (binary : Nat) : Nat := Id.run do\n  let mut b := binary\n  let mut decimal := 0\n  let mut i := 0\n  -- Simulate a while loop using a bounded for with early break.\n  for _ in [:binary + 1] do\n    if b == 0 then break\n    let decDigit := b % 10\n    decimal := decimal + decDigit * Nat.pow 2 i\n    b := b / 10\n    i := i + 1\n  return decimal\n\nend Task24\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task24\n\n#guard binary_to_decimal 100 == 4\n#guard binary_to_decimal 1011 == 11\n#guard binary_to_decimal 1101101 == 109\n", "notes": "Used Id.run and mutable vars (let mut) to mirror Python state updates. Replaced the while loop with a for loop over a safe upper bound (binary + 1) and early break when the working copy reaches 0. Used Nat.pow for 2^i and returned early with return at the end. No recursion, no additional imports, and tests use Bool equality with #guard."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task24.lean"}
{"task_id": 25, "status": "ok", "input_item": {"text": "Write a python function to find the product of non-repeated elements in a given array.", "code": "def find_Product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ", "task_id": 25, "test_setup_code": "", "test_list": ["assert find_Product([1,1,2,3],4) == 6", "assert find_Product([1,2,3,1,1],5) == 6", "assert find_Product([1,1,4,5,6],5) == 120"], "challenge_test_list": ["assert find_Product([1,1,4,5,6,5,7,1,1,3,4],11) == 2520"]}, "lean_result": {"task_id": 25, "lean_module_name": "Task25", "lean_code": "import Batteries\nopen Std\n\nnamespace Task25\n\n/--\nPrecondition: `n ≤ arr.size`. Mirrors Python behavior of multiplying each distinct element once.\nWe avoid sorting (per constraints) and use a HashSet to track seen elements.\n-/\ndef find_Product (arr : Array Nat) (n : Nat) : Nat := Id.run do\n  let mut seen : Std.HashSet Nat := Std.HashSet.empty\n  let mut prod : Nat := 1\n  for i in [:n] do\n    let x := arr.get! i\n    if seen.contains x then\n      ()\n    else\n      seen := seen.insert x\n      prod := prod * x\n  return prod\n\nend Task25\n", "lean_tests": "import Batteries\nopen Std\nopen Task25\n\n#eval (\n  let r := find_Product #[1,1,2,3] 4\n  if r == 6 then () else panic! \"assert failed: find_Product([1,1,2,3],4) == 6\"\n)\n\n#eval (\n  let r := find_Product #[1,2,3,1,1] 5\n  if r == 6 then () else panic! \"assert failed: find_Product([1,2,3,1,1],5) == 6\"\n)\n\n#eval (\n  let r := find_Product #[1,1,4,5,6] 5\n  if r == 120 then () else panic! \"assert failed: find_Product([1,1,4,5,6],5) == 120\"\n)\n\n#eval (\n  let r := find_Product #[1,1,4,5,6,5,7,1,1,3,4] 11\n  if r == 2520 then () else panic! \"assert failed: challenge test == 2520\"\n)\n", "notes": "Implemented in imperative style with Id.run, mutable vars (let mut), and a for loop. Since sorting is forbidden, used Std.HashSet to multiply each distinct element once, matching the effective behavior of the given Python across provided tests. Used Array for input and direct indexed access with arr.get!. Included early return at end."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task25.lean"}
{"task_id": 26, "status": "ok", "input_item": {"text": "Write a function to check if the given tuple list has all k elements.", "code": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ", "task_id": 26, "test_setup_code": "", "test_list": ["assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True", "assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True", "assert check_k_elements([(9, 9), (9, 9, 9, 9)], 7) == False"], "challenge_test_list": ["assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 6, 4), (4, )], 4) == False"]}, "lean_result": {"task_id": 26, "lean_module_name": "Task26", "lean_code": "import Batteries\nopen Std\n\nnamespace Task26\n\n-- Checks whether every element in every inner array equals K.\n-- Preconditions: test_list contains arrays of Nats; indices are assumed valid when accessed.\ndef check_k_elements (test_list : Array (Array Nat)) (K : Nat) : Bool := Id.run do\n  let mut res := true\n  for tup in test_list do\n    for ele in tup do\n      if ele != K then\n        res := false\n  return res\n\nend Task26\n", "lean_tests": "import Batteries\nopen Std\nopen Task26\n\n#guard check_k_elements (# [# [4,4], # [4,4,4], # [4,4], # [4,4,4,4], # [4]]) 4 = true\n#guard check_k_elements (# [# [7,7,7], # [7,7]]) 7 = true\n#guard check_k_elements (# [# [9,9], # [9,9,9,9]]) 7 = false\n\n-- Challenge test\n#guard check_k_elements (# [# [4,4], # [4,4,4], # [4,4], # [4,4,6,4], # [4]]) 4 = false\n", "notes": "Implemented in imperative style: function body wrapped in Id.run do, mutable variable res via let mut, and nested for loops directly mirroring Python's iteration over tuples and elements. Used Array for the tuple list and inner tuples. No early returns to match Python's full traversal behavior."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task26.lean"}
{"task_id": 27, "status": "ok", "input_item": {"text": "Write a python function to remove all digits from a list of strings.", "code": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list", "task_id": 27, "test_setup_code": "", "test_list": ["assert remove(['4words', '3letters', '4digits']) == ['words', 'letters', 'digits']", "assert remove(['28Jan','12Jan','11Jan']) == ['Jan','Jan','Jan']", "assert remove(['wonder1','wonder2','wonder3']) == ['wonder','wonder','wonder']"], "challenge_test_list": []}, "lean_result": {"task_id": 27, "lean_module_name": "Task27", "lean_code": "import Batteries\nopen Std\n\nnamespace Task27\n\n-- Remove all digits from each string in the input array.\n-- Mirrors the Python implementation using imperative style.\ndef remove (xs : Array String) : Array String := Id.run do\n  let digit0 : Nat := ('0' : Char).toNat\n  let digit9 : Nat := ('9' : Char).toNat\n  let mut res : Array String := #[]\n  for s in xs do\n    let mut t := \"\"\n    for c in s.data do\n      let n := c.toNat\n      if !(digit0 ≤ n && n ≤ digit9) then\n        t := t.push c\n    res := res.push t\n  return res\n\nend Task27\n", "lean_tests": "import Batteries\nopen Std\nopen Task27\n\n#guard remove #[\"4words\", \"3letters\", \"4digits\"] == #[\"words\", \"letters\", \"digits\"]\n#guard remove #[\"28Jan\",\"12Jan\",\"11Jan\"] == #[\"Jan\",\"Jan\",\"Jan\"]\n#guard remove #[\"wonder1\",\"wonder2\",\"wonder3\"] == #[\"wonder\",\"wonder\",\"wonder\"]\n", "notes": "Implemented remove using Id.run with mutable variables and for loops. Iterated over String characters via s.data and filtered out digits by comparing Char.toNat against '0'..'9'. Built each output string imperatively with String.push and accumulated results in an Array using Array.push. Tests compare Arrays using BEq with #guard."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task27.lean"}
{"task_id": 28, "status": "ok", "input_item": {"text": "Write a python function to find binomial co-efficient.", "code": "def binomial_Coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k) ", "task_id": 28, "test_setup_code": "", "test_list": ["assert binomial_Coeff(5,2) == 10", "assert binomial_Coeff(4,3) == 4", "assert binomial_Coeff(3,2) == 3"], "challenge_test_list": ["assert binomial_Coeff(14,6) == 3003"]}, "lean_result": {"task_id": 28, "lean_module_name": "Task28", "lean_code": "import Batteries\nopen Std\n\nnamespace Task28\n\n-- Computes the binomial coefficient C(n, k) in imperative style (no recursion)\n-- Preconditions: n, k are natural numbers\n-- Uses the iterative identity: C(n, i) = C(n, i-1) * (n - i + 1) / i\ndef binomial_Coeff (n k : Nat) : Nat := Id.run do\n  if k > n then\n    return 0\n  if k == 0 || k == n then\n    return 1\n  let mut kk := k\n  if kk > n - kk then\n    kk := n - kk\n  let mut res : Nat := 1\n  let mut i : Nat := 0\n  -- Loop kk times; at step i, res becomes C(n, i)\n  for _ in [:kk] do\n    res := res * (n - i)\n    res := res / (i + 1)\n    i := i + 1\n  return res\n\nend Task28\n", "lean_tests": "import Batteries\nopen Std\nopen Task28\n\n#guard binomial_Coeff 5 2 == 10\n#guard binomial_Coeff 4 3 == 4\n#guard binomial_Coeff 3 2 == 3\n#guard binomial_Coeff 14 6 == 3003\n", "notes": "Rewrote the recursive Python function into an imperative, loop-based computation using the multiplicative formula for binomial coefficients. The function body is wrapped in Id.run do, uses let mut for mutable variables, early returns for base cases, and a for loop to accumulate the result."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task28.lean"}
{"task_id": 29, "status": "ok", "input_item": {"text": "Write a python function to find the element occurring odd number of times.", "code": "def get_Odd_Occurrence(arr,arr_size):   \r\n    for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1", "task_id": 29, "test_setup_code": "", "test_list": ["assert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1", "assert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3", "assert get_Odd_Occurrence([2,3,5,4,5,2,4,3,5,2,4,4,2],13) == 5"], "challenge_test_list": []}, "lean_result": {"task_id": 29, "lean_module_name": "Task29", "lean_code": "import Batteries\nopen Std\n\nnamespace Task29\n\n/--\n  Find the element occurring an odd number of times.\n  Precondition: `arr_size ≤ arr.size`.\n-/\ndef getOddOccurrence (arr : Array Int) (arr_size : Nat) : Int :=\n  Id.run do\n    for i in [:arr_size] do\n      let mut count : Nat := 0\n      for j in [:arr_size] do\n        if arr[i]! == arr[j]! then\n          count := count + 1\n      if count % 2 == 1 then\n        return arr[i]!\n    return (-1)\n\nend Task29\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task29\n\n#guard getOddOccurrence #[1,2,3,1,2,3,1] 7 == 1\n#guard getOddOccurrence #[1,2,3,2,3,1,3] 7 == 3\n#guard getOddOccurrence #[2,3,5,4,5,2,4,3,5,2,4,4,2] 13 == 5\n", "notes": "Used Id.run with mutable variables and for loops to mirror Python's imperative style. Inner and outer loops count occurrences and return early when an odd count is found. Arrays are used for indexed access, with arr[i]! for unchecked access under the stated precondition. The function returns Int to allow the -1 sentinel."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task29.lean"}
{"task_id": 30, "status": "ok", "input_item": {"text": "Write a python function to count all the substrings starting and ending with same characters.", "code": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ", "task_id": 30, "test_setup_code": "", "test_list": ["assert count_Substring_With_Equal_Ends(\"abc\") == 3", "assert count_Substring_With_Equal_Ends(\"abcda\") == 6", "assert count_Substring_With_Equal_Ends(\"ab\") == 2"], "challenge_test_list": []}, "lean_result": {"task_id": 30, "lean_module_name": "Task30", "lean_code": "import Batteries\nopen Std\n\nnamespace Task30\n\n-- Precondition: input string is non-empty when this function is called\n-- (in our usage below, we only call it on substrings of length ≥ 1)\ndef check_Equality (s : String) : Bool := Id.run do\n  let arr : Array Char := s.data.toArray\n  let first := arr[0]!\n  let last := arr[arr.size - 1]!\n  return first == last\n\ndef count_Substring_With_Equal_Ends (s : String) : Nat := Id.run do\n  let n := s.length\n  let mut result := 0\n  for i in [:n] do\n    let maxj := n - i\n    for k in [:maxj] do\n      let j := k + 1\n      let sub := (s.drop i).take j\n      if check_Equality sub then\n        result := result + 1\n  return result\n\nend Task30\n", "lean_tests": "import Batteries\nopen Std\nopen Task30\n\n#eval\n  if count_Substring_With_Equal_Ends \"abc\" == 3 then\n    0\n  else\n    panic! \"Test 1 failed\"\n\n#eval\n  if count_Substring_With_Equal_Ends \"abcda\" == 6 then\n    0\n  else\n    panic! \"Test 2 failed\"\n\n#eval\n  if count_Substring_With_Equal_Ends \"ab\" == 2 then\n    0\n  else\n    panic! \"Test 3 failed\"\n", "notes": "Used Id.run do, let mut, and for-loops to mirror Python's imperative style. Substrings are built using String.drop and String.take to avoid forbidden String APIs. check_Equality compares first and last characters via an Array Char for indexed access. Early returns and mutable counters reflect procedural flow."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task30.lean"}
{"task_id": 31, "status": "error", "error": "APIConnectionError('Connection error.')", "input_item": {"text": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.", "code": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result", "task_id": 31, "test_setup_code": "", "test_list": ["assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],3)==[5, 7, 1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],1)==[1]", "assert func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],5)==[6, 5, 7, 8, 1]"], "challenge_test_list": []}}
{"task_id": 32, "status": "ok", "input_item": {"text": "Write a python function to find the largest prime factor of a given number.", "code": "import math \r\ndef max_Prime_Factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)", "task_id": 32, "test_setup_code": "", "test_list": ["assert max_Prime_Factors(15) == 5", "assert max_Prime_Factors(6) == 3", "assert max_Prime_Factors(2) == 2"], "challenge_test_list": []}, "lean_result": {"task_id": 32, "lean_module_name": "Task32", "lean_code": "import Batteries\nopen Std\n\nnamespace Task32\n\n-- Find the largest prime factor of a given number (n ≥ 0)\n-- Preconditions follow Python's assumption that inputs are nonnegative.\n-- For n = 0 or n = 1, this returns 0 (no prime factors).\ndef max_Prime_Factors (n : Nat) : Nat := Id.run do\n  let mut n1 := n\n  let mut maxPrime : Nat := 0\n  -- remove factors of 2\n  if n1 % 2 == 0 then\n    for _ in [:n] do\n      if n1 % 2 == 0 then\n        maxPrime := 2\n        n1 := n1 / 2\n      else\n        break\n  -- check odd factors starting from 3\n  let mut i := 3\n  for _ in [:n] do\n    if i * i > n1 then\n      break\n    if n1 % i == 0 then\n      for _ in [:n] do\n        if n1 % i == 0 then\n          maxPrime := i\n          n1 := n1 / i\n        else\n          break\n    i := i + 2\n  -- if remaining n1 is a prime > 2, it's the largest prime factor\n  if n1 > 2 then\n    maxPrime := n1\n  return maxPrime\n\n-- Tests mirroring Python asserts\n#guard max_Prime_Factors 15 = 5\n#guard max_Prime_Factors 6 = 3\n#guard max_Prime_Factors 2 = 2\n\nend Task32\n", "lean_tests": "-- Tests are included in the module above via #guard directives.", "notes": "Implemented in imperative style using Id.run do, mutable variables (let mut), and for loops with break to emulate while-loops. We avoid sqrt by using the i*i > n1 termination condition. The function returns Nat, mirroring Python's int output for nonnegative inputs."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task32.lean"}
{"task_id": 33, "status": "ok", "input_item": {"text": "Write a python function to convert a decimal number to binary number.", "code": "def decimal_To_Binary(N): \r\n    B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number  ", "task_id": 33, "test_setup_code": "", "test_list": ["assert decimal_To_Binary(10) == 1010", "assert decimal_To_Binary(1) == 1", "assert decimal_To_Binary(20) == 10100"], "challenge_test_list": []}, "lean_result": {"task_id": 33, "lean_module_name": "Task33", "lean_code": "import Batteries\nopen Std\n\nnamespace Task33\n\n-- Convert a decimal number (Nat) to its binary representation written as a decimal number\n-- Example: 10 -> 1010\ndef decimal_To_Binary (N : Nat) : Nat := Id.run do\n  let mut B_Number := 0\n  let mut cnt := 0\n  let mut Nmut := N\n  -- Python while loop doesn't run when N == 0; return 0 directly\n  if Nmut == 0 then\n    return 0\n  -- Upper bound on iterations: at most N + 1 divisions by 2 to reach 0\n  let maxIters := Nmut + 1\n  for _ in [:maxIters] do\n    if Nmut == 0 then\n      break\n    let rem := Nmut % 2\n    let c := Nat.pow 10 cnt\n    B_Number := B_Number + rem * c\n    Nmut := Nmut / 2\n    cnt := cnt + 1\n  return B_Number\n\nend Task33\n", "lean_tests": "open Task33\n\n#guard decimal_To_Binary 10 == 1010\n#guard decimal_To_Binary 1 == 1\n#guard decimal_To_Binary 20 == 10100\n", "notes": "Used Id.run do, mutable variables with let mut, and a for loop with break to emulate the Python while loop. Early return handles the N == 0 case. No lists or sets were needed; arithmetic follows the Python logic with Nat.pow for 10^cnt."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task33.lean"}
{"task_id": 34, "status": "ok", "input_item": {"text": "Write a python function to find the missing number in a sorted array.", "code": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ", "task_id": 34, "test_setup_code": "", "test_list": ["assert find_missing([1,2,3,5],4) == 4", "assert find_missing([1,3,4,5],4) == 2", "assert find_missing([1,2,3,5,6,7],5) == 4"], "challenge_test_list": []}, "lean_result": {"task_id": 34, "lean_module_name": "Task34", "lean_code": "import Batteries\nopen Std\n\n/-\nPreconditions (mirroring Python intent):\n- `ar` is sorted ascending and has at least `N` elements.\n- It contains numbers starting from 1 with exactly one missing in the first `N+1` natural numbers.\n- We handle the potential mid = 0 case explicitly to avoid negative indexing.\n- Returns -1 if not found (e.g., invalid inputs), matching the Python fallback.\n-/\ndef find_missing (ar : Array Nat) (N : Nat) : Int := Id.run do\n  if N == 0 then\n    return -1\n  let mut l := 0\n  let mut r := N - 1\n  -- Simulate the while loop with a bounded for-loop and manual break\n  for _ in [:N+1] do\n    if l > r then\n      break\n    let mid := (l + r) / 2\n    let midVal := ar.get! mid -- assumes ar has at least N elements\n    if midVal != mid + 1 then\n      -- To avoid negative indexing, handle mid == 0 explicitly\n      if mid == 0 then\n        return Int.ofNat 1\n      let before := ar.get! (mid - 1)\n      if before == mid then\n        return Int.ofNat (mid + 1)\n      -- move left\n      r := mid - 1\n    else\n      -- move right\n      l := mid + 1\n  return -1\n", "lean_tests": "#guard find_missing #[1,2,3,5] 4 == (4 : Int)\n#guard find_missing #[1,3,4,5] 4 == (2 : Int)\n#guard find_missing #[1,2,3,5,6,7] 5 == (4 : Int)\n", "notes": "Used Id.run do with mutable variables and a for-loop to simulate the Python while loop. Employed Array for indexed access via get!. Early returns handle found cases and invalid inputs. Added a safe mid==0 check to avoid negative indexing, which mirrors Python's intent without out-of-bounds behavior."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task34.lean"}
{"task_id": 35, "status": "ok", "input_item": {"text": "Write a function to find the n-th rectangular number.", "code": "def find_rect_num(n):\r\n  return n*(n + 1) ", "task_id": 35, "test_setup_code": "", "test_list": ["assert find_rect_num(4) == 20", "assert find_rect_num(5) == 30", "assert find_rect_num(6) == 42"], "challenge_test_list": []}, "lean_result": {"task_id": 35, "lean_module_name": "Task35", "lean_code": "import Batteries\nopen Std\n\nnamespace Task35\n\n-- Find the n-th rectangular number: n * (n + 1)\ndef find_rect_num (n : Nat) : Nat := Id.run do\n  let mut res := n * (n + 1)\n  return res\n\nend Task35\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task35\n\n#guard (find_rect_num 4 = 20)\n#guard (find_rect_num 5 = 30)\n#guard (find_rect_num 6 = 42)\n", "notes": "Used Id.run do with a mutable variable and an explicit return to match imperative style. No loops or arrays were necessary given the direct arithmetic computation."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task35.lean"}
{"task_id": 36, "status": "ok", "input_item": {"text": "Write a python function to find the nth digit in the proper fraction of two given numbers.", "code": "def find_Nth_Digit(p,q,N) :  \r\n    while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;  ", "task_id": 36, "test_setup_code": "", "test_list": ["assert find_Nth_Digit(1,2,1) == 5", "assert find_Nth_Digit(3,5,1) == 6", "assert find_Nth_Digit(5,6,5) == 3"], "challenge_test_list": []}, "lean_result": {"task_id": 36, "lean_module_name": "Task36", "lean_code": "import Batteries\nopen Std\n\nnamespace Task36\n\n-- Precondition: q > 0, N > 0 (to mirror Python's while loop semantics)\ndef find_Nth_Digit (p q N : Nat) : Nat := Id.run do\n  let mut p := p\n  let mut res := 0\n  for _ in [:N] do\n    p := p * 10\n    let r := p / q\n    res := r\n    p := p % q\n  return res\n\nend Task36\n", "lean_tests": "import Batteries\nopen Std\n\nnamespace Task36\n\n#guard find_Nth_Digit 1 2 1 == 5\n#guard find_Nth_Digit 3 5 1 == 6\n#guard find_Nth_Digit 5 6 5 == 3\n\nend Task36\n", "notes": "Implemented an imperative loop with Id.run and mutable variables. Replaced Python's while N>0 with a for-loop over [:N], matching iteration count. Used Nat division and modulus for floor and remainder. Early return at end mirrors Python's return. Tests use #guard with boolean equality."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task36.lean"}
{"task_id": 37, "status": "ok", "input_item": {"text": "Write a function to sort a given mixed list of integers and strings.", "code": "def sort_mixed_list(mixed_list):\r\n    int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part", "task_id": 37, "test_setup_code": "", "test_list": ["assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "assert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']"], "challenge_test_list": []}, "lean_result": {"task_id": 37, "lean_module_name": "Task37", "lean_code": "import Batteries\nopen Std\n\n/-\nWe represent the mixed Python list (ints and strings) as Array (Sum Nat String),\nwhere Sum.inl n is an integer and Sum.inr s is a string.\n-/\n\ndef selectionSortNat (arr : Array Nat) : Array Nat := Id.run do\n  let mut a := arr\n  let n := a.size\n  for i in [:n] do\n    let mut minIdx := i\n    let mut minVal := a.get! i\n    for j in [i+1:n] do\n      let v := a.get! j\n      if v < minVal then\n        minVal := v\n        minIdx := j\n    let vi := a.get! i\n    a := a.set! i minVal\n    a := a.set! minIdx vi\n  return a\n\ndef selectionSortString (arr : Array String) : Array String := Id.run do\n  let mut a := arr\n  let n := a.size\n  for i in [:n] do\n    let mut minIdx := i\n    let mut minVal := a.get! i\n    for j in [i+1:n] do\n      let v := a.get! j\n      if v < minVal then\n        minVal := v\n        minIdx := j\n    let vi := a.get! i\n    a := a.set! i minVal\n    a := a.set! minIdx vi\n  return a\n\ndef sort_mixed_list (mixed_list : Array (Sum Nat String)) : Array (Sum Nat String) := Id.run do\n  -- Separate ints and strings\n  let mut ints : Array Nat := #[]\n  let mut strs : Array String := #[]\n  for x in mixed_list do\n    match x with\n    | Sum.inl n => ints := ints.push n\n    | Sum.inr s => strs := strs.push s\n  -- Sort both parts using imperative selection sort\n  let intsSorted := selectionSortNat ints\n  let strsSorted := selectionSortString strs\n  -- Concatenate: ints first, then strings\n  let mut res : Array (Sum Nat String) := #[]\n  for n in intsSorted do\n    res := res.push (Sum.inl n)\n  for s in strsSorted do\n    res := res.push (Sum.inr s)\n  return res\n", "lean_tests": "open Std\n\n-- Test 1\n#guard\n  let input : Array (Sum Nat String) := #[\n    .inl 19, .inr \"red\", .inl 12, .inr \"green\", .inr \"blue\", .inl 10, .inr \"white\", .inr \"green\", .inl 1\n  ]\n  let expected : Array (Sum Nat String) := #[\n    .inl 1, .inl 10, .inl 12, .inl 19, .inr \"blue\", .inr \"green\", .inr \"green\", .inr \"red\", .inr \"white\"\n  ]\n  sort_mixed_list input = expected\n\n-- Test 2 (same as Python repeated assert)\n#guard\n  let input : Array (Sum Nat String) := #[\n    .inl 19, .inr \"red\", .inl 12, .inr \"green\", .inr \"blue\", .inl 10, .inr \"white\", .inr \"green\", .inl 1\n  ]\n  let expected : Array (Sum Nat String) := #[\n    .inl 1, .inl 10, .inl 12, .inl 19, .inr \"blue\", .inr \"green\", .inr \"green\", .inr \"red\", .inr \"white\"\n  ]\n  sort_mixed_list input = expected\n\n-- Test 3 (same again)\n#guard\n  let input : Array (Sum Nat String) := #[\n    .inl 19, .inr \"red\", .inl 12, .inr \"green\", .inr \"blue\", .inl 10, .inr \"white\", .inr \"green\", .inl 1\n  ]\n  let expected : Array (Sum Nat String) := #[\n    .inl 1, .inl 10, .inl 12, .inl 19, .inr \"blue\", .inr \"green\", .inr \"green\", .inr \"red\", .inr \"white\"\n  ]\n  sort_mixed_list input = expected\n", "notes": "Used imperative selection sort implemented with nested for loops, mutable variables (let mut), and Array.set!/get! swaps. The main function separates ints and strings, sorts each part imperatively, and concatenates results, all within Id.run do. No sorting library calls are used."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task37.lean"}
{"task_id": 38, "status": "ok", "input_item": {"text": "Write a function to find the division of first even and odd number of a given list.", "code": "def div_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)", "task_id": 38, "test_setup_code": "", "test_list": ["assert div_even_odd([1,3,5,7,4,1,6,8])==4", "assert div_even_odd([1,2,3,4,5,6,7,8,9,10])==2", "assert div_even_odd([1,5,7,9,10])==10"], "challenge_test_list": []}, "lean_result": {"task_id": 38, "lean_module_name": "Task38", "lean_code": "import Batteries\nopen Std\n\nnamespace Task38\n\n-- Find the division of the first even and first odd number in the given array.\n-- If either is not found, defaults remain -1 as in the Python version.\n-- Preconditions: the array is assumed to contain at least one odd number to avoid division by -1 in tests.\ndef div_even_odd (list1 : Array Int) : Int := Id.run do\n  let mut firstEven : Int := -1\n  let mut firstOdd : Int := -1\n  for el in list1 do\n    if firstEven == -1 && el % 2 == 0 then\n      firstEven := el\n    if firstOdd == -1 && el % 2 != 0 then\n      firstOdd := el\n    if firstEven != -1 && firstOdd != -1 then\n      return firstEven / firstOdd\n  return firstEven / firstOdd\n\nend Task38\n", "lean_tests": "import Batteries\nopen Std\nopen Task38\n\n#guard div_even_odd #[1,3,5,7,4,1,6,8] == 4\n#guard div_even_odd #[1,2,3,4,5,6,7,8,9,10] == 2\n#guard div_even_odd #[1,5,7,9,10] == 10\n", "notes": "Used Id.run with mutable variables and a for-loop over the input Array. Early return mimics Python's generator short-circuiting once both the first even and first odd are found. Used Int to mirror Python's use of -1 as a sentinel. Tests use #guard with boolean equality checks."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task38.lean"}
{"task_id": 39, "status": "ok", "input_item": {"text": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.", "code": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "task_id": 39, "test_setup_code": "", "test_list": ["assert rearange_string(\"aab\")==('aba')", "assert rearange_string(\"aabb\")==('abab')", "assert rearange_string(\"abccdd\")==('cdabcd')"], "challenge_test_list": []}, "lean_result": {"task_id": 39, "lean_module_name": "Task39", "lean_code": "import Batteries\nopen Std\n\nnamespace Task39\n\n-- Preconditions: We treat String as sequence of Chars; indices assumed valid when used.\n-- Returns a rearranged string where no adjacent chars are equal, or \"\" if impossible.\ndef rearange_string (S : String) : String := Id.run do\n  -- Build frequency counts as an Array of (Char × Nat)\n  let mut counts : Array (Char × Nat) := #[]\n  for c in S.data do\n    let mut found := false\n    let mut idx := 0\n    for j in [:counts.size] do\n      if (counts[j]!).fst == c then\n        found := true\n        idx := j\n        break\n    if found then\n      let (ch, n) := counts[idx]!\n      counts := counts.set! idx (ch, n + 1)\n    else\n      counts := counts.push (c, 1)\n\n  -- Compute maximum count\n  let mut maxCount : Nat := 0\n  for p in counts do\n    if p.snd > maxCount then\n      maxCount := p.snd\n\n  let n := S.length\n  -- Feasibility check\n  if maxCount * 2 > n + 1 then\n    return \"\"\n\n  -- Greedy construction by repeatedly taking the two highest counts (lexicographically tie-broken)\n  let mut ans : Array Char := #[]\n  for _ in [:n] do\n    -- pick top1\n    let mut have1 := false\n    let mut top1Idx : Nat := 0\n    let mut top1Cnt : Nat := 0\n    let mut top1Ch  : Char := '\\u0000'\n    for j in [:counts.size] do\n      let (ch, cnt) := counts[j]!\n      if cnt > 0 then\n        if !have1 then\n          have1 := true\n          top1Idx := j; top1Cnt := cnt; top1Ch := ch\n        else\n          if cnt > top1Cnt then\n            top1Idx := j; top1Cnt := cnt; top1Ch := ch\n          else\n            if cnt == top1Cnt then\n              if ch < top1Ch then\n                top1Idx := j; top1Ch := ch\n    if !have1 then\n      break\n\n    -- pick top2 (excluding top1), with same tie-breaking\n    let mut have2 := false\n    let mut top2Idx : Nat := 0\n    let mut top2Cnt : Nat := 0\n    let mut top2Ch  : Char := '\\u0000'\n    for j in [:counts.size] do\n      if j == top1Idx then\n        continue\n      let (ch, cnt) := counts[j]!\n      if cnt > 0 then\n        if !have2 then\n          have2 := true\n          top2Idx := j; top2Cnt := cnt; top2Ch := ch\n        else\n          if cnt > top2Cnt then\n            top2Idx := j; top2Cnt := cnt; top2Ch := ch\n          else\n            if cnt == top2Cnt then\n              if ch < top2Ch then\n                top2Idx := j; top2Ch := ch\n    if !have2 then\n      break\n\n    -- append both\n    ans := ans.push top1Ch\n    ans := ans.push top2Ch\n\n    -- decrement their counts\n    let (ch1, c1) := counts[top1Idx]!\n    counts := counts.set! top1Idx (ch1, c1 - 1)\n    let (ch2, c2) := counts[top2Idx]!\n    counts := counts.set! top2Idx (ch2, c2 - 1)\n\n  -- Append any leftover single character if present\n  let mut leftover : Option Char := none\n  for j in [:counts.size] do\n    let (ch, cnt) := counts[j]!\n    if cnt > 0 then\n      leftover := some ch\n      break\n  match leftover with\n  | some ch =>\n    ans := ans.push ch\n  | none => ()\n\n  return String.mk ans.toList\n\nend Task39\n", "lean_tests": "import Batteries\nopen Std\n\nopen Task39\n\n#guard rearange_string \"aab\" = \"aba\"\n#guard rearange_string \"aabb\" = \"abab\"\n#guard rearange_string \"abccdd\" = \"cdabcd\"\n", "notes": "Implemented a greedy rearrangement using imperative loops and Array-based frequency counts. Avoided any heap or sorting APIs per constraints by scanning to select the top two characters each iteration, with lexicographic tie-breaking to match Python heap behavior. Used Id.run do, let mut, for loops with break and continue, and built the result as an Array of Char before converting to String."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task39.lean"}
{"task_id": 40, "status": "ok", "input_item": {"text": "Write a function to find frequency of the elements in a given list of lists using collections module.", "code": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):\r\n  result = Counter(chain.from_iterable(nums))\r\n  return result", "task_id": 40, "test_setup_code": "", "test_list": ["assert freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])==({2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1})", "assert freq_element([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==({1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1})", "assert freq_element([[15,20,30,40],[80,90,100,110],[30,30,80,90]])==({30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1})"], "challenge_test_list": []}, "lean_result": {"task_id": 40, "lean_module_name": "Task40", "lean_code": "import Batteries\nopen Std\n\nnamespace Task40\n\n/--\n  freqElement flattens a nested array of Nats and counts element frequencies.\n  Preconditions: indices assumed valid when accessing arrays.\n-/\ndef freqElement (nums : Array (Array Nat)) : Std.HashMap Nat Nat := Id.run do\n  let mut hm : Std.HashMap Nat Nat := Std.HashMap.empty\n  for sub in nums do\n    for x in sub do\n      let prev := match hm.find? x with\n        | some v => v\n        | none => 0\n      hm := hm.insert x (prev + 1)\n  return hm\n\nend Task40\n", "lean_tests": "import Batteries\nopen Std\n\n/-- helper to build a HashMap from key/value pairs -/\ndef buildMap (pairs : Array (Nat × Nat)) : Std.HashMap Nat Nat := Id.run do\n  let mut m : Std.HashMap Nat Nat := Std.HashMap.empty\n  for p in pairs do\n    m := m.insert p.fst p.snd\n  return m\n\n-- Test 1\n#eval\n  let got := Task40.freqElement #[(#[(1),(2),(3),(2)]), (#[(4),(5),(6),(2)]), (#[(7),(1),(9),(5)])]\n  let expected := buildMap #[(2,3),(1,2),(5,2),(3,1),(4,1),(6,1),(7,1),(9,1)]\n  if got == expected then () else panic! \"Test 1 failed\"\n\n-- Test 2\n#eval\n  let got := Task40.freqElement #[(#[(1),(2),(3),(4)]), (#[(5),(6),(7),(8)]), (#[(9),(10),(11),(12)])]\n  let expected := buildMap #[(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1)]\n  if got == expected then () else panic! \"Test 2 failed\"\n\n-- Test 3\n#eval\n  let got := Task40.freqElement #[(#[(15),(20),(30),(40)]), (#[(80),(90),(100),(110)]), (#[(30),(30),(80),(90)])]\n  let expected := buildMap #[(30,3),(80,2),(90,2),(15,1),(20,1),(40,1),(100,1),(110,1)]\n  if got == expected then () else panic! \"Test 3 failed\"\n", "notes": "Implemented freqElement imperatively: wrapped in Id.run do, used a mutable Std.HashMap for frequency counts, nested for loops over the outer and inner Arrays, and explicit updates via find?/insert. Tests compare HashMaps directly using == without any sorting. Arrays are used for all list-like data, and early return pattern is followed at the end."}, "lean_file": "TacticsGeneration/Tasks/Imperative/Task40.lean"}
