{"task_id": 1, "status": "ok", "input_item": {"text": "Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].", "code": "R = 3\r\nC = 3\r\ndef min_cost(cost, m, n): \r\n\ttc = [[0 for x in range(C)] for x in range(R)] \r\n\ttc[0][0] = cost[0][0] \r\n\tfor i in range(1, m+1): \r\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \r\n\tfor j in range(1, n+1): \r\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \r\n\tfor i in range(1, m+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \r\n\treturn tc[m][n]", "task_id": 1, "test_setup_code": "", "test_list": ["assert min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2) == 8", "assert min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2) == 12", "assert min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2) == 16"], "challenge_test_list": []}, "lean_result": {"task_id": 1, "lean_module_name": "Task1", "lean_code": "import Batteries\nopen Std\n\ndef set2dNat (a : Array (Array Nat)) (y x : Nat) (value : Nat) : Array (Array Nat) :=\n  a.modify y (fun row => row.set! x value)\n\ndef get2dNat (a : Array (Array Nat)) (y x : Nat) (fallback : Nat) : Nat :=\n  let row := a.getD y #[]\n  row.getD x fallback\n\n/--\nPreconditions:\n- m and n are within the bounds of the given cost matrix (0 ≤ m < rows, 0 ≤ n < cols).\n- Moves allowed: right, down, and diagonal down-right.\n-/\ndef minCost (cost : List (List Nat)) (m n : Nat) : Nat := Id.run do\n  let costA : Array (Array Nat) := (cost.map (fun r => r.toArray)).toArray\n  let mut dp : Array (Array Nat) := Array.replicate (m+1) (Array.replicate (n+1) 0)\n  -- base cell\n  dp := set2dNat dp 0 0 (get2dNat costA 0 0 0)\n  -- first column\n  for i in [1 : m+1] do\n    let prev := get2dNat dp (i-1) 0 0\n    let c := get2dNat costA i 0 0\n    dp := set2dNat dp i 0 (prev + c)\n  -- first row\n  for j in [1 : n+1] do\n    let prev := get2dNat dp 0 (j-1) 0\n    let c := get2dNat costA 0 j 0\n    dp := set2dNat dp 0 j (prev + c)\n  -- rest of the table\n  for i in [1 : m+1] do\n    for j in [1 : n+1] do\n      let diag := get2dNat dp (i-1) (j-1) 0\n      let up := get2dNat dp (i-1) j 0\n      let left := get2dNat dp i (j-1) 0\n      let best := Nat.min diag (Nat.min up left)\n      let c := get2dNat costA i j 0\n      dp := set2dNat dp i j (best + c)\n  return get2dNat dp m n 0\n", "lean_tests": "#guard minCost [[1, 2, 3], [4, 8, 2], [1, 5, 3]] 2 2 = 8\n#guard minCost [[2, 3, 4], [5, 9, 3], [2, 6, 4]] 2 2 = 12\n#guard minCost [[3, 4, 5], [6, 10, 4], [3, 7, 5]] 2 2 = 16\n", "notes": ["Dynamic programming with arrays; allowed moves are right, down, and diagonal.", "Cost matrix converted to Array of Arrays once for O(1) access.", "Assumes indices (m, n) are within the bounds of the given matrix.", "No forbidden imports or tokens used; no sorting or heap APIs."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task1.lean"}
{"task_id": 2, "status": "ok", "input_item": {"text": "Write a function to find the similar elements from the given two tuple lists.", "code": "def similar_elements(test_tup1, test_tup2):\r\n  res = tuple(set(test_tup1) & set(test_tup2))\r\n  return (res) ", "task_id": 2, "test_setup_code": "", "test_list": ["assert similar_elements((3, 4, 5, 6),(5, 7, 4, 10)) == (4, 5)", "assert similar_elements((1, 2, 3, 4),(5, 4, 3, 7)) == (3, 4)", "assert similar_elements((11, 12, 14, 13),(17, 15, 14, 13)) == (13, 14)"], "challenge_test_list": []}, "lean_result": {"task_id": 2, "lean_module_name": "Task2", "lean_code": "import Batteries\nopen Std\n\nnamespace Task2\n\n/-- Find similar elements (set intersection) between two lists of integers.\n    Returns a HashSet containing elements common to both lists. -/\ndef similarElements (l1 l2 : List Int) : HashSet Int :=\n  let s1 : HashSet Int := HashSet.ofList l1\n  let s2 : HashSet Int := HashSet.ofList l2\n  s1.filter (fun x => s2.contains x)\n\nend Task2\n", "lean_tests": "open Task2\n\n#guard similarElements [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [4, 5]\n#guard similarElements [1, 2, 3, 4] [5, 4, 3, 7] == HashSet.ofList [3, 4]\n#guard similarElements [11, 12, 14, 13] [17, 15, 14, 13] == HashSet.ofList [13, 14]\n", "notes": ["Implemented set-like behavior using Std.HashSet as required.", "Kept the API simple: intersection via HashSet.filter with membership check.", "Tests compare HashSets directly using == to avoid ordering assumptions."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task2.lean"}
{"task_id": 3, "status": "ok", "input_item": {"text": "Write a python function to identify non-prime numbers.", "code": "import math\r\ndef is_not_prime(n):\r\n    result = False\r\n    for i in range(2,int(math.sqrt(n)) + 1):\r\n        if n % i == 0:\r\n            result = True\r\n    return result", "task_id": 3, "test_setup_code": "", "test_list": ["assert is_not_prime(2) == False", "assert is_not_prime(10) == True", "assert is_not_prime(35) == True"], "challenge_test_list": []}, "lean_result": {"task_id": 3, "lean_module_name": "Task3", "lean_code": "import Batteries\nopen Std\n\ndef isNotPrime (n : Nat) : Bool := Id.run do\n  if n < 2 then\n    return true\n  for x in [2 : Nat.sqrt n + 1] do\n    if n % x == 0 then return true\n  return false\n", "lean_tests": "#guard isNotPrime 2 == false\n#guard isNotPrime 10 == true\n#guard isNotPrime 35 == true\n#guard isNotPrime 37 == false\n#guard isNotPrime 1 == true\n#guard isNotPrime 0 == true\n", "notes": ["Simple trial division up to sqrt(n) with early exit using Id.run to allow returns inside the for-loop.", "Explicitly treat 0 and 1 as non-prime (return true for n < 2).", "No extra imports; adheres to forbidden tokens and sorting/heap constraints."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task3.lean"}
{"task_id": 4, "status": "ok", "input_item": {"text": "Write a function to find the largest integers from a given list of numbers using heap queue algorithm.", "code": "import heapq as hq\r\ndef heap_queue_largest(nums,n):\r\n  largest_nums = hq.nlargest(n, nums)\r\n  return largest_nums", "task_id": 4, "test_setup_code": "", "test_list": ["assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],2)==[85, 75] ", "assert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],5)==[85, 75, 65, 58, 35]"], "challenge_test_list": []}, "lean_result": {"task_id": 4, "lean_module_name": "Task4", "lean_code": "import Batteries\nopen Std\n\nnamespace Task4\n\n-- Find the maximum element of a non-empty list\ndef listMax? (xs : List Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | x :: xs => some (xs.foldl Nat.max x)\n\n-- Remove the first occurrence of a value from a list\ndef removeFirst (a : Nat) (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == a then ys else y :: removeFirst a ys\n\n-- Repeatedly pick the current maximum and remove one occurrence, up to n times\n-- Returns the selected elements in the order they were picked (descending)\ndef heapQueueLargest (nums : List Nat) (n : Nat) : List Nat := Id.run do\n  let mut xs := nums\n  let mut res : Array Nat := #[]\n  for _ in [:n] do\n    match listMax? xs with\n    | none => break\n    | some m =>\n      res := res.push m\n      xs := removeFirst m xs\n  return res.toList\n\nend Task4\n", "lean_tests": "#guard Task4.heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 3 == [85, 75, 65]\n#guard Task4.heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 2 == [85, 75]\n#guard Task4.heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 5 == [85, 75, 65, 58, 35]\n", "notes": ["Avoided heap APIs per hard constraint 0f; implemented repeated max-extraction using List folds.", "No sorting used; deterministic order arises from picking current maximum each iteration.", "Simple helpers: listMax? via foldl Nat.max and removeFirst to drop one occurrence."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task4.lean"}
{"task_id": 5, "status": "ok", "input_item": {"text": "Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.", "code": "def count_ways(n): \r\n\tA = [0] * (n + 1) \r\n\tB = [0] * (n + 1) \r\n\tA[0] = 1\r\n\tA[1] = 0\r\n\tB[0] = 0\r\n\tB[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \r\n\t\tB[i] = A[i - 1] + B[i - 2] \r\n\treturn A[n] ", "task_id": 5, "test_setup_code": "", "test_list": ["assert count_ways(2) == 3", "assert count_ways(8) == 153", "assert count_ways(12) == 2131"], "challenge_test_list": []}, "lean_result": {"task_id": 5, "lean_module_name": "Task5", "lean_code": "import Batteries\nopen Std\n\n/--\n  countWays n returns the number of tilings of a 3×n board using 2×1 dominoes.\n  Uses a standard DP with two sequences:\n  - A[i]: number of full tilings of 3×i\n  - B[i]: number of ways to tile 3×i with a specific single-cell deficiency pattern\n  Recurrences:\n    A[i] = A[i-2] + 2*B[i-1]\n    B[i] = A[i-1] + B[i-2]\n  Base:\n    A[0] = 1, A[1] = 0, B[0] = 0, B[1] = 1\n-*/\ndef countWays (n : Nat) : Nat := Id.run do\n  let mut A := Array.replicate (n+1) 0\n  let mut B := Array.replicate (n+1) 0\n  -- Base values\n  A := A.set! 0 1\n  if n >= 1 then\n    -- A[1] stays 0; B[1] = 1\n    B := B.set! 1 1\n  if n <= 1 then\n    return A[n]!\n  -- DP\n  for i in [2 : n+1] do\n    A := A.set! i (A[i-2]! + 2 * B[i-1]!)\n    B := B.set! i (A[i-1]! + B[i-2]!)\n  return A[n]!\n", "lean_tests": "#guard countWays 2 == 3\n#guard countWays 8 == 153\n#guard countWays 12 == 2131\n", "notes": "- Implemented classic DP for 3×n domino tilings with auxiliary sequence for the deficiency state.\n- Safe initialization for n = 0 or 1; base cases handled without extra imports.\n- Arrays used for clarity and iteration; no sorting, sets, or extra packages."}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task5.lean"}
{"task_id": 6, "status": "ok", "input_item": {"text": "Write a python function to check whether the two numbers differ at one bit position only or not.", "code": "def is_Power_Of_Two (x): \r\n    return x and (not(x & (x - 1))) \r\ndef differ_At_One_Bit_Pos(a,b): \r\n    return is_Power_Of_Two(a ^ b)", "task_id": 6, "test_setup_code": "", "test_list": ["assert differ_At_One_Bit_Pos(13,9) == True", "assert differ_At_One_Bit_Pos(15,8) == False", "assert differ_At_One_Bit_Pos(2,4) == False"], "challenge_test_list": []}, "lean_result": {"task_id": 6, "lean_module_name": "Task6", "lean_code": "import Batteries\nopen Std\n\nnamespace Task6\n\n-- Returns true iff x is a power of two (and nonzero)\ndef isPowerOfTwo (x : Nat) : Bool :=\n  x != 0 && ((x &&& (x - 1)) == 0)\n\n-- Returns true iff a and b differ at exactly one bit position\ndef differAtOneBitPos (a b : Nat) : Bool :=\n  isPowerOfTwo (a ^^^ b)\n\nend Task6\n", "lean_tests": "#guard Task6.differAtOneBitPos 13 9 == true\n#guard Task6.differAtOneBitPos 15 8 == false\n#guard Task6.differAtOneBitPos 2 4 == false\n", "notes": "- Uses the standard XOR trick: a and b differ at exactly one bit iff a XOR b is a nonzero power of two.\n- Bitwise operations use built-in Nat operators (&&& for AND, ^^^ for XOR).\n- No extra imports; complies with all constraints."}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task6.lean"}
{"task_id": 7, "status": "ok", "input_item": {"text": "Write a function to find all words which are at least 4 characters long in a string by using regex.", "code": "import re\r\ndef find_char_long(text):\r\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))", "task_id": 7, "test_setup_code": "", "test_list": ["assert find_char_long('Please move back to stream') == ['Please', 'move', 'back', 'stream']", "assert find_char_long('Jing Eco and Tech') == ['Jing', 'Tech']", "assert find_char_long('Jhingai wulu road Zone 3') == ['Jhingai', 'wulu', 'road', 'Zone']"], "challenge_test_list": []}, "lean_result": {"task_id": 7, "lean_module_name": "Task7", "lean_code": "import Batteries\nopen Std\n\ndef findCharLong (text : String) : List String :=\n  text.splitOn \" \" |>.filter (fun w => w.length >= 4)\n", "lean_tests": "#guard findCharLong \"Please move back to stream\" == [\"Please\", \"move\", \"back\", \"stream\"]\n#guard findCharLong \"Jing Eco and Tech\" == [\"Jing\", \"Tech\"]\n#guard findCharLong \"Jhingai wulu road Zone 3\" == [\"Jhingai\", \"wulu\", \"road\", \"Zone\"]\n", "notes": ["Used simple space-based tokenization with String.splitOn, then filtered by length >= 4.", "Did not use regex explicitly to comply with minimal complexity and import constraints.", "Matches the required outputs for the provided tests."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task7.lean"}
{"task_id": 8, "status": "ok", "input_item": {"text": "Write a function to find squares of individual elements in a list using lambda function.", "code": "def square_nums(nums):\r\n square_nums = list(map(lambda x: x ** 2, nums))\r\n return square_nums", "task_id": 8, "test_setup_code": "", "test_list": ["assert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "assert square_nums([10,20,30])==([100,400,900])", "assert square_nums([12,15])==([144,225])"], "challenge_test_list": []}, "lean_result": {"task_id": 8, "lean_module_name": "Task8", "lean_code": "import Batteries\nopen Std\n\nnamespace Task8\n\n-- Returns a list of squares for each element using a lambda\ndef squareNums (nums : List Nat) : List Nat :=\n  nums.map (fun x => x * x)\n\nend Task8\n", "lean_tests": "#guard Task8.squareNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n#guard Task8.squareNums [10,20,30] == [100,400,900]\n#guard Task8.squareNums [12,15] == [144,225]\n", "notes": ["Implemented squares via List.map and a simple lambda (fun x => x * x).", "Chose multiplication instead of exponentiation to avoid reliance on pow instances.", "No extra imports; adheres to the fixed header constraint."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task8.lean"}
{"task_id": 9, "status": "ok", "input_item": {"text": "Write a python function to find the minimum number of rotations required to get the same string.", "code": "def find_Rotations(str): \r\n    tmp = str + str\r\n    n = len(str) \r\n    for i in range(1,n + 1): \r\n        substring = tmp[i: i+n] \r\n        if (str == substring): \r\n            return i \r\n    return n ", "task_id": 9, "test_setup_code": "", "test_list": ["assert find_Rotations(\"aaaa\") == 1", "assert find_Rotations(\"ab\") == 2", "assert find_Rotations(\"abc\") == 3"], "challenge_test_list": []}, "lean_result": {"task_id": 9, "lean_module_name": "Task9", "lean_code": "import Batteries\nopen Std\n\nnamespace Task9\n\n-- Return the minimum k > 0 such that rotating s by k yields s again.\n-- If s is empty, we return 0.\n-- Rotation check uses only String.drop, String.take, String.length, and (++) as required.\ndef findRotations (s : String) : Nat :=\n  let n := s.length\n  if n == 0 then 0\n  else\n    let rec loop (k : Nat) : Nat :=\n      if k > n then n\n      else if s == (s.drop k) ++ (s.take k) then k\n      else loop (k+1)\n    loop 1\n\nend Task9\n", "lean_tests": "#guard Task9.findRotations \"aaaa\" == 1\n#guard Task9.findRotations \"ab\" == 2\n#guard Task9.findRotations \"abc\" == 3\n", "notes": ["Implemented minimal rotation using a simple loop and rotation check: s == s.drop k ++ s.take k.", "Only allowed String operations are used (length, take, drop, ++). No Substring or String.Pos.", "Empty string returns 0; non-empty strings search k in [1..n].", "All constraints satisfied: only Batteries/Std imported, no sorting, no classical features."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task9.lean"}
{"task_id": 10, "status": "ok", "input_item": {"text": "Write a function to get the n smallest items from a dataset.", "code": "import heapq\r\ndef small_nnum(list1,n):\r\n  smallest=heapq.nsmallest(n,list1)\r\n  return smallest", "task_id": 10, "test_setup_code": "", "test_list": ["assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[10,20]", "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5)==[10,20,20,40,50]", "assert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3)==[10,20,20]"], "challenge_test_list": []}, "lean_result": {"task_id": 10, "lean_module_name": "Task10", "lean_code": "import Batteries\nopen Std\n\n/-- Find the minimum of a non-empty list. Returns `none` for empty lists. -/\ndef findMin? (l : List Nat) : Option Nat :=\n  match l with\n  | [] => none\n  | x :: xs => some <| xs.foldl (fun m y => if y < m then y else m) x\n\n/-- Remove the first occurrence of `x` from the list (if present). -/\ndef removeOne (x : Nat) (l : List Nat) : List Nat :=\n  match l with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne x ys\n\n/--\nGet the n smallest items from the dataset `list1` in ascending order.\nIf `n` exceeds the list length, returns all elements in ascending order.\n-/\ndef smallNNum (list1 : List Nat) (n : Nat) : List Nat := Id.run do\n  let mut l := list1\n  let mut k := n\n  let mut res : Array Nat := #[]\n  while k > 0 do\n    match findMin? l with\n    | none => break\n    | some m =>\n      res := res.push m\n      l := removeOne m l\n      k := k - 1\n  return res.toList\n", "lean_tests": "#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 2 == [10,20]\n#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 5 == [10,20,20,40,50]\n#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 3 == [10,20,20]\n", "notes": ["Implemented selection-style approach per constraints: repeatedly find current minimum with a fold, remove one occurrence, append to result, repeat up to n.", "No heap or sorting APIs used; relies only on List operations and a simple loop in Id.", "Preserves ascending order by pushing minima to an Array and converting to List at the end."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task10.lean"}
{"task_id": 11, "status": "ok", "input_item": {"text": "Write a python function to remove first and last occurrence of a given character from the string.", "code": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ", "task_id": 11, "test_setup_code": "", "test_list": ["assert remove_Occ(\"hello\",\"l\") == \"heo\"", "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"", "assert remove_Occ(\"PHP\",\"P\") == \"H\""], "challenge_test_list": ["assert remove_Occ(\"hellolloll\",\"l\") == \"helollol\"", "assert remove_Occ(\"\",\"l\") == \"\""]}, "lean_result": {"task_id": 11, "lean_module_name": "Task11", "lean_code": "import Batteries\nopen Std\n\nnamespace Task11\n\n-- Remove the first and last occurrence of substring c (assumed non-empty, typically a single character)\n-- from the string s. If c does not occur or occurs once, the function removes those occurrences\n-- accordingly.\ndef removeOcc (s : String) (c : String) : String := Id.run do\n  let parts := s.splitOn c\n  let n := parts.length\n  if n ≤ 1 then\n    return s\n  else\n    let mut res := (parts.get! 0) ++ (parts.get! 1)\n    for i in [2 : n-1] do\n      res := res ++ c ++ (parts.get! i)\n    res := res ++ (parts.get! (n-1))\n    return res\n\nend Task11\n", "lean_tests": "#guard Task11.removeOcc \"hello\" \"l\" == \"heo\"\n#guard Task11.removeOcc \"abcda\" \"a\" == \"bcd\"\n#guard Task11.removeOcc \"PHP\" \"P\" == \"H\"\n\n-- Challenge tests\n#guard Task11.removeOcc \"hellolloll\" \"l\" == \"helollol\"\n#guard Task11.removeOcc \"\" \"l\" == \"\"\n", "notes": ["Implemented by splitting on the target substring and reconstructing while omitting the first and last delimiters.", "Assumes the second argument is a non-empty substring (typically a single character).", "No use of String.extract or String.Pos; only String.splitOn, take, drop, and concatenation are used.", "Not set-like; no sorting or HashSet needed."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task11.lean"}
{"task_id": 12, "status": "ok", "input_item": {"text": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "code": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result", "task_id": 12, "test_setup_code": "", "test_list": ["assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"], "challenge_test_list": []}, "lean_result": {"task_id": 12, "lean_module_name": "Task12", "lean_code": "import Batteries\nopen Std\n\nnamespace Task12\n\n-- Sum of a row\ndef rowSum (r : List Int) : Int := r.foldl (· + ·) 0\n\n-- Enumerate a list with starting index\ndef enumerateFrom {α} (xs : List α) (start : Nat) : List (Nat × α) :=\n  match xs with\n  | [] => []\n  | x :: xs' => (start, x) :: enumerateFrom xs' (start + 1)\n\n-- Find the index and row with minimal row-sum (first occurrence on ties)\ndef findMinIndexBySum (rows : List (List Int)) : Option (Nat × List Int) :=\n  match enumerateFrom rows 0 with\n  | [] => none\n  | (i, r) :: rest =>\n      let init := (i, r, rowSum r)\n      let (bestI, bestR, _bestS) :=\n        rest.foldl\n          (fun (bi, br, bs) (j, srow) =>\n            let s := rowSum srow\n            if s < bs then (j, srow, s) else (bi, br, bs))\n          init\n      some (bestI, bestR)\n\n-- Remove exactly one element at a given index\ndef removeAtIndex {α} (xs : List α) (n : Nat) : List α :=\n  match xs, n with\n  | [], _ => []\n  | _ :: xs', 0 => xs'\n  | x :: xs', Nat.succ k => x :: removeAtIndex xs' k\n\n-- Selection-style sort by row sum (ascending)\ndef sortMatrix (m : List (List Int)) : List (List Int) :=\n  let rec loop (xs acc : List (List Int)) : List (List Int) :=\n    match xs with\n    | [] => acc.reverse\n    | _ =>\n      match findMinIndexBySum xs with\n      | none => acc.reverse\n      | some (i, row) =>\n          let xs' := removeAtIndex xs i\n          loop xs' (row :: acc)\n  loop m []\n\nend Task12\n", "lean_tests": "open Task12\n\n#guard sortMatrix [[1, 2, 3], [2, 4, 5], [1, 1, 1]] == [[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n#guard sortMatrix [[1, 2, 3], [-2, 4, -5], [1, -1, 1]] == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]]\n#guard sortMatrix [[5, 8, 9], [6, 4, 3], [2, 1, 4]] == [[2, 1, 4], [6, 4, 3], [5, 8, 9]]\n", "notes": ["Implemented selection-style sorting per constraint 0f: repeatedly find current minimum by fold, remove one occurrence by index, append to result.", "Deterministic tie-breaking: first occurrence preserved when row sums are equal.", "No forbidden imports or identifiers; uses only Batteries/Std.", "Straightforward helper functions: rowSum, enumerateFrom, findMinIndexBySum, removeAtIndex."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task12.lean"}
{"task_id": 13, "status": "ok", "input_item": {"text": "Write a function to count the most common words in a dictionary.", "code": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n", "task_id": 13, "test_setup_code": "", "test_list": ["assert count_common(['red','green','black','pink','black','white','black','eyes','white','black','orange','pink','pink','red','red','white','orange','white',\"black\",'pink','green','green','pink','green','pink','white','orange',\"orange\",'red']) == [('pink', 6), ('black', 5), ('white', 5), ('red', 4)]", "assert count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one', 'three', 'one']) == [('one', 4), ('two', 2), ('three', 2), ('four', 1)]", "assert count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple', 'Netflix', 'Amazon']) == [('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]"], "challenge_test_list": []}, "lean_result": {"task_id": 13, "lean_module_name": "Task13", "lean_code": "import Batteries\nopen Std\n\nstructure WordStat where\n  word : String\n  count : Nat\n  first : Nat\n  deriving BEq\n\n/-- Count the most common words and return the top 4 as (word, count).\n    Ties are broken by the earliest first occurrence in the input list. -/\ndef countCommon (words : List String) : List (String × Nat) := Id.run do\n  -- Build frequency map with first occurrence index\n  let mut m : Std.HashMap String (Nat × Nat) := {}\n  let mut idx := 0\n  for w in words do\n    match m.find? w with\n    | some (c, f) => m := m.insert w (c+1, f)\n    | none => m := m.insert w (1, idx)\n    idx := idx + 1\n  -- Convert to list of stats\n  let mut stats : List WordStat := m.toList.map (fun (k, v) =>\n    let (c, f) := v\n    { word := k, count := c, first := f }\n  )\n  -- Helper to choose better stat (higher count, then smaller first index)\n  let better (a b : WordStat) : Bool :=\n    a.count > b.count || (a.count == b.count && a.first < b.first)\n  -- Select top 4 by repeated best selection\n  let k := 4\n  let mut res : List (String × Nat) := []\n  let mut i := 0\n  while i < k do\n    match stats with\n    | [] => break\n    | h::t =>\n      let best := List.foldl (init := h) t (fun b a => if better a b then a else b)\n      res := res ++ [(best.word, best.count)]\n      stats := stats.filter (fun s => s.word != best.word)\n      i := i + 1\n  return res\n", "lean_tests": "#guard countCommon [\"red\",\"green\",\"black\",\"pink\",\"black\",\"white\",\"black\",\"eyes\",\"white\",\"black\",\"orange\",\"pink\",\"pink\",\"red\",\"red\",\"white\",\"orange\",\"white\",\"black\",\"pink\",\"green\",\"green\",\"pink\",\"green\",\"pink\",\"white\",\"orange\",\"orange\",\"red\"]\n  == [(\"pink\", 6), (\"black\", 5), (\"white\", 5), (\"red\", 4)]\n\n#guard countCommon [\"one\", \"two\", \"three\", \"four\", \"five\", \"one\", \"two\", \"one\", \"three\", \"one\"]\n  == [(\"one\", 4), (\"two\", 2), (\"three\", 2), (\"four\", 1)]\n\n#guard countCommon [\"Facebook\", \"Apple\", \"Amazon\", \"Netflix\", \"Google\", \"Apple\", \"Netflix\", \"Amazon\"]\n  == [(\"Apple\", 2), (\"Amazon\", 2), (\"Netflix\", 2), (\"Facebook\", 1)]\n", "notes": ["Counts built using Std.HashMap; also tracked first occurrence index for deterministic tie-breaking.", "Top-4 selection implemented by repeated linear scan (no sorting, no heaps), complying with sorting ban.", "Output is an ordered List of (String × Nat) matching expected order: descending count, then earliest first occurrence.", "No extra imports; only Batteries and Std as required."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task13.lean"}
{"task_id": 14, "status": "ok", "input_item": {"text": "Write a python function to find the volume of a triangular prism.", "code": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ", "task_id": 14, "test_setup_code": "", "test_list": ["assert find_Volume(10,8,6) == 240", "assert find_Volume(3,2,2) == 6", "assert find_Volume(1,2,1) == 1"], "challenge_test_list": []}, "lean_result": {"task_id": 14, "lean_module_name": "Task14", "lean_code": "import Batteries\nopen Std\n\nnamespace Task14\n\n/--\n  Volume of a triangular prism with base `b`, height of the triangular base `h`,\n  and length `l` is (b * h * l) / 2.\n  Assumes inputs are non-negative integers and the result is integral for given tests.\n-/\ndef findVolume (b h l : Nat) : Nat :=\n  (b * h * l) / 2\n\nend Task14\n", "lean_tests": "#guard Task14.findVolume 10 8 6 = 240\n#guard Task14.findVolume 3 2 2 = 6\n#guard Task14.findVolume 1 2 1 = 1\n", "notes": ["Implemented the standard formula V = (1/2) * base * height * length using Nat arithmetic.", "Kept the API simple with non-negative integer inputs and output.", "Tests mirror the provided Python asserts using #guard."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task14.lean"}
{"task_id": 15, "status": "ok", "input_item": {"text": "Write a function to split a string at lowercase letters.", "code": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))", "task_id": 15, "test_setup_code": "", "test_list": ["assert split_lowerstring(\"AbCd\")==['bC','d']", "assert split_lowerstring(\"Python\")==['y', 't', 'h', 'o', 'n']", "assert split_lowerstring(\"Programming\")==['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']"], "challenge_test_list": []}, "lean_result": {"task_id": 15, "lean_module_name": "Task15", "lean_code": "import Batteries\nopen Std\n\n/-- Return true iff the character is an ASCII lowercase letter 'a'..'z'. -/\ndef isLowerAscii (c : Char) : Bool :=\n  match c with\n  | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm'\n  | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' => true\n  | _ => false\n\n/-- Collect character indices (0-based, by characters) where the string has lowercase letters. -/\ndef lowerStarts (s : String) : List Nat :=\n  let rec go (cs : List Char) (i : Nat) (acc : List Nat) : List Nat :=\n    match cs with\n    | [] => acc.reverse\n    | c :: cs' =>\n      if isLowerAscii c then\n        go cs' (i+1) (i :: acc)\n      else\n        go cs' (i+1) acc\n  go s.data 0 []\n\n/-- Build segments starting at each index in `starts`, ending just before the next such index or at the end. -/\ndef buildSegments (s : String) (starts : List Nat) : List String :=\n  let rec go (st : List Nat) (acc : List String) : List String :=\n    match st with\n    | [] => acc.reverse\n    | [i] => ((s.drop i) :: acc).reverse\n    | i :: j :: rest =>\n      let seg := (s.drop i).take (j - i)\n      go (j :: rest) (seg :: acc)\n  go starts []\n\n/-- Split a string at lowercase letters: for each lowercase letter position i, take the substring from i up to (but not including) the next lowercase position, or to the end if none. -/\ndef splitLowerString (s : String) : List String :=\n  buildSegments s (lowerStarts s)\n", "lean_tests": "#guard splitLowerString \"AbCd\" == [\"bC\", \"d\"]\n#guard splitLowerString \"Python\" == [\"y\", \"t\", \"h\", \"o\", \"n\"]\n#guard splitLowerString \"Programming\" == [\"r\", \"o\", \"g\", \"r\", \"a\", \"m\", \"m\", \"i\", \"n\", \"g\"]\n", "notes": ["Detected lowercase positions using a simple Char pattern match to avoid forbidden Prop→Bool conversions.", "Constructed substrings using String.drop and String.take only, complying with the String API restrictions.", "Segments start at each lowercase character and extend up to the next lowercase start (exclusive) or to the end."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task15.lean"}
{"task_id": 16, "status": "ok", "input_item": {"text": "Write a function to find sequences of lowercase letters joined with an underscore.", "code": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')", "task_id": 16, "test_setup_code": "", "test_list": ["assert text_lowercase_underscore(\"aab_cbbbc\")==('Found a match!')", "assert text_lowercase_underscore(\"aab_Abbbc\")==('Not matched!')", "assert text_lowercase_underscore(\"Aaab_abbbc\")==('Not matched!')"], "challenge_test_list": ["assert text_lowercase_underscore(\"aab-cbbbc\")==('Not matched!')"]}, "lean_result": {"task_id": 16, "lean_module_name": "Task16", "lean_code": "import Batteries\nopen Std\n\nnamespace Task16\n\n-- Check if a string is a non-empty sequence of lowercase letters a..z\ndef isLowercaseLetters (s : String) : Bool :=\n  match s.data with\n  | [] => false\n  | cs => allLower cs\nwhere\n  allLower (cs : List Char) : Bool :=\n    match cs with\n    | [] => true\n    | c :: cs' => if 'a' ≤ c && c ≤ 'z' then allLower cs' else false\n\n-- Returns \"Found a match!\" if the whole string is two lowercase sequences joined by a single underscore\ndef textLowercaseUnderscore (s : String) : String :=\n  match s.splitOn \"_\" with\n  | [a, b] => if isLowercaseLetters a && isLowercaseLetters b then \"Found a match!\" else \"Not matched!\"\n  | _ => \"Not matched!\"\n\nend Task16\n", "lean_tests": "open Task16\n\n#guard textLowercaseUnderscore \"aab_cbbbc\" = \"Found a match!\"\n#guard textLowercaseUnderscore \"aab_Abbbc\" = \"Not matched!\"\n#guard textLowercaseUnderscore \"Aaab_abbbc\" = \"Not matched!\"\n#guard textLowercaseUnderscore \"aab-cbbbc\" = \"Not matched!\"\n", "notes": ["Implemented a simple parser without regex: split on underscore and validate both sides are non-empty lowercase a..z sequences.", "String operations restricted to splitOn and iteration via String.data to comply with constraints (no String.extract/Pos).", "Exact match required for the whole string, matching the provided tests."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task16.lean"}
{"task_id": 17, "status": "ok", "input_item": {"text": "Write a function to find the perimeter of a square.", "code": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter", "task_id": 17, "test_setup_code": "", "test_list": ["assert square_perimeter(10)==40", "assert square_perimeter(5)==20", "assert square_perimeter(4)==16"], "challenge_test_list": []}, "lean_result": {"task_id": 17, "lean_module_name": "Task17", "lean_code": "import Batteries\nopen Std\n\nnamespace Task17\n\n/-- Returns the perimeter of a square given the side length. -/\ndef squarePerimeter (side : Nat) : Nat := 4 * side\n\nend Task17\n", "lean_tests": "#guard Task17.squarePerimeter 10 == 40\n#guard Task17.squarePerimeter 5 == 20\n#guard Task17.squarePerimeter 4 == 16\n", "notes": "- Simple arithmetic: perimeter = 4 * side (Nat).\n- No extra imports or advanced features; complies with all constraints.\n- Placed function in namespace Task17 within module Task17 for clarity."}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task17.lean"}
{"task_id": 18, "status": "ok", "input_item": {"text": "Write a function to remove characters from the first string which are present in the second string.", "code": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ", "task_id": 18, "test_setup_code": "", "test_list": ["assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'", "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'", "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles' "], "challenge_test_list": []}, "lean_result": {"task_id": 18, "lean_module_name": "Task18", "lean_code": "import Batteries\nopen Std\n\nnamespace Task18\n\n/-- Build a set of characters present in a string. -/\ndef charsToSet (s : String) : HashSet Char :=\n  s.foldl (fun acc c => acc.insert c) ({} : HashSet Char)\n\n/-- Remove characters from s1 that appear in s2. -/\ndef removeDirtyChars (s1 s2 : String) : String :=\n  let bad := charsToSet s2\n  s1.foldl (fun acc c => if bad.contains c then acc else acc.push c) \"\"\n\nend Task18\n", "lean_tests": "open Task18\n\n#guard removeDirtyChars \"probasscurve\" \"pros\" == \"bacuve\"\n#guard removeDirtyChars \"digitalindia\" \"talent\" == \"digiidi\"\n#guard removeDirtyChars \"exoticmiles\" \"toxic\" == \"emles\"\n", "notes": ["Built a HashSet of characters from the second string for O(1) membership checks.", "Traversed the first string with String.foldl and appended characters using String.push when not present in the set.", "Avoided forbidden APIs and imports; used only Batteries/Std and no IO."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task18.lean"}
{"task_id": 19, "status": "ok", "input_item": {"text": "Write a function to find whether a given array of integers contains any duplicate element.", "code": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ", "task_id": 19, "test_setup_code": "", "test_list": ["assert test_duplicate(([1,2,3,4,5]))==False", "assert test_duplicate(([1,2,3,4, 4]))==True", "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"], "challenge_test_list": []}, "lean_result": {"task_id": 19, "lean_module_name": "Task19", "lean_code": "import Batteries\nopen Std\n\nnamespace Task19\n\n/-- Return true iff the input contains any duplicate element. -/\ndef hasDuplicateList (xs : List Int) : Bool := Id.run do\n  let mut seen : HashSet Int := {}\n  for x in xs do\n    if seen.contains x then\n      return true\n    seen := seen.insert x\n  return false\n\n/-- Convenience wrapper for arrays. -/\ndef hasDuplicateArray (xs : Array Int) : Bool :=\n  hasDuplicateList xs.toList\n\nend Task19\n", "lean_tests": "#guard Task19.hasDuplicateArray #[1,2,3,4,5] == false\n#guard Task19.hasDuplicateArray #[1,2,3,4,4] == true\n#guard Task19.hasDuplicateArray #[1,1,2,2,3,3,4,4,5] == true\n\n#guard Task19.hasDuplicateList [1,2,3,4,5] == false\n#guard Task19.hasDuplicateList [1,2,3,4,4] == true", "notes": "- Implemented duplicate detection using Std.HashSet for O(n) average time.\n- Provided both List and Array interfaces; tests use Array to match the task phrasing.\n- No sorting or extra libraries; complies with all hard constraints."}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task19.lean"}
{"task_id": 20, "status": "ok", "input_item": {"text": "Write a function to check if the given number is woodball or not.", "code": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False", "task_id": 20, "test_setup_code": "", "test_list": ["assert is_woodall(383) == True", "assert is_woodall(254) == False", "assert is_woodall(200) == False"], "challenge_test_list": ["assert is_woodall(32212254719) == True", "assert is_woodall(32212254718) == False", "assert is_woodall(159) == True"]}, "lean_result": {"task_id": 20, "lean_module_name": "Task20", "lean_code": "import Batteries\nopen Std\n\nnamespace Task20\n\n-- A Woodall number has the form n * 2^n - 1 for some n >= 1.\n-- This function checks whether the given x is a Woodall number.\ndef isWoodall (x : Nat) : Bool := Id.run do\n  let target := x + 1\n  let mut n := 1\n  let mut pow2 := 2\n  while n * pow2 ≤ target do\n    if n * pow2 == target then\n      return true\n    n := n + 1\n    pow2 := pow2 * 2\n  return false\n\nend Task20\n", "lean_tests": "open Task20\n\n#guard isWoodall 383 == true\n#guard isWoodall 254 == false\n#guard isWoodall 200 == false\n\n#guard isWoodall 32212254719 == true\n#guard isWoodall 32212254718 == false\n#guard isWoodall 159 == true\n", "notes": ["Implemented Woodall number check: x is Woodall if there exists n >= 1 with x + 1 = n * 2^n.", "Iterative approach doubling pow2 and incrementing n ensures monotonic growth of n*2^n and avoids sorting or complex structures.", "Uses only Batteries/Std; pure function with simple loop in Id.run; Nat is unbounded so large literals are safe."]}, "lean_file": "TacticsGeneration/Tasks/Free_code/Task20.lean"}
