{"text": "Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].", "task_id": 1, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y <| fun row => row.modify x f\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef List.get2d {α : Type} (l : List (List α)) (y x : Nat) (fallback : α) :=\n  (l.getD y []).getD x fallback\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef minCost (cost : List (List Nat)) (m n : Nat) : Nat := Id.run do\n  let mut tc : Array (Array Nat) :=\n    Array.replicate (m+1) (Array.replicate (n+1) 0)\n  tc := tc.set2d? 0 0 (cost.get2d 0 0 0)\n  for i in [1 : m+1] do\n    tc := tc.set2d? i 0 <| tc.get2d (i-1) 0 0 + cost.get2d i 0 0\n  for j in [1 : n+1] do\n    tc := tc.set2d? 0 j <| tc.get2d 0 (j-1) 0 + cost.get2d 0 j 0\n  for i in [1 : m+1] do\n    for j in [1 : n+1] do\n      tc := tc.set2d? i j <|\n        min (tc.get2d (i-1) (j-1) 0) (\n          min (tc.get2d (i-1) j 0) (tc.get2d i (j-1) 0)\n        ) + cost.get2d i j 0\n  return tc.get2d m n 0\n\n#guard minCost [[1, 2, 3], [4, 8, 2], [1, 5, 3]] 2 2 = 8\n#guard minCost [[2, 3, 4], [5, 9, 3], [2, 6, 4]] 2 2 = 12\n#guard minCost [[3, 4, 5], [6, 10, 4], [3, 7, 5]] 2 2 = 16\n", "test_list": ["#guard minCost [[1, 2, 3], [4, 8, 2], [1, 5, 3]] 2 2 = 8", "#guard minCost [[2, 3, 4], [5, 9, 3], [2, 6, 4]] 2 2 = 12", "#guard minCost [[3, 4, 5], [6, 10, 4], [3, 7, 5]] 2 2 = 16"]}
{"text": "Write a function to find the similar elements from the given two tuple lists.", "task_id": 2, "code": "import Batteries\n\nopen Std\n\ndef similarElements (l1 l2 : List Int) : HashSet Int := Id.run do\n  let s1 := HashSet.ofList l1\n  let s2 := HashSet.ofList l2\n  return s1.filter (fun x => x ∈ s2)\n\n#guard similarElements [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [4, 5]\n#guard similarElements [1, 2, 3, 4] [5, 4, 3, 7] == HashSet.ofList [3, 4]\n#guard similarElements [11, 12, 14, 13] [17, 15, 14, 13] == HashSet.ofList [13, 14]\n", "test_list": ["#guard similarElements [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [4, 5]", "#guard similarElements [1, 2, 3, 4] [5, 4, 3, 7] == HashSet.ofList [3, 4]", "#guard similarElements [11, 12, 14, 13] [17, 15, 14, 13] == HashSet.ofList [13, 14]"]}
{"text": "Write a python function to identify non-prime numbers.", "task_id": 3, "code": "import Batteries\n\nopen Std\n\ndef isNotPrime (n : Nat) : Bool := Id.run do\n  for x in [2 : Nat.sqrt n + 1] do\n    if n % x == 0 then return true\n  return false\n\n#guard isNotPrime 2 == false\n#guard isNotPrime 10 == true\n#guard isNotPrime 35 == true\n", "test_list": ["#guard isNotPrime 2 == false", "#guard isNotPrime 10 == true", "#guard isNotPrime 35 == true"]}
{"text": "Write a function to find the largest integers from a given list of numbers using heap queue algorithm.", "task_id": 4, "code": "import Batteries\n\nopen Std\n\ndef heapQueueLargest (nums : List Nat) (n : Nat) : List Nat := Id.run do\n  let mut heap := nums.toArray.toBinaryHeap (· < ·)\n  let mut res := #[]\n  for _ in [: n] do\n    match heap.max with\n    | none => break\n    | some x => res := res.push x\n    heap := heap.popMax\n  return res.toList\n\n#guard heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 3 == [85, 75, 65]\n#guard heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 2 == [85, 75]\n#guard heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 5 == [85, 75, 65, 58, 35]\n", "test_list": ["#guard heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 3 == [85, 75, 65]", "#guard heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 2 == [85, 75]", "#guard heapQueueLargest [25, 35, 22, 85, 14, 65, 75, 22, 58] 5 == [85, 75, 65, 58, 35]"]}
{"text": "Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.", "task_id": 5, "code": "import Batteries\n\nopen Std\n\ndef countWays (n : Nat) : Nat := Id.run do\n  let mut A := Array.replicate (n+1) 0\n  let mut B := Array.replicate (n+1) 0\n  A := A.modify 0 (fun _ => 1)\n  A := A.modify 1 (fun _ => 0)\n  B := B.modify 0 (fun _ => 0)\n  B := B.modify 1 (fun _ => 1)\n  for i in [2 : n+1] do\n    A := A.set! i <| A[i-2]! + 2*B[i-1]!\n    B := B.set! i <| A[i-1]! + B[i-2]!\n  return A[n]!\n\n#guard countWays 2 == 3\n#guard countWays 8 == 153\n#guard countWays 12 == 2131\n", "test_list": ["#guard countWays 2 == 3", "#guard countWays 8 == 153", "#guard countWays 12 == 2131"]}
{"text": "Write a python function to check whether the two numbers differ at one bit position only or not.", "task_id": 6, "code": "import Batteries\n\nopen Std\n\ndef isPowerOfTwo (x : Nat) : Bool := x != 0 && (x &&& (x - 1)) == 0\ndef differAtOneBitPos (a b : Nat) := isPowerOfTwo (a ^^^ b)\n\n#guard differAtOneBitPos 13 9 == true\n#guard differAtOneBitPos 15 8 == false\n#guard differAtOneBitPos 2 4 == false\n", "test_list": ["#guard differAtOneBitPos 13 9 == true", "#guard differAtOneBitPos 15 8 == false", "#guard differAtOneBitPos 2 4 == false"]}
{"text": "Write a function to find all words which are at least 4 characters long in a string by using regex.", "task_id": 7, "code": "import Batteries\n\nopen Std\n\ndef findLongWords (text : String) : List String :=\n  text.splitOn.filter (fun x => x.length >= 4)\n\n#guard findLongWords \"Please move back to stream\" == [\"Please\", \"move\", \"back\", \"stream\"]\n#guard findLongWords \"Jing Eco and Tech\" == [\"Jing\", \"Tech\"]\n#guard findLongWords \"Jhingai wulu road Zone 3\" == [\"Jhingai\", \"wulu\", \"road\", \"Zone\"]\n", "test_list": ["#guard findLongWords \"Please move back to stream\" == [\"Please\", \"move\", \"back\", \"stream\"]", "#guard findLongWords \"Jing Eco and Tech\" == [\"Jing\", \"Tech\"]", "#guard findLongWords \"Jhingai wulu road Zone 3\" == [\"Jhingai\", \"wulu\", \"road\", \"Zone\"]"]}
{"text": "Write a function to find squares of individual elements in a list using lambda function.", "task_id": 8, "code": "import Batteries\n\nopen Std\n\ndef squareNums (nums : List Nat) : List Nat := nums.map (fun x => x ^ 2)\n\n#guard squareNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n#guard squareNums [10, 20, 30] == [100, 400, 900]\n#guard squareNums [12, 15] == [144, 225]\n", "test_list": ["#guard squareNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "#guard squareNums [10, 20, 30] == [100, 400, 900]", "#guard squareNums [12, 15] == [144, 225]"]}
{"text": "Write a python function to find the minimum number of rotations required to get the same string.", "task_id": 9, "code": "import Batteries\n\nopen Std\n\ndef findRotations (s : String) : Nat := Id.run do\n  let n := s.length\n  for k in [1 : n + 1] do\n    if s == (s.drop k) ++ (s.take k) then\n      return k\n  return n\n\n#guard findRotations \"aaaa\" == 1\n#guard findRotations \"ab\" == 2\n#guard findRotations \"abc\" == 3\n", "test_list": ["#guard findRotations \"aaaa\" == 1", "#guard findRotations \"ab\" == 2", "#guard findRotations \"abc\" == 3"]}
{"text": "Write a function to get the n smallest items from a dataset.", "task_id": 10, "code": "import Batteries\n\nopen Std\n\ndef removeFirst (xs : List Nat) (a : Nat) : List Nat :=\n  match xs with\n  | []      => []\n  | y :: ys => if y = a then ys else y :: removeFirst ys a\n\ndef listMin (x : Nat) (xs : List Nat) : Nat :=\n  xs.foldl (fun m z => if z < m then z else m) x\n\ndef smallNNum (xs : List Nat) (n : Nat) : List Nat :=\n  let rec loop (rest : List Nat) (k : Nat) (acc : List Nat) : List Nat :=\n    match k with\n    | 0        => acc.reverse\n    | k' + 1   =>\n      match rest with\n      | []      => acc.reverse\n      | y :: ys =>\n        let m   := listMin y ys\n        let rem := removeFirst (y :: ys) m\n        loop rem k' (m :: acc)\n  loop xs n []\n\n#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 2 == [10, 20]\n#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 5 == [10, 20, 20, 40, 50]\n#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 3 == [10, 20, 20]\n", "test_list": ["#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 2 == [10, 20]", "#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 5 == [10, 20, 20, 40, 50]", "#guard smallNNum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 3 == [10, 20, 20]"]}
{"text": "Write a python function to remove first and last occurrence of a given character from the string.", "task_id": 11, "code": "import Batteries\nopen Std\n\ndef removeOcc (s : String) (ch : Char) : String := Id.run do\n  let mut str := s\n  for i in [0 : str.length] do\n    if str.data[i]? == some ch then\n      str := (str.take i) ++ (str.drop (i + 1))\n      break\n  for i in (List.range str.length).reverse do\n    if str.data[i]? == some ch then\n      str := (str.take i) ++ (str.drop (i + 1))\n      break\n  return str\n\n#guard removeOcc \"hello\" 'l' == \"heo\"\n#guard removeOcc \"abcda\" 'a' == \"bcd\"\n#guard removeOcc \"PHP\" 'P' == \"H\"\n#guard removeOcc \"hellolloll\" 'l' == \"helollol\"\n#guard removeOcc \"\" 'l' == \"\"\n", "test_list": ["#guard removeOcc \"hello\" 'l' == \"heo\"", "#guard removeOcc \"abcda\" 'a' == \"bcd\"", "#guard removeOcc \"PHP\" 'P' == \"H\"", "#guard removeOcc \"hellolloll\" 'l' == \"helollol\"", "#guard removeOcc \"\" 'l' == \"\""]}
{"text": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "task_id": 12, "code": "import Batteries\nopen Std\n\ndef insert {α : Type} (cmp : α → α → Bool) (x : α) : List α → List α\n  | []      => [x]\n  | y :: ys => if cmp x y then x :: y :: ys else y :: insert cmp x ys\n\ndef isort {α : Type} (cmp : α → α → Bool) : List α → List α\n  | []       => []\n  | x :: xs  => insert cmp x (isort cmp xs)\n\ndef sortMatrix (M : List (List Int)) : List (List Int) :=\n  isort (fun a b => a.foldl (· + ·) 0 < b.foldl (· + ·) 0) M\n\n#eval sortMatrix [[1, 2, 3], [2, 4, 5], [1, 1, 1]] \n#eval sortMatrix [[1, 2, 3], [-2, 4, -5], [1, -1, 1]] \n#eval sortMatrix [[5, 8, 9], [6, 4, 3], [2, 1, 4]]\n", "test_list": []}
{"text": "Write a function to count the most common words in a dictionary.", "task_id": 13, "code": "import Batteries\nopen Std\n\nabbrev Entry := (String × Nat × Nat)  \n\ndef better (a b : Entry) : Bool :=\n  match a, b with\n  | (_, ca, ia), (_, cb, ib) => if ca == cb then ia < ib else ca > cb\n\ndef removeAtIdx {α} (xs : List α) (i : Nat) : List α :=\n  match xs, i with\n  | [], _ => []\n  | _ :: xs, 0 => xs\n  | x :: xs, i+1 => x :: removeAtIdx xs i\n\ndef findMaxIdx (xs : List Entry) : Option (Nat × Entry) :=\n  match xs with\n  | [] => none\n  | x :: xs =>\n    let rec loop (lst : List Entry) (i : Nat) (best : Entry) (bestIdx : Nat) : (Nat × Entry) :=\n      match lst with\n      | [] => (bestIdx, best)\n      | y :: ys =>\n        let best' := if better y best then y else best\n        let bestIdx' := if better y best then i else bestIdx\n        loop ys (i+1) best' bestIdx'\n    some <| loop xs 1 x 0\n\ndef lookupCount (xs : List (String × Nat)) (w : String) : Option Nat :=\n  match xs with\n  | [] => none\n  | (w', c) :: ys => if w' == w then some c else lookupCount ys w\n\ndef updateCount (xs : List (String × Nat)) (w : String) (c : Nat) : List (String × Nat) :=\n  match xs with\n  | [] => [(w, c)]\n  | (w', d) :: ys =>\n    if w' == w then\n      (w, c) :: ys\n    else\n      (w', d) :: updateCount ys w c\n\ndef countCommon (words : List String) : List (String × Nat) := Id.run do\n  let arr := words.toArray\n  let mut countsList : List (String × Nat) := []\n  let mut order : Array String := #[]\n  for i in [0:arr.size] do\n    let w := arr[i]!\n    match lookupCount countsList w with\n    | none =>\n      countsList := (w, 1) :: countsList\n      order := order.push w\n    | some c =>\n      countsList := updateCount countsList w (c + 1)\n  \n  let mut entries : List Entry := []\n  for j in [0:order.size] do\n    let w := order[j]!\n    let c := (lookupCount countsList w).getD 0\n    entries := (w, c, j) :: entries\n  \n  let k := 4\n  let mut xs := entries\n  let mut res : List (String × Nat) := []\n  for _ in [:k] do\n    match findMaxIdx xs with\n    | none => break\n    | some (j, best) =>\n      let (w, c, _) := best\n      res := res ++ [(w, c)]\n      xs := removeAtIdx xs j\n  return res\n\n#guard countCommon [\"red\",\"green\",\"black\",\"pink\",\"black\",\"white\",\"black\",\"eyes\",\"white\",\"black\",\"orange\",\"pink\",\"pink\",\"red\",\"red\",\"white\",\"orange\",\"white\",\"black\",\"pink\",\"green\",\"green\",\"pink\",\"green\",\"pink\",\"white\",\"orange\",\"orange\",\"red\"] == [(\"pink\", 6), (\"black\", 5), (\"white\", 5), (\"red\", 4)]\n#guard countCommon [\"one\", \"two\", \"three\", \"four\", \"five\", \"one\", \"two\", \"one\", \"three\", \"one\"] == [(\"one\", 4), (\"two\", 2), (\"three\", 2), (\"four\", 1)]\n#guard countCommon [\"Facebook\", \"Apple\", \"Amazon\", \"Netflix\", \"Google\", \"Apple\", \"Netflix\", \"Amazon\"] == [(\"Apple\", 2), (\"Amazon\", 2), (\"Netflix\", 2), (\"Facebook\", 1)]\n", "test_list": ["#guard countCommon [\"red\",\"green\",\"black\",\"pink\",\"black\",\"white\",\"black\",\"eyes\",\"white\",\"black\",\"orange\",\"pink\",\"pink\",\"red\",\"red\",\"white\",\"orange\",\"white\",\"black\",\"pink\",\"green\",\"green\",\"pink\",\"green\",\"pink\",\"white\",\"orange\",\"orange\",\"red\"] == [(\"pink\", 6), (\"black\", 5), (\"white\", 5), (\"red\", 4)]", "#guard countCommon [\"one\", \"two\", \"three\", \"four\", \"five\", \"one\", \"two\", \"one\", \"three\", \"one\"] == [(\"one\", 4), (\"two\", 2), (\"three\", 2), (\"four\", 1)]", "#guard countCommon [\"Facebook\", \"Apple\", \"Amazon\", \"Netflix\", \"Google\", \"Apple\", \"Netflix\", \"Amazon\"] == [(\"Apple\", 2), (\"Amazon\", 2), (\"Netflix\", 2), (\"Facebook\", 1)]"]}
{"text": "Write a python function to find the volume of a triangular prism.", "task_id": 14, "code": "import Batteries\n\nopen Std\n\ndef findVolume (l b h : Nat) : Nat :=\n  (l * b * h) / 2\n\n#guard findVolume 10 8 6 == 240\n#guard findVolume 3 2 2 == 6\n#guard findVolume 1 2 1 == 1\n", "test_list": ["#guard findVolume 10 8 6 == 240", "#guard findVolume 3 2 2 == 6", "#guard findVolume 1 2 1 == 1"]}
{"text": "Write a function to split a string at lowercase letters.", "task_id": 15, "code": "import Batteries\nopen Std\n\ndef splitLowerString (text : String) : List String :=\n  let rec aux (current : String) (remaining : List Char) (acc : List String) : List String :=\n    match remaining with\n    | [] => if current.isEmpty then acc else acc ++ [current]\n    | c::cs =>\n      if c.isLower then\n        if current.isEmpty then\n          aux (String.mk [c]) cs acc\n        else\n          aux (String.mk [c]) cs (acc ++ [current])\n      else\n        aux (current.push c) cs acc\n  aux \"\" text.data []\n\n#eval splitLowerString \"AbCd\" == [\"bC\", \"d\"]\n#eval splitLowerString \"Python\" == [\"y\", \"t\", \"h\", \"o\", \"n\"]\n#eval splitLowerString \"Programming\" == [\"r\", \"o\", \"g\", \"r\", \"a\", \"m\", \"m\", \"i\", \"n\", \"g\"]\n", "test_list": []}
{"text": "Write a function to find sequences of lowercase letters joined with an underscore.", "task_id": 16, "code": "import Batteries\n\nopen Std\n\ndef natLe (a b : Nat) : Bool :=\n  match Nat.decLe a b with\n  | isTrue _ => true\n  | isFalse _ => false\n\ndef charLe (a b : Char) : Bool := natLe a.toNat b.toNat\n\ndef isLowerAscii (c : Char) : Bool := charLe 'a' c && charLe c 'z'\n\ndef allLowerAscii (s : String) : Bool := (s.toList).all isLowerAscii\n\ndef text_lowercase_underscore (text : String) : String :=\n  let parts := text.splitOn \"_\"\n  if parts.length == 2 then\n    let a := parts.getD 0 \"\"\n    let b := parts.getD 1 \"\"\n    if a != \"\" && b != \"\" && allLowerAscii a && allLowerAscii b then\n      \"Found a match!\"\n    else\n      \"Not matched!\"\n  else\n    \"Not matched!\"\n\n#guard text_lowercase_underscore \"aab_cbbbc\" = \"Found a match!\"\n#guard text_lowercase_underscore \"aab_Abbbc\" = \"Not matched!\"\n#guard text_lowercase_underscore \"Aaab_abbbc\" = \"Not matched!\"\n#guard text_lowercase_underscore \"aab-cbbbc\" = \"Not matched!\"\n", "test_list": ["#guard text_lowercase_underscore \"aab_cbbbc\" = \"Found a match!\"", "#guard text_lowercase_underscore \"aab_Abbbc\" = \"Not matched!\"", "#guard text_lowercase_underscore \"Aaab_abbbc\" = \"Not matched!\"", "#guard text_lowercase_underscore \"aab-cbbbc\" = \"Not matched!\""]}
{"text": "Write a function to find the perimeter of a square.", "task_id": 17, "code": "import Batteries\n\nopen Std\n\ndef squarePerimeter (a : Nat) : Nat :=\n  4 * a\n\n#guard squarePerimeter 10 == 40\n#guard squarePerimeter 5 == 20\n#guard squarePerimeter 4 == 16\n", "test_list": ["#guard squarePerimeter 10 == 40", "#guard squarePerimeter 5 == 20", "#guard squarePerimeter 4 == 16"]}
{"text": "Write a function to remove characters from the first string which are present in the second string.", "task_id": 18, "code": "import Batteries\nopen Std\n\ndef NO_OF_CHARS : Nat := 256\n\ndef strToList (s : String) : List Char := s.toList\n\ndef lstToString (L : List Char) : String := String.mk L\n\ndef getCharCountArray (s : String) : Array Nat := Id.run do\n  let mut count := Array.replicate NO_OF_CHARS 0\n  for c in s.toList do\n    let idx := c.toNat\n    \n    count := count.set! idx (count[idx]! + 1)\n  return count\n\ndef removeDirtyChars (string second_string : String) : String := Id.run do\n  let count := getCharCountArray second_string\n  let mut res_ind := 0\n  let mut str_list := (strToList string).toArray\n  for ip_ind in [0 : str_list.size] do\n    let c := str_list[ip_ind]!\n    let idx := c.toNat\n    if count[idx]! == 0 then\n      str_list := str_list.set! res_ind c\n      res_ind := res_ind + 1\n    else\n      pure ()\n  return lstToString ((str_list.extract 0 res_ind).toList)\n\n#guard removeDirtyChars \"probasscurve\" \"pros\" = \"bacuve\"\n#guard removeDirtyChars \"digitalindia\" \"talent\" = \"digiidi\"\n#guard removeDirtyChars \"exoticmiles\" \"toxic\" = \"emles\"\n", "test_list": ["#guard removeDirtyChars \"probasscurve\" \"pros\" = \"bacuve\"", "#guard removeDirtyChars \"digitalindia\" \"talent\" = \"digiidi\"", "#guard removeDirtyChars \"exoticmiles\" \"toxic\" = \"emles\""]}
{"text": "Write a function to find whether a given array of integers contains any duplicate element.", "task_id": 19, "code": "import Batteries\n\nopen Std\n\ndef testDuplicate (arraynums : List Int) : Bool :=\n  let numsSet := arraynums.foldl (fun acc x => acc.insert x) HashSet.emptyWithCapacity\n  arraynums.length ≠ numsSet.size\n\n#guard testDuplicate [1, 2, 3, 4, 5] = false\n#guard testDuplicate [1, 2, 3, 4, 4] = true\n#guard testDuplicate [1, 1, 2, 2, 3, 3, 4, 4, 5] = true\n", "test_list": ["#guard testDuplicate [1, 2, 3, 4, 5] = false", "#guard testDuplicate [1, 2, 3, 4, 4] = true", "#guard testDuplicate [1, 1, 2, 2, 3, 3, 4, 4, 5] = true"]}
{"text": "Write a function to check if the given number is woodball or not.", "task_id": 20, "code": "import Batteries\n\nopen Std\n\ndef isWoodall (x : Int) : Bool := Id.run do\n  if x % 2 == 0 then\n    return false\n  if x == 1 then\n    return true\n  let mut x := x + 1\n  let mut p := 0\n  while x % 2 == 0 do\n    x := x / 2\n    p := p + 1\n    if p == x then\n      return true\n  return false\n\n#guard isWoodall 383 == true\n#guard isWoodall 254 == false\n#guard isWoodall 200 == false\n#guard isWoodall 32212254719 == true\n#guard isWoodall 32212254718 == false\n#guard isWoodall 159 == true\n", "test_list": ["#guard isWoodall 383 == true", "#guard isWoodall 254 == false", "#guard isWoodall 200 == false", "#guard isWoodall 32212254719 == true", "#guard isWoodall 32212254718 == false", "#guard isWoodall 159 == true"]}
{"text": "Write a function to find m number of multiples of n.", "task_id": 21, "code": "import Batteries\nopen Std\n\ndef multiplesOfNum (m n : Nat) : List Nat :=\n  (List.range m).map (λ i => n * (i + 1))\n\n#guard multiplesOfNum 4 3 == [3, 6, 9, 12]\n#guard multiplesOfNum 2 5 == [5, 10]\n#guard multiplesOfNum 9 2 == [2, 4, 6, 8, 10, 12, 14, 16, 18]\n", "test_list": ["#guard multiplesOfNum 4 3 == [3, 6, 9, 12]", "#guard multiplesOfNum 2 5 == [5, 10]", "#guard multiplesOfNum 9 2 == [2, 4, 6, 8, 10, 12, 14, 16, 18]"]}
{"text": "Write a function to find the first duplicate element in a given array of integers.", "task_id": 22, "code": "import Batteries\n\nopen Std\n\ndef findFirstDuplicate (nums : List Int) : Int := Id.run do\n  let mut numSet := HashSet.empty\n  let noDuplicate := -1\n  for num in nums do\n    if numSet.contains num then\n      return num\n    else\n      numSet := numSet.insert num\n  return noDuplicate\n\n#guard findFirstDuplicate [1, 2, 3, 4, 4, 5] == 4\n#guard findFirstDuplicate [1, 2, 3, 4] == -1\n#guard findFirstDuplicate [1, 1, 2, 3, 3, 2, 2] == 1\n", "test_list": ["#guard findFirstDuplicate [1, 2, 3, 4, 4, 5] == 4", "#guard findFirstDuplicate [1, 2, 3, 4] == -1", "#guard findFirstDuplicate [1, 1, 2, 3, 3, 2, 2] == 1"]}
{"text": "Write a python function to find the maximum sum of elements of list in a list of lists.", "task_id": 23, "code": "import Batteries\n\nopen Std\n\ndef maximumSum (list1 : List (List Int)) : Int :=\n  list1.foldl (fun maxi x =>\n    let sum := x.foldl (fun acc y => acc + y) 0\n    if sum > maxi then sum else maxi\n  ) (-100000)\n\n#guard maximumSum [[1,2,3],[4,5,6],[10,11,12],[7,8,9]] == 33\n#guard maximumSum [[0,1,1],[1,1,2],[3,2,1]] == 6\n#guard maximumSum [[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]] == 19\n#guard maximumSum [[0,-1,-1],[-1,-1,-2],[-3,-2,-1]] == -2\n", "test_list": ["#guard maximumSum [[1,2,3],[4,5,6],[10,11,12],[7,8,9]] == 33", "#guard maximumSum [[0,1,1],[1,1,2],[3,2,1]] == 6", "#guard maximumSum [[0,1,3],[1,2,1],[9,8,2],[0,1,0],[6,4,8]] == 19", "#guard maximumSum [[0,-1,-1],[-1,-1,-2],[-3,-2,-1]] == -2"]}
{"text": "Write a function to convert the given binary number to its decimal equivalent.", "task_id": 24, "code": "import Batteries\n\nopen Std\n\ndef binaryToDecimal (binary : Nat) : Nat := Id.run do\n  let mut binary1 := binary\n  let mut decimal := 0\n  let mut i := 0\n  while binary1 != 0 do\n    let dec := binary1 % 10\n    decimal := decimal + dec * 2 ^ i\n    binary1 := binary1 / 10\n    i := i + 1\n  return decimal\n\n#guard binaryToDecimal 100 == 4\n#guard binaryToDecimal 1011 == 11\n#guard binaryToDecimal 1101101 == 109\n", "test_list": ["#guard binaryToDecimal 100 == 4", "#guard binaryToDecimal 1011 == 11", "#guard binaryToDecimal 1101101 == 109"]}
{"text": "Write a python function to find the product of non-repeated elements in a given array.", "task_id": 25, "code": "import Batteries\nopen Std\n\ndef minOfList (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => t.foldl (fun m x => if x < m then x else m) h\n\ndef removeOne (x : Nat) (l : List Nat) : List Nat :=\n  match l with\n  | [] => []\n  | h :: t => if h == x then t else h :: removeOne x t\n\ndef selectionSort (l : List Nat) : List Nat :=\n  Id.run do\n    let mut remaining := l\n    let mut acc : List Nat := []\n    let len := remaining.length\n    for _ in [0:len] do\n      match remaining with\n      | [] => pure ()\n      | _ =>\n        let m := minOfList remaining\n        remaining := removeOne m remaining\n        acc := acc ++ [m]\n    return acc\n\ndef nthD (l : List Nat) (i : Nat) (d : Nat) : Nat :=\n  match l.drop i with\n  | [] => d\n  | h :: _ => h\n\ndef findProduct (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let sorted := selectionSort arr\n  let mut prod := 1\n  for i in [0 : n] do\n    let prev := if i == 0 then nthD sorted (n - 1) 0 else nthD sorted (i - 1) 0\n    let curr := nthD sorted i 0\n    if prev == curr then\n      pure ()\n    else\n      prod := prod * curr\n  return prod\n\n#guard findProduct [1,1,2,3] 4 = 6\n#guard findProduct [1,2,3,1,1] 5 = 6\n#guard findProduct [1,1,4,5,6] 5 = 120\n\n#guard findProduct [1,1,4,5,6,5,7,1,1,3,4] 11 = 2520\n", "test_list": ["#guard findProduct [1,1,2,3] 4 = 6", "#guard findProduct [1,2,3,1,1] 5 = 6", "#guard findProduct [1,1,4,5,6] 5 = 120", "#guard findProduct [1,1,4,5,6,5,7,1,1,3,4] 11 = 2520"]}
{"text": "Write a function to check if the given tuple list has all k elements.", "task_id": 26, "code": "import Batteries\nopen Std\n\ndef checkKElements (testList : List (List Nat)) (k : Nat) : Bool :=\n  let res :=\n    testList.all fun tup =>\n      tup.all fun ele => ele == k\n  res\n\n#guard checkKElements [[4, 4], [4, 4, 4], [4, 4], [4, 4, 4, 4], [4]] 4 == true\n#guard checkKElements [[7, 7, 7], [7, 7]] 7 == true\n#guard checkKElements [[9, 9], [9, 9, 9, 9]] 7 == false\n#guard checkKElements [[4, 4], [4, 4, 4], [4, 4], [4, 4, 6, 4], [4]] 4 == false\n", "test_list": ["#guard checkKElements [[4, 4], [4, 4, 4], [4, 4], [4, 4, 4, 4], [4]] 4 == true", "#guard checkKElements [[7, 7, 7], [7, 7]] 7 == true", "#guard checkKElements [[9, 9], [9, 9, 9, 9]] 7 == false", "#guard checkKElements [[4, 4], [4, 4, 4], [4, 4], [4, 4, 6, 4], [4]] 4 == false"]}
{"text": "Write a python function to remove all digits from a list of strings.", "task_id": 27, "code": "import Batteries\n\nopen Std\n\ndef removeDigits (list : List String) : List String :=\n  let pattern := \"[0-9]\"\n  list.map (fun s => s.foldl (fun acc c => if c.isDigit then acc else acc.push c) \"\")\n\n#guard removeDigits [\"4words\", \"3letters\", \"4digits\"] == [\"words\", \"letters\", \"digits\"]\n#guard removeDigits [\"28Jan\", \"12Jan\", \"11Jan\"] == [\"Jan\", \"Jan\", \"Jan\"]\n#guard removeDigits [\"wonder1\", \"wonder2\", \"wonder3\"] == [\"wonder\", \"wonder\", \"wonder\"]\n", "test_list": ["#guard removeDigits [\"4words\", \"3letters\", \"4digits\"] == [\"words\", \"letters\", \"digits\"]", "#guard removeDigits [\"28Jan\", \"12Jan\", \"11Jan\"] == [\"Jan\", \"Jan\", \"Jan\"]", "#guard removeDigits [\"wonder1\", \"wonder2\", \"wonder3\"] == [\"wonder\", \"wonder\", \"wonder\"]"]}
{"text": "Write a python function to find binomial co-efficient.", "task_id": 28, "code": "import Batteries\n\nopen Std\n\ndef binomial_Coeff (n k : Nat) : Nat :=\n  match n with\n  | 0 => if k == 0 then 1 else 0\n  | Nat.succ n' =>\n    if k > Nat.succ n' then 0\n    else if k == 0 || k == Nat.succ n' then 1\n    else binomial_Coeff n' (k - 1) + binomial_Coeff n' k\n\n#guard binomial_Coeff 5 2 = 10\n#guard binomial_Coeff 4 3 = 4\n#guard binomial_Coeff 3 2 = 3\n#guard binomial_Coeff 14 6 = 3003\n", "test_list": ["#guard binomial_Coeff 5 2 = 10", "#guard binomial_Coeff 4 3 = 4", "#guard binomial_Coeff 3 2 = 3", "#guard binomial_Coeff 14 6 = 3003"]}
{"text": "Write a python function to find the element occurring odd number of times.", "task_id": 29, "code": "import Batteries\nopen Std\n\ndef getOddOccurrence (arr : List Int) (arrSize : Nat) : Int :=\n  let rec findOdd (i : Nat) : Int :=\n    if i >= arrSize then -1 else\n      let count := (List.range arrSize).foldl (fun acc j => if arr.getD i 0 == arr.getD j 0 then acc + 1 else acc) 0\n      if count % 2 != 0 then arr.getD i 0 else findOdd (i + 1)\n  findOdd 0\n\n#guard getOddOccurrence [1, 2, 3, 1, 2, 3, 1] 7 == 1\n#guard getOddOccurrence [1, 2, 3, 2, 3, 1, 3] 7 == 3\n#guard getOddOccurrence [2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2] 13 == 5\n", "test_list": ["#guard getOddOccurrence [1, 2, 3, 1, 2, 3, 1] 7 == 1", "#guard getOddOccurrence [1, 2, 3, 2, 3, 1, 3] 7 == 3", "#guard getOddOccurrence [2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2] 13 == 5"]}
{"text": "Write a python function to count all the substrings starting and ending with same characters.", "task_id": 30, "code": "import Batteries\nopen Std\n\ndef checkEquality (s : String) : Bool :=\n  s.data.headD ' ' == s.data.reverse.headD ' '\n\ndef countSubstringWithEqualEnds (s : String) : Nat :=\n  let n := s.length\n  let rec loop (i j result : Nat) : Nat :=\n    if i < n then\n      if j < n - i + 1 then\n        let subStr := s.drop i |>.take j\n        let newResult := if checkEquality subStr then result + 1 else result\n        loop i (j + 1) newResult\n      else\n        loop (i + 1) 1 result\n    else\n        result\n  loop 0 1 0\n\n#guard countSubstringWithEqualEnds \"abc\" == 3\n#guard countSubstringWithEqualEnds \"abcda\" == 6\n#guard countSubstringWithEqualEnds \"ab\" == 2\n", "test_list": ["#guard countSubstringWithEqualEnds \"abc\" == 3", "#guard countSubstringWithEqualEnds \"abcda\" == 6", "#guard countSubstringWithEqualEnds \"ab\" == 2"]}
{"text": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.", "task_id": 31, "code": "import Batteries\nopen Std\n\ndef ltPair (p q : Nat × Nat) : Bool :=\n  if p.fst < q.fst then true\n  else if q.fst < p.fst then false\n  else if p.snd < q.snd then true else false\n\ndef findMinPair (xs : List (Nat × Nat)) : Option (Nat × Nat) :=\n  xs.foldl (fun acc x =>\n    match acc with\n    | none => some x\n    | some m => if ltPair x m then some x else some m\n  ) none\n\ndef removeFirstPair (xs : List (Nat × Nat)) (p : Nat × Nat) : List (Nat × Nat) :=\n  match xs with\n  | [] => []\n  | y :: ys => if y = p then ys else y :: removeFirstPair ys p\n\ndef countsFindOpt (xs : List (Nat × Nat)) (k : Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | (k', v) :: ys => if k = k' then some v else countsFindOpt ys k\n\ndef countsInc (xs : List (Nat × Nat)) (k : Nat) : List (Nat × Nat) :=\n  match xs with\n  | [] => []\n  | (k', v) :: ys =>\n    if k = k' then\n      (k', v + 1) :: ys\n    else\n      (k', v) :: countsInc ys k\n\ndef func (nums : List (List Nat)) (k : Nat) : List Nat := Id.run do\n  if k == 0 then\n    return []\n  let mut counts : List (Nat × Nat) := []\n  let mut order : Array Nat := #[]\n  \n  for row in nums do\n    for i in row do\n      match countsFindOpt counts i with\n      | some _ =>\n        counts := countsInc counts i\n      | none =>\n        counts := (i, 1) :: counts\n        order := order.push i\n  \n  let mut temp : List (Nat × Nat) := []  \n  for key in order.toList do\n    let v := match countsFindOpt counts key with | some c => c | none => 0\n    if temp.length < k then\n      temp := (v, key) :: temp\n      \n    else\n      match findMinPair temp with\n      | none => ()\n      | some p =>\n        if v > p.fst then\n          temp := removeFirstPair temp p\n          temp := (v, key) :: temp\n        else\n          ()\n  \n  let pops := temp.length\n  let mut result : List Nat := []\n  for _ in [: pops] do\n    match findMinPair temp with\n    | none => ()\n    | some p =>\n      result := result ++ [p.snd]\n      temp := removeFirstPair temp p\n  return result\n\n#guard func [[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]] 3 == [5, 7, 1]\n#guard func [[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]] 1 == [1]\n#guard func [[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]] 5 == [6, 5, 7, 8, 1]\n", "test_list": ["#guard func [[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]] 3 == [5, 7, 1]", "#guard func [[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]] 1 == [1]", "#guard func [[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]] 5 == [6, 5, 7, 8, 1]"]}
{"text": "Write a python function to find the largest prime factor of a given number.", "task_id": 32, "code": "import Batteries\nopen Std\n\ndef maxPrimeFactors (n : Nat) : Nat := Id.run do\n  let mut n := n\n  let mut maxPrime := 0\n  while n % 2 == 0 do\n    maxPrime := 2\n    n := n / 2\n  let sqrt_n : Nat := Nat.sqrt n\n  for i in [3: sqrt_n + 1] do\n    if i % 2 == 1 then\n      while n % i == 0 do\n        maxPrime := i\n        n := n / i\n  if n > 2 then\n    maxPrime := n\n  return maxPrime\n\n#guard maxPrimeFactors 15 == 5\n#guard maxPrimeFactors 6 == 3\n#guard maxPrimeFactors 2 == 2\n", "test_list": ["#guard maxPrimeFactors 15 == 5", "#guard maxPrimeFactors 6 == 3", "#guard maxPrimeFactors 2 == 2"]}
{"text": "Write a python function to convert a decimal number to binary number.", "task_id": 33, "code": "import Batteries\n\nopen Std\n\ndef decimalToBinary (N : Nat) : Nat := Id.run do\n  let mut N := N\n  let mut bNumber : Nat := 0\n  let mut cnt : Nat := 0\n  while N != 0 do\n    let rem := N % 2\n    let c := Nat.pow 10 cnt\n    bNumber := bNumber + rem * c\n    N := N / 2\n    cnt := cnt + 1\n  return bNumber\n\n#guard decimalToBinary 10 = 1010\n#guard decimalToBinary 1 = 1\n#guard decimalToBinary 20 = 10100\n", "test_list": ["#guard decimalToBinary 10 = 1010", "#guard decimalToBinary 1 = 1", "#guard decimalToBinary 20 = 10100"]}
{"text": "Write a python function to find the missing number in a sorted array.", "task_id": 34, "code": "import Batteries\n\nopen Std\n\ndef findMissing (ar : List Nat) (N : Nat) : Int := Id.run do\n  \n  \n  \n  \n  let mut l : Nat := 0\n  let mut r : Nat := N - 1\n  while Nat.ble l r do\n    let mid := (l + r) / 2\n    let aMid := ar.getD mid 0\n    if (aMid ≠ mid + 1) ∧ (ar.getD (mid - 1) 0 = mid) then\n      return (Int.ofNat (mid + 1))\n    else if aMid ≠ mid + 1 then\n      r := mid - 1\n    else\n      l := mid + 1\n  return (-1)\n\n#guard findMissing [1, 2, 3, 5] 4 = (4 : Int)\n#guard findMissing [1, 3, 4, 5] 4 = (2 : Int)\n#guard findMissing [1, 2, 3, 5, 6, 7] 5 = (4 : Int)\n", "test_list": ["#guard findMissing [1, 2, 3, 5] 4 = (4 : Int)", "#guard findMissing [1, 3, 4, 5] 4 = (2 : Int)", "#guard findMissing [1, 2, 3, 5, 6, 7] 5 = (4 : Int)"]}
{"text": "Write a function to find the n-th rectangular number.", "task_id": 35, "code": "import Batteries\n\nopen Std\n\ndef findRectNum (n : Nat) : Nat :=\n  n * (n + 1)\n\n#guard findRectNum 4 == 20\n#guard findRectNum 5 == 30\n#guard findRectNum 6 == 42\n", "test_list": ["#guard findRectNum 4 == 20", "#guard findRectNum 5 == 30", "#guard findRectNum 6 == 42"]}
{"text": "Write a python function to find the nth digit in the proper fraction of two given numbers.", "task_id": 36, "code": "import Batteries\n\nopen Std\n\ndef findNthDigit (p q N : Nat) : Nat := Id.run do\n  let mut p := p\n  let mut N := N\n  let mut res := 0\n  while N > 0 do\n    N := N - 1\n    p := p * 10\n    res := p / q\n    p := p % q\n  return res\n\n#guard findNthDigit 1 2 1 == 5\n#guard findNthDigit 3 5 1 == 6\n#guard findNthDigit 5 6 5 == 3\n", "test_list": ["#guard findNthDigit 1 2 1 == 5", "#guard findNthDigit 3 5 1 == 6", "#guard findNthDigit 5 6 5 == 3"]}
{"text": "Write a function to sort a given mixed list of integers and strings.", "task_id": 37, "code": "import Batteries\n\nopen Std\n\ninductive Mixed where\n  | int (n : Nat)\n  | str (s : String)\n  deriving Repr, DecidableEq\n\nprivate def strLe (a b : String) : Bool :=\n  match compare a b with\n  | Ordering.lt => true\n  | Ordering.eq => true\n  | Ordering.gt => false\n\nprivate def removeOne [BEq α] (x : α) : List α → List α\n  | [] => []\n  | y :: ys => if x == y then ys else y :: removeOne x ys\n\nprivate def findMin? (le : α → α → Bool) (xs : List α) : Option α :=\n  match xs with\n  | [] => none\n  | x :: xs' => some <| xs'.foldl (fun m y => if le y m then y else m) x\n\nprivate def selectionSortBy [BEq α] (le : α → α → Bool) (xs : List α) : List α := Id.run do\n  let mut ys := xs\n  let mut acc : List α := []\n  let maxIters := xs.length\n  for _ in [: maxIters] do\n    match findMin? le ys with\n    | none => break\n    | some m =>\n      acc := m :: acc\n      ys := removeOne m ys\n  return acc.reverse\n\ndef sortMixedList (mixedList : List Mixed) : List Mixed :=\n  let intPart : List Nat := mixedList.filterMap (fun\n    | Mixed.int n => some n\n    | _ => none)\n  let strPart : List String := mixedList.filterMap (fun\n    | Mixed.str s => some s\n    | _ => none)\n  let intSorted := selectionSortBy Nat.ble intPart\n  let strSorted := selectionSortBy strLe strPart\n  intSorted.map Mixed.int ++ strSorted.map Mixed.str\n\n#guard sortMixedList [Mixed.int 19, Mixed.str \"red\", Mixed.int 12, Mixed.str \"green\", Mixed.str \"blue\", Mixed.int 10, Mixed.str \"white\", Mixed.str \"green\", Mixed.int 1]\n  = [Task37.Mixed.int 1, Task37.Mixed.int 10, Task37.Mixed.int 12, Task37.Mixed.int 19,\n     Task37.Mixed.str \"blue\", Task37.Mixed.str \"green\", Task37.Mixed.str \"green\", Task37.Mixed.str \"red\", Task37.Mixed.str \"white\"]\n#guard sortMixedList [Mixed.int 19, Mixed.str \"red\", Mixed.int 12, Mixed.str \"green\", Mixed.str \"blue\", Mixed.int 10, Mixed.str \"white\", Mixed.str \"green\", Mixed.int 1]\n  = [Task37.Mixed.int 1, Task37.Mixed.int 10, Task37.Mixed.int 12, Task37.Mixed.int 19,\n     Task37.Mixed.str \"blue\", Task37.Mixed.str \"green\", Task37.Mixed.str \"green\", Task37.Mixed.str \"red\", Task37.Mixed.str \"white\"]\n#guard sortMixedList [Mixed.int 19, Mixed.str \"red\", Mixed.int 12, Mixed.str \"green\", Mixed.str \"blue\", Mixed.int 10, Mixed.str \"white\", Mixed.str \"green\", Mixed.int 1]\n  = [Task37.Mixed.int 1, Task37.Mixed.int 10, Task37.Mixed.int 12, Task37.Mixed.int 19,\n     Task37.Mixed.str \"blue\", Task37.Mixed.str \"green\", Task37.Mixed.str \"green\", Task37.Mixed.str \"red\", Task37.Mixed.str \"white\"]\n", "test_list": ["#guard sortMixedList [Mixed.int 19, Mixed.str \"red\", Mixed.int 12, Mixed.str \"green\", Mixed.str \"blue\", Mixed.int 10, Mixed.str \"white\", Mixed.str \"green\", Mixed.int 1]", "#guard sortMixedList [Mixed.int 19, Mixed.str \"red\", Mixed.int 12, Mixed.str \"green\", Mixed.str \"blue\", Mixed.int 10, Mixed.str \"white\", Mixed.str \"green\", Mixed.int 1]", "#guard sortMixedList [Mixed.int 19, Mixed.str \"red\", Mixed.int 12, Mixed.str \"green\", Mixed.str \"blue\", Mixed.int 10, Mixed.str \"white\", Mixed.str \"green\", Mixed.int 1]"]}
{"text": "Write a function to find the division of first even and odd number of a given list.", "task_id": 38, "code": "import Batteries\n\nopen Std\n\ndef divEvenOdd (list1 : List Int) : Int :=\n  let firstEven := list1.find? (fun el => el % 2 == 0) |>.getD (-1)\n  let firstOdd := list1.find? (fun el => el % 2 != 0) |>.getD (-1)\n  firstEven / firstOdd\n\n#guard divEvenOdd [1,3,5,7,4,1,6,8] == 4\n#guard divEvenOdd [1,2,3,4,5,6,7,8,9,10] == 2\n#guard divEvenOdd [1,5,7,9,10] == 10\n", "test_list": ["#guard divEvenOdd [1,3,5,7,4,1,6,8] == 4", "#guard divEvenOdd [1,2,3,4,5,6,7,8,9,10] == 2", "#guard divEvenOdd [1,5,7,9,10] == 10"]}
{"text": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.", "task_id": 39, "code": "import Batteries\n\nopen Std\n\ndef countChar (xs : List Char) (c : Char) : Nat :=\n  xs.foldl (fun acc x => if x == c then acc + 1 else acc) 0\n\ndef dedupChars (xs : List Char) : List Char :=\n  let rec go (xs : List Char) (seen : HashSet Char) (acc : List Char) : List Char :=\n    match xs with\n    | [] => acc.reverse\n    | c :: cs =>\n      if seen.contains c then\n        go cs seen acc\n      else\n        go cs (seen.insert c) (c :: acc)\n  go xs ({} : HashSet Char) []\n\nprivate def pairBetter (a b : Nat × Char) : Bool :=\n  if a.fst == b.fst then a.snd < b.snd else a.fst > b.fst\n\ndef pickMax (xs : List (Nat × Char)) : Option ((Nat × Char) × List (Nat × Char)) :=\n  match xs with\n  | [] => none\n  | x :: xs =>\n    let rec go (best : Nat × Char) (ys : List (Nat × Char)) (acc : List (Nat × Char)) : (Nat × Char) × List (Nat × Char) :=\n      match ys with\n      | [] => (best, acc.reverse)\n      | y :: ys' =>\n        if pairBetter y best then\n          go y ys' (best :: acc)\n        else\n          go best ys' (y :: acc)\n    let (best, rest) := go x xs []\n    some (best, rest)\n\npartial def loopRearr (pairs : List (Nat × Char)) (remaining : Nat) (ans : String) : String :=\n  if remaining == 0 then\n    ans\n  else\n    match pickMax pairs with\n    | none => ans\n    | some (p1, rest1) =>\n      if remaining == 1 then\n        ans.push p1.snd\n      else\n        match pickMax rest1 with\n        | none => ans.push p1.snd\n        | some (p2, rest2) =>\n          let ans' := (ans.push p1.snd).push p2.snd\n          let rest2' :=\n            let l0 := rest2\n            let l1 := if p1.fst - 1 > 0 then (p1.fst - 1, p1.snd) :: l0 else l0\n            let l2 := if p2.fst - 1 > 0 then (p2.fst - 1, p2.snd) :: l1 else l1\n            l2\n          loopRearr rest2' (remaining - 2) ans'\n\ndef rearangeString (S : String) : String :=\n  let chars := S.toList\n  let uniq := dedupChars chars\n  let pairs : List (Nat × Char) := uniq.map (fun c => (countChar chars c, c))\n  let maxCount := pairs.foldl (fun m p => Nat.max m p.fst) 0\n  let n := S.length\n  if maxCount * 2 > n + 1 then\n    \"\"\n  else\n    loopRearr pairs n \"\"\n\n#guard rearangeString \"aab\" == \"aba\"\n#guard rearangeString \"aabb\" == \"abab\"\n#guard rearangeString \"abccdd\" == \"cdabcd\"\n", "test_list": ["#guard rearangeString \"aab\" == \"aba\"", "#guard rearangeString \"aabb\" == \"abab\"", "#guard rearangeString \"abccdd\" == \"cdabcd\""]}
{"text": "Write a function to find frequency of the elements in a given list of lists using collections module.", "task_id": 40, "code": "import Batteries\nopen Std\n\ndef lookupHMNat (m : Std.HashMap Nat Nat) (k : Nat) : Option Nat := Id.run do\n  let mut res : Option Nat := none\n  for (k2, v2) in m do\n    if k2 = k then\n      res := some v2\n  return res\n\ndef freqElement (nums : List (List Nat)) : Std.HashMap Nat Nat := Id.run do\n  let mut m : Std.HashMap Nat Nat := {}\n  for sub in nums do\n    for x in sub do\n      let c := (lookupHMNat m x).getD 0\n      m := m.insert x (c + 1)\n  return m\n\ndef hashMapEqNat (m1 m2 : Std.HashMap Nat Nat) : Bool := Id.run do\n  if m1.size != m2.size then\n    return false\n  let mut ok := true\n  for (k, v) in m1 do\n    match lookupHMNat m2 k with\n    | some v2 => if v2 != v then ok := false\n    | none => ok := false\n    if !ok then break\n  return ok\n\n#guard hashMapEqNat (freqElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]]) (Std.HashMap.ofList [(2, 3), (1, 2), (5, 2), (3, 1), (4, 1), (6, 1), (7, 1), (9, 1)])\n#guard hashMapEqNat (freqElement [[1,2,3,4],[5,6,7,8],[9,10,11,12]]) (Std.HashMap.ofList [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1)])\n#guard hashMapEqNat (freqElement [[15,20,30,40],[80,90,100,110],[30,30,80,90]]) (Std.HashMap.ofList [(30,3),(80,2),(90,2),(15,1),(20,1),(40,1),(100,1),(110,1)])\n", "test_list": ["#guard hashMapEqNat (freqElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]]) (Std.HashMap.ofList [(2, 3), (1, 2), (5, 2), (3, 1), (4, 1), (6, 1), (7, 1), (9, 1)])", "#guard hashMapEqNat (freqElement [[1,2,3,4],[5,6,7,8],[9,10,11,12]]) (Std.HashMap.ofList [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1),(11,1),(12,1)])", "#guard hashMapEqNat (freqElement [[15,20,30,40],[80,90,100,110],[30,30,80,90]]) (Std.HashMap.ofList [(30,3),(80,2),(90,2),(15,1),(20,1),(40,1),(100,1),(110,1)])"]}
{"text": "Write a function to filter even numbers using lambda function.", "task_id": 41, "code": "import Batteries\n\nopen Std\n\ndef filterEvenNumbers (nums : List Int) : List Int :=\n  nums.filter (fun x => x % 2 == 0)\n\n#guard filterEvenNumbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [2, 4, 6, 8, 10]\n#guard filterEvenNumbers [10, 20, 45, 67, 84, 93] == [10, 20, 84]\n#guard filterEvenNumbers [5, 7, 9, 8, 6, 4, 3] == [8, 6, 4]\n", "test_list": ["#guard filterEvenNumbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [2, 4, 6, 8, 10]", "#guard filterEvenNumbers [10, 20, 45, 67, 84, 93] == [10, 20, 84]", "#guard filterEvenNumbers [5, 7, 9, 8, 6, 4, 3] == [8, 6, 4]"]}
{"text": "Write a python function to find the sum of repeated elements in a given array.", "task_id": 42, "code": "import Batteries\n\nopen Std\n\ndef findSum (arr : List Int) (n : Nat) : Int :=\n  arr.foldl (fun acc x => if (arr.foldl (fun count y => if y == x then count + 1 else count) 0) > 1 then acc + x else acc) 0\n\n#guard findSum [1, 2, 3, 1, 1, 4, 5, 6] 8 == 3\n#guard findSum [1, 2, 3, 1, 1] 5 == 3\n#guard findSum [1, 1, 2] 3 == 2\n#guard findSum [1, 1, 2, 3, 4, 5, 6, 3, 5] 9 == 18\n", "test_list": ["#guard findSum [1, 2, 3, 1, 1, 4, 5, 6] 8 == 3", "#guard findSum [1, 2, 3, 1, 1] 5 == 3", "#guard findSum [1, 1, 2] 3 == 2", "#guard findSum [1, 1, 2, 3, 4, 5, 6, 3, 5] 9 == 18"]}
{"text": "Write a function to find sequences of lowercase letters joined with an underscore using regex.", "task_id": 43, "code": "import Batteries\n\nopen Std\n\ndef isLowercaseLetters (s : String) : Bool :=\n  match s.data with\n  | [] => false\n  | cs => cs.all (fun c => c >= 'a' && c <= 'z')\n\ndef textMatch (text : String) : String :=\n  match text.splitOn \"_\" with\n  | [a, b] =>\n    if isLowercaseLetters a && isLowercaseLetters b then\n      \"Found a match!\"\n    else\n      \"Not matched!\"\n  | _ => \"Not matched!\"\n\n#guard textMatch \"aab_cbbbc\" = \"Found a match!\"\n#guard textMatch \"aab_Abbbc\" = \"Not matched!\"\n#guard textMatch \"Aaab_abbbc\" = \"Not matched!\"\n#guard textMatch \"aab-cbbbc\" = \"Not matched!\"\n", "test_list": ["#guard textMatch \"aab_cbbbc\" = \"Found a match!\"", "#guard textMatch \"aab_Abbbc\" = \"Not matched!\"", "#guard textMatch \"Aaab_abbbc\" = \"Not matched!\"", "#guard textMatch \"aab-cbbbc\" = \"Not matched!\""]}
{"text": "Write a function that matches a word at the beginning of a string.", "task_id": 44, "code": "import Batteries\n\nopen Std\n\ndef textMatchString (text : String) : String :=\n  let firstWord := text.takeWhile Char.isAlphanum\n  if firstWord.length > 0 && text.drop firstWord.length != text then\n    \"Found a match!\"\n  else\n    \"Not matched!\"\n\n#guard textMatchString \" python\" == \"Not matched!\"\n#guard textMatchString \"python\" == \"Found a match!\"\n#guard textMatchString \"  lang\" == \"Not matched!\"\n#guard textMatchString \"foo\" == \"Found a match!\"\n", "test_list": ["#guard textMatchString \" python\" == \"Not matched!\"", "#guard textMatchString \"python\" == \"Found a match!\"", "#guard textMatchString \"  lang\" == \"Not matched!\"", "#guard textMatchString \"foo\" == \"Found a match!\""]}
{"text": "Write a function to find the gcd of the given array elements.", "task_id": 45, "code": "import Batteries\nopen Std\n\ndef findGcd (x y : Nat) : Nat := Id.run do\n  let mut a := x\n  let mut b := y\n  while b != 0 do\n    let tmp := b\n    b := a % b\n    a := tmp\n  return a\n\ndef getGcd (l : List Nat) : Nat := Id.run do\n  let mut gcd := findGcd (l.getD 0 0) (l.getD 1 0)  \n  for i in [2 : l.length] do\n    gcd := findGcd gcd (l.getD i 0)  \n  return gcd\n\n#guard getGcd [2, 4, 6, 8, 16] = 2\n#guard getGcd [1, 2, 3] = 1\n#guard getGcd [2, 4, 6, 8] = 2\n", "test_list": ["#guard getGcd [2, 4, 6, 8, 16] = 2", "#guard getGcd [1, 2, 3] = 1", "#guard getGcd [2, 4, 6, 8] = 2"]}
{"text": "Write a python function to determine whether all the numbers are different from each other are not.", "task_id": 46, "code": "import Batteries\n\nopen Std\n\ndef testDistinct (data : List Nat) : Bool :=\n  let dataHashSet := HashSet.ofList data\n  data.length == dataHashSet.size\n\n#guard testDistinct [1, 5, 7, 9] = true\n#guard testDistinct [2, 4, 5, 5, 7, 9] = false\n#guard testDistinct [1, 2, 3] = true\n", "test_list": ["#guard testDistinct [1, 5, 7, 9] = true", "#guard testDistinct [2, 4, 5, 5, 7, 9] = false", "#guard testDistinct [1, 2, 3] = true"]}
{"text": "Write a python function to find the last digit when factorial of a divides factorial of b.", "task_id": 47, "code": "import Batteries\nopen Std\n\ndef compute_Last_Digit (A B : Nat) : Nat := Id.run do\n  let mut variable_ := 1\n  if A == B then\n    return 1\n  else if decide ((B - A) ≥ 5) then\n    return 0\n  else\n    for i in [A+1 : B+1] do\n      variable_ := (variable_ * (i % 10)) % 10\n    return variable_ % 10\n\n#guard compute_Last_Digit 2 4 = 2\n#guard compute_Last_Digit 6 8 = 6\n#guard compute_Last_Digit 1 2 = 2\n\n#guard compute_Last_Digit 3 7 = 0\n#guard compute_Last_Digit 20 23 = 6\n#guard compute_Last_Digit 1021 1024 = 4\n", "test_list": ["#guard compute_Last_Digit 2 4 = 2", "#guard compute_Last_Digit 6 8 = 6", "#guard compute_Last_Digit 1 2 = 2", "#guard compute_Last_Digit 3 7 = 0", "#guard compute_Last_Digit 20 23 = 6", "#guard compute_Last_Digit 1021 1024 = 4"]}
{"text": "Write a python function to set all odd bits of a given number.", "task_id": 48, "code": "import Batteries\n\nopen Std\n\ndef oddBitSetNumber (n : Nat) : Nat := Id.run do\n  let L := if n == 0 then 0 else Nat.log2 n + 1\n  let mut res := 0\n  for count in [: L] do\n    if count % 2 == 0 then\n      res := res ||| (1 <<< count)\n  return n ||| res\n\n#guard oddBitSetNumber 10 = 15\n#guard oddBitSetNumber 20 = 21\n#guard oddBitSetNumber 30 = 31\n", "test_list": ["#guard oddBitSetNumber 10 = 15", "#guard oddBitSetNumber 20 = 21", "#guard oddBitSetNumber 30 = 31"]}
{"text": "Write a function to extract every first or specified element from a given two-dimensional list.", "task_id": 49, "code": "import Batteries\n\nopen Std\n\ndef specifiedElement (nums : List (List Nat)) (N : Nat) : List Nat :=\n  nums.map (fun i => i[N]!)  \n\n#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 0 == [1, 4, 7]\n#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 2 == [3, 6, 9]\n#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 1 == [2, 5, 1]\n", "test_list": ["#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 0 == [1, 4, 7]", "#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 2 == [3, 6, 9]", "#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 1 == [2, 5, 1]"]}
{"text": "Write a function to find the list with minimum length using lambda function.", "task_id": 50, "code": "import Batteries\n\nopen Std\n\ndef minLengthList (inputList : List (List Nat)) : Nat × List Nat :=\n  let minLength := inputList.foldl (fun acc x => min acc x.length) (List.head! inputList).length\n  let minList := inputList.foldl (fun acc x => if x.length < acc.length then x else acc) (List.head! inputList)\n  (minLength, minList)\n\n#guard minLengthList [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] == (1, [0])\n#guard minLengthList [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]] == (1,[1])\n#guard minLengthList [[3,4,5],[6,7,8,9],[10,11,12],[1,2]] == (2,[1,2])\n", "test_list": ["#guard minLengthList [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] == (1, [0])", "#guard minLengthList [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]] == (1,[1])", "#guard minLengthList [[3,4,5],[6,7,8,9],[10,11,12],[1,2]] == (2,[1,2])"]}
{"text": "Write a function to print check if the triangle is equilateral or not.", "task_id": 51, "code": "import Batteries\n\nopen Std\n\ndef checkEquilateral (x y z : Nat) : Bool :=\n  if x == y && y == z then\n    true\n  else\n    false\n\n#guard checkEquilateral 6 8 12 == false\n#guard checkEquilateral 6 6 12 == false\n#guard checkEquilateral 6 6 6 == true\n", "test_list": ["#guard checkEquilateral 6 8 12 == false", "#guard checkEquilateral 6 6 12 == false", "#guard checkEquilateral 6 6 6 == true"]}
{"text": "Write a function to caluclate area of a parallelogram.", "task_id": 52, "code": "import Batteries\n\nopen Std\n\ndef parallelogramArea (b h : Nat) : Nat :=\n  let area := b * h\n  area\n\n#guard parallelogramArea 10 20 == 200\n#guard parallelogramArea 15 20 == 300\n#guard parallelogramArea 8 9 == 72\n", "test_list": ["#guard parallelogramArea 10 20 == 200", "#guard parallelogramArea 15 20 == 300", "#guard parallelogramArea 8 9 == 72"]}
{"text": "Write a python function to check whether the first and last characters of a given string are equal or not.", "task_id": 53, "code": "import Batteries\nopen Std\n\ndef checkEquality (str : String) : String :=\n  let cs := str.data\n  if cs.head? == cs.getLast? then\n    \"Equal\"\n  else\n    \"Not Equal\"\n\n#guard checkEquality \"abcda\" == \"Equal\"\n#guard checkEquality \"ab\" == \"Not Equal\"\n#guard checkEquality \"mad\" == \"Not Equal\"\n", "test_list": ["#guard checkEquality \"abcda\" == \"Equal\"", "#guard checkEquality \"ab\" == \"Not Equal\"", "#guard checkEquality \"mad\" == \"Not Equal\""]}
{"text": "Write a function to sort the given array by using counting sort.", "task_id": 54, "code": "import Batteries\n\nopen Std\n\ndef countingSort (my_list : List Nat) : List Nat := Id.run do\n  let n := my_list.length\n  let arrInput := my_list.toArray\n  let mut maxVal := 0\n  for idx in [: n] do\n    let v := arrInput[idx]!\n    if v > maxVal then\n      maxVal := v\n  let mut buckets := Array.replicate (maxVal + 1) 0\n  for v in my_list do\n    buckets := buckets.set! v (buckets[v]! + 1)\n  let mut arr := arrInput\n  let mut i := 0\n  for j in [0 : maxVal + 1] do\n    let count := buckets[j]!\n    for _ in [: count] do\n      arr := arr.set! i j\n      i := i + 1\n  return arr.toList\n\n#guard countingSort [1, 23, 4, 5, 6, 7, 8] = [1, 4, 5, 6, 7, 8, 23]\n#guard countingSort [12, 9, 28, 33, 69, 45] = [9, 12, 28, 33, 45, 69]\n#guard countingSort [8, 4, 14, 3, 2, 1] = [1, 2, 3, 4, 8, 14]\n", "test_list": ["#guard countingSort [1, 23, 4, 5, 6, 7, 8] = [1, 4, 5, 6, 7, 8, 23]", "#guard countingSort [12, 9, 28, 33, 69, 45] = [9, 12, 28, 33, 45, 69]", "#guard countingSort [8, 4, 14, 3, 2, 1] = [1, 2, 3, 4, 8, 14]"]}
{"text": "Write a function to find t-nth term of geometric series.", "task_id": 55, "code": "import Batteries\n\nopen Std\n\ndef tnGp (a r n : Nat) : Nat :=\n  a * r^(n - 1)\n\n#guard tnGp 1 2 5 == 16\n#guard tnGp 1 4 5 == 256\n#guard tnGp 2 3 6 == 486\n", "test_list": ["#guard tnGp 1 2 5 == 16", "#guard tnGp 1 4 5 == 256", "#guard tnGp 2 3 6 == 486"]}
{"text": "Write a python function to check if a given number is one less than twice its reverse.", "task_id": 56, "code": "import Batteries\n\nopen Std\n\ndef rev (num : Nat) : Nat := Id.run do\n  let mut n := num\n  let mut revNum := 0\n  while n > 0 do\n    revNum := revNum * 10 + n % 10\n    n := n / 10\n  return revNum\n\ndef check (n : Nat) : Bool :=\n  2 * rev n == n + 1\n\n#guard check 70 == false\n#guard check 23 == false\n#guard check 73 == true\n", "test_list": ["#guard check 70 == false", "#guard check 23 == false", "#guard check 73 == true"]}
{"text": "Write a python function to find the largest number that can be formed with the given digits.", "task_id": 57, "code": "import Batteries\n\nopen Std\n\ndef findMaxNum (arr : List Nat) (n : Nat) : Nat :=\n  let rec collectMaxNum (xs : List Nat) (acc : Nat) : Nat :=\n    match xs with\n    | [] => acc\n    | x :: xs' => collectMaxNum xs' (acc * 10 + x)\n  let maxList := Id.run do\n    let mut result : List Nat := []\n    let mut originalList := arr\n    for _ in [0:n] do\n      if originalList.isEmpty then break\n      let maxDigit := originalList.foldl (init := 0) max\n      result := result ++ [maxDigit]\n      originalList := originalList.erase maxDigit\n    return result\n  collectMaxNum maxList 0\n\n#guard findMaxNum [1, 2, 3] 3 == 321\n#guard findMaxNum [4, 5, 6, 1] 4 == 6541\n#guard findMaxNum [1, 2, 3, 9] 4 == 9321\n", "test_list": ["#guard findMaxNum [1, 2, 3] 3 == 321", "#guard findMaxNum [4, 5, 6, 1] 4 == 6541", "#guard findMaxNum [1, 2, 3, 9] 4 == 9321"]}
{"text": "Write a python function to check whether the given two integers have opposite sign or not.", "task_id": 58, "code": "import Batteries\nopen Std\n\ndef oppositeSigns (x y : Int) : Bool :=\n  (x < 0 ∧ y ≥ 0) ∨ (x ≥ 0 ∧ y < 0)\n\n#eval oppositeSigns 1 (-2) == true\n#eval oppositeSigns 3 2 == false\n#eval oppositeSigns (-10) (-10) == false\n", "test_list": []}
{"text": "Write a function to find the nth octagonal number.", "task_id": 59, "code": "import Batteries\n\nopen Std\n\ndef isOctagonal (n : Nat) : Nat := 3 * n * n - 2 * n\n\n#guard isOctagonal 5 == 65\n#guard isOctagonal 10 == 280\n#guard isOctagonal 15 == 645\n", "test_list": ["#guard isOctagonal 5 == 65", "#guard isOctagonal 10 == 280", "#guard isOctagonal 15 == 645"]}
{"text": "Write a function to find the maximum length of the subsequence with difference between adjacent elements for the given array.", "task_id": 60, "code": "import Batteries\n\nopen Std\n\ndef maxLenSub (arr : List Int) (n : Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let mut mls : Array Nat := Array.replicate n 1\n  for i in [: n] do\n    for j in [: i] do\n      if Int.natAbs (a[i]! - a[j]!) ≤ 1 && mls[i]! < mls[j]! + 1 then\n        mls := mls.set! i (mls[j]! + 1)\n  let mut best := 0\n  for i in [: n] do\n    if best < mls[i]! then\n      best := mls[i]!\n  return best\n\n#guard maxLenSub ([2, 5, 6, 3, 7, 6, 5, 8] : List Int) 8 == 5\n#guard maxLenSub ([-2, -1, 5, -1, 4, 0, 3] : List Int) 7 == 4\n#guard maxLenSub ([9, 11, 13, 15, 18] : List Int) 5 == 1\n", "test_list": ["#guard maxLenSub ([2, 5, 6, 3, 7, 6, 5, 8] : List Int) 8 == 5", "#guard maxLenSub ([-2, -1, 5, -1, 4, 0, 3] : List Int) 7 == 4", "#guard maxLenSub ([9, 11, 13, 15, 18] : List Int) 5 == 1"]}
{"text": "Write a python function to count number of substrings with the sum of digits equal to their length.", "task_id": 61, "code": "import Batteries\nopen Std\n\ndef charDigit (s : String) : Nat :=\n  if s == \"0\" then 0 else\n  if s == \"1\" then 1 else\n  if s == \"2\" then 2 else\n  if s == \"3\" then 3 else\n  if s == \"4\" then 4 else\n  if s == \"5\" then 5 else\n  if s == \"6\" then 6 else\n  if s == \"7\" then 7 else\n  if s == \"8\" then 8 else\n  if s == \"9\" then 9 else 0\n\ndef countSubstrings (s : String) (n : Nat) : Nat := Id.run do\n  let mut cnt : Nat := 0\n  let mut sm : Int := 0\n  let mut mp : Std.HashMap Int Nat := {}\n  mp := mp.insert 0 1\n  let mut ts := s\n  for i in [: n] do\n    let d := charDigit (ts.take 1)\n    sm := sm + Int.ofNat d\n    let diff : Int := sm - Int.ofNat (i + 1)\n    let prev :=\n      mp.fold (init := 0) (fun acc k v => if k == diff then v else acc)\n    cnt := cnt + prev\n    mp := mp.insert diff (prev + 1)\n    ts := ts.drop 1\n  return cnt\n\n#guard countSubstrings \"112112\" 6 = 6\n#guard countSubstrings \"111\" 3 = 6\n#guard countSubstrings \"1101112\" 7 = 12\n", "test_list": ["#guard countSubstrings \"112112\" 6 = 6", "#guard countSubstrings \"111\" 3 = 6", "#guard countSubstrings \"1101112\" 7 = 12"]}
{"text": "Write a python function to find smallest number in a list.", "task_id": 62, "code": "import Batteries\nopen Std\n\ndef smallestNum (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0  \n  | x :: xs => xs.foldl (fun acc x => if x < acc then x else acc) x\n\n#guard smallestNum [10, 20, 1, 45, 99] == 1\n#guard smallestNum [1, 2, 3] == 1\n#guard smallestNum [45, 46, 50, 60] == 45\n", "test_list": ["#guard smallestNum [10, 20, 1, 45, 99] == 1", "#guard smallestNum [1, 2, 3] == 1", "#guard smallestNum [45, 46, 50, 60] == 45"]}
{"text": "Write a function to find the maximum difference between available pairs in the given tuple list.", "task_id": 63, "code": "import Batteries\nopen Std\n\ndef absDiff (a b : Nat) : Nat :=\n  if b ≥ a then b - a else a - b\n\ndef maxDifference (testList : List (Nat × Nat)) : Nat :=\n  let temp := testList.map (fun (a, b) => absDiff b a)\n  temp.foldl Nat.max 0\n\n#eval maxDifference [(3, 5), (1, 7), (10, 3), (1, 2)] == 7\n#eval maxDifference [(4, 6), (2, 17), (9, 13), (11, 12)] == 15\n#eval maxDifference [(12, 35), (21, 27), (13, 23), (41, 22)] == 23\n", "test_list": []}
{"text": "Write a function to sort a list of tuples using lambda.", "task_id": 64, "code": "import Batteries\n\nopen Std\n\ndef removeOne [BEq α] (xs : List α) (x : α) : List α :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne ys x\n\ndef findMinBySecond (xs : List (String × Nat)) : Option (String × Nat) :=\n  match xs with\n  | [] => none\n  | x :: xt =>\n    some <| xt.foldl (fun acc y => if y.snd ≤ acc.snd then y else acc) x\n\ndef selectionSortBySecond (xs : List (String × Nat)) : List (String × Nat) :=\n  let n := xs.length\n  let rec loop (ys : List (String × Nat)) (acc : List (String × Nat)) (fuel : Nat) : List (String × Nat) :=\n    match fuel with\n    | 0 => acc.reverse  \n    | fuel' + 1 =>\n      match ys with\n      | [] => acc.reverse\n      | _ =>\n        match findMinBySecond ys with\n        | none => acc.reverse\n        | some m =>\n          let ys' := removeOne ys m\n          loop ys' (m :: acc) fuel'\n  loop xs [] n\n\ndef subjectMarks (subjectmarks : List (String × Nat)) : List (String × Nat) :=\n  selectionSortBySecond subjectmarks\n\n#guard subjectMarks [(\"English\", 88), (\"Science\", 90), (\"Maths\", 97), (\"Social sciences\", 82)] == [(\"Social sciences\", 82), (\"English\", 88), (\"Science\", 90), (\"Maths\", 97)]\n#guard subjectMarks [(\"Telugu\",49),(\"Hindhi\",54),(\"Social\",33)] == [(\"Social\",33),(\"Telugu\",49),(\"Hindhi\",54)]\n#guard subjectMarks [(\"Physics\",96),(\"Chemistry\",97),(\"Biology\",45)] == [(\"Biology\",45),(\"Physics\",96),(\"Chemistry\",97)]\n", "test_list": ["#guard subjectMarks [(\"English\", 88), (\"Science\", 90), (\"Maths\", 97), (\"Social sciences\", 82)] == [(\"Social sciences\", 82), (\"English\", 88), (\"Science\", 90), (\"Maths\", 97)]", "#guard subjectMarks [(\"Telugu\",49),(\"Hindhi\",54),(\"Social\",33)] == [(\"Social\",33),(\"Telugu\",49),(\"Hindhi\",54)]", "#guard subjectMarks [(\"Physics\",96),(\"Chemistry\",97),(\"Biology\",45)] == [(\"Biology\",45),(\"Physics\",96),(\"Chemistry\",97)]"]}
{"text": "Write a function of recursion list sum.", "task_id": 65, "code": "import Batteries\nopen Std\n\ninductive Nested where\n  | num : Nat → Nested\n  | list : List Nested → Nested\n  deriving Repr\n\ndef nestedSum : Nested → Nat\n  | .num n => n\n  | .list xs => xs.foldl (fun acc el => acc + nestedSum el) 0\n\ndef recursiveListSum (dataList : List Nested) : Nat :=\n  nestedSum (Nested.list dataList)\n\n#guard recursiveListSum [Nested.num 1, Nested.num 2, Nested.list [Nested.num 3, Nested.num 4], Nested.list [Nested.num 5, Nested.num 6]] = 21\n#guard recursiveListSum [Nested.num 7, Nested.num 10, Nested.list [Nested.num 15, Nested.num 14], Nested.list [Nested.num 19, Nested.num 41]] = 106\n#guard recursiveListSum [Nested.num 10, Nested.num 20, Nested.list [Nested.num 30, Nested.num 40], Nested.list [Nested.num 50, Nested.num 60]] = 210\n", "test_list": ["#guard recursiveListSum [Nested.num 1, Nested.num 2, Nested.list [Nested.num 3, Nested.num 4], Nested.list [Nested.num 5, Nested.num 6]] = 21", "#guard recursiveListSum [Nested.num 7, Nested.num 10, Nested.list [Nested.num 15, Nested.num 14], Nested.list [Nested.num 19, Nested.num 41]] = 106", "#guard recursiveListSum [Nested.num 10, Nested.num 20, Nested.list [Nested.num 30, Nested.num 40], Nested.list [Nested.num 50, Nested.num 60]] = 210"]}
{"text": "Write a python function to count positive numbers in a list.", "task_id": 66, "code": "import Batteries\n\nopen Std\n\ndef posCount (list : List Int) : Nat :=\n  list.foldl (fun acc num => if num >= 0 then acc + 1 else acc) 0\n\n#guard posCount [1, -2, 3, -4] == 2\n#guard posCount [3, 4, 5, -1] == 3\n#guard posCount [1, 2, 3, 4] == 4\n", "test_list": ["#guard posCount [1, -2, 3, -4] == 2", "#guard posCount [3, 4, 5, -1] == 3", "#guard posCount [1, 2, 3, 4] == 4"]}
{"text": "Write a function to find the number of ways to partition a set of bell numbers.", "task_id": 67, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) : Array (Array α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) : Array (Array α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) : α :=\n  (a.getD y #[]).getD x fallback\n\ndef bellNumber (n : Nat) : Nat := Id.run do\n  let size := n + 1\n  let mut bell : Array (Array Nat) := Array.replicate size (Array.replicate size 0)\n  bell := bell.set2d? 0 0 1\n  for i in [1 : n+1] do\n    bell := bell.set2d? i 0 (bell.get2d (i-1) (i-1) 0)\n    for j in [1 : i+1] do\n      let v := bell.get2d (i-1) (j-1) 0 + bell.get2d i (j-1) 0\n      bell := bell.set2d? i j v\n  return bell.get2d n 0 0\n\n#guard bellNumber 2 == 2\n#guard bellNumber 10 == 115975\n#guard bellNumber 56 == 6775685320645824322581483068371419745979053216268760300\n", "test_list": ["#guard bellNumber 2 == 2", "#guard bellNumber 10 == 115975", "#guard bellNumber 56 == 6775685320645824322581483068371419745979053216268760300"]}
{"text": "Write a python function to check whether the given array is monotonic or not.", "task_id": 68, "code": "import Batteries\n\nopen Std\n\ndef isMonotonic (A : List Int) : Bool :=\n  (A.length ≤ 1) ||\n  ((A.foldl (fun (result, prev) x => (result && prev <= x, x)) (true, A.head!)).1 ||\n   (A.foldl (fun (result, prev) x => (result && prev >= x, x)) (true, A.head!)).1)\n\n#guard isMonotonic [6, 5, 4, 4] == true\n#guard isMonotonic [1, 2, 2, 3] == true\n#guard isMonotonic [1, 3, 2] == false\n", "test_list": ["#guard isMonotonic [6, 5, 4, 4] == true", "#guard isMonotonic [1, 2, 2, 3] == true", "#guard isMonotonic [1, 3, 2] == false"]}
{"text": "Write a function to check whether a list contains the given sublist or not.", "task_id": 69, "code": "import Batteries\n\nopen Std\n\ndef isSublist (l s : List Nat) : Bool :=\n  if s == [] then\n    true\n  else if s == l then\n    true\n  else if s.length > l.length then\n    false\n  else Id.run do\n    let mut subSet := false\n    for i in [0 : l.length] do\n      if l.getD i 0 == s.getD 0 0 then\n        let mut n := 1\n        while (n < s.length) && (l.getD (i+n) 0 == s.getD n 0) do\n          n := n + 1\n        if n == s.length then\n          subSet := true\n    return subSet\n\n#guard isSublist [2,4,3,5,7] [3,7] == false\n#guard isSublist [2,4,3,5,7] [4,3] == true\n#guard isSublist [2,4,3,5,7] [1,6] == false\n", "test_list": ["#guard isSublist [2,4,3,5,7] [3,7] == false", "#guard isSublist [2,4,3,5,7] [4,3] == true", "#guard isSublist [2,4,3,5,7] [1,6] == false"]}
{"text": "Write a function to find whether all the given tuples have equal length or not.", "task_id": 70, "code": "import Batteries\n\nopen Std\n\ndef findEqualTuple (input : List (List Nat)) (k : Nat) : Nat :=\n  let flag := Id.run do\n    let mut flag := 1\n    for tuple in input do\n      if tuple.length ≠ k then\n        flag := 0\n        break\n    return flag\n  flag\n\ndef getEqual (input : List (List Nat)) (k : Nat) : String :=\n  if findEqualTuple input k == 1 then\n    \"All tuples have same length\"\n  else\n    \"All tuples do not have same length\"\n\n#guard getEqual [[11, 22, 33], [44, 55, 66]] 3 == \"All tuples have same length\"\n#guard getEqual [[1, 2, 3], [4, 5, 6, 7]] 3 == \"All tuples do not have same length\"\n#guard getEqual [[1, 2], [3, 4]] 2 == \"All tuples have same length\"\n", "test_list": ["#guard getEqual [[11, 22, 33], [44, 55, 66]] 3 == \"All tuples have same length\"", "#guard getEqual [[1, 2, 3], [4, 5, 6, 7]] 3 == \"All tuples do not have same length\"", "#guard getEqual [[1, 2], [3, 4]] 2 == \"All tuples have same length\""]}
{"text": "Write a function to sort a list of elements using comb sort.", "task_id": 71, "code": "import Batteries\n\nopen Std\n\ndef combSort (nums : List Nat) : List Nat := Id.run do\n  let mut arr := nums.toArray\n  let mut gaps : Nat := arr.size\n  let mut swapped : Bool := true\n  let mut i : Nat := 0\n  while gaps > 1 || swapped do\n    gaps := (gaps * 10) / 13\n    swapped := false\n    i := 0\n    while gaps + i < arr.size do\n      let a := arr[i]!\n      let b := arr[i + gaps]!\n      if a > b then\n        arr := arr.set! i b\n        arr := arr.set! (i + gaps) a\n        swapped := true\n      i := i + 1\n  return arr.toList\n\n#guard combSort [5, 15, 37, 25, 79] == [5, 15, 25, 37, 79]\n#guard combSort [41, 32, 15, 19, 22] == [15, 19, 22, 32, 41]\n#guard combSort [99, 15, 13, 47] == [13, 15, 47, 99]\n", "test_list": ["#guard combSort [5, 15, 37, 25, 79] == [5, 15, 25, 37, 79]", "#guard combSort [41, 32, 15, 19, 22] == [15, 19, 22, 32, 41]", "#guard combSort [99, 15, 13, 47] == [13, 15, 47, 99]"]}
{"text": "Write a python function to check whether the given number can be represented as difference of two squares or not.", "task_id": 72, "code": "import Batteries\n\nopen Std\n\ndef difSquare (n : Int) : Bool :=\n  if n % 4 != 2 then true else false\n\n#guard difSquare 5 == true\n#guard difSquare 10 == false\n#guard difSquare 15 == true\n", "test_list": ["#guard difSquare 5 == true", "#guard difSquare 10 == false", "#guard difSquare 15 == true"]}
{"text": "Write a function to split the given string with multiple delimiters by using regex.", "task_id": 73, "code": "import Batteries\nopen Std\n\ndef multipleSplit (text : String) : List String :=\n  let delimiters : List Char := [';', ',', '*', '\\n']\n  let processChar (c : Char) (acc : List (List Char)) : List (List Char) :=\n    if c ∈ delimiters then [] :: acc else\n      match acc with\n      | [] => [[c]]\n      | h :: t => (c :: h) :: t\n  text.toList.foldr processChar [[]] |>.reverse.map (fun chars => String.mk chars |>.trim)\n\n#eval multipleSplit \"Forces of the \\ndarkness*are coming into the play.\" \n#eval multipleSplit \"Mi Box runs on the \\n Latest android*which has google assistance and chromecast.\" \n#eval multipleSplit \"Certain services\\nare subjected to change*over the seperate subscriptions.\"\n", "test_list": []}
{"text": "Write a function to check whether it follows the sequence given in the patterns array.", "task_id": 74, "code": "import Batteries\nopen Std\n\ndef isSamepatterns (colors : List String) (patterns : List String) : Bool := Id.run do\n  if colors.length != patterns.length then\n    return false\n  let mut assoc : List (String × List String) := []\n  let mut pset : HashSet String := HashSet.emptyWithCapacity 0\n  let mut sset : HashSet String := HashSet.emptyWithCapacity 0\n  let len := patterns.length\n  for i in [0 : len] do\n    let p := patterns.getD i \"\"\n    let c := colors.getD i \"\"\n    pset := pset.insert p\n    sset := sset.insert c\n    let rec appendAt (xs : List (String × List String)) : List (String × List String) :=\n      match xs with\n      | [] => [(p, [c])]\n      | (k, vs) :: rest =>\n        if k = p then\n          (k, vs ++ [c]) :: rest\n        else\n          (k, vs) :: appendAt rest\n    assoc := appendAt assoc\n  if pset.size != sset.size then\n    return false\n  for kv in assoc do\n    let values := kv.snd\n    let rec allEqual (lst : List String) (prev? : Option String) : Bool :=\n      match lst with\n      | [] => true\n      | x :: xs =>\n        match prev? with\n        | none => allEqual xs (some x)\n        | some y => if x = y then allEqual xs (some y) else false\n    if !(allEqual values none) then\n      return false\n  return true\n\n#guard isSamepatterns [\"red\",\"green\",\"green\"] [\"a\", \"b\", \"b\"] == true\n#guard isSamepatterns [\"red\",\"green\",\"greenn\"] [\"a\",\"b\",\"b\"] == false\n#guard isSamepatterns [\"red\",\"green\",\"greenn\"] [\"a\",\"b\"] == false\n", "test_list": ["#guard isSamepatterns [\"red\",\"green\",\"green\"] [\"a\", \"b\", \"b\"] == true", "#guard isSamepatterns [\"red\",\"green\",\"greenn\"] [\"a\",\"b\",\"b\"] == false", "#guard isSamepatterns [\"red\",\"green\",\"greenn\"] [\"a\",\"b\"] == false"]}
{"text": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.", "task_id": 75, "code": "import Batteries\nopen Std\n\ndef findTuples (testList : List (List Nat)) (k : Nat) : String :=\n  let res := testList.filter (fun sub => sub.all (fun ele => ele % k == 0))\n  toString res\n\n#guard findTuples [[6, 24, 12], [7, 9, 6], [12, 18, 21]] 6 == \"[[6, 24, 12]]\"\n#guard findTuples [[5, 25, 30], [4, 2, 3], [7, 8, 9]] 5 == \"[[5, 25, 30]]\"\n#guard findTuples [[7, 9, 16], [8, 16, 4], [19, 17, 18]] 4 == \"[[8, 16, 4]]\"\n", "test_list": ["#guard findTuples [[6, 24, 12], [7, 9, 6], [12, 18, 21]] 6 == \"[[6, 24, 12]]\"", "#guard findTuples [[5, 25, 30], [4, 2, 3], [7, 8, 9]] 5 == \"[[5, 25, 30]]\"", "#guard findTuples [[7, 9, 16], [8, 16, 4], [19, 17, 18]] 4 == \"[[8, 16, 4]]\""]}
{"text": "Write a python function to count the number of squares in a rectangle.", "task_id": 76, "code": "import Batteries\n\nopen Std\n\ndef countSquares (m : Nat) (n : Nat) : Nat :=\n  let (m, n) := if n < m then (n, m) else (m, n)\n  (m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2)\n\n#guard countSquares 4 3 == 20\n#guard countSquares 2 2 == 5\n#guard countSquares 1 1 == 1\n", "test_list": ["#guard countSquares 4 3 == 20", "#guard countSquares 2 2 == 5", "#guard countSquares 1 1 == 1"]}
{"text": "Write a python function to find the difference between sum of even and odd digits.", "task_id": 77, "code": "import Batteries\n\nopen Std\n\ndef isDiff (n : Int) : Bool :=\n  n % 11 == 0\n\n#guard isDiff 12345 == false\n#guard isDiff 1212112 == true\n#guard isDiff 1212 == false\n", "test_list": ["#guard isDiff 12345 == false", "#guard isDiff 1212112 == true", "#guard isDiff 1212 == false"]}
{"text": "Write a python function to find number of integers with odd number of set bits.", "task_id": 78, "code": "import Batteries\nopen Std\n\ndef countSetBits (n : Nat) : Nat :=\n  Id.run do\n    let mut count := 0\n    let mut x := n\n    while x > 0 do\n      count := count + (x % 2)\n      x := x / 2\n    return count\n\ndef countWithOddSetBits (n : Nat) : Nat :=\n  let halfN := n / 2\n  if n % 2 != 0 then\n    (n + 1) / 2\n  else\n    let count := countSetBits n\n    let ans := halfN\n    if count % 2 != 0 then\n      ans + 1\n    else\n      ans\n\n#guard countWithOddSetBits 5 == 3\n#guard countWithOddSetBits 10 == 5\n#guard countWithOddSetBits 15 == 8\n", "test_list": ["#guard countWithOddSetBits 5 == 3", "#guard countWithOddSetBits 10 == 5", "#guard countWithOddSetBits 15 == 8"]}
{"text": "Write a python function to check whether the length of the word is odd or not.", "task_id": 79, "code": "import Batteries\n\nopen Std\n\ndef wordLen (s : String) : Bool :=\n  let words := s.splitOn \" \"\n  match words with\n  | [] => false\n  | word::_ => word.length % 2 != 0\n\n#guard wordLen \"Hadoop\" == false\n#guard wordLen \"great\" == true\n#guard wordLen \"structure\" == true\n", "test_list": ["#guard wordLen \"Hadoop\" == false", "#guard wordLen \"great\" == true", "#guard wordLen \"structure\" == true"]}
{"text": "Write a function to find the nth tetrahedral number.", "task_id": 80, "code": "import Batteries\n\nopen Std\n\ndef tetrahedralNumber (n : Nat) : Float :=\n  (n * (n + 1) * (n + 2)).toFloat / 6.0\n\n#guard tetrahedralNumber 5 == 35.0\n#guard tetrahedralNumber 6 == 56.0\n#guard tetrahedralNumber 7 == 84.0\n", "test_list": ["#guard tetrahedralNumber 5 == 35.0", "#guard tetrahedralNumber 6 == 56.0", "#guard tetrahedralNumber 7 == 84.0"]}
{"text": "Write a function to zip the two given tuples.", "task_id": 81, "code": "import Batteries\n\nopen Std\n\ndef zipTuples (test_tup1 : List Nat) (test_tup2 : List Nat) : List (Nat × Nat) := Id.run do\n  \n  let a1 := test_tup1.toArray\n  let a2 := test_tup2.toArray\n  let len2 := a2.size\n  let mut res : Array (Nat × Nat) := #[]\n  for i in [0 : a1.size] do\n    let j := a1[i]!\n    let idx := i % len2\n    let k := a2[idx]!\n    res := res.push (j, k)\n  return res.toList\n\n#guard zipTuples [7, 8, 4, 5, 9, 10] [1, 5, 6] = [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]\n#guard zipTuples [8, 9, 5, 6, 10, 11] [2, 6, 7] = [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]\n#guard zipTuples [9, 10, 6, 7, 11, 12] [3, 7, 8] = [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]\n", "test_list": ["#guard zipTuples [7, 8, 4, 5, 9, 10] [1, 5, 6] = [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]", "#guard zipTuples [8, 9, 5, 6, 10, 11] [2, 6, 7] = [(8, 2), (9, 6), (5, 7), (6, 2), (10, 6), (11, 7)]", "#guard zipTuples [9, 10, 6, 7, 11, 12] [3, 7, 8] = [(9, 3), (10, 7), (6, 8), (7, 3), (11, 7), (12, 8)]"]}
{"text": "Write a function to find the volume of a sphere.", "task_id": 82, "code": "import Batteries\n\nopen Std\n\ndef volumeSphere (r : Nat) : Float :=\n  let pi : Float := 3.141592653589793\n  (((4.0 / 3.0) * pi) * (Float.ofNat r)) * (Float.ofNat r) * (Float.ofNat r)\n\n#guard volumeSphere 10 == (4188.790204786391 : Float)\n#guard volumeSphere 25 == (65449.84694978735 : Float)\n#guard volumeSphere 20 == (33510.32163829113 : Float)\n", "test_list": ["#guard volumeSphere 10 == (4188.790204786391 : Float)", "#guard volumeSphere 25 == (65449.84694978735 : Float)", "#guard volumeSphere 20 == (33510.32163829113 : Float)"]}
{"text": "Write a python function to find the character made by adding all the characters of the given string.", "task_id": 83, "code": "import Batteries\n\nopen Std\n\ndef getChar (str : String) : Char :=\n  let sum := (str.toList.foldl (fun acc c => acc + (c.toNat - 'a'.toNat + 1)) 0)\n  if sum % 26 == 0 then 'z'\n  else Char.ofNat ((sum % 26) + 'a'.toNat - 1)\n\n#guard getChar \"abc\" == 'f'\n#guard getChar \"gfg\" == 't'\n#guard getChar \"ab\" == 'c'\n", "test_list": ["#guard getChar \"abc\" == 'f'", "#guard getChar \"gfg\" == 't'", "#guard getChar \"ab\" == 'c'"]}
{"text": "Write a function to find the n-th number in newman conway sequence.", "task_id": 84, "code": "import Batteries\n\nopen Std\n\npartial def sequence (n : Nat) : Nat :=\n  if n == 1 || n == 2 then\n    1\n  else\n    let prev := sequence (n - 1)\n    sequence prev + sequence (n - prev)\n\n#guard sequence 10 = 6\n#guard sequence 2 = 1\n#guard sequence 3 = 2\n", "test_list": ["#guard sequence 10 = 6", "#guard sequence 2 = 1", "#guard sequence 3 = 2"]}
{"text": "Write a function to find the surface area of a sphere.", "task_id": 85, "code": "import Batteries\n\nopen Std\n\ndef surfaceareaSphere (r : Nat) : Float :=\n  let rr := Float.ofNat r\n  (4.0 : Float) * (3.141592653589793 : Float) * rr * rr\n\n#guard surfaceareaSphere 10 == (1256.6370614359173 : Float)\n#guard surfaceareaSphere 15 == (2827.4333882308138 : Float)\n#guard surfaceareaSphere 20 == (5026.548245743669 : Float)\n", "test_list": ["#guard surfaceareaSphere 10 == (1256.6370614359173 : Float)", "#guard surfaceareaSphere 15 == (2827.4333882308138 : Float)", "#guard surfaceareaSphere 20 == (5026.548245743669 : Float)"]}
{"text": "Write a function to find nth centered hexagonal number.", "task_id": 86, "code": "import Batteries\n\nopen Std\n\ndef centeredHexagonalNumber (n : Nat) : Nat := 3 * n * (n - 1) + 1\n\n#guard centeredHexagonalNumber 10 == 271\n#guard centeredHexagonalNumber 2 == 7\n#guard centeredHexagonalNumber 9 == 217\n", "test_list": ["#guard centeredHexagonalNumber 10 == 271", "#guard centeredHexagonalNumber 2 == 7", "#guard centeredHexagonalNumber 9 == 217"]}
{"text": "Write a function to merge three dictionaries into a single expression.", "task_id": 87, "code": "import Batteries\nopen Std\n\ndef mergeDictionariesThree (dict1 dict2 dict3 : HashMap String String) : HashMap String String := Id.run do\n  let mut m : HashMap String String := {}\n\n  for (k, v) in dict3.toList do\n    m := m.insert k v\n  for (k, v) in dict2.toList do\n    m := m.insert k v\n  for (k, v) in dict1.toList do\n    m := m.insert k v\n  return m\n\ndef lookupInList {α β} [BEq α] (k : α) (l : List (α × β)) : Option β :=\n  let rec go (l : List (α × β)) : Option β :=\n    match l with\n    | [] => none\n    | (k2, v2) :: t => if k2 == k then some v2 else go t\n  go l\n\ndef mapsEqual {α β} [BEq α] [Hashable α] [BEq β]\n  (m1 : HashMap α β) (m2 : HashMap α β) : Bool := Id.run do\n  if m1.size != m2.size then\n    return false\n  let l2 := m2.toList\n  for (k, v) in m1.toList do\n    match lookupInList k l2 with\n    | some v2 => if v2 == v then pure () else return false\n    | none => return false\n  return true\n\ndef d1 : HashMap String String := HashMap.ofList [(\"R\",\"Red\"), (\"B\",\"Black\"), (\"P\",\"Pink\")]\ndef d2 : HashMap String String := HashMap.ofList [(\"G\",\"Green\"), (\"W\",\"White\")]\ndef d3 : HashMap String String := HashMap.ofList [(\"O\",\"Orange\"), (\"W\",\"White\"), (\"B\",\"Black\")]\ndef expected1 : HashMap String String := HashMap.ofList [(\"B\",\"Black\"), (\"R\",\"Red\"), (\"P\",\"Pink\"), (\"G\",\"Green\"), (\"W\",\"White\"), (\"O\",\"Orange\")]\n#guard mapsEqual (mergeDictionariesThree d1 d2 d3) expected1\n\ndef d1b : HashMap String String := HashMap.ofList [(\"R\",\"Red\"), (\"B\",\"Black\"), (\"P\",\"Pink\")]\ndef d2b : HashMap String String := HashMap.ofList [(\"G\",\"Green\"), (\"W\",\"White\")]\ndef d3b : HashMap String String := HashMap.ofList [(\"L\",\"lavender\"), (\"B\",\"Blue\")]\ndef expected2 : HashMap String String := HashMap.ofList [(\"W\",\"White\"), (\"P\",\"Pink\"), (\"B\",\"Black\"), (\"R\",\"Red\"), (\"G\",\"Green\"), (\"L\",\"lavender\")]\n#guard mapsEqual (mergeDictionariesThree d1b d2b d3b) expected2\n\ndef d1c : HashMap String String := HashMap.ofList [(\"R\",\"Red\"), (\"B\",\"Black\"), (\"P\",\"Pink\")]\ndef d2c : HashMap String String := HashMap.ofList [(\"L\",\"lavender\"), (\"B\",\"Blue\")]\ndef d3c : HashMap String String := HashMap.ofList [(\"G\",\"Green\"), (\"W\",\"White\")]\ndef expected3 : HashMap String String := HashMap.ofList [(\"B\",\"Black\"), (\"P\",\"Pink\"), (\"R\",\"Red\"), (\"G\",\"Green\"), (\"L\",\"lavender\"), (\"W\",\"White\")]\n#guard mapsEqual (mergeDictionariesThree d1c d2c d3c) expected3\n", "test_list": ["#guard mapsEqual (mergeDictionariesThree d1 d2 d3) expected1", "#guard mapsEqual (mergeDictionariesThree d1b d2b d3b) expected2", "#guard mapsEqual (mergeDictionariesThree d1c d2c d3c) expected3"]}
{"text": "Write a function to get the frequency of the elements in a list.", "task_id": 88, "code": "import Batteries\nopen Std\n\ndef findVal? (m : Std.HashMap Nat Nat) (k : Nat) : Option Nat := Id.run do\n  let mut r : Option Nat := none\n  for (k', v) in m do\n    if k' == k then\n      r := some v\n  return r\n\ndef freqCount (list1 : List Nat) : Std.HashMap Nat Nat := Id.run do\n  let mut m : Std.HashMap Nat Nat := Std.HashMap.emptyWithCapacity list1.length\n  for x in list1 do\n    let c := match findVal? m x with\n      | some v => v\n      | none => 0\n    m := m.insert x (c + 1)\n  return m\n\ndef mapEqPairs (m : Std.HashMap Nat Nat) (ps : List (Nat × Nat)) : Bool :=\n  let sizeOk := m.size == ps.length\n  let allOk := ps.foldl (fun acc (p : Nat × Nat) =>\n    acc && (match findVal? m p.fst with\n      | some v => v == p.snd\n      | none => false)) true\n  sizeOk && allOk\n\n#guard mapEqPairs (freqCount [10,10,10,10,20,20,20,20,40,40,50,50,30]) [(10,4), (20,4), (40,2), (50,2), (30,1)]\n#guard mapEqPairs (freqCount [1,2,3,4,3,2,4,1,3,1,4]) [(1,3), (2,2), (3,3), (4,3)]\n#guard mapEqPairs (freqCount [5,6,7,4,9,10,4,5,6,7,9,5]) [(10,1), (5,3), (6,2), (7,2), (4,2), (9,2)]\n", "test_list": ["#guard mapEqPairs (freqCount [10,10,10,10,20,20,20,20,40,40,50,50,30]) [(10,4), (20,4), (40,2), (50,2), (30,1)]", "#guard mapEqPairs (freqCount [1,2,3,4,3,2,4,1,3,1,4]) [(1,3), (2,2), (3,3), (4,3)]", "#guard mapEqPairs (freqCount [5,6,7,4,9,10,4,5,6,7,9,5]) [(10,1), (5,3), (6,2), (7,2), (4,2), (9,2)]"]}
{"text": "Write a function to find the closest smaller number than n.", "task_id": 89, "code": "import Batteries\n\nopen Std\n\ndef closestNum (N : Nat) : Nat :=\n  N - 1\n\n#guard closestNum 11 == 10\n#guard closestNum 7 == 6\n#guard closestNum 12 == 11\n", "test_list": ["#guard closestNum 11 == 10", "#guard closestNum 7 == 6", "#guard closestNum 12 == 11"]}
{"text": "Write a python function to find the length of the longest word.", "task_id": 90, "code": "import Batteries\n\nopen Std\n\ndef lenLog (list1 : List String) : Nat :=\n  let initialMax := (list1.headD \"\").length\n  list1.foldl (fun maxLen i => if i.length > maxLen then i.length else maxLen) initialMax\n\n#guard lenLog [\"python\",\"PHP\",\"bigdata\"] == 7\n#guard lenLog [\"a\",\"ab\",\"abc\"] == 3\n#guard lenLog [\"small\",\"big\",\"tall\"] == 5\n", "test_list": ["#guard lenLog [\"python\",\"PHP\",\"bigdata\"] == 7", "#guard lenLog [\"a\",\"ab\",\"abc\"] == 3", "#guard lenLog [\"small\",\"big\",\"tall\"] == 5"]}
{"text": "Write a function to check if a substring is present in a given list of string values.", "task_id": 91, "code": "import Batteries\n\nopen Std\n\ndef containsSubstr (s sub : String) : Bool := Id.run do\n  if sub.length == 0 then\n    return true\n  if sub.length > s.length then\n    return false\n  let limit := s.length - sub.length + 1\n  for i in [0 : limit] do\n    if ((s.drop i).take sub.length) == sub then\n      return true\n  return false\n\ndef findSubstring (str1 : List String) (sub_str : String) : Bool :=\n  str1.any (fun s => containsSubstr s sub_str)\n\n#guard findSubstring [\"red\", \"black\", \"white\", \"green\", \"orange\"] \"ack\" == true\n#guard findSubstring [\"red\", \"black\", \"white\", \"green\", \"orange\"] \"abc\" == false\n#guard findSubstring [\"red\", \"black\", \"white\", \"green\", \"orange\"] \"ange\" == true\n", "test_list": ["#guard findSubstring [\"red\", \"black\", \"white\", \"green\", \"orange\"] \"ack\" == true", "#guard findSubstring [\"red\", \"black\", \"white\", \"green\", \"orange\"] \"abc\" == false", "#guard findSubstring [\"red\", \"black\", \"white\", \"green\", \"orange\"] \"ange\" == true"]}
{"text": "Write a function to check whether the given number is undulating or not.", "task_id": 92, "code": "import Batteries\nopen Std\n\ndef isUndulating (n : String) : Bool :=\n  if n.length ≤ 2 then\n    false\n  else\n    let rec check (chars : List Char) (i : Nat) : Bool :=\n      if i ≥ chars.length then true\n      else\n        match (chars.getD (i - 2) 'a'), (chars.getD i 'b') with\n        | c1, c2 => if c1 != c2 then false else check chars (i + 1)\n    check n.data 2\n\n#guard isUndulating \"1212121\" == true\n#guard isUndulating \"1991\" == false\n#guard isUndulating \"121\" == true\n", "test_list": ["#guard isUndulating \"1212121\" == true", "#guard isUndulating \"1991\" == false", "#guard isUndulating \"121\" == true"]}
{"text": "Write a function to calculate the value of 'a' to the power 'b'.", "task_id": 93, "code": "import Batteries\n\nopen Std\n\ndef power (a b : Nat) : Nat :=\n  match b with\n  | 0 => 1\n  | 1 => a\n  | Nat.succ (Nat.succ k) =>\n      if a == 0 then 0 else a * power a (Nat.succ k)\n\n#guard power 3 4 = 81\n#guard power 2 3 = 8\n#guard power 5 5 = 3125\n", "test_list": ["#guard power 3 4 = 81", "#guard power 2 3 = 8", "#guard power 5 5 = 3125"]}
{"text": "Write a function to extract the index minimum value record from the given tuples.", "task_id": 94, "code": "import Batteries\nopen Std\n\ndef indexMinimum (testList : List (String × Nat)) : String :=\n  match testList.foldl (fun acc x => if x.snd < acc.snd then x else acc) (\"\", Nat.succ $ testList.foldl (fun acc x => max acc x.snd) 0) with\n  | (res, _) => res\n\n#guard indexMinimum [(\"Rash\", 143), (\"Manjeet\", 200), (\"Varsha\", 100)] == \"Varsha\"\n#guard indexMinimum [(\"Yash\", 185), (\"Dawood\", 125), (\"Sanya\", 175)] == \"Dawood\"\n#guard indexMinimum [(\"Sai\", 345), (\"Salman\", 145), (\"Ayesha\", 96)] == \"Ayesha\"\n", "test_list": ["#guard indexMinimum [(\"Rash\", 143), (\"Manjeet\", 200), (\"Varsha\", 100)] == \"Varsha\"", "#guard indexMinimum [(\"Yash\", 185), (\"Dawood\", 125), (\"Sanya\", 175)] == \"Dawood\"", "#guard indexMinimum [(\"Sai\", 345), (\"Salman\", 145), (\"Ayesha\", 96)] == \"Ayesha\""]}
{"text": "Write a python function to find the minimum length of sublist.", "task_id": 95, "code": "import Batteries\n\nopen Std\n\ndef findMinLength (lst : List (List Nat)) : Nat :=\n  lst.foldl (fun acc x => Nat.min acc x.length) (lst.head!.length)\n\n#guard findMinLength [[1], [1, 2]] = 1\n#guard findMinLength [[1, 2], [1, 2, 3], [1, 2, 3, 4]] = 2\n#guard findMinLength [[3, 3, 3], [4, 4, 4, 4]] = 3\n", "test_list": ["#guard findMinLength [[1], [1, 2]] = 1", "#guard findMinLength [[1, 2], [1, 2, 3], [1, 2, 3, 4]] = 2", "#guard findMinLength [[3, 3, 3], [4, 4, 4, 4]] = 3"]}
{"text": "Write a python function to find the number of divisors of a given integer.", "task_id": 96, "code": "import Batteries\n\nopen Std\n\ndef divisor (n : Nat) : Nat :=\n  let x := (List.range (n + 1)).drop 1 |>.filter (fun i => n % i == 0) |>.length\n  x\n\n#guard divisor 15 == 4\n#guard divisor 12 == 6\n#guard divisor 9 == 3\n", "test_list": ["#guard divisor 15 == 4", "#guard divisor 12 == 6", "#guard divisor 9 == 3"]}
{"text": "Write a function to multiply all the numbers in a list and divide with the length of the list.", "task_id": 98, "code": "import Batteries\nopen Std\n\ndef multiplyNum (numbers : List Int) : Float :=\n  let total := numbers.foldl (· * ·) 1\n  let totalFloat := Float.ofInt total\n  totalFloat / Float.ofNat numbers.length\n\n#guard multiplyNum [8, 2, 3, -1, 7] == -67.2\n#guard multiplyNum [-10, -20, -30] == -2000.0\n#guard multiplyNum [19, 15, 18] == 1710.0\n", "test_list": ["#guard multiplyNum [8, 2, 3, -1, 7] == -67.2", "#guard multiplyNum [-10, -20, -30] == -2000.0", "#guard multiplyNum [19, 15, 18] == 1710.0"]}
{"text": "Write a function to convert the given decimal number to its binary equivalent.", "task_id": 99, "code": "import Batteries\n\nopen Std\n\ndef decimalToBinary (n : Nat) : String := Id.run do\n  if n == 0 then\n    return \"0\"\n  let mut x := n\n  let mut res := \"\"\n  while x > 0 do\n    let d := x % 2\n    res := toString d ++ res\n    x := x / 2\n  return res\n\n#guard decimalToBinary 8 = \"1000\"\n#guard decimalToBinary 18 = \"10010\"\n#guard decimalToBinary 7 = \"111\"\n", "test_list": ["#guard decimalToBinary 8 = \"1000\"", "#guard decimalToBinary 18 = \"10010\"", "#guard decimalToBinary 7 = \"111\""]}
{"text": "Write a function to find the next smallest palindrome of a specified number.", "task_id": 100, "code": "import Batteries\nopen Std\n\ndef nextSmallestPalindrome (num : Nat) : Nat :=\n  let isPalindrome (n : Nat) : Bool :=\n    let s := toString n\n    s == String.mk s.data.reverse\n  let rec findNext (n : Nat) (limit : Nat) : Nat :=\n    if h : limit > 0 then\n      if isPalindrome n then n else findNext (n + 1) (limit - 1)\n    else\n      n\n  findNext (num + 1) 1_000_000\n\n#eval nextSmallestPalindrome 99 == 101\n#eval nextSmallestPalindrome 1221 == 1331\n#eval nextSmallestPalindrome 120 == 121\n", "test_list": []}
{"text": "Write a function to find the kth element in the given array.", "task_id": 101, "code": "import Batteries\nopen Std\n\ndef kthElement (arr : List Nat) (n k : Nat) : Nat := Id.run do\n  \n  for _i in [0 : n] do\n    for _ in [0 : n - _i - 1] do\n      pure ()\n  \n  let dropped := arr.drop (k - 1)\n  return match dropped with\n    | h :: _ => h\n    | [] => 0\n\n#guard kthElement [12, 3, 5, 7, 19] 5 2 = 3\n#guard kthElement [17, 24, 8, 23] 4 3 = 8\n#guard kthElement [16, 21, 25, 36, 4] 5 4 = 36\n", "test_list": ["#guard kthElement [12, 3, 5, 7, 19] 5 2 = 3", "#guard kthElement [17, 24, 8, 23] 4 3 = 8", "#guard kthElement [16, 21, 25, 36, 4] 5 4 = 36"]}
{"text": "Write a function to convert snake case string to camel case string.", "task_id": 102, "code": "import Batteries\nopen Std\n\ndef snakeToCamel (word : String) : String :=\n  word.splitOn \"_\" |>.map String.capitalize |>.foldl (· ++ ·) \"\"\n\n#guard snakeToCamel \"python_program\" == \"PythonProgram\"\n#guard snakeToCamel \"python_language\" == \"PythonLanguage\"\n#guard snakeToCamel \"programming_language\" == \"ProgrammingLanguage\"\n", "test_list": ["#guard snakeToCamel \"python_program\" == \"PythonProgram\"", "#guard snakeToCamel \"python_language\" == \"PythonLanguage\"", "#guard snakeToCamel \"programming_language\" == \"ProgrammingLanguage\""]}
{"text": "Write a function to find eulerian number a(n, m).", "task_id": 103, "code": "import Batteries\n\nopen Std\n\npartial def eulerianNum (n m : Nat) : Nat :=\n  if (Nat.ble n m) || (n == 0) then\n    0\n  else if m == 0 then\n    1\n  else\n    let a := (n - m) * eulerianNum (n - 1) (m - 1)\n    let b := (m + 1) * eulerianNum (n - 1) m\n    a + b\n\n#guard eulerianNum 3 1 = 4\n#guard eulerianNum 4 1 = 11\n#guard eulerianNum 5 3 = 26\n", "test_list": ["#guard eulerianNum 3 1 = 4", "#guard eulerianNum 4 1 = 11", "#guard eulerianNum 5 3 = 26"]}
{"text": "Write a function to sort each sublist of strings in a given list of lists using lambda function.", "task_id": 104, "code": "import Batteries\n\nopen Std\n\ndef insertBy (cmp : α → α → Bool) (x : α) (xs : List α) : List α :=\n  match xs with\n  | [] => [x]\n  | y :: ys => if cmp x y then x :: y :: ys else y :: insertBy cmp x ys\n\ndef isort (cmp : α → α → Bool) (xs : List α) : List α :=\n  List.foldr (insertBy cmp) [] xs\n\ndef sortSublists (inputList : List (List String)) : List (List String) :=\n  inputList.map (isort (fun x y => x.front < y.front))\n\n#eval sortSublists [[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]] == [[\"green\", \"orange\"], [\"black\", \"white\"], [\"black\", \"orange\", \"white\"]]\n#eval sortSublists [[\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]] == [[\" red \", \"green\"], [\" black\", \"blue \"], [\" orange\", \"brown\"]]\n#eval sortSublists [[\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]] == [[\"gold\", \"zilver\"],[\"aluminium\", \"magnesium\"], [\"bronze\", \"steel\"]]\n", "test_list": []}
{"text": "Write a python function to count true booleans in the given list.", "task_id": 105, "code": "import Batteries\n\nopen Std\n\ndef count (lst : List Bool) : Nat := lst.foldl (fun acc b => if b then acc + 1 else acc) 0\n\n#guard count [true, false, true] == 2\n#guard count [false, false] == 0\n#guard count [true, true, true] == 3\n", "test_list": ["#guard count [true, false, true] == 2", "#guard count [false, false] == 0", "#guard count [true, true, true] == 3"]}
{"text": "Write a function to add the given list to the given tuples.", "task_id": 106, "code": "import Batteries\n\nopen Std\n\ndef addLists (testList : List Nat) (testTup : List Nat) : List Nat :=\n  testTup ++ testList\n\n#guard addLists [5, 6, 7] [9, 10] = [9, 10, 5, 6, 7]\n#guard addLists [6, 7, 8] [10, 11] = [10, 11, 6, 7, 8]\n#guard addLists [7, 8, 9] [11, 12] = [11, 12, 7, 8, 9]\n", "test_list": ["#guard addLists [5, 6, 7] [9, 10] = [9, 10, 5, 6, 7]", "#guard addLists [6, 7, 8] [10, 11] = [10, 11, 6, 7, 8]", "#guard addLists [7, 8, 9] [11, 12] = [11, 12, 7, 8, 9]"]}
{"text": "Write a python function to count hexadecimal numbers for a given range.", "task_id": 107, "code": "import Batteries\n\nopen Std\n\ndef count_Hexadecimal (L R : Nat) : Nat := Id.run do\n  let mut count := 0\n  for i in [L : R+1] do\n    if h15 : i ≤ 15 then\n      if h10 : 10 ≤ i then\n        count := count + 1\n      else\n        pure ()\n    else\n      let mut k := i\n      while k != 0 do\n        if hDigit : 10 ≤ k % 16 then\n          count := count + 1\n        else\n          pure ()\n        k := k / 16\n  return count\n\n#guard count_Hexadecimal 10 15 = 6\n#guard count_Hexadecimal 2 4 = 0\n#guard count_Hexadecimal 15 16 = 1\n", "test_list": ["#guard count_Hexadecimal 10 15 = 6", "#guard count_Hexadecimal 2 4 = 0", "#guard count_Hexadecimal 15 16 = 1"]}
{"text": "Write a function to merge multiple sorted inputs into a single sorted iterator using heap queue algorithm.", "task_id": 108, "code": "import Batteries\n\nopen Std\n\npartial def removeOne (l : List Nat) (v : Nat) : List Nat :=\n  match l with\n  | [] => []\n  | x :: xs => if x == v then xs else x :: removeOne xs v\n\ndef minOfList (l : List Nat) : Nat :=\n  match l with\n  | [] => 0 \n  | x :: xs => xs.foldl (fun m y => if y < m then y else m) x\n\npartial def selectionSort (l : List Nat) : List Nat :=\n  let rec aux (l acc : List Nat) : List Nat :=\n    match l with\n    | [] => acc.reverse\n    | _ =>\n      let m := minOfList l\n      let l' := removeOne l m\n      aux l' (m :: acc)\n  aux l []\n\npartial def mergeTwo (a b : List Nat) : List Nat :=\n  let rec go (a b acc : List Nat) : List Nat :=\n    match a, b with\n    | [], _ => acc.reverse ++ b\n    | _, [] => acc.reverse ++ a\n    | ha :: ta, hb :: tb =>\n      if ha ≤ hb then go ta (hb :: tb) (ha :: acc)\n      else go (ha :: ta) tb (hb :: acc)\n  go a b []\n\ndef mergeSortedList (num1 num2 num3 : List Nat) : List Nat :=\n  let num1 := selectionSort num1\n  let num2 := selectionSort num2\n  let num3 := selectionSort num3\n  let merged12 := mergeTwo num1 num2\n  let mergedAll := mergeTwo merged12 num3\n  mergedAll\n\n#guard mergeSortedList [25, 24, 15, 4, 5, 29, 110] [19, 20, 11, 56, 25, 233, 154] [24, 26, 54, 48] == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n#guard mergeSortedList [1, 3, 5, 6, 8, 9] [2, 5, 7, 11] [1, 4, 7, 8, 12] == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\n#guard mergeSortedList [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1] [25, 35, 22, 85, 14, 65, 75, 25, 58] [12, 74, 9, 50, 61, 41] == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]\n", "test_list": ["#guard mergeSortedList [25, 24, 15, 4, 5, 29, 110] [19, 20, 11, 56, 25, 233, 154] [24, 26, 54, 48] == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]", "#guard mergeSortedList [1, 3, 5, 6, 8, 9] [2, 5, 7, 11] [1, 4, 7, 8, 12] == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]", "#guard mergeSortedList [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1] [25, 35, 22, 85, 14, 65, 75, 25, 58] [12, 74, 9, 50, 61, 41] == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"]}
{"text": "Write a python function to find the count of rotations of a binary string with odd value.", "task_id": 109, "code": "import Batteries\nopen Std\n\ndef oddEquivalent (s : String) (n : Nat) : Nat :=\n  let count := s.data.take n |>.filter (· == '1') |>.length\n  count\n\n#guard oddEquivalent \"011001\" 6 == 3\n#guard oddEquivalent \"11011\" 5 == 4\n#guard oddEquivalent \"1010\" 4 == 2\n", "test_list": ["#guard oddEquivalent \"011001\" 6 == 3", "#guard oddEquivalent \"11011\" 5 == 4", "#guard oddEquivalent \"1010\" 4 == 2"]}
{"text": "Write a function to extract the ranges that are missing from the given list with the given start range and end range values.", "task_id": 110, "code": "import Batteries\nopen Std\n\ndef extractMissing (testList : List (Nat × Nat)) (strtVal stopVal : Nat) : List (Nat × Nat) :=\n  let rec loop (lst : List (Nat × Nat)) (strtVal : Nat) (acc : List (Nat × Nat)) : List (Nat × Nat) :=\n    match lst with\n    | [] => acc\n    | (s₀, s₁) :: subs =>\n      if s₀ > strtVal then\n        let newAcc := (strtVal, s₀) :: acc\n        let newStrtVal := s₁\n        loop subs newStrtVal newAcc\n      else if strtVal < stopVal then\n        let newAcc := (strtVal, stopVal) :: acc\n        loop subs strtVal newAcc\n      else\n        acc\n  loop testList strtVal []\n\n#eval extractMissing [(6, 9), (15, 34), (48, 70)] 2 100 == [(2, 6), (9, 100), (9, 15), (34, 100), (34, 48), (70, 100)].reverse\n#eval extractMissing [(7, 2), (15, 19), (38, 50)] 5 60 == [(5, 7), (2, 60), (2, 15), (19, 60), (19, 38), (50, 60)].reverse\n#eval extractMissing [(7, 2), (15, 19), (38, 50)] 1 52 == [(1, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)].reverse\n", "test_list": []}
{"text": "Write a function to find common elements in given nested lists. * list item * list item * list item * list item", "task_id": 111, "code": "import Batteries\nopen Std\n\ndef commonInNestedLists (nestedlist : List (List Nat)) : List Nat :=\n  match nestedlist with\n  | [] => []\n  | x::xs =>\n    let sets := xs.map HashSet.ofList\n    let common := sets.foldl (fun acc set => acc.filter (fun x => set.contains x)) (HashSet.ofList x)\n    common.toList\n\ndef isort (xs : List Nat) : List Nat :=\n  let rec insert (x : Nat) (ys : List Nat) : List Nat :=\n    match ys with\n    | [] => [x]\n    | y :: ys' => if x ≤ y then x :: y :: ys' else y :: insert x ys'\n  xs.foldl (fun sorted x => insert x sorted) []\n\n#eval isort [18, 12]\n\n#eval commonInNestedLists [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]] == [12, 18]\n#eval commonInNestedLists [[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]] == [5, 23]\n#eval commonInNestedLists [[2, 3, 4, 1], [4, 5], [6, 4, 8], [4, 5], [6, 8, 4]] == [4]\n\n#eval commonInNestedLists [[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]] == [12, 18]\n#eval commonInNestedLists [[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]] == [5, 23]\n#eval commonInNestedLists [[2, 3, 4, 1], [4, 5], [6, 4, 8], [4, 5], [6, 8, 4]] == [4]\n", "test_list": []}
{"text": "Write a python function to find the perimeter of a cylinder.", "task_id": 112, "code": "import Batteries\n\nopen Std\n\ndef perimeter (diameter height : Nat) : Nat :=\n  2 * (diameter + height)\n\n#guard perimeter 2 4 == 12\n#guard perimeter 1 2 == 6\n#guard perimeter 3 1 == 8\n", "test_list": ["#guard perimeter 2 4 == 12", "#guard perimeter 1 2 == 6", "#guard perimeter 3 1 == 8"]}
{"text": "Write a function to check if a string represents an integer or not.", "task_id": 113, "code": "import Batteries\nopen Std\n\ndef checkInteger (text : String) : Option Bool :=\n  let text := text.trim\n  if text.length < 1 then\n    none\n  else\n    let allDigits (s : String) (start : Nat) : Bool :=\n      s.drop start |>.all (fun ch => ch.isDigit)\n    let firstCharIsSign :=\n      match text.data with\n      | [] => false\n      | c::_ => c == '+' || c == '-'\n    if allDigits text 0 then\n      some true\n    else if firstCharIsSign && allDigits text 1 then\n      some true\n    else\n      some false\n\n#eval checkInteger \"python\" == some false\n#eval checkInteger \"1\" == some true\n#eval checkInteger \"12345\" == some true\n", "test_list": []}
{"text": "Write a function to assign frequency to each tuple in the given tuple list.", "task_id": 114, "code": "import Batteries\n\nopen Std\n\ndef joinWith (sep : String) (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: xs' => xs'.foldl (fun acc s => acc ++ sep ++ s) x\n\ndef tupleString (l : List Nat) : String :=\n  \"(\" ++ joinWith \", \" (l.map toString) ++ \")\"\n\ndef updateCounts (acc : List (List Nat × Nat)) (k : List Nat) : List (List Nat × Nat) :=\n  let (found, rev) :=\n    acc.foldl\n      (fun (p : Bool × List (List Nat × Nat)) (e : List Nat × Nat) =>\n        let found := p.1\n        let rev := p.2\n        let k' := e.1\n        let n  := e.2\n        if !found && k' == k then\n          (true, (k', n+1) :: rev)\n        else\n          (found, e :: rev)\n      )\n      (false, [])\n  let acc' := rev.reverse\n  if found then acc' else acc' ++ [(k, 1)]\n\ndef assignFreq (testList : List (List Nat)) : String :=\n  let counts := testList.foldl updateCounts []\n  let itemsStrs := counts.map (fun (k, n) => tupleString (k ++ [n]))\n  \"[\" ++ joinWith \", \" itemsStrs ++ \"]\"\n\n#guard assignFreq [[6, 5, 8], [2, 7], [6, 5, 8], [6, 5, 8], [9], [2, 7]] = \"[(6, 5, 8, 3), (2, 7, 2), (9, 1)]\"\n#guard assignFreq [[4, 2, 4], [7, 1], [4, 8], [4, 2, 4], [9, 2], [7, 1]] = \"[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]\"\n#guard assignFreq [[11, 13, 10], [17, 21], [4, 2, 3], [17, 21], [9, 2], [4, 2, 3]] = \"[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]\"\n", "test_list": ["#guard assignFreq [[6, 5, 8], [2, 7], [6, 5, 8], [6, 5, 8], [9], [2, 7]] = \"[(6, 5, 8, 3), (2, 7, 2), (9, 1)]\"", "#guard assignFreq [[4, 2, 4], [7, 1], [4, 8], [4, 2, 4], [9, 2], [7, 1]] = \"[(4, 2, 4, 2), (7, 1, 2), (4, 8, 1), (9, 2, 1)]\"", "#guard assignFreq [[11, 13, 10], [17, 21], [4, 2, 3], [17, 21], [9, 2], [4, 2, 3]] = \"[(11, 13, 10, 1), (17, 21, 2), (4, 2, 3, 2), (9, 2, 1)]\""]}
{"text": "Write a function to check whether all dictionaries in a list are empty or not.", "task_id": 115, "code": "import Batteries\n\nopen Std\n\ndef emptyDit (list1 : List (List Nat)) : Bool :=\n  list1.foldl (fun acc d => acc && d.isEmpty) true\n\n#guard emptyDit [[], [], []] == true\n#guard emptyDit [[1, 2], [], []] == false\n#guard emptyDit ([] : List (List Nat)) == true\n", "test_list": ["#guard emptyDit [[], [], []] == true", "#guard emptyDit [[1, 2], [], []] == false", "#guard emptyDit ([] : List (List Nat)) == true"]}
{"text": "Write a function to convert a given tuple of positive integers into an integer.", "task_id": 116, "code": "import Batteries\nopen Std\n\ndef tupleToInt (nums : List Nat) : Int :=\n  let strNums := nums.map (toString)\n  let concatenated := strNums.foldl (fun acc s => acc ++ s) \"\"\n  match concatenated.toInt? with\n  | some n => n\n  | none   => 0\n\n#guard tupleToInt [1, 2, 3] == 123\n#guard tupleToInt [4, 5, 6] == 456\n#guard tupleToInt [5, 6, 7] == 567\n", "test_list": ["#guard tupleToInt [1, 2, 3] == 123", "#guard tupleToInt [4, 5, 6] == 456", "#guard tupleToInt [5, 6, 7] == 567"]}
{"text": "Write a function to convert all possible convertible elements in the list to float.", "task_id": 117, "code": "import Batteries\n\nopen Std\n\ndef isAlphaStr (s : String) : Bool :=\n  s.length > 0 && s.toList.all (fun c => c.isAlpha)\n\ndef hasDot (s : String) : Bool :=\n  s.toList.any (fun c => c = '.')\n\ndef convElemRepr (ele : String) : String :=\n  if isAlphaStr ele then\n    \"'\" ++ ele ++ \"'\"\n  else\n    if hasDot ele then ele else ele ++ \".0\"\n\ndef joinWith (sep : String) (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: xr => xr.foldl (fun acc s => acc ++ sep ++ s) x\n\ndef list_to_float (test_list : List (String × String)) : String :=\n  let tuples := test_list.map (fun (a, b) => (convElemRepr a, convElemRepr b))\n  let parts := tuples.map (fun (x, y) => \"(\" ++ x ++ \", \" ++ y ++ \")\")\n  \"[\" ++ joinWith \", \" parts ++ \"]\"\n\n#guard list_to_float [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] == \"[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\"\n#guard list_to_float [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] == \"[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\"\n#guard list_to_float [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] == \"[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\"\n", "test_list": ["#guard list_to_float [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] == \"[(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]\"", "#guard list_to_float [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] == \"[(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]\"", "#guard list_to_float [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] == \"[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]\""]}
{"text": "[link text](https:// [link text](https:// [link text](https://)))write a function to convert a string to a list.", "task_id": 118, "code": "import Batteries\n\nopen Std\n\ndef stringToList (s : String) : List String :=\n  s.splitOn \" \"\n\n#guard stringToList \"python programming\" == [\"python\", \"programming\"]\n#guard stringToList \"lists tuples strings\" == [\"lists\", \"tuples\", \"strings\"]\n#guard stringToList \"write a program\" == [\"write\", \"a\", \"program\"]\n", "test_list": ["#guard stringToList \"python programming\" == [\"python\", \"programming\"]", "#guard stringToList \"lists tuples strings\" == [\"lists\", \"tuples\", \"strings\"]", "#guard stringToList \"write a program\" == [\"write\", \"a\", \"program\"]"]}
{"text": "Write a python function to find the element that appears only once in a sorted array.", "task_id": 119, "code": "import Batteries\n\nopen Std\n\ndef search (arr : List Nat) (n : Nat) : Nat :=\n  let xor := arr.foldl (fun acc x => acc ^^^ x) 0\n  xor\n\n#guard search [1,1,2,2,3] 5 == 3\n#guard search [1,1,3,3,4,4,5,5,7,7,8] 11 == 8\n#guard search [1,2,2,3,3,4,4] 7 == 1\n", "test_list": ["#guard search [1,1,2,2,3] 5 == 3", "#guard search [1,1,3,3,4,4,5,5,7,7,8] 11 == 8", "#guard search [1,2,2,3,3,4,4] 7 == 1"]}
{"text": "Write a function to find the maximum product from the pairs of tuples within a given list.", "task_id": 120, "code": "import Batteries\nopen Std\n\ndef maxProductTuple (list1 : List (Nat × Nat)) : Nat :=\n  list1.foldl (fun acc (x, y) => Nat.max acc (x * y)) 0\n\n#eval (maxProductTuple [(2, 7), (2, 6), (1, 8), (4, 9)] == 36)\n#eval (maxProductTuple [(10, 20), (15, 2), (5, 10)] == 200)\n#eval (maxProductTuple [(11, 44), (10, 15), (20, 5), (12, 9)] == 484)\n", "test_list": []}
{"text": "Write a function to find the triplet with sum of the given array", "task_id": 121, "code": "import Batteries\nopen Std\n\ndef checkTriplet (A : List Int) : Nat → Int → Nat → Bool\n| 0, sum, count => count == 3 && sum == 0\n| n+1, sum, count =>\n  if count == 3 then\n    sum == 0\n  else if sum < 0 then\n    false\n  else\n    let a_n := A.getD n 0\n    checkTriplet A n (sum - a_n) (count + 1) ||\n    checkTriplet A n sum count\n\n#guard checkTriplet [2, 7, 4, 0, 9, 5, 1, 3] 8 6 0 == true\n#guard checkTriplet [1, 4, 5, 6, 7, 8, 5, 9] 8 6 0 == false\n#guard checkTriplet [10, 4, 2, 3, 5] 5 15 0 == true\n", "test_list": ["#guard checkTriplet [2, 7, 4, 0, 9, 5, 1, 3] 8 6 0 == true", "#guard checkTriplet [1, 4, 5, 6, 7, 8, 5, 9] 8 6 0 == false", "#guard checkTriplet [10, 4, 2, 3, 5] 5 15 0 == true"]}
{"text": "Write a function to find n’th smart number.", "task_id": 122, "code": "import Batteries\n\nopen Std\n\nprivate def insertBy {α} (cmp : α → α → Bool) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys => if cmp x y then x :: y :: ys else y :: insertBy cmp x ys\n\nprivate def isort {α} (cmp : α → α → Bool) : List α → List α\n  | [] => []\n  | x :: xs => insertBy cmp x (isort cmp xs)\n\ndef smartNumber (n : Nat) : Nat := Id.run do\n  let MAX : Nat := 3000\n  let mut primes : Array Int := Array.replicate MAX 0\n  let mut result : Array Nat := #[]\n  for i in [2 : MAX] do\n    if primes[i]! == 0 then\n      primes := primes.set! i 1\n      let mut j := i * 2\n      while j < MAX do\n        primes := primes.set! j (primes[j]! - 1)\n        if primes[j]! + 3 == 0 then\n          result := result.push j\n        j := j + i\n  let sorted := isort (· ≤ ·) result.toList\n  return sorted.getD (n - 1) 0\n\n#guard smartNumber 1 == 30\n#guard smartNumber 50 == 273\n#guard smartNumber 1000 == 2664\n", "test_list": ["#guard smartNumber 1 == 30", "#guard smartNumber 50 == 273", "#guard smartNumber 1000 == 2664"]}
{"text": "Write a function to sum all amicable numbers from 1 to a specified number.", "task_id": 123, "code": "import Batteries\nopen Std\n\ndef divisorsSum (n : Nat) : Nat :=\n  (List.range n).foldl (fun acc i => if n % (i + 1) == 0 then acc + (i + 1) else acc) 0\n\ndef amicableNumbersSum (limit : Nat) : Nat :=\n  Id.run do\n    let mut amicables := HashSet.empty\n    for num in [2:limit + 1] do\n      if !amicables.contains num then\n        let sumFact := divisorsSum num\n        let sumFact2 := divisorsSum sumFact\n        if num == sumFact2 && num != sumFact then\n          amicables := amicables.insert num\n          amicables := amicables.insert sumFact\n    return amicables.fold (fun acc x => acc + x) 0\n\n#eval amicableNumbersSum 999 \n#eval amicableNumbersSum 9999 \n#eval amicableNumbersSum 99\n", "test_list": []}
{"text": "Write a function to get the angle of a complex number.", "task_id": 124, "code": "import Batteries\n\nopen Std\n\ndef angleComplex (a b : Float) : Float := Float.atan2 b a\n\n#guard angleComplex 0 1 == 1.5707963267948966\n#guard angleComplex 2 1 == 0.4636476090008061\n#guard angleComplex 0 2 == 1.5707963267948966\n", "test_list": ["#guard angleComplex 0 1 == 1.5707963267948966", "#guard angleComplex 2 1 == 0.4636476090008061", "#guard angleComplex 0 2 == 1.5707963267948966"]}
{"text": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.", "task_id": 125, "code": "import Batteries\nopen Std\n\ndef findLength (string : String) (n : Nat) : Nat := Id.run do\n  let mut currentSum : Int := 0\n  let mut maxSum : Int := 0\n  let chars := string.data.take n\n  for c in chars do\n    currentSum := currentSum + (if c == '0' then (1 : Int) else (-1))\n    if currentSum < 0 then\n      currentSum := 0\n    if currentSum > maxSum then\n      maxSum := currentSum\n  if maxSum == 0 then\n    return 0\n  else\n    return Int.toNat maxSum\n\n#guard findLength \"11000010001\" 11 = 6\n#guard findLength \"10111\" 5 = 1\n#guard findLength \"11011101100101\" 14 = 2\n", "test_list": ["#guard findLength \"11000010001\" 11 = 6", "#guard findLength \"10111\" 5 = 1", "#guard findLength \"11011101100101\" 14 = 2"]}
{"text": "Write a python function to find the sum of common divisors of two given numbers.", "task_id": 126, "code": "import Batteries\n\nopen Std\n\ndef sumDivisors (a b : Nat) : Nat := Id.run do\n  let mut sum := 0\n  for i in [1 : min a b] do\n    if a % i == 0 && b % i == 0 then\n      sum := sum + i\n  return sum\n\n#guard sumDivisors 10 15 == 6\n#guard sumDivisors 100 150 == 93\n#guard sumDivisors 4 6 == 3\n", "test_list": ["#guard sumDivisors 10 15 == 6", "#guard sumDivisors 100 150 == 93", "#guard sumDivisors 4 6 == 3"]}
{"text": "Write a function to multiply two integers without using the * operator in python.", "task_id": 127, "code": "import Batteries\n\nopen Std\n\ndef multiplyIntNat (x : Int) (n : Nat) : Int :=\n  match n with\n  | 0 => 0\n  | Nat.succ k => x + multiplyIntNat x k\n\ndef multiplyInt (x y : Int) : Int :=\n  if y < 0 then\n    - multiplyIntNat x (Int.toNat (-y))\n  else\n    multiplyIntNat x (Int.toNat y)\n\n#guard multiplyInt 10 20 = 200\n#guard multiplyInt 5 10 = 50\n#guard multiplyInt 4 8 = 32\n", "test_list": ["#guard multiplyInt 10 20 = 200", "#guard multiplyInt 5 10 = 50", "#guard multiplyInt 4 8 = 32"]}
{"text": "Write a function to shortlist words that are longer than n from a given list of words.", "task_id": 128, "code": "import Batteries\n\nopen Std\n\ndef longWords (n : Nat) (str : String) : List String :=\n  let txt := str.splitOn \" \"\n  txt.foldl (fun acc x => if x.length > n then acc ++ [x] else acc) []\n\n#guard longWords 3 \"python is a programming language\" == [\"python\", \"programming\", \"language\"]\n#guard longWords 2 \"writing a program\" == [\"writing\", \"program\"]\n#guard longWords 5 \"sorting list\" == [\"sorting\"]\n", "test_list": ["#guard longWords 3 \"python is a programming language\" == [\"python\", \"programming\", \"language\"]", "#guard longWords 2 \"writing a program\" == [\"writing\", \"program\"]", "#guard longWords 5 \"sorting list\" == [\"sorting\"]"]}
{"text": "Write a function to calculate magic square.", "task_id": 129, "code": "import Batteries\n\nopen Std\n\ndef magicSquareTest (myMatrix : List (List Nat)) : Bool :=\n  let iSize := (myMatrix.headD []).length\n  let sumList := Id.run do\n    let mut sums := ([] : List Nat)\n    for lines in myMatrix do\n      sums := sums ++ [lines.foldl (fun acc x => acc + x) 0]\n    for col in [0:iSize] do\n      sums := sums ++ [myMatrix.foldl (fun acc row => acc + row.getD col 0) 0]\n    let result1 := List.foldl (fun acc i => acc + (myMatrix.getD i []).getD i 0) 0 (List.range iSize)\n    sums := sums ++ [result1]\n    let result2 := List.foldl (fun acc i => acc + (myMatrix.getD (iSize - i - 1) []).getD i 0) 0 (List.range iSize)\n    sums := sums ++ [result2]\n    return sums\n  HashSet.ofList sumList |>.size == 1\n\n#guard magicSquareTest [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]] = true\n#guard magicSquareTest [[2, 7, 6], [9, 5, 1], [4, 3, 8]] = true\n#guard magicSquareTest [[2, 7, 6], [9, 5, 1], [4, 3, 7]] = false\n", "test_list": ["#guard magicSquareTest [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]] = true", "#guard magicSquareTest [[2, 7, 6], [9, 5, 1], [4, 3, 8]] = true", "#guard magicSquareTest [[2, 7, 6], [9, 5, 1], [4, 3, 7]] = false"]}
{"text": "Write a function to find the item with maximum frequency in a given list.", "task_id": 130, "code": "import Batteries\n\nopen Std\n\ndef updateCount (acc : List (Nat × Nat)) (x : Nat) : List (Nat × Nat) :=\n  match acc with\n  | [] => [(x, 1)]\n  | (y, c) :: rest =>\n    if x == y then\n      (y, c + 1) :: rest\n    else\n      (y, c) :: updateCount rest x\n\ndef maxOccurrences (nums : List Nat) : Nat × Nat :=\n  let counts := nums.foldl updateCount []\n  match counts with\n  | [] => (0, 0)\n  | h :: t =>\n    let best := t.foldl (fun (best : Nat × Nat) (p : Nat × Nat) =>\n      let (curk, curc) := best\n      let (k, c) := p\n      if c > curc then (k, c) else best\n    ) h\n    best\n\n#guard maxOccurrences [2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2] = (2, 5)\n#guard maxOccurrences [2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18] = (8, 2)\n#guard maxOccurrences [10,20,20,30,40,90,80,50,30,20,50,10] = (20, 3)\n", "test_list": ["#guard maxOccurrences [2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2] = (2, 5)", "#guard maxOccurrences [2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,16,18] = (8, 2)", "#guard maxOccurrences [10,20,20,30,40,90,80,50,30,20,50,10] = (20, 3)"]}
{"text": "Write a python function to reverse only the vowels of a given string.", "task_id": 131, "code": "import Batteries\nopen Std\n\ndef reverseVowels (str1 : String) : String :=\n  let vowels := str1.foldl (init := []) fun vowels char =>\n    if char ∈ \"aeiouAEIOU\".data then char :: vowels else vowels\n  let vowelsList := vowels.reverse\n  let rec process (s : List Char) (vowels : List Char) (acc : List Char) : List Char :=\n    match s with\n    | [] => acc.reverse\n    | c :: cs =>\n      if c ∈ \"aeiouAEIOU\".data then\n        match vowels with\n        | [] => process cs vowels (c :: acc)\n        | v :: vs => process cs vs (v :: acc)\n      else\n        process cs vowels (c :: acc)\n  String.mk <| process str1.data vowelsList []\n\n#eval (reverseVowels \"Python\" == \"Python\")\n#eval (reverseVowels \"USA\" == \"ASU\")\n#eval (reverseVowels \"ab\" == \"ba\")\n", "test_list": []}
{"text": "Write a function to convert tuple to a string.", "task_id": 132, "code": "import Batteries\nopen Std\n\ndef tupString (tup1 : List Char) : String := String.mk tup1\n\n#guard tupString ['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'] == \"exercises\"\n#guard tupString ['p', 'y', 't', 'h', 'o', 'n'] == \"python\"\n#guard tupString ['p', 'r', 'o', 'g', 'r', 'a', 'm'] == \"program\"\n", "test_list": ["#guard tupString ['e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'] == \"exercises\"", "#guard tupString ['p', 'y', 't', 'h', 'o', 'n'] == \"python\"", "#guard tupString ['p', 'r', 'o', 'g', 'r', 'a', 'm'] == \"program\""]}
{"text": "Write a function to calculate the sum of the negative numbers of a given list of numbers using lambda function.", "task_id": 133, "code": "import Batteries\n\nopen Std\n\ndef sumNegativenum (nums : List Int) : Int :=\n  let negNums := nums.filter (fun x => x < 0)\n  negNums.foldl (fun acc x => acc + x) 0\n\n#guard sumNegativenum [2, 4, -6, -9, 11, -12, 14, -5, 17] == -32\n#guard sumNegativenum [10, 15, -14, 13, -18, 12, -20] == -52\n#guard sumNegativenum [19, -65, 57, 39, 152, -639, 121, 44, 90, -190] == -894\n", "test_list": ["#guard sumNegativenum [2, 4, -6, -9, 11, -12, 14, -5, 17] == -32", "#guard sumNegativenum [10, 15, -14, 13, -18, 12, -20] == -52", "#guard sumNegativenum [19, -65, 57, 39, 152, -639, 121, 44, 90, -190] == -894"]}
{"text": "Write a python function to check whether the last element of given array is even or odd after performing an operation p times.", "task_id": 134, "code": "import Batteries\n\nopen Std\n\ndef checkLast (arr : List Int) (n p : Nat) : String :=\n  let sum := arr.foldl (fun acc x => acc + x) 0\n  if p == 1 then\n    if sum % 2 == 0 then\n      \"ODD\"\n    else\n      \"EVEN\"\n  else\n    \"EVEN\"\n\n#guard checkLast [5, 7, 10] 3 1 == \"ODD\"\n#guard checkLast [2, 3] 2 3 == \"EVEN\"\n#guard checkLast [1, 2, 3] 3 1 == \"ODD\"\n", "test_list": ["#guard checkLast [5, 7, 10] 3 1 == \"ODD\"", "#guard checkLast [2, 3] 2 3 == \"EVEN\"", "#guard checkLast [1, 2, 3] 3 1 == \"ODD\""]}
{"text": "Write a function to find the nth hexagonal number.", "task_id": 135, "code": "import Batteries\n\nopen Std\n\ndef hexagonalNum (n : Nat) : Nat :=\n  n * (2*n - 1)\n\n#guard hexagonalNum 10 = 190\n#guard hexagonalNum 5 = 45\n#guard hexagonalNum 7 = 91\n", "test_list": ["#guard hexagonalNum 10 = 190", "#guard hexagonalNum 5 = 45", "#guard hexagonalNum 7 = 91"]}
{"text": "Write a function to calculate electricity bill.", "task_id": 136, "code": "import Batteries\n\nopen Std\n\ndef calElectbill (units : Nat) : Float :=\n  let amountCents :=\n    if units < 50 then\n      units * 260\n    else if units <= 100 then\n      13000 + (units - 50) * 325\n    else if units <= 200 then\n      13000 + 16250 + (units - 100) * 526\n    else\n      13000 + 16250 + 52600 + (units - 200) * 845\n  let surchargeCents :=\n    if units < 50 then 2500\n    else if units <= 100 then 3500\n    else if units <= 200 then 4500\n    else 7500\n  let totalCents := amountCents + surchargeCents\n  (Float.ofNat totalCents) / 100.0\n\n#guard calElectbill 75 == 246.25\n#guard calElectbill 265 == 1442.75\n#guard calElectbill 100 == 327.5\n", "test_list": ["#guard calElectbill 75 == 246.25", "#guard calElectbill 265 == 1442.75", "#guard calElectbill 100 == 327.5"]}
{"text": "Write a function to find the ration of zeroes in an array of integers.", "task_id": 137, "code": "import Batteries\n\nopen Std\n\ndef zeroCount (nums : List Int) : Float := Id.run do\n  let n := nums.length\n  let mut n1 : Nat := 0\n  for x in nums do\n    if x == 0 then\n      n1 := n1 + 1\n    else\n      ()\n  \n  \n  let num := n1 * 100\n  let roundedInt := (num * 2 + n) / (2 * n)\n  return (Float.ofNat roundedInt) / 100.0\n\n#guard zeroCount [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8] == 0.15\n#guard zeroCount [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] == 0.0\n#guard zeroCount [2, 4, -6, -9, 11, -12, 14, -5, 17] == 0.0\n", "test_list": ["#guard zeroCount [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8] == 0.15", "#guard zeroCount [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] == 0.0", "#guard zeroCount [2, 4, -6, -9, 11, -12, 14, -5, 17] == 0.0"]}
{"text": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.", "task_id": 138, "code": "import Batteries\n\nopen Std\n\ndef is_Sum_Of_Powers_Of_Two (n : Nat) : Bool :=\n  if n % 2 == 1 then\n    false\n  else\n    true\n\n#guard is_Sum_Of_Powers_Of_Two 10 == true\n#guard is_Sum_Of_Powers_Of_Two 7 == false\n#guard is_Sum_Of_Powers_Of_Two 14 == true\n", "test_list": ["#guard is_Sum_Of_Powers_Of_Two 10 == true", "#guard is_Sum_Of_Powers_Of_Two 7 == false", "#guard is_Sum_Of_Powers_Of_Two 14 == true"]}
{"text": "Write a function to find the circumference of a circle.", "task_id": 139, "code": "import Batteries\n\nopen Std\n\ndef circleCircumference (r : Nat) : Float :=\n  let perimeter := 2.0 * 3.1415 * (Nat.toFloat r)\n  perimeter\n\n#guard circleCircumference 10 == 62.830000000000005\n#guard circleCircumference 5 == 31.415000000000003\n#guard circleCircumference 4 == 25.132\n", "test_list": ["#guard circleCircumference 10 == 62.830000000000005", "#guard circleCircumference 5 == 31.415000000000003", "#guard circleCircumference 4 == 25.132"]}
{"text": "Write a function to extract elements that occur singly in the given tuple list.", "task_id": 140, "code": "import Batteries\n\nopen Std\n\ndef extractSingly (testList : List (List Nat)) : List Nat := Id.run do\n  let mut temp : HashSet Nat := HashSet.empty\n  let mut res : Array Nat := #[]\n  for inner in testList do\n    for ele in inner do\n      if !temp.contains ele then\n        temp := temp.insert ele\n        res := res.push ele\n  return res.toList\n\n#guard extractSingly [[3, 4, 5], [4, 5, 7], [1, 4]] == [3, 4, 5, 7, 1]\n#guard extractSingly [[1, 2, 3], [4, 2, 3], [7, 8]] == [1, 2, 3, 4, 7, 8]\n#guard extractSingly [[7, 8, 9], [10, 11, 12], [10, 11]] == [7, 8, 9, 10, 11, 12]\n", "test_list": ["#guard extractSingly [[3, 4, 5], [4, 5, 7], [1, 4]] == [3, 4, 5, 7, 1]", "#guard extractSingly [[1, 2, 3], [4, 2, 3], [7, 8]] == [1, 2, 3, 4, 7, 8]", "#guard extractSingly [[7, 8, 9], [10, 11, 12], [10, 11]] == [7, 8, 9, 10, 11, 12]"]}
{"text": "Write a function to sort a list of elements using pancake sort.", "task_id": 141, "code": "import Batteries\n\nopen Std\n\ndef indexFirst (xs : List Nat) (v : Nat) : Nat :=\n  let rec go (lst : List Nat) (i : Nat) : Nat :=\n    match lst with\n    | [] => 0\n    | y :: ys => if y = v then i else go ys (i+1)\n  go xs 0\n\ndef pancakeSort (nums : List Nat) : List Nat := Id.run do\n  let mut nums := nums\n  let mut arrLen := nums.length\n  while arrLen > 1 do\n    let pref := nums.take arrLen\n    let m := pref.foldl Nat.max 0\n    let mi := indexFirst nums m\n    nums := (nums.take (mi+1)).reverse ++ nums.drop (mi+1)\n    nums := (nums.take arrLen).reverse ++ nums.drop arrLen\n    arrLen := arrLen - 1\n  return nums\n\n#guard pancakeSort [15, 79, 25, 38, 69] = [15, 25, 38, 69, 79]\n#guard pancakeSort [98, 12, 54, 36, 85] = [12, 36, 54, 85, 98]\n#guard pancakeSort [41, 42, 32, 12, 23] = [12, 23, 32, 41, 42]\n", "test_list": ["#guard pancakeSort [15, 79, 25, 38, 69] = [15, 25, 38, 69, 79]", "#guard pancakeSort [98, 12, 54, 36, 85] = [12, 36, 54, 85, 98]", "#guard pancakeSort [41, 42, 32, 12, 23] = [12, 23, 32, 41, 42]"]}
{"text": "Write a function to count the same pair in three given lists.", "task_id": 142, "code": "import Batteries\n\nopen Std\n\ndef count_samepair (list1 list2 list3 : List Nat) : Nat :=\n  match list1, list2, list3 with\n  | m :: ms, n :: ns, o :: os =>\n    let inc := if (m == n) && (n == o) then 1 else 0\n    inc + count_samepair ms ns os\n  | _, _, _ => 0\n\n#guard count_samepair [1,2,3,4,5,6,7,8] [2,2,3,1,2,6,7,9] [2,1,3,1,2,6,7,9] = 3\n#guard count_samepair [1,2,3,4,5,6,7,8] [2,2,3,1,2,6,7,8] [2,1,3,1,2,6,7,8] = 4\n#guard count_samepair [1,2,3,4,2,6,7,8] [2,2,3,1,2,6,7,8] [2,1,3,1,2,6,7,8] = 5\n", "test_list": ["#guard count_samepair [1,2,3,4,5,6,7,8] [2,2,3,1,2,6,7,9] [2,1,3,1,2,6,7,9] = 3", "#guard count_samepair [1,2,3,4,5,6,7,8] [2,2,3,1,2,6,7,8] [2,1,3,1,2,6,7,8] = 4", "#guard count_samepair [1,2,3,4,2,6,7,8] [2,2,3,1,2,6,7,8] [2,1,3,1,2,6,7,8] = 5"]}
{"text": "Write a function to find number of lists present in the given tuple.", "task_id": 143, "code": "import Batteries\n\nopen Std\n\ndef findLists (Input : List (List Nat)) : Nat :=\n  Input.length\n\n#guard findLists [[1, 2, 3, 4], [5, 6, 7, 8]] = 2\n#guard findLists [[1, 2], [3, 4], [5, 6]] = 3\n#guard findLists [[9, 8, 7, 6, 5, 4, 3, 2, 1]] = 1\n", "test_list": ["#guard findLists [[1, 2, 3, 4], [5, 6, 7, 8]] = 2", "#guard findLists [[1, 2], [3, 4], [5, 6]] = 3", "#guard findLists [[9, 8, 7, 6, 5, 4, 3, 2, 1]] = 1"]}
{"text": "Write a python function to find the sum of absolute differences in all pairs of the given array.", "task_id": 144, "code": "import Batteries\nopen Std\n\ndef getAtD {α} (xs : List α) (i : Nat) (d : α) : α :=\n  match xs.drop i with\n  | [] => d\n  | y :: _ => y\n\ndef sumPairs (arr : List Int) (n : Nat) : Int := Id.run do\n  let mut s : Int := 0\n  for i in [0 : n] do\n    let j := (n - 1) - i\n    let x := getAtD arr j 0\n    let term := (Int.ofNat j) * x - (Int.ofNat i) * x\n    s := s + term\n  return s\n\n#guard sumPairs [1, 8, 9, 15, 16] 5 = 74\n#guard sumPairs [1, 2, 3, 4] 4 = 10\n#guard sumPairs [1, 2, 3, 4, 5, 7, 9, 11, 14] 9 = 188\n", "test_list": ["#guard sumPairs [1, 8, 9, 15, 16] 5 = 74", "#guard sumPairs [1, 2, 3, 4] 4 = 10", "#guard sumPairs [1, 2, 3, 4, 5, 7, 9, 11, 14] 9 = 188"]}
{"text": "Write a python function to find the maximum difference between any two elements in a given array.", "task_id": 145, "code": "import Batteries\nopen Std\n\ndef maxAbsDiff (arr : List Nat) (n : Nat) : Nat :=\n  let l := arr.take n\n  match l with\n  | [] => 0\n  | x :: xs =>\n    let (mn, mx) :=\n      xs.foldl\n        (fun (mnmx : Nat × Nat) z =>\n          let mn := mnmx.fst\n          let mx := mnmx.snd\n          (Nat.min mn z, Nat.max mx z))\n        (x, x)\n    mx - mn\n\n#guard maxAbsDiff [2,1,5,3] 4 = 4\n#guard maxAbsDiff [9,3,2,5,1] 5 = 8\n#guard maxAbsDiff [3,2,1] 3 = 2\n", "test_list": ["#guard maxAbsDiff [2,1,5,3] 4 = 4", "#guard maxAbsDiff [9,3,2,5,1] 5 = 8", "#guard maxAbsDiff [3,2,1] 3 = 2"]}
{"text": "Write a function to find the ascii value of total characters in a string.", "task_id": 146, "code": "import Batteries\n\nopen Std\n\ndef ascii_value_string (str1 : String) : Nat :=\n  \n  match str1.toList with\n  | c :: _ => Char.toNat c\n  | [] => 0\n\n#guard ascii_value_string \"python\" = 112\n#guard ascii_value_string \"Program\" = 80\n#guard ascii_value_string \"Language\" = 76\n", "test_list": ["#guard ascii_value_string \"python\" = 112", "#guard ascii_value_string \"Program\" = 80", "#guard ascii_value_string \"Language\" = 76"]}
{"text": "Write a function to find the maximum total path sum in the given triangle.", "task_id": 147, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef maxPathSum (tri : List (List Nat)) (m n : Nat) : Nat := Id.run do\n  let mut a : Array (Array Nat) := tri.toArray.map (fun row => row.toArray)\n  \n  for di in [0 : m] do\n    let i := (m - 1) - di\n    \n    for j in [0 : i + 1] do\n      let below := a.get2d (i+1) j 0\n      let belowRight := a.get2d (i+1) (j+1) 0\n      let chosen := if below > belowRight then below else belowRight\n      let current := a.get2d i j 0\n      a := a.set2d? i j (current + chosen)\n  return a.get2d 0 0 0\n\n#guard maxPathSum [[1, 0, 0], [4, 8, 0], [1, 5, 3]] 2 2 = 14\n#guard maxPathSum [[13, 0, 0], [7, 4, 0], [2, 4, 6]] 2 2 = 24\n#guard maxPathSum [[2, 0, 0], [11, 18, 0], [21, 25, 33]] 2 2 = 53\n", "test_list": ["#guard maxPathSum [[1, 0, 0], [4, 8, 0], [1, 5, 3]] 2 2 = 14", "#guard maxPathSum [[13, 0, 0], [7, 4, 0], [2, 4, 6]] 2 2 = 24", "#guard maxPathSum [[2, 0, 0], [11, 18, 0], [21, 25, 33]] 2 2 = 53"]}
{"text": "Write a function to divide a number into two parts such that the sum of digits is maximum.", "task_id": 148, "code": "import Batteries\n\nopen Std\n\ndef sumDigitsSingle (x : Nat) : Nat := Id.run do\n  let mut ans := 0\n  let mut y := x\n  while y != 0 do\n    ans := ans + y % 10\n    y := y / 10\n  return ans\n\ndef closest (x : Nat) : Nat := Id.run do\n  let mut ans := 0\n  while ans * 10 + 9 ≤ x do\n    ans := ans * 10 + 9\n  return ans\n\ndef sumDigitsTwoparts (N : Nat) : Nat :=\n  let A := closest N\n  sumDigitsSingle A + sumDigitsSingle (N - A)\n\n#guard sumDigitsTwoparts 35 == 17\n#guard sumDigitsTwoparts 7 == 7\n#guard sumDigitsTwoparts 100 == 19\n", "test_list": ["#guard sumDigitsTwoparts 35 == 17", "#guard sumDigitsTwoparts 7 == 7", "#guard sumDigitsTwoparts 100 == 19"]}
{"text": "Write a python function to find whether the given number is present in the infinite sequence or not.", "task_id": 150, "code": "import Batteries\nopen Std\n\ndef doesContainB (a b c : Int) : Bool :=\n  if a == b then\n    true\n  else\n    let diff := b - a\n    if (decide ((diff * c) > 0)) && (diff % c == 0) then true else false\n\n#guard doesContainB 1 7 3 == true\n#guard doesContainB 1 (-3) 5 == false\n#guard doesContainB 3 2 5 == false\n", "test_list": ["#guard doesContainB 1 7 3 == true", "#guard doesContainB 1 (-3) 5 == false", "#guard doesContainB 3 2 5 == false"]}
{"text": "Write a python function to check whether the given number is co-prime or not.", "task_id": 151, "code": "import Batteries\n\nopen Std\n\ndef gcd (p q : Nat) : Nat := Id.run do\n  let mut p := p\n  let mut q := q\n  while q != 0 do\n    let oldP := p\n    p := q\n    q := oldP % p\n  return p\n\ndef isCoprime (x y : Nat) : Bool := gcd x y == 1\n\n#guard isCoprime 17 13 == true\n#guard isCoprime 15 21 == false\n#guard isCoprime 25 45 == false\n", "test_list": ["#guard isCoprime 17 13 == true", "#guard isCoprime 15 21 == false", "#guard isCoprime 25 45 == false"]}
{"text": "Write a function to sort the given array by using merge sort.", "task_id": 152, "code": "import Batteries\n\nopen Std\n\npartial def merge (a b : List Nat) : List Nat :=\n  match a, b with\n  | [], _ => b\n  | _, [] => a\n  | ha::ta, hb::tb =>\n    if ha < hb then\n      ha :: merge ta b\n    else\n      hb :: merge a tb\n\npartial def mergeSort (x : List Nat) : List Nat :=\n  match x with\n  | [] => []\n  | [a] => [a]\n  | _ =>\n    let middle := x.length / 2\n    let a := x.take middle\n    let b := x.drop middle\n    merge (mergeSort a) (mergeSort b)\n\n#guard mergeSort [3, 4, 2, 6, 5, 7, 1, 9] = [1, 2, 3, 4, 5, 6, 7, 9]\n#guard mergeSort [7, 25, 45, 78, 11, 33, 19] = [7, 11, 19, 25, 33, 45, 78]\n#guard mergeSort [3, 1, 4, 9, 8] = [1, 3, 4, 8, 9]\n", "test_list": ["#guard mergeSort [3, 4, 2, 6, 5, 7, 1, 9] = [1, 2, 3, 4, 5, 6, 7, 9]", "#guard mergeSort [7, 25, 45, 78, 11, 33, 19] = [7, 11, 19, 25, 33, 45, 78]", "#guard mergeSort [3, 1, 4, 9, 8] = [1, 3, 4, 8, 9]"]}
{"text": "Write a function to find the vertex of a parabola.", "task_id": 153, "code": "import Batteries\n\nopen Std\n\ndef parabolaVertex (a b c : Float) : Float × Float :=\n  let vertex := ((-b / (2 * a)), (((4 * a * c) - (b * b)) / (4 * a)))\n  vertex\n\n#guard parabolaVertex 5 3 2 == (-0.3, 1.55)\n#guard parabolaVertex 9 8 4 == (-0.4444444444444444, 2.2222222222222223)\n#guard parabolaVertex 2 4 6 == (-1.0, 4.0)\n", "test_list": ["#guard parabolaVertex 5 3 2 == (-0.3, 1.55)", "#guard parabolaVertex 9 8 4 == (-0.4444444444444444, 2.2222222222222223)", "#guard parabolaVertex 2 4 6 == (-1.0, 4.0)"]}
{"text": "Write a function to extract every specified element from a given two dimensional list.", "task_id": 154, "code": "import Batteries\n\nopen Std\n\ndef specifiedElement (nums : List (List Nat)) (N : Nat) : List Nat :=\n  nums.map (fun i => i.getD N 0)\n\n#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 0 == [1, 4, 7]\n#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 2 == [3, 6, 9]\n#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 3 == [2, 2, 5]\n", "test_list": ["#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 0 == [1, 4, 7]", "#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 2 == [3, 6, 9]", "#guard specifiedElement [[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]] 3 == [2, 2, 5]"]}
{"text": "Write a python function to toggle all even bits of a given number.", "task_id": 155, "code": "import Batteries\n\nopen Std\n\ndef evenBitToggleNumber (n : Nat) : Nat := Id.run do\n  let mut res := 0\n  let mut count := 0\n  let mut temp := n\n  while temp > 0 do\n    if count % 2 == 1 then\n      res := res ||| (2 ^ count)\n    count := count + 1\n    temp := temp / 2\n  return n ^^^ res\n\n#guard evenBitToggleNumber 10 = 0\n#guard evenBitToggleNumber 20 = 30\n#guard evenBitToggleNumber 30 = 20\n", "test_list": ["#guard evenBitToggleNumber 10 = 0", "#guard evenBitToggleNumber 20 = 30", "#guard evenBitToggleNumber 30 = 20"]}
{"text": "Write a function to convert a tuple of string values to a tuple of integer values.", "task_id": 156, "code": "import Batteries\n\nopen Std\n\ndef charToDigit (c : Char) : Nat := c.toNat - '0'.toNat\n\ndef parseNat (s : String) : Nat :=\n  s.data.foldl (fun acc c => acc * 10 + charToDigit c) 0\n\ndef tupleIntStr (tupleStr : List (String × String)) : List (Nat × Nat) :=\n  tupleStr.map (fun x => (parseNat x.fst, parseNat x.snd))\n\n#guard tupleIntStr [(\"333\", \"33\"), (\"1416\", \"55\")] = [(333, 33), (1416, 55)]\n#guard tupleIntStr [(\"999\", \"99\"), (\"1000\", \"500\")] = [(999, 99), (1000, 500)]\n#guard tupleIntStr [(\"666\", \"66\"), (\"1500\", \"555\")] = [(666, 66), (1500, 555)]\n", "test_list": ["#guard tupleIntStr [(\"333\", \"33\"), (\"1416\", \"55\")] = [(333, 33), (1416, 55)]", "#guard tupleIntStr [(\"999\", \"99\"), (\"1000\", \"500\")] = [(999, 99), (1000, 500)]", "#guard tupleIntStr [(\"666\", \"66\"), (\"1500\", \"555\")] = [(666, 66), (1500, 555)]"]}
{"text": "Write a function to reflect the run-length encoding from a list.", "task_id": 157, "code": "import Batteries\nopen Std\n\nnoncomputable instance instDecidableEqFloat : DecidableEq Float := Classical.decEq _\n\ndef encodeList {α : Type} [DecidableEq α] (list1 : List α) : List (Nat × α) :=\n  match list1 with\n  | [] => []\n  | x :: xs =>\n    let rec go (current : α) (count : Nat) (rest : List α) (acc : List (Nat × α)) : List (Nat × α) :=\n      match rest with\n      | [] => ((count, current) :: acc).reverse\n      | y :: ys =>\n        match decEq y current with\n        | isTrue _ => go current (count + 1) ys acc\n        | isFalse _ => go y 1 ys ((count, current) :: acc)\n    go x 1 xs []\n\n#guard encodeList [1.0, 1.0, 2.0, 3.0, 4.0, 4.3, 5.0, 1.0] = [(2, 1.0), (1, 2.0), (1, 3.0), (1, 4.0), (1, 4.3), (1, 5.0), (1, 1.0)]\n#guard encodeList (\"automatically\".data) = [(1, 'a'), (1, 'u'), (1, 't'), (1, 'o'), (1, 'm'), (1, 'a'), (1, 't'), (1, 'i'), (1, 'c'), (1, 'a'), (2, 'l'), (1, 'y')]\n#guard encodeList (\"python\".data) = [(1, 'p'), (1, 'y'), (1, 't'), (1, 'h'), (1, 'o'), (1, 'n')]\n", "test_list": ["#guard encodeList [1.0, 1.0, 2.0, 3.0, 4.0, 4.3, 5.0, 1.0] = [(2, 1.0), (1, 2.0), (1, 3.0), (1, 4.0), (1, 4.3), (1, 5.0), (1, 1.0)]", "#guard encodeList (\"automatically\".data) = [(1, 'a'), (1, 'u'), (1, 't'), (1, 'o'), (1, 'm'), (1, 'a'), (1, 't'), (1, 'i'), (1, 'c'), (1, 'a'), (2, 'l'), (1, 'y')]", "#guard encodeList (\"python\".data) = [(1, 'p'), (1, 'y'), (1, 't'), (1, 'h'), (1, 'o'), (1, 'n')]"]}
{"text": "Write a python function to find k number of operations required to make all elements equal.", "task_id": 158, "code": "import Batteries\n\nopen Std\n\ndef min_Ops (arr : List Nat) (n k : Nat) : Int := Id.run do\n  \n  let xs := arr.take n\n  let max1 := xs.foldl (fun m x => if m < x then x else m) 0\n  let mut res : Int := 0\n  for x in xs do\n    if (max1 - x) % k != 0 then\n      return (-1)\n    else\n      res := res + Int.ofNat ((max1 - x) / k)\n  return res\n\n#guard min_Ops [2,2,2,2] 4 3 == (0 : Int)\n#guard min_Ops [4,2,6,8] 4 3 == (-1 : Int)\n#guard min_Ops [21,33,9,45,63] 5 6 == (24 : Int)\n", "test_list": ["#guard min_Ops [2,2,2,2] 4 3 == (0 : Int)", "#guard min_Ops [4,2,6,8] 4 3 == (-1 : Int)", "#guard min_Ops [21,33,9,45,63] 5 6 == (24 : Int)"]}
{"text": "Write a function to print the season for the given month and day.", "task_id": 159, "code": "import Batteries\n\nopen Std\n\ndef monthSeason (month : String) (days : Nat) : String :=\n  let season0 :=\n    if month == \"January\" || month == \"February\" || month == \"March\" then\n      \"winter\"\n    else if month == \"April\" || month == \"May\" || month == \"June\" then\n      \"spring\"\n    else if month == \"July\" || month == \"August\" || month == \"September\" then\n      \"summer\"\n    else\n      \"autumn\"\n  let season1 :=\n    if (month == \"March\") && Nat.blt 19 days then\n      \"spring\"\n    else if (month == \"June\") && Nat.blt 20 days then\n      \"summer\"\n    else if (month == \"September\") && Nat.blt 21 days then\n      \"autumn\"\n    else if (month == \"October\") && Nat.blt 21 days then\n      \"autumn\"\n    else if (month == \"November\") && Nat.blt 21 days then\n      \"autumn\"\n    else if (month == \"December\") && Nat.blt 20 days then\n      \"winter\"\n    else\n      season0\n  season1\n\n#guard monthSeason \"January\" 4 == \"winter\"\n#guard monthSeason \"October\" 28 == \"autumn\"\n#guard monthSeason \"June\" 6 == \"spring\"\n", "test_list": ["#guard monthSeason \"January\" 4 == \"winter\"", "#guard monthSeason \"October\" 28 == \"autumn\"", "#guard monthSeason \"June\" 6 == \"spring\""]}
{"text": "Write a function to find x and y that satisfies ax + by = n.", "task_id": 160, "code": "import Batteries\n\nopen Std\n\ndef solution (a b n : Nat) : Sum (String × Nat × String × Nat) String := Id.run do\n  for i in [: n+1] do\n    if Nat.ble (i * a) n then\n      if (n - i * a) % b == 0 then\n        let y := (n - i * a) / b\n        return Sum.inl (\"x = \", i, \", y = \", y)\n      else\n        pure ()\n    else\n      pure ()\n  return Sum.inr \"No solution\"\n\n#guard solution 2 3 7 = Sum.inl (\"x = \", 2, \", y = \", 1)\n#guard solution 4 2 7 = Sum.inr \"No solution\"\n#guard solution 1 13 17 = Sum.inl (\"x = \", 4, \", y = \", 1)\n", "test_list": ["#guard solution 2 3 7 = Sum.inl (\"x = \", 2, \", y = \", 1)", "#guard solution 4 2 7 = Sum.inr \"No solution\"", "#guard solution 1 13 17 = Sum.inl (\"x = \", 4, \", y = \", 1)"]}
{"text": "Write a function to remove all elements from a given list present in another list.", "task_id": 161, "code": "import Batteries\n\nopen Std\n\ndef removeElements (list1 list2 : List Nat) : List Nat :=\n  list1.filter (fun x => !(list2.contains x))\n\n#guard removeElements [1,2,3,4,5,6,7,8,9,10] [2,4,6,8] = [1, 3, 5, 7, 9, 10]\n#guard removeElements [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [1, 3, 5, 7] = [2, 4, 6, 8, 9, 10]\n#guard removeElements [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [5,7] = [1, 2, 3, 4, 6, 8, 9, 10]\n", "test_list": ["#guard removeElements [1,2,3,4,5,6,7,8,9,10] [2,4,6,8] = [1, 3, 5, 7, 9, 10]", "#guard removeElements [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [1, 3, 5, 7] = [2, 4, 6, 8, 9, 10]", "#guard removeElements [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] [5,7] = [1, 2, 3, 4, 6, 8, 9, 10]"]}
{"text": "Write a function to calculate the sum of the positive integers of n+(n-2)+(n-4)... (until n-x =< 0).", "task_id": 162, "code": "import Batteries\n\nopen Std\n\ndef sumSeries : Nat → Nat\n| 0 => 0\n| 1 => 1\n| Nat.succ (Nat.succ k) => (k + 2) + sumSeries k\n\n#guard sumSeries 6 = 12\n#guard sumSeries 10 = 30\n#guard sumSeries 9 = 25\n", "test_list": ["#guard sumSeries 6 = 12", "#guard sumSeries 10 = 30", "#guard sumSeries 9 = 25"]}
{"text": "Write a function to calculate the area of a regular polygon.", "task_id": 163, "code": "import Batteries\n\nopen Std\n\ndef areaPolygon (s l : Float) : Float :=\n  let piF : Float := 3.141592653589793\n  let area := s * (l * l) / (4.0 * Float.tan (piF / s))\n  area\n\n#guard areaPolygon 4.0 20.0 == 400.00000000000006\n#guard areaPolygon 10.0 15.0 == 1731.1969896610804\n#guard areaPolygon 9.0 7.0 == 302.90938549487214\n", "test_list": ["#guard areaPolygon 4.0 20.0 == 400.00000000000006", "#guard areaPolygon 10.0 15.0 == 1731.1969896610804", "#guard areaPolygon 9.0 7.0 == 302.90938549487214"]}
{"text": "Write a python function to check whether the sum of divisors are same or not.", "task_id": 164, "code": "import Batteries\n\nopen Std\n\ndef divSum (n : Nat) : Nat := Id.run do\n  let mut s := 1\n  for i in [2 : Nat.sqrt n + 1] do\n    if n % i == 0 then\n      s := s + i + n / i\n  return s\n\ndef areEquivalent (num1 num2 : Nat) : Bool :=\n  divSum num1 == divSum num2\n\n#guard areEquivalent 36 57 == false\n#guard areEquivalent 2 4 == false\n#guard areEquivalent 23 47 == true\n", "test_list": ["#guard areEquivalent 36 57 == false", "#guard areEquivalent 2 4 == false", "#guard areEquivalent 23 47 == true"]}
{"text": "Write a python function to count characters at same position in a given string (lower and uppercase characters) as in english alphabet.", "task_id": 165, "code": "import Batteries\n\nopen Std\n\ndef countCharPosition (str1 : String) : Nat := Id.run do\n  let ordA : Int := Int.ofNat (Char.toNat 'A')\n  let ordLowerA : Int := Int.ofNat (Char.toNat 'a')\n  let mut count : Nat := 0\n  let mut i : Nat := 0\n  for c in str1.data do\n    let ci : Int := Int.ofNat (Char.toNat c)\n    let iI : Int := Int.ofNat i\n    if iI == ci - ordA || iI == ci - ordLowerA then\n      count := count + 1\n    i := i + 1\n  return count\n\n#guard countCharPosition \"xbcefg\" = 2\n#guard countCharPosition \"ABcED\" = 3\n#guard countCharPosition \"AbgdeF\" = 5\n", "test_list": ["#guard countCharPosition \"xbcefg\" = 2", "#guard countCharPosition \"ABcED\" = 3", "#guard countCharPosition \"AbgdeF\" = 5"]}
{"text": "Write a python function to count the pairs with xor as an even number.", "task_id": 166, "code": "import Batteries\n\nopen Std\n\ndef find_even_Pair (A : List Nat) (N : Nat) : Nat := Id.run do\n  let mut evenPair := 0\n  for i in [0:N] do\n    for j in [i+1:N] do\n      let ai := A.getD i 0\n      let aj := A.getD j 0\n      if ((ai ^^^ aj) % 2 == 0) then\n        evenPair := evenPair + 1\n  return evenPair\n\n#guard find_even_Pair [5,4,7,2,1] 5 = 4\n#guard find_even_Pair [7,2,8,1,0,5,11] 7 = 9\n#guard find_even_Pair [1,2,3] 3 = 1\n", "test_list": ["#guard find_even_Pair [5,4,7,2,1] 5 = 4", "#guard find_even_Pair [7,2,8,1,0,5,11] 7 = 9", "#guard find_even_Pair [1,2,3] 3 = 1"]}
{"text": "Write a python function to find smallest power of 2 greater than or equal to n.", "task_id": 167, "code": "import Batteries\n\nopen Std\n\ndef next_Power_Of_2 (n : Nat) : Nat := Id.run do\n  let mut count := 0\n  if n != 0 && (n &&& (n - 1)) == 0 then\n    return n\n  let mut m := n\n  while m != 0 do\n    m := m >>> 1\n    count := count + 1\n  return (1 <<< count)\n\n#guard next_Power_Of_2 0 = 1\n#guard next_Power_Of_2 5 = 8\n#guard next_Power_Of_2 17 = 32\n", "test_list": ["#guard next_Power_Of_2 0 = 1", "#guard next_Power_Of_2 5 = 8", "#guard next_Power_Of_2 17 = 32"]}
{"text": "Write a python function to find the frequency of a number in a given array.", "task_id": 168, "code": "import Batteries\n\nopen Std\n\ndef frequency (a : List Nat) (x : Nat) : Nat := Id.run do\n  let mut count := 0\n  for i in a do\n    if i == x then\n      count := count + 1\n  return count\n\n#guard frequency [1,2,3] 4 = 0\n#guard frequency [1,2,2,3,3,3,4] 3 = 3\n#guard frequency [0,1,2,3,1,2] 1 = 2\n", "test_list": ["#guard frequency [1,2,3] 4 = 0", "#guard frequency [1,2,2,3,3,3,4] 3 = 3", "#guard frequency [0,1,2,3,1,2] 1 = 2"]}
{"text": "Write a function to calculate the nth pell number.", "task_id": 169, "code": "import Batteries\n\nopen Std\n\ndef getPell (n : Nat) : Nat := Id.run do\n  if n <= 2 then\n    return n\n  let mut a := 1\n  let mut b := 2\n  for _ in [3 : n+1] do\n    let c := 2 * b + a\n    a := b\n    b := c\n  return b\n\n#guard getPell 4 == 12\n#guard getPell 7 == 169\n#guard getPell 8 == 408\n", "test_list": ["#guard getPell 4 == 12", "#guard getPell 7 == 169", "#guard getPell 8 == 408"]}
{"text": "Write a function to find sum of the numbers in a list between the indices of a specified range.", "task_id": 170, "code": "import Batteries\n\nopen Std\n\ndef sumRangeList (list1 : List Nat) (m n : Nat) : Nat := Id.run do\n  \n  let mut sum_range := 0\n  for i in [m : n+1] do\n    sum_range := sum_range + list1.getD i 0\n  return sum_range\n\n#guard sumRangeList [2,1,5,6,8,3,4,9,10,11,8,12] 8 10 = 29\n#guard sumRangeList [2,1,5,6,8,3,4,9,10,11,8,12] 5 7 = 16\n#guard sumRangeList [2,1,5,6,8,3,4,9,10,11,8,12] 7 10 = 38\n", "test_list": ["#guard sumRangeList [2,1,5,6,8,3,4,9,10,11,8,12] 8 10 = 29", "#guard sumRangeList [2,1,5,6,8,3,4,9,10,11,8,12] 5 7 = 16", "#guard sumRangeList [2,1,5,6,8,3,4,9,10,11,8,12] 7 10 = 38"]}
{"text": "Write a function to find the perimeter of a pentagon.", "task_id": 171, "code": "import Batteries\n\nopen Std\n\ndef perimeter_pentagon (a : Nat) : Nat :=\n  5 * a\n\n#guard perimeter_pentagon 5 = 25\n#guard perimeter_pentagon 10 = 50\n#guard perimeter_pentagon 15 = 75\n", "test_list": ["#guard perimeter_pentagon 5 = 25", "#guard perimeter_pentagon 10 = 50", "#guard perimeter_pentagon 15 = 75"]}
{"text": "Write a function to find the occurence of characters 'std' in the given string 1. list item 1. list item 1. list item 2. list item 2. list item 2. list item", "task_id": 172, "code": "import Batteries\n\nopen Std\n\ndef countOccurance (s : String) : Nat := Id.run do\n  let n := s.length\n  let mut count := 0\n  for i in [0 : n] do\n    let sub := (s.drop i).take 3\n    if sub == \"std\" then\n      count := count + 1\n  return count\n\n#guard countOccurance \"letstdlenstdporstd\" = 3\n#guard countOccurance \"truststdsolensporsd\" = 1\n#guard countOccurance \"makestdsostdworthit\" = 2\n", "test_list": ["#guard countOccurance \"letstdlenstdporstd\" = 3", "#guard countOccurance \"truststdsolensporsd\" = 1", "#guard countOccurance \"makestdsostdworthit\" = 2"]}
{"text": "Write a function to remove everything except alphanumeric characters from a string.", "task_id": 173, "code": "import Batteries\n\nopen Std\n\ndef remove_splchar (text : String) : String :=\n  text.foldl (init := \"\") (fun acc c => if Char.isAlphanum c then acc.push c else acc)\n\n#guard remove_splchar \"python  @#&^%$*program123\" == \"pythonprogram123\"\n#guard remove_splchar \"python %^$@!^&*()  programming24%$^^()    language\" == \"pythonprogramming24language\"\n#guard remove_splchar \"python   ^%&^()(+_)(_^&67)                  program\" == \"python67program\"\n", "test_list": ["#guard remove_splchar \"python  @#&^%$*program123\" == \"pythonprogram123\"", "#guard remove_splchar \"python %^$@!^&*()  programming24%$^^()    language\" == \"pythonprogramming24language\"", "#guard remove_splchar \"python   ^%&^()(+_)(_^&67)                  program\" == \"python67program\""]}
{"text": "Write a function to group a sequence of key-value pairs into a dictionary of lists.", "task_id": 174, "code": "import Batteries\nopen Std\n\ndef find? [BEq α] [Hashable α] (m : HashMap α β) (k : α) : Option β :=\n  m.fold (init := (none : Option β)) (fun acc a b =>\n    match acc with\n    | some _ => acc\n    | none => if a == k then some b else none)\n\ndef groupKeyvalue (l : List (String × Nat)) : Std.HashMap String (List Nat) := Id.run do\n  let mut m : Std.HashMap String (List Nat) := {}\n  for (k, v) in l do\n    let old :=\n      match m.find? k with\n      | some xs => xs\n      | none => []\n    m := m.insert k (old ++ [v])\n  return m\n\n#guard (\n  (match (Task174.groupKeyvalue [(\"yellow\", 1), (\"blue\", 2), (\"yellow\", 3), (\"blue\", 4), (\"red\", 1)]).find? \"yellow\" with | some xs => xs | none => []) == [1, 3]\n  &&\n  (match (Task174.groupKeyvalue [(\"yellow\", 1), (\"blue\", 2), (\"yellow\", 3), (\"blue\", 4), (\"red\", 1)]).find? \"blue\" with | some xs => xs | none => []) == [2, 4]\n  &&\n  (match (Task174.groupKeyvalue [(\"yellow\", 1), (\"blue\", 2), (\"yellow\", 3), (\"blue\", 4), (\"red\", 1)]).find? \"red\" with | some xs => xs | none => []) == [1]\n  &&\n  ((Task174.groupKeyvalue [(\"yellow\", 1), (\"blue\", 2), (\"yellow\", 3), (\"blue\", 4), (\"red\", 1)]).toList.length == 3)\n)\n\n#guard (\n  (match (Task174.groupKeyvalue [(\"python\", 1), (\"python\", 2), (\"python\", 3), (\"python\", 4), (\"python\", 5)]).find? \"python\" with | some xs => xs | none => []) == [1,2,3,4,5]\n  &&\n  ((Task174.groupKeyvalue [(\"python\", 1), (\"python\", 2), (\"python\", 3), (\"python\", 4), (\"python\", 5)]).toList.length == 1)\n)\n\n#guard (\n  (match (Task174.groupKeyvalue [(\"yellow\",100), (\"blue\", 200), (\"yellow\", 300), (\"blue\", 400), (\"red\", 100)]).find? \"yellow\" with | some xs => xs | none => []) == [100, 300]\n  &&\n  (match (Task174.groupKeyvalue [(\"yellow\",100), (\"blue\", 200), (\"yellow\", 300), (\"blue\", 400), (\"red\", 100)]).find? \"blue\" with | some xs => xs | none => []) == [200, 400]\n  &&\n  (match (Task174.groupKeyvalue [(\"yellow\",100), (\"blue\", 200), (\"yellow\", 300), (\"blue\", 400), (\"red\", 100)]).find? \"red\" with | some xs => xs | none => []) == [100]\n  &&\n  ((Task174.groupKeyvalue [(\"yellow\",100), (\"blue\", 200), (\"yellow\", 300), (\"blue\", 400), (\"red\", 100)]).toList.length == 3)\n)\n", "test_list": ["#guard (", "#guard (", "#guard ("]}
{"text": "Write a function to verify validity of a string of parentheses.", "task_id": 175, "code": "import Batteries\n\nopen Std\n\ndef isValidParenthese (str1 : String) : Bool :=\n  let final := str1.foldl (init := (some ([] : List Char))) (fun acc c =>\n    match acc with\n    | none => none\n    | some stack =>\n      if c == '(' || c == '{' || c == '[' then\n        some (c :: stack)\n      else\n        match stack with\n        | [] => none\n        | top :: rest =>\n          match top with\n          | '(' => if c == ')' then some rest else none\n          | '{' => if c == '}' then some rest else none\n          | '[' => if c == ']' then some rest else none\n          | _ => none\n  )\n  match final with\n  | some [] => true\n  | _ => false\n\n#guard isValidParenthese \"(){}[]\" == true\n#guard isValidParenthese \"()[{)}\" == false\n#guard isValidParenthese \"()\" == true\n", "test_list": ["#guard isValidParenthese \"(){}[]\" == true", "#guard isValidParenthese \"()[{)}\" == false", "#guard isValidParenthese \"()\" == true"]}
{"text": "Write a function to find the perimeter of a triangle.", "task_id": 176, "code": "import Batteries\n\nopen Std\n\ndef perimeterTriangle (a b c : Nat) : Nat :=\n  let perimeter := a + b + c\n  perimeter\n\n#guard perimeterTriangle 10 20 30 = 60\n#guard perimeterTriangle 3 4 5 = 12\n#guard perimeterTriangle 25 35 45 = 105\n", "test_list": ["#guard perimeterTriangle 10 20 30 = 60", "#guard perimeterTriangle 3 4 5 = 12", "#guard perimeterTriangle 25 35 45 = 105"]}
{"text": "Write a python function to find two distinct numbers such that their lcm lies within the given range.", "task_id": 177, "code": "import Batteries\n\nopen Std\n\ndef answer (L R : Nat) : Int × Int :=\n  if 2 * L ≤ R then (Int.ofNat L, Int.ofNat (2 * L)) else (-1, -1)\n\n#guard answer 3 8 = ((3, 6) : Int × Int)\n#guard answer 2 6 = ((2, 4) : Int × Int)\n#guard answer 1 3 = ((1, 2) : Int × Int)\n", "test_list": ["#guard answer 3 8 = ((3, 6) : Int × Int)", "#guard answer 2 6 = ((2, 4) : Int × Int)", "#guard answer 1 3 = ((1, 2) : Int × Int)"]}
{"text": "Write a function to search some literals strings in a string.", "task_id": 178, "code": "import Batteries\nopen Std\n\ndef containsSubstr (text pat : String) : Bool := Id.run do\n  let tlen := text.length\n  let plen := pat.length\n  if plen == 0 then\n    return true\n  if tlen < plen then\n    return false\n  for i in [0 : tlen - plen + 1] do\n    let seg := (text.drop i).take plen\n    if seg == pat then\n      return true\n  return false\n\ndef stringLiterals (patterns : List String) (text : String) : String := Id.run do\n  for pattern in patterns do\n    if containsSubstr text pattern then\n      return \"Matched!\"\n    else\n      return \"Not Matched!\"\n  \n  return \"Not Matched!\"\n\n#guard stringLiterals [\"language\"] \"python language\" = \"Matched!\"\n#guard stringLiterals [\"program\"] \"python language\" = \"Not Matched!\"\n#guard stringLiterals [\"python\"] \"programming language\" = \"Not Matched!\"\n", "test_list": ["#guard stringLiterals [\"language\"] \"python language\" = \"Matched!\"", "#guard stringLiterals [\"program\"] \"python language\" = \"Not Matched!\"", "#guard stringLiterals [\"python\"] \"programming language\" = \"Not Matched!\""]}
{"text": "Write a function to find if the given number is a keith number or not.", "task_id": 179, "code": "import Batteries\nopen Std\n\ndef collectDigits (temp : Nat) (acc : List Nat) (n : Nat) : (List Nat × Nat) :=\n  let rec loop (temp : Nat) (acc : List Nat) (n : Nat) (fuel : Nat) : (List Nat × Nat) :=\n    match fuel with\n    | 0 => (acc, n)\n    | fuel' + 1 =>\n      if temp > 0 then\n        loop (temp / 10) (acc ++ [temp % 10]) (n + 1) fuel'\n      else\n        (acc, n)\n  loop temp acc n (temp + 1)\n\ndef keithLoop (x n : Nat) (terms : Array Nat) (i nextTerm : Nat) : Bool :=\n  let rec loop (terms : Array Nat) (i nextTerm : Nat) (fuel : Nat) : Bool :=\n    match fuel with\n    | 0 => false\n    | fuel' + 1 =>\n      if nextTerm < x then\n        let s := Id.run do\n          let mut s := 0\n          for j in [1 : n + 1] do\n            let idx := i - j\n            let v := Array.getD terms idx 0\n            s := s + v\n          return s\n        loop (terms.push s) (i + 1) s fuel'\n      else\n        nextTerm == x\n  loop terms i nextTerm (x + 10000)\n\ndef isNumKeith (x : Nat) : Bool := Id.run do\n  let (termsLE, n) := collectDigits x [] 0\n  let termsList := termsLE.reverse\n  let termsArr : Array Nat := Array.mk termsList\n  return keithLoop x n termsArr n 0\n\n#guard isNumKeith 14 == true\n#guard isNumKeith 12 == false\n#guard isNumKeith 197 == true\n", "test_list": ["#guard isNumKeith 14 == true", "#guard isNumKeith 12 == false", "#guard isNumKeith 197 == true"]}
{"text": "Write a function to calculate distance between two points using latitude and longitude.", "task_id": 180, "code": "import Batteries\nopen Std\n\ndef distanceLatLong (slat slon elat elon : Float) : Float :=\n  let dist := 6371.01 * Float.acos (Float.sin slat * Float.sin elat + Float.cos slat * Float.cos elat * Float.cos (slon - elon))\n  dist\n\ndef approxEq (a b tol : Float) : Bool :=\n  let d := if a >= b then a - b else b - a\n  decide (d ≤ tol)\n\n#guard approxEq (distanceLatLong 23.5 67.5 25.5 69.5) 12179.372041317429 1e-9\n#guard approxEq (distanceLatLong 10.5 20.5 30.5 40.5) 6069.397933300514 1e-9\n#guard approxEq (distanceLatLong 10.0 20.0 30.0 40.0) 6783.751974994595 1e-9\n", "test_list": ["#guard approxEq (distanceLatLong 23.5 67.5 25.5 69.5) 12179.372041317429 1e-9", "#guard approxEq (distanceLatLong 10.5 20.5 30.5 40.5) 6069.397933300514 1e-9", "#guard approxEq (distanceLatLong 10.0 20.0 30.0 40.0) 6783.751974994595 1e-9"]}
{"text": "Write a function to find the longest common prefix in the given set of strings.", "task_id": 181, "code": "import Batteries\n\nopen Std\n\nprivate def lcpLenAux (l1 l2 : List Char) (acc : Nat) : Nat :=\n  match l1, l2 with\n  | c1 :: t1, c2 :: t2 =>\n    if c1 == c2 then lcpLenAux t1 t2 (acc + 1) else acc\n  | _, _ => acc\n\ndef commonPrefixUtil (str1 str2 : String) : String :=\n  let k := lcpLenAux str1.data str2.data 0\n  str1.take k\n\ndef commonPrefix (arr : List String) (n : Nat) : String :=\n  let taken := arr.take n\n  match taken with\n  | [] => \"\"\n  | p :: xs => xs.foldl (fun acc s => commonPrefixUtil acc s) p\n\n#guard commonPrefix [\"tablets\", \"tables\", \"taxi\", \"tamarind\"] 4 = \"ta\"\n#guard commonPrefix [\"apples\", \"ape\", \"april\"] 3 = \"ap\"\n#guard commonPrefix [\"teens\", \"teenager\", \"teenmar\"] 3 = \"teen\"\n", "test_list": ["#guard commonPrefix [\"tablets\", \"tables\", \"taxi\", \"tamarind\"] 4 = \"ta\"", "#guard commonPrefix [\"apples\", \"ape\", \"april\"] 3 = \"ap\"", "#guard commonPrefix [\"teens\", \"teenager\", \"teenmar\"] 3 = \"teen\""]}
{"text": "Write a function to find uppercase, lowercase, special character and numeric values using regex.", "task_id": 182, "code": "import Batteries\n\nopen Std\n\ndef lettersFrom (start : Char) (len : Nat) : List Char :=\n  (List.range len).map (fun i => Char.ofNat (start.toNat + i))\n\ndef charSetFrom (start : Char) (len : Nat) : HashSet Char :=\n  HashSet.ofList (lettersFrom start len)\n\ndef uppercaseSet : HashSet Char := charSetFrom 'A' 26\ndef lowercaseSet : HashSet Char := charSetFrom 'a' 26\ndef digitSet     : HashSet Char := charSetFrom '0' 10\ndef specialSet   : HashSet Char := HashSet.ofList [',', ' ', '.', '!', '?']\n\ndef charToString (c : Char) : String := String.mk [c]\n\ndef find_character (s : String) : (List String × List String × List String × List String) := Id.run do\n  let mut ups : List String := []\n  let mut lows : List String := []\n  let mut nums : List String := []\n  let mut specs : List String := []\n  for c in s.data do\n    if c ∈ uppercaseSet then\n      ups := (charToString c) :: ups\n    else if c ∈ lowercaseSet then\n      lows := (charToString c) :: lows\n    else if c ∈ digitSet then\n      nums := (charToString c) :: nums\n    else if c ∈ specialSet then\n      specs := (charToString c) :: specs\n    else\n      pure ()\n  return (ups.reverse, lows.reverse, nums.reverse, specs.reverse)\n\n#guard find_character \"ThisIsGeeksforGeeks\" == ([\"T\", \"I\", \"G\", \"G\"], [\"h\", \"i\", \"s\", \"s\", \"e\", \"e\", \"k\", \"s\", \"f\", \"o\", \"r\", \"e\", \"e\", \"k\", \"s\"], [], [])\n#guard find_character \"Hithere2\" == ([\"H\"], [\"i\", \"t\", \"h\", \"e\", \"r\", \"e\"], [\"2\"], [])\n#guard find_character \"HeyFolks32\" == ([\"H\", \"F\"], [\"e\", \"y\", \"o\", \"l\", \"k\", \"s\"], [\"3\", \"2\"], [])\n", "test_list": ["#guard find_character \"ThisIsGeeksforGeeks\" == ([\"T\", \"I\", \"G\", \"G\"], [\"h\", \"i\", \"s\", \"s\", \"e\", \"e\", \"k\", \"s\", \"f\", \"o\", \"r\", \"e\", \"e\", \"k\", \"s\"], [], [])", "#guard find_character \"Hithere2\" == ([\"H\"], [\"i\", \"t\", \"h\", \"e\", \"r\", \"e\"], [\"2\"], [])", "#guard find_character \"HeyFolks32\" == ([\"H\", \"F\"], [\"e\", \"y\", \"o\", \"l\", \"k\", \"s\"], [\"3\", \"2\"], [])"]}
{"text": "Write a function to count all the distinct pairs having a difference of k in any array.", "task_id": 183, "code": "import Batteries\n\nopen Std\n\ndef countPairs (arr : List Nat) (n : Nat) (k : Nat) : Nat := Id.run do\n  \n  let a := arr.toArray\n  let mut count := 0\n  for i in [0 : n] do\n    for j in [i+1 : n] do\n      let xi := a.getD i 0\n      let xj := a.getD j 0\n      if (xi - xj == k) || (xj - xi == k) then\n        count := count + 1\n  return count\n\n#guard countPairs [1, 5, 3, 4, 2] 5 3 = 2\n#guard countPairs [8, 12, 16, 4, 0, 20] 6 4 = 5\n#guard countPairs [2, 4, 1, 3, 4] 5 2 = 3\n", "test_list": ["#guard countPairs [1, 5, 3, 4, 2] 5 3 = 2", "#guard countPairs [8, 12, 16, 4, 0, 20] 6 4 = 5", "#guard countPairs [2, 4, 1, 3, 4] 5 2 = 3"]}
{"text": "Write a function to find all the values in a list that are greater than a specified number.", "task_id": 184, "code": "import Batteries\n\nopen Std\n\ndef greaterSpecificnum (list : List Nat) (num : Nat) : Bool :=\n  list.all (fun x => Nat.ble num x)\n\n#guard greaterSpecificnum [220, 330, 500] 200 == true\n#guard greaterSpecificnum [12, 17, 21] 20 == false\n#guard greaterSpecificnum [1, 2, 3, 4] 10 == false\n", "test_list": ["#guard greaterSpecificnum [220, 330, 500] 200 == true", "#guard greaterSpecificnum [12, 17, 21] 20 == false", "#guard greaterSpecificnum [1, 2, 3, 4] 10 == false"]}
{"text": "Write a function to find the focus of a parabola.", "task_id": 185, "code": "import Batteries\n\nopen Std\n\ndef parabolaFocus (a b c : Float) : Float × Float :=\n  let focus := (-b / (2 * a), ((4 * a * c) - (b * b) + 1) / (4 * a))\n  focus\n\n#guard parabolaFocus 5 3 2 == (-0.3, 1.6)\n#guard parabolaFocus 9 8 4 == (-0.4444444444444444, 2.25)\n#guard parabolaFocus 2 4 6 == (-1.0, 4.125)\n", "test_list": ["#guard parabolaFocus 5 3 2 == (-0.3, 1.6)", "#guard parabolaFocus 9 8 4 == (-0.4444444444444444, 2.25)", "#guard parabolaFocus 2 4 6 == (-1.0, 4.125)"]}
{"text": "Write a function to search some literals strings in a string by using regex.", "task_id": 186, "code": "import Batteries\n\nopen Std\n\ndef containsSubstring (s p : String) : Bool := Id.run do\n  let n := s.length\n  let m := p.length\n  if m == 0 then\n    return true\n  if m > n then\n    return false\n  for i in [0 : n - m + 1] do\n    if (s.drop i).take m == p then\n      return true\n  return false\n\ndef check_literals (text : String) (patterns : List String) : String := Id.run do\n  for pattern in patterns do\n    if containsSubstring text pattern then\n      return \"Matched!\"\n    else\n      return \"Not Matched!\"\n  return \"Not Matched!\"\n\n#guard check_literals \"The quick brown fox jumps over the lazy dog.\" [\"fox\"] == \"Matched!\"\n#guard check_literals \"The quick brown fox jumps over the lazy dog.\" [\"horse\"] == \"Not Matched!\"\n#guard check_literals \"The quick brown fox jumps over the lazy dog.\" [\"lazy\"] == \"Matched!\"\n", "test_list": ["#guard check_literals \"The quick brown fox jumps over the lazy dog.\" [\"fox\"] == \"Matched!\"", "#guard check_literals \"The quick brown fox jumps over the lazy dog.\" [\"horse\"] == \"Not Matched!\"", "#guard check_literals \"The quick brown fox jumps over the lazy dog.\" [\"lazy\"] == \"Matched!\""]}
{"text": "Write a function to find the longest common subsequence for the given two sequences.", "task_id": 187, "code": "import Batteries\n\nopen Std\n\npartial def longestCommonSubsequence (X Y : String) (m n : Nat) : Nat :=\n  if m == 0 || n == 0 then 0\n  else\n    let xLast := (X.take m).drop (m - 1)\n    let yLast := (Y.take n).drop (n - 1)\n    if xLast == yLast then\n      1 + longestCommonSubsequence X Y (m - 1) (n - 1)\n    else\n      let a := longestCommonSubsequence X Y m (n - 1)\n      let b := longestCommonSubsequence X Y (m - 1) n\n      if a >= b then a else b\n\n#guard longestCommonSubsequence \"AGGTAB\" \"GXTXAYB\" 6 7 = 4\n#guard longestCommonSubsequence \"ABCDGH\" \"AEDFHR\" 6 6 = 3\n#guard longestCommonSubsequence \"AXYT\" \"AYZX\" 4 4 = 2\n", "test_list": ["#guard longestCommonSubsequence \"AGGTAB\" \"GXTXAYB\" 6 7 = 4", "#guard longestCommonSubsequence \"ABCDGH\" \"AEDFHR\" 6 6 = 3", "#guard longestCommonSubsequence \"AXYT\" \"AYZX\" 4 4 = 2"]}
{"text": "Write a python function to check whether the given number can be represented by product of two squares or not.", "task_id": 188, "code": "import Batteries\n\nopen Std\n\ndef prodSquare (n : Nat) : Bool := Id.run do\n  for i in [2 : n + 1] do\n    if i * i < n + 1 then\n      for j in [2 : n + 1] do\n        if i * i * j * j == n then\n          return true\n  return false\n\n#guard prodSquare 25 == false\n#guard prodSquare 30 == false\n#guard prodSquare 16 == true\n", "test_list": ["#guard prodSquare 25 == false", "#guard prodSquare 30 == false", "#guard prodSquare 16 == true"]}
{"text": "Write a python function to find the first missing positive number.", "task_id": 189, "code": "import Batteries\n\nopen Std\n\ndef firstMissingPositive (arr : List Int) (n : Nat) : Nat := Id.run do\n  \n  let mut a : Array Int := arr.toArray\n  let mut ptr : Nat := 0\n  \n  for i in [: n] do\n    if a[i]! == 1 then\n      ptr := 1\n  if ptr == 0 then\n    return 1\n  \n  for i in [: n] do\n    let ai := a[i]!\n    if ai ≤ 0 || ai > Int.ofNat n then\n      a := a.set! i 1\n  \n  for i in [: n] do\n    let ai := a[i]!\n    \n    let r : Int := (ai - 1) % (Int.ofNat n)\n    let j : Nat := Int.toNat r\n    let old := a[j]!\n    a := a.set! j (old + Int.ofNat n)\n  \n  for i in [: n] do\n    if a[i]! ≤ Int.ofNat n then\n      return i + 1\n  return n + 1\n\n#guard firstMissingPositive [1, 2, 3, -1, 5] 5 = 4\n#guard firstMissingPositive [0, -1, -2, 1, 5, 8] 6 = 2\n#guard firstMissingPositive [0, 1, 2, 5, -8] 5 = 3\n", "test_list": ["#guard firstMissingPositive [1, 2, 3, -1, 5] 5 = 4", "#guard firstMissingPositive [0, -1, -2, 1, 5, 8] 6 = 2", "#guard firstMissingPositive [0, 1, 2, 5, -8] 5 = 3"]}
{"text": "Write a python function to count the number of integral co-ordinates that lie inside a square.", "task_id": 190, "code": "import Batteries\n\nopen Std\n\ndef count_Intgral_Points (x1 y1 x2 y2 : Int) : Int :=\n  (y2 - y1 - 1) * (x2 - x1 - 1)\n\n#guard count_Intgral_Points 1 1 4 4 = 4\n#guard count_Intgral_Points 1 2 1 2 = 1\n#guard count_Intgral_Points 4 2 6 4 = 1\n", "test_list": ["#guard count_Intgral_Points 1 1 4 4 = 4", "#guard count_Intgral_Points 1 2 1 2 = 1", "#guard count_Intgral_Points 4 2 6 4 = 1"]}
{"text": "Write a function to check whether the given month name contains 30 days or not.", "task_id": 191, "code": "import Batteries\n\nopen Std\n\ndef checkMonthnumber (monthname3 : String) : Bool :=\n  if monthname3 == \"April\" || monthname3 == \"June\" || monthname3 == \"September\" || monthname3 == \"November\" then\n    true\n  else\n    false\n\n#guard checkMonthnumber \"February\" == false\n#guard checkMonthnumber \"June\" == true\n#guard checkMonthnumber \"April\" == true\n", "test_list": ["#guard checkMonthnumber \"February\" == false", "#guard checkMonthnumber \"June\" == true", "#guard checkMonthnumber \"April\" == true"]}
{"text": "Write a python function to check whether a string has atleast one letter and one number.", "task_id": 192, "code": "import Batteries\n\nopen Std\n\ndef isAsciiDigit (c : Char) : Bool :=\n  if ('0' ≤ c ∧ c ≤ '9') then true else false\n\ndef isAsciiLetter (c : Char) : Bool :=\n  if (('a' ≤ c ∧ c ≤ 'z') ∨ ('A' ≤ c ∧ c ≤ 'Z')) then true else false\n\ndef checkString (str : String) : Bool := Id.run do\n  let mut flag_l := false\n  let mut flag_n := false\n  for c in str.data do\n    if isAsciiLetter c then\n      flag_l := true\n    if isAsciiDigit c then\n      flag_n := true\n  return flag_l && flag_n\n\n#guard checkString \"thishasboth29\" == true\n#guard checkString \"python\" == false\n#guard checkString \"string\" == false\n", "test_list": ["#guard checkString \"thishasboth29\" == true", "#guard checkString \"python\" == false", "#guard checkString \"string\" == false"]}
{"text": "Write a function to remove the duplicates from the given tuple.", "task_id": 193, "code": "import Batteries\n\nopen Std\n\ndef removeTuple (testTup : List Nat) : HashSet Nat :=\n  HashSet.ofList testTup\n\n#guard removeTuple [1, 3, 5, 2, 3, 5, 1, 1, 3] == Std.HashSet.ofList [1, 2, 3, 5]\n#guard removeTuple [2, 3, 4, 4, 5, 6, 6, 7, 8, 8] == Std.HashSet.ofList [2, 3, 4, 5, 6, 7, 8]\n#guard removeTuple [11, 12, 13, 11, 11, 12, 14, 13] == Std.HashSet.ofList [11, 12, 13, 14]\n", "test_list": ["#guard removeTuple [1, 3, 5, 2, 3, 5, 1, 1, 3] == Std.HashSet.ofList [1, 2, 3, 5]", "#guard removeTuple [2, 3, 4, 4, 5, 6, 6, 7, 8, 8] == Std.HashSet.ofList [2, 3, 4, 5, 6, 7, 8]", "#guard removeTuple [11, 12, 13, 11, 11, 12, 14, 13] == Std.HashSet.ofList [11, 12, 13, 14]"]}
{"text": "Write a python function to convert octal number to decimal number.", "task_id": 194, "code": "import Batteries\n\nopen Std\n\ndef octal_To_Decimal (n : Nat) : Nat :=\n  let rec go (temp base dec : Nat) : Nat :=\n    if temp = 0 then dec\n    else\n      let last_digit := temp % 10\n      let temp2 := temp / 10\n      let dec2 := dec + last_digit * base\n      let base2 := base * 8\n      go temp2 base2 dec2\n  go n 1 0\n\n#guard octal_To_Decimal 25 = 21\n#guard octal_To_Decimal 30 = 24\n#guard octal_To_Decimal 40 = 32\n", "test_list": ["#guard octal_To_Decimal 25 = 21", "#guard octal_To_Decimal 30 = 24", "#guard octal_To_Decimal 40 = 32"]}
{"text": "Write a python function to find the first position of an element in a sorted array.", "task_id": 195, "code": "import Batteries\nopen Std\n\ndef listGetD {α} (l : List α) (i : Nat) (d : α) : α :=\n  match l.drop i with\n  | [] => d\n  | h :: _ => h\n\ndef first (arr : List Nat) (x : Nat) (n : Nat) : Int := Id.run do\n  \n  let mut low : Int := 0\n  let mut high : Int := (Int.ofNat n) - 1\n  let mut res : Int := -1\n  while _h : low ≤ high do\n    let mid : Int := (low + high) / 2\n    let midNat : Nat := Int.toNat mid\n    let midVal : Nat := listGetD arr midNat 0\n    if midVal > x then\n      high := mid - 1\n    else if midVal < x then\n      low := mid + 1\n    else\n      res := mid\n      high := mid - 1\n  return res\n\n#guard first [1,2,3,4,5,6,6] 6 6 = 5\n#guard first [1,2,2,2,3,2,2,4,2] 2 9 = 1\n#guard first [1,2,3] 1 3 = 0\n", "test_list": ["#guard first [1,2,3,4,5,6,6] 6 6 = 5", "#guard first [1,2,2,2,3,2,2,4,2] 2 9 = 1", "#guard first [1,2,3] 1 3 = 0"]}
{"text": "Write a function to remove all the tuples with length k.", "task_id": 196, "code": "import Batteries\n\nopen Std\n\ndef removeTuples (testList : List (List Nat)) (K : Nat) : List (List Nat) :=\n  testList.filter (fun ele => ele.length != K)\n\n#guard removeTuples [[4, 5], [4], [8, 6, 7], [1], [3, 4, 6, 7]] 1 = [[4, 5], [8, 6, 7], [3, 4, 6, 7]]\n#guard removeTuples [[4, 5], [4, 5], [6, 7], [1, 2, 3], [3, 4, 6, 7]] 2 = [[1, 2, 3], [3, 4, 6, 7]]\n#guard removeTuples [[1, 4, 4], [4, 3], [8, 6, 7], [1], [3, 6, 7]] 3 = [[4, 3], [1]]\n", "test_list": ["#guard removeTuples [[4, 5], [4], [8, 6, 7], [1], [3, 4, 6, 7]] 1 = [[4, 5], [8, 6, 7], [3, 4, 6, 7]]", "#guard removeTuples [[4, 5], [4, 5], [6, 7], [1, 2, 3], [3, 4, 6, 7]] 2 = [[1, 2, 3], [3, 4, 6, 7]]", "#guard removeTuples [[1, 4, 4], [4, 3], [8, 6, 7], [1], [3, 6, 7]] 3 = [[4, 3], [1]]"]}
{"text": "Write a function to perform the exponentiation of the given two tuples.", "task_id": 197, "code": "import Batteries\n\nopen Std\n\ndef find_exponentio (test_tup1 test_tup2 : List Nat) : List Nat :=\n  (List.zip test_tup1 test_tup2).map (fun (a, b) => a ^ b)\n\n#guard find_exponentio [10, 4, 5, 6] [5, 6, 7, 5] == [100000, 4096, 78125, 7776]\n#guard find_exponentio [11, 5, 6, 7] [6, 7, 8, 6] == [1771561, 78125, 1679616, 117649]\n#guard find_exponentio [12, 6, 7, 8] [7, 8, 9, 7] == [35831808, 1679616, 40353607, 2097152]\n", "test_list": ["#guard find_exponentio [10, 4, 5, 6] [5, 6, 7, 5] == [100000, 4096, 78125, 7776]", "#guard find_exponentio [11, 5, 6, 7] [6, 7, 8, 6] == [1771561, 78125, 1679616, 117649]", "#guard find_exponentio [12, 6, 7, 8] [7, 8, 9, 7] == [35831808, 1679616, 40353607, 2097152]"]}
{"text": "Write a function to find the largest triangle that can be inscribed in an ellipse.", "task_id": 198, "code": "import Batteries\n\nopen Std\n\ndef largestTriangle (a b : Float) : Float :=\n  if a < 0.0 || b < 0.0 then\n    -1.0\n  else\n    (3.0 * Float.sqrt 3.0 * (a * a)) / (4.0 * b)\n\n#guard largestTriangle 4.0 2.0 == 10.392304845413264\n#guard largestTriangle 5.0 7.0 == 4.639421805988064\n#guard largestTriangle 9.0 1.0 == 105.2220865598093\n", "test_list": ["#guard largestTriangle 4.0 2.0 == 10.392304845413264", "#guard largestTriangle 5.0 7.0 == 4.639421805988064", "#guard largestTriangle 9.0 1.0 == 105.2220865598093"]}
{"text": "Write a python function to find highest power of 2 less than or equal to given number.", "task_id": 199, "code": "import Batteries\n\nopen Std\n\ndef highestPowerOf2 (n : Nat) : Nat := Id.run do\n  let mut res := 0\n  let mut i := n\n  while i > 0 do\n    if (i &&& (i - 1)) == 0 then\n      res := i\n      break\n    i := i - 1\n  return res\n\n#guard highestPowerOf2 10 = 8\n#guard highestPowerOf2 19 = 16\n#guard highestPowerOf2 32 = 32\n", "test_list": ["#guard highestPowerOf2 10 = 8", "#guard highestPowerOf2 19 = 16", "#guard highestPowerOf2 32 = 32"]}
{"text": "Write a function to find all index positions of the maximum values in a given list.", "task_id": 200, "code": "import Batteries\n\nopen Std\n\ndef positionMax (list1 : List Nat) : List Nat :=\n  \n  let maxVal :=\n    match list1 with\n    | [] => 0\n    | x :: xs => xs.foldl (fun m a => if a > m then a else m) x\n  let (_, resRev) :=\n    list1.foldl\n      (fun (p : Nat × List Nat) (j : Nat) =>\n        let (i, res) := p\n        let res := if j == maxVal then i :: res else res\n        (i+1, res))\n      (0, [])\n  resRev.reverse\n\n#guard positionMax [12,33,23,10,67,89,45,667,23,12,11,10,54] == [7]\n#guard positionMax [1,2,2,2,4,4,4,5,5,5,5] == [7,8,9,10]\n#guard positionMax [2,1,5,6,8,3,4,9,10,11,8,12] == [11]\n", "test_list": ["#guard positionMax [12,33,23,10,67,89,45,667,23,12,11,10,54] == [7]", "#guard positionMax [1,2,2,2,4,4,4,5,5,5,5] == [7,8,9,10]", "#guard positionMax [2,1,5,6,8,3,4,9,10,11,8,12] == [11]"]}
{"text": "Write a python function to check whether the elements in a list are same or not.", "task_id": 201, "code": "import Batteries\n\nopen Std\n\ndef chkList (lst : List String) : Bool :=\n  match lst with\n  | [] => false\n  | x :: xs => xs.all (fun y => y == x)\n\n#guard chkList [\"one\",\"one\",\"one\"] == true\n#guard chkList [\"one\",\"Two\",\"Three\"] == false\n#guard chkList [\"bigdata\",\"python\",\"Django\"] == false\n", "test_list": ["#guard chkList [\"one\",\"one\",\"one\"] == true", "#guard chkList [\"one\",\"Two\",\"Three\"] == false", "#guard chkList [\"bigdata\",\"python\",\"Django\"] == false"]}
{"text": "Write a function to remove even characters in a string.", "task_id": 202, "code": "import Batteries\n\nopen Std\n\ndef removeEven (str1 : String) : String := Id.run do\n  let mut str2 := \"\"\n  let mut i : Nat := 0\n  for ch in str1.data do\n    i := i + 1\n    if i % 2 != 0 then\n      str2 := str2.push ch\n  return str2\n\n#guard removeEven \"python\" == \"pto\"\n#guard removeEven \"program\" == \"porm\"\n#guard removeEven \"language\" == \"lnug\"\n", "test_list": ["#guard removeEven \"python\" == \"pto\"", "#guard removeEven \"program\" == \"porm\"", "#guard removeEven \"language\" == \"lnug\""]}
{"text": "Write a python function to find the hamming distance between given two integers.", "task_id": 203, "code": "import Batteries\n\nopen Std\n\ndef hamming_Distance (n1 n2 : Nat) : Nat := Id.run do\n  let mut x := n1 ^^^ n2\n  let mut setBits := 0\n  while x > 0 do\n    setBits := setBits + (x &&& 1)\n    x := x >>> 1\n  return setBits\n\n#guard hamming_Distance 4 8 = 2\n#guard hamming_Distance 2 4 = 2\n#guard hamming_Distance 1 2 = 2\n", "test_list": ["#guard hamming_Distance 4 8 = 2", "#guard hamming_Distance 2 4 = 2", "#guard hamming_Distance 1 2 = 2"]}
{"text": "Write a python function to count the occurrence of a given character in a string.", "task_id": 204, "code": "import Batteries\n\nopen Std\n\ndef count (s : String) (c : String) : Nat := Id.run do\n  let mut res := 0\n  for i in [0 : s.length] do\n    if (s.drop i).take 1 == c then\n      res := res + 1\n  return res\n\n#guard count \"abcc\" \"c\" = 2\n#guard count \"ababca\" \"a\" = 3\n#guard count \"mnmm0pm\" \"m\" = 4\n", "test_list": ["#guard count \"abcc\" \"c\" = 2", "#guard count \"ababca\" \"a\" = 3", "#guard count \"mnmm0pm\" \"m\" = 4"]}
{"text": "Write a function to find the inversions of tuple elements in the given tuple list.", "task_id": 205, "code": "import Batteries\n\nopen Std\n\ndef inversionElements (test_tup : List Int) : List Int :=\n  let res := test_tup.map (fun x => -x - 1)\n  res\n\n#guard inversionElements [7, 8, 9, 1, 10, 7] = [-8, -9, -10, -2, -11, -8]\n#guard inversionElements [2, 4, 5, 6, 1, 7] = [-3, -5, -6, -7, -2, -8]\n#guard inversionElements [8, 9, 11, 14, 12, 13] = [-9, -10, -12, -15, -13, -14]\n", "test_list": ["#guard inversionElements [7, 8, 9, 1, 10, 7] = [-8, -9, -10, -2, -11, -8]", "#guard inversionElements [2, 4, 5, 6, 1, 7] = [-3, -5, -6, -7, -2, -8]", "#guard inversionElements [8, 9, 11, 14, 12, 13] = [-9, -10, -12, -15, -13, -14]"]}
{"text": "Write a function to perform the adjacent element concatenation in the given tuples.", "task_id": 206, "code": "import Batteries\n\nopen Std\n\ndef concatenateElements (test_tup : List String) : List String :=\n  (List.zip test_tup (test_tup.drop 1)).map (fun p => p.fst ++ p.snd)\n\n#guard concatenateElements [\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\"] = [\"DSP IS \", \"IS BEST \", \"BEST FOR \", \"FOR ALL \", \"ALL UTS\"]\n#guard concatenateElements [\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\"] = [\"RES IS \", \"IS BEST \", \"BEST FOR \", \"FOR ALL \", \"ALL QESR\"]\n#guard concatenateElements [\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\"] = [\"MSAMIS \", \"IS BEST \", \"BEST FOR \", \"FOR ALL \", \"ALL SKD\"]\n", "test_list": ["#guard concatenateElements [\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\"] = [\"DSP IS \", \"IS BEST \", \"BEST FOR \", \"FOR ALL \", \"ALL UTS\"]", "#guard concatenateElements [\"RES \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"QESR\"] = [\"RES IS \", \"IS BEST \", \"BEST FOR \", \"FOR ALL \", \"ALL QESR\"]", "#guard concatenateElements [\"MSAM\", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"SKD\"] = [\"MSAMIS \", \"IS BEST \", \"BEST FOR \", \"FOR ALL \", \"ALL SKD\"]"]}
{"text": "Write a function to count the longest repeating subsequences such that the two subsequences don’t have same string characters at same positions.", "task_id": 207, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef find_longest_repeating_subseq (str : String) : Nat := Id.run do\n  let n := str.length\n  let mut dp : Array (Array Nat) := Array.replicate (n+1) (Array.replicate (n+1) 0)\n  for i in [1 : n+1] do\n    for j in [1 : n+1] do\n      let ci := (str.drop (i-1)).take 1\n      let cj := (str.drop (j-1)).take 1\n      let value :=\n        if ci == cj && i != j then\n          1 + dp.get2d (i-1) (j-1) 0\n        else\n          Nat.max (dp.get2d i (j-1) 0) (dp.get2d (i-1) j 0)\n      dp := dp.set2d? i j value\n  return dp.get2d n n 0\n\n#guard find_longest_repeating_subseq \"AABEBCDD\" = 3\n#guard find_longest_repeating_subseq \"aabb\" = 2\n#guard find_longest_repeating_subseq \"aab\" = 1\n", "test_list": ["#guard find_longest_repeating_subseq \"AABEBCDD\" = 3", "#guard find_longest_repeating_subseq \"aabb\" = 2", "#guard find_longest_repeating_subseq \"aab\" = 1"]}
{"text": "Write a function to check the given decimal with a precision of 2 by using regex.", "task_id": 208, "code": "import Batteries\n\nopen Std\n\ndef isDigit (c : Char) : Bool := ('0' ≤ c) && (c ≤ '9')\n\npartial def consumeDigits : List Char → Nat → (Nat × List Char)\n  | [], acc => (acc, [])\n  | c :: cs, acc => if isDigit c then consumeDigits cs (acc + 1) else (acc, c :: cs)\n\ndef isDecimal (num : String) : Bool :=\n  let cs := num.data\n  let (n1, rest) := consumeDigits cs 0\n  if n1 == 0 then false else\n    match rest with\n    | [] => true\n    | c :: rest2 =>\n      if c == '.' then\n        let (n2, rest3) := consumeDigits rest2 0\n        (n2 == 1 || n2 == 2) && rest3.isEmpty\n      else\n        false\n\n#guard isDecimal \"123.11\" == true\n#guard isDecimal \"0.21\" == true\n#guard isDecimal \"123.1214\" == false\n", "test_list": ["#guard isDecimal \"123.11\" == true", "#guard isDecimal \"0.21\" == true", "#guard isDecimal \"123.1214\" == false"]}
{"text": "Write a function to delete the smallest element from the given heap and then insert a new item.", "task_id": 209, "code": "import Batteries\n\nopen Std\n\nprivate def siftDown (arr : Array Nat) (i n : Nat) : Array Nat := Id.run do\n  let mut a := arr\n  let mut idx := i\n  while true do\n    let left := 2*idx + 1\n    if left >= n then\n      break\n    let right := left + 1\n    let c :=\n      if right < n && a[right]! < a[left]! then right else left\n    if a[idx]! <= a[c]! then\n      break\n    else\n      let ai := a[idx]!\n      let ac := a[c]!\n      a := a.set! idx ac\n      a := a.set! c ai\n      idx := c\n  return a\n\nprivate def heapify (arr : Array Nat) : Array Nat := Id.run do\n  let mut a := arr\n  let n := a.size\n  let mut i := n / 2\n  while i > 0 do\n    i := i - 1\n    a := siftDown a i n\n  return a\n\ndef heapReplace (heap : List Nat) (a : Nat) : List Nat := Id.run do\n  let mut ar := heap.toArray\n  ar := heapify ar\n  if ar.size = 0 then\n    return []\n  ar := ar.set! 0 a\n  ar := siftDown ar 0 ar.size\n  return ar.toList\n\n#guard heapReplace [25, 44, 68, 21, 39, 23, 89] 21 == [21, 25, 23, 44, 39, 68, 89]\n#guard heapReplace [25, 44, 68, 21, 39, 23, 89] 110 == [23, 25, 68, 44, 39, 110, 89]\n#guard heapReplace [25, 44, 68, 21, 39, 23, 89] 500 == [23, 25, 68, 44, 39, 500, 89]\n", "test_list": ["#guard heapReplace [25, 44, 68, 21, 39, 23, 89] 21 == [21, 25, 23, 44, 39, 68, 89]", "#guard heapReplace [25, 44, 68, 21, 39, 23, 89] 110 == [23, 25, 68, 44, 39, 110, 89]", "#guard heapReplace [25, 44, 68, 21, 39, 23, 89] 500 == [23, 25, 68, 44, 39, 500, 89]"]}
{"text": "Write a function to check that the given string contains only a certain set of characters(in this case a-z, a-z and 0-9) by using regex.", "task_id": 210, "code": "import Batteries\n\nopen Std\n\nprivate def allowedChars : List Char :=\n  let lowers := (List.range 26).map (fun i => Char.ofNat ('a'.toNat + i))\n  let uppers := (List.range 26).map (fun i => Char.ofNat ('A'.toNat + i))\n  let digits := (List.range 10).map (fun i => Char.ofNat ('0'.toNat + i))\n  lowers ++ uppers ++ digits ++ ['.']\n\nprivate def allowedSet : HashSet Char := HashSet.ofList allowedChars\n\ndef isAllowedSpecificChar (s : String) : Bool :=\n  s.data.all (fun c => allowedSet.contains c)\n\n#guard isAllowedSpecificChar \"ABCDEFabcdef123450\" == true\n#guard isAllowedSpecificChar \"*&%@#!}{\" == false\n#guard isAllowedSpecificChar \"HELLOhowareyou98765\" == true\n", "test_list": ["#guard isAllowedSpecificChar \"ABCDEFabcdef123450\" == true", "#guard isAllowedSpecificChar \"*&%@#!}{\" == false", "#guard isAllowedSpecificChar \"HELLOhowareyou98765\" == true"]}
{"text": "Write a python function to count numbers whose oth and nth bits are set.", "task_id": 211, "code": "import Batteries\n\nopen Std\n\ndef countNum (n : Nat) : Nat :=\n  if n == 1 then\n    1\n  else\n    2 ^ (n - 2)\n\n#guard countNum 2 = 1\n#guard countNum 3 = 2\n#guard countNum 1 = 1\n", "test_list": ["#guard countNum 2 = 1", "#guard countNum 3 = 2", "#guard countNum 1 = 1"]}
{"text": "Write a python function to find the sum of fourth power of n natural numbers.", "task_id": 212, "code": "import Batteries\n\nopen Std\n\ndef fourth_Power_Sum (n : Nat) : Nat := Id.run do\n  let mut s := 0\n  for i in [1 : n+1] do\n    s := s + i*i*i*i\n  return s\n\n#guard fourth_Power_Sum 2 = 17\n#guard fourth_Power_Sum 4 = 354\n#guard fourth_Power_Sum 6 = 2275\n", "test_list": ["#guard fourth_Power_Sum 2 = 17", "#guard fourth_Power_Sum 4 = 354", "#guard fourth_Power_Sum 6 = 2275"]}
{"text": "Write a function to perform the concatenation of two string tuples.", "task_id": 213, "code": "import Batteries\n\nopen Std\n\ndef concatenateStrings (testTup1 : List String) (testTup2 : List String) : List String :=\n  List.zipWith (fun a b => a ++ b) testTup1 testTup2\n\n#guard concatenateStrings [\"Manjeet\", \"Nikhil\", \"Akshat\"] [\" Singh\", \" Meherwal\", \" Garg\"] == [\"Manjeet Singh\", \"Nikhil Meherwal\", \"Akshat Garg\"]\n#guard concatenateStrings [\"Shaik\", \"Ayesha\", \"Sanya\"] [\" Dawood\", \" Begum\", \" Singh\"] == [\"Shaik Dawood\", \"Ayesha Begum\", \"Sanya Singh\"]\n#guard concatenateStrings [\"Harpreet\", \"Priyanka\", \"Muskan\"] [\"Kour\", \" Agarwal\", \"Sethi\"] == [\"HarpreetKour\", \"Priyanka Agarwal\", \"MuskanSethi\"]\n", "test_list": ["#guard concatenateStrings [\"Manjeet\", \"Nikhil\", \"Akshat\"] [\" Singh\", \" Meherwal\", \" Garg\"] == [\"Manjeet Singh\", \"Nikhil Meherwal\", \"Akshat Garg\"]", "#guard concatenateStrings [\"Shaik\", \"Ayesha\", \"Sanya\"] [\" Dawood\", \" Begum\", \" Singh\"] == [\"Shaik Dawood\", \"Ayesha Begum\", \"Sanya Singh\"]", "#guard concatenateStrings [\"Harpreet\", \"Priyanka\", \"Muskan\"] [\"Kour\", \" Agarwal\", \"Sethi\"] == [\"HarpreetKour\", \"Priyanka Agarwal\", \"MuskanSethi\"]"]}
{"text": "Write a function to convert radians to degrees.", "task_id": 214, "code": "import Batteries\n\nopen Std\n\ndef degreeRadian (radian : Nat) : Float :=\n  let pi : Float := 3.141592653589793\n  (Float.ofNat radian) * (180.0 / pi)\n\n#guard degreeRadian 90 == 5156.620156177409\n#guard degreeRadian 60 == 3437.746770784939\n#guard degreeRadian 120 == 6875.493541569878\n", "test_list": ["#guard degreeRadian 90 == 5156.620156177409", "#guard degreeRadian 60 == 3437.746770784939", "#guard degreeRadian 120 == 6875.493541569878"]}
{"text": "Write a function to decode a run-length encoded given list.", "task_id": 215, "code": "import Batteries\nopen Std\n\ninductive Encoded (α : Type) where\n| single : α → Encoded α\n| run : Nat → α → Encoded α\n\ndef decode_list {α : Type} (alist : List (Encoded α)) : List α :=\n  alist.foldr\n    (fun g acc =>\n      match g with\n      | Encoded.single x => x :: acc\n      | Encoded.run n x => (List.replicate n x) ++ acc)\n    []\n\n#guard decode_list [Encoded.run 2 1, Encoded.single 2, Encoded.single 3, Encoded.run 2 4, Encoded.single 5, Encoded.single 1] = [1,1,2,3,4,4,5,1]\n#guard decode_list [Encoded.single \"a\", Encoded.single \"u\", Encoded.single \"t\", Encoded.single \"o\", Encoded.single \"m\", Encoded.single \"a\", Encoded.single \"t\", Encoded.single \"i\", Encoded.single \"c\", Encoded.single \"a\", Encoded.run 2 \"l\", Encoded.single \"y\"] = [\"a\", \"u\", \"t\", \"o\", \"m\", \"a\", \"t\", \"i\", \"c\", \"a\", \"l\", \"l\", \"y\"]\n#guard decode_list [Encoded.single \"p\", Encoded.single \"y\", Encoded.single \"t\", Encoded.single \"h\", Encoded.single \"o\", Encoded.single \"n\"] = [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]\n", "test_list": ["#guard decode_list [Encoded.run 2 1, Encoded.single 2, Encoded.single 3, Encoded.run 2 4, Encoded.single 5, Encoded.single 1] = [1,1,2,3,4,4,5,1]", "#guard decode_list [Encoded.single \"a\", Encoded.single \"u\", Encoded.single \"t\", Encoded.single \"o\", Encoded.single \"m\", Encoded.single \"a\", Encoded.single \"t\", Encoded.single \"i\", Encoded.single \"c\", Encoded.single \"a\", Encoded.run 2 \"l\", Encoded.single \"y\"] = [\"a\", \"u\", \"t\", \"o\", \"m\", \"a\", \"t\", \"i\", \"c\", \"a\", \"l\", \"l\", \"y\"]", "#guard decode_list [Encoded.single \"p\", Encoded.single \"y\", Encoded.single \"t\", Encoded.single \"h\", Encoded.single \"o\", Encoded.single \"n\"] = [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]"]}
{"text": "Write a function to check if a nested list is a subset of another nested list.", "task_id": 216, "code": "import Batteries\n\nopen Std\n\ndef checkSubsetList {α : Type} [DecidableEq α] (list1 list2 : List (List α)) : Bool := Id.run do\n  \n  \n  let _l1 : List α := match list1 with | [] => [] | x :: _ => x\n  let _l2 : List α := match list2 with | [] => [] | x :: _ => x\n  let mut exist := true\n  for i in list2 do\n    if !(i ∈ list1) then\n      exist := false\n  return exist\n\n#guard checkSubsetList [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14]] [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]] == false\n#guard checkSubsetList [[2, 3, 1], [4, 5], [6, 8]] [[4, 5], [6, 8]] == true\n#guard checkSubsetList [[\"a\", \"b\"], [\"e\"], [\"c\", \"d\"]] [[\"g\"]] == false\n", "test_list": ["#guard checkSubsetList [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14]] [[12, 18, 23, 25, 45], [7, 11, 19, 24, 28], [1, 5, 8, 18, 15, 16]] == false", "#guard checkSubsetList [[2, 3, 1], [4, 5], [6, 8]] [[4, 5], [6, 8]] == true", "#guard checkSubsetList [[\"a\", \"b\"], [\"e\"], [\"c\", \"d\"]] [[\"g\"]] == false"]}
{"text": "Write a python function to find the first repeated character in a given string.", "task_id": 217, "code": "import Batteries\n\nopen Std\n\ndef first_Repeated_Char (str : String) : String := Id.run do\n  let mut h : HashSet Char := {}\n  for ch in str.toList do\n    if h.contains ch then\n      return String.singleton ch\n    else\n      h := h.insert ch\n  return \"\\x00\"\n\n#guard first_Repeated_Char \"Google\" == \"o\"\n#guard first_Repeated_Char \"data\" == \"a\"\n#guard first_Repeated_Char \"python\" == \"\\x00\"\n", "test_list": ["#guard first_Repeated_Char \"Google\" == \"o\"", "#guard first_Repeated_Char \"data\" == \"a\"", "#guard first_Repeated_Char \"python\" == \"\\x00\""]}
{"text": "Write a python function to find the minimum operations required to make two numbers equal.", "task_id": 218, "code": "import Batteries\n\nopen Std\n\ndef minOperations (A B : Nat) : Nat :=\n  \n  let (a, b) := if A > B then (B, A) else (A, B)\n  let g := Nat.gcd a b\n  let b' := b / g\n  b' - 1\n\n#guard minOperations 2 4 = 1\n#guard minOperations 4 10 = 4\n#guard minOperations 1 4 = 3\n", "test_list": ["#guard minOperations 2 4 = 1", "#guard minOperations 4 10 = 4", "#guard minOperations 1 4 = 3"]}
{"text": "Write a function to extract maximum and minimum k elements in the given tuple.", "task_id": 219, "code": "import Batteries\nopen Std\n\ndef insertSorted (x : Nat) (l : List Nat) : List Nat :=\n  match l with\n  | [] => [x]\n  | y :: ys =>\n    if x ≤ y then\n      x :: y :: ys\n    else\n      y :: insertSorted x ys\n\ndef selectionSort (l : List Nat) : List Nat :=\n  let rec sort (xs : List Nat) : List Nat :=\n    match xs with\n    | [] => []\n    | h :: t => insertSorted h (sort t)\n  sort l\n\ndef extractMinMax (testTup : List Nat) (K : Nat) : List Nat :=\n  let temp := selectionSort testTup\n  let n := temp.length\n  let rec loop (i : Nat) (xs : List Nat) (acc : List Nat) : List Nat :=\n    match xs with\n    | [] => acc.reverse\n    | y :: ys =>\n      if i < K || i >= n - K then\n        loop (i + 1) ys (y :: acc)\n      else\n        loop (i + 1) ys acc\n  loop 0 temp []\n\n#guard extractMinMax [5, 20, 3, 7, 6, 8] 2 = [3, 5, 8, 20]\n#guard extractMinMax [4, 5, 6, 1, 2, 7] 3 = [1, 2, 4, 5, 6, 7]\n#guard extractMinMax [2, 3, 4, 8, 9, 11, 7] 4 = [2, 3, 4, 7, 8, 9, 11]\n", "test_list": ["#guard extractMinMax [5, 20, 3, 7, 6, 8] 2 = [3, 5, 8, 20]", "#guard extractMinMax [4, 5, 6, 1, 2, 7] 3 = [1, 2, 4, 5, 6, 7]", "#guard extractMinMax [2, 3, 4, 8, 9, 11, 7] 4 = [2, 3, 4, 7, 8, 9, 11]"]}
{"text": "Write a function to replace maximum n occurrences of spaces, commas, or dots with a colon.", "task_id": 220, "code": "import Batteries\n\nopen Std\n\ndef replaceMaxSpecialchar (text : String) (n : Nat) : String :=\n  let (rev, _) := text.data.foldl\n    (fun (s : List Char × Nat) ch =>\n      let (acc, cnt) := s\n      if cnt < n && (ch = ' ' || ch = ',' || ch = '.') then\n        (':' :: acc, cnt + 1)\n      else\n        (ch :: acc, cnt)\n    ) ([], 0)\n  String.mk rev.reverse\n\n#guard replaceMaxSpecialchar \"Python language, Programming language.\" 2 = \"Python:language: Programming language.\"\n#guard replaceMaxSpecialchar \"a b c,d e f\" 3 = \"a:b:c:d e f\"\n#guard replaceMaxSpecialchar \"ram reshma,ram rahim\" 1 = \"ram:reshma,ram rahim\"\n", "test_list": ["#guard replaceMaxSpecialchar \"Python language, Programming language.\" 2 = \"Python:language: Programming language.\"", "#guard replaceMaxSpecialchar \"a b c,d e f\" 3 = \"a:b:c:d e f\"", "#guard replaceMaxSpecialchar \"ram reshma,ram rahim\" 1 = \"ram:reshma,ram rahim\""]}
{"text": "Write a python function to find the first even number in a given list of numbers.", "task_id": 221, "code": "import Batteries\n\nopen Std\n\ndef firstEven (nums : List Int) : Int :=\n  match nums.find? (fun el => Int.emod el 2 == 0) with\n  | some x => x\n  | none => -1\n\n#guard firstEven [1, 3, 5, 7, 4, 1, 6, 8] == 4\n#guard firstEven [2, 3, 4] == 2\n#guard firstEven [5, 6, 7] == 6\n", "test_list": ["#guard firstEven [1, 3, 5, 7, 4, 1, 6, 8] == 4", "#guard firstEven [2, 3, 4] == 2", "#guard firstEven [5, 6, 7] == 6"]}
{"text": "Write a function to check if all the elements in tuple have same data type or not.", "task_id": 222, "code": "import Batteries\n\nopen Std\n\ninductive PyVal where\n| int : Nat → PyVal\n| str : String → PyVal\nderiving BEq, Repr\n\ndef sameTag (a b : PyVal) : Bool :=\n  match a, b with\n  | .int _, .int _ => true\n  | .str _, .str _ => true\n  | _, _ => false\n\ndef checkType (testTuple : List PyVal) : Bool := Id.run do\n  let mut res := true\n  match testTuple with\n  | [] => return true \n  | first :: rest =>\n    for ele in rest do\n      if !(sameTag ele first) then\n        res := false\n        break\n    return res\n\n#guard checkType [PyVal.int 5, PyVal.int 6, PyVal.int 7, PyVal.int 3, PyVal.int 5, PyVal.int 6] = true\n#guard checkType [PyVal.int 1, PyVal.int 2, PyVal.str \"4\"] = false\n#guard checkType [PyVal.int 3, PyVal.int 2, PyVal.int 1, PyVal.int 4, PyVal.int 5] = true\n", "test_list": ["#guard checkType [PyVal.int 5, PyVal.int 6, PyVal.int 7, PyVal.int 3, PyVal.int 5, PyVal.int 6] = true", "#guard checkType [PyVal.int 1, PyVal.int 2, PyVal.str \"4\"] = false", "#guard checkType [PyVal.int 3, PyVal.int 2, PyVal.int 1, PyVal.int 4, PyVal.int 5] = true"]}
{"text": "Write a python function to count set bits of a given number.", "task_id": 224, "code": "import Batteries\n\nopen Std\n\ndef countSetBits (n : Nat) : Nat := Id.run do\n  let mut nn := n\n  let mut count := 0\n  while nn != 0 do\n    count := count + (nn % 2)\n    nn := nn / 2\n  return count\n\n#guard countSetBits 2 = 1\n#guard countSetBits 4 = 1\n#guard countSetBits 6 = 2\n", "test_list": ["#guard countSetBits 2 = 1", "#guard countSetBits 4 = 1", "#guard countSetBits 6 = 2"]}
{"text": "Write a python function to find the minimum element in a sorted and rotated array.", "task_id": 225, "code": "import Batteries\nopen Std\n\ndef listGet (xs : List Nat) (i : Nat) : Nat :=\n  let rec go (xs : List Nat) (i : Nat) : Nat :=\n    match xs, i with\n    | [], _ => 0\n    | x :: _, 0 => x\n    | _ :: xs', Nat.succ i' => go xs' i'\n  go xs i\n\ndef find_Min (arr : List Nat) (low high : Nat) : Nat := Id.run do\n  let mut lo := low\n  let mut hi := high\n  while lo < hi do\n    let mid := lo + (hi - lo) / 2\n    if listGet arr mid == listGet arr hi then\n      hi := hi - 1\n    else if listGet arr mid > listGet arr hi then\n      lo := mid + 1\n    else\n      hi := mid\n  return listGet arr hi\n\n#guard find_Min [1,2,3,4,5] 0 4 = 1\n#guard find_Min [4,6,8] 0 2 = 4\n#guard find_Min [2,3,5,7,9] 0 4 = 2\n", "test_list": ["#guard find_Min [1,2,3,4,5] 0 4 = 1", "#guard find_Min [4,6,8] 0 2 = 4", "#guard find_Min [2,3,5,7,9] 0 4 = 2"]}
{"text": "Write a python function to remove the characters which have odd index values of a given string.", "task_id": 226, "code": "import Batteries\n\nopen Std\n\ndef oddValuesString (str : String) : String := Id.run do\n  let n := str.length\n  let mut result := \"\"\n  for i in [0:n] do\n    if i % 2 == 0 then\n      result := result ++ (str.drop i).take 1\n  return result\n\n#guard oddValuesString \"abcdef\" == \"ace\"\n#guard oddValuesString \"python\" == \"pto\"\n#guard oddValuesString \"data\" == \"dt\"\n", "test_list": ["#guard oddValuesString \"abcdef\" == \"ace\"", "#guard oddValuesString \"python\" == \"pto\"", "#guard oddValuesString \"data\" == \"dt\""]}
{"text": "Write a function to find minimum of three numbers.", "task_id": 227, "code": "import Batteries\n\nopen Std\n\ndef minOfThree (a b c : Int) : Int :=\n  if h1 : a ≤ b ∧ a ≤ c then\n    a\n  else if h2 : b ≤ a ∧ b ≤ c then\n    b\n  else\n    c\n\n#guard minOfThree 10 20 0 = 0\n#guard minOfThree 19 15 18 = 15\n#guard minOfThree (-10) (-20) (-30) = (-30)\n", "test_list": ["#guard minOfThree 10 20 0 = 0", "#guard minOfThree 19 15 18 = 15", "#guard minOfThree (-10) (-20) (-30) = (-30)"]}
{"text": "Write a python function to check whether all the bits are unset in the given range or not.", "task_id": 228, "code": "import Batteries\n\nopen Std\n\ndef all_Bits_Set_In_The_Given_Range (n l r : Nat) : Bool :=\n  let num := (((Nat.shiftLeft 1 r) - 1) ^^^ ((Nat.shiftLeft 1 (l - 1)) - 1))\n  let new_num := n &&& num\n  if new_num == 0 then true else false\n\n#guard all_Bits_Set_In_The_Given_Range 4 1 2 == true\n#guard all_Bits_Set_In_The_Given_Range 17 2 4 == true\n#guard all_Bits_Set_In_The_Given_Range 39 4 6 == false\n", "test_list": ["#guard all_Bits_Set_In_The_Given_Range 4 1 2 == true", "#guard all_Bits_Set_In_The_Given_Range 17 2 4 == true", "#guard all_Bits_Set_In_The_Given_Range 39 4 6 == false"]}
{"text": "Write a function to re-arrange the elements of the given array so that all negative elements appear before positive ones.", "task_id": 229, "code": "import Batteries\n\nopen Std\n\ndef re_arrange_array (arr : List Int) (n : Nat) : List Int := Id.run do\n  \n  let mut a := arr.toArray\n  let mut j : Nat := 0\n  for i in [: n] do\n    let xi := a[i]!\n    if xi < 0 then\n      let temp := xi\n      let yj := a[j]!\n      a := a.set! i yj\n      a := a.set! j temp\n      j := j + 1\n  return a.toList\n\n#guard re_arrange_array [-1, 2, -3, 4, 5, 6, -7, 8, 9] 9 == [-1, -3, -7, 4, 5, 6, 2, 8, 9]\n#guard re_arrange_array [12, -14, -26, 13, 15] 5 == [-14, -26, 12, 13, 15]\n#guard re_arrange_array [10, 24, 36, -42, -39, -78, 85] 7 == [-42, -39, -78, 10, 24, 36, 85]\n", "test_list": ["#guard re_arrange_array [-1, 2, -3, 4, 5, 6, -7, 8, 9] 9 == [-1, -3, -7, 4, 5, 6, 2, 8, 9]", "#guard re_arrange_array [12, -14, -26, 13, 15] 5 == [-14, -26, 12, 13, 15]", "#guard re_arrange_array [10, 24, 36, -42, -39, -78, 85] 7 == [-42, -39, -78, 10, 24, 36, 85]"]}
{"text": "Write a function to replace blank spaces with any character in a string.", "task_id": 230, "code": "import Batteries\n\nopen Std\n\nprivate def joinWith (sep : String) : List String -> String\n  | [] => \"\"\n  | [x] => x\n  | x :: xs => x ++ sep ++ joinWith sep xs\n\ndef replaceBlank (str1 : String) (char : String) : String :=\n  joinWith char (str1.splitOn \" \")\n\n#guard replaceBlank \"hello people\" \"@\" == \"hello@people\"\n#guard replaceBlank \"python program language\" \"$\" == \"python$program$language\"\n#guard replaceBlank \"blank space\" \"-\" == \"blank-space\"\n", "test_list": ["#guard replaceBlank \"hello people\" \"@\" == \"hello@people\"", "#guard replaceBlank \"python program language\" \"$\" == \"python$program$language\"", "#guard replaceBlank \"blank space\" \"-\" == \"blank-space\""]}
{"text": "Write a function to find the maximum sum in the given right triangle of numbers.", "task_id": 231, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef maxSum (tri : List (List Nat)) (n : Nat) : Nat := Id.run do\n  let mut t : Array (Array Nat) := tri.toArray.map (fun row => row.toArray)\n  if n > 1 then\n    let v00 := t.get2d 0 0 0\n    let v11 := t.get2d 1 1 0\n    t := t.set2d? 1 1 (v11 + v00)\n    let v10 := t.get2d 1 0 0\n    t := t.set2d? 1 0 (v10 + v00)\n  for i in [2 : n] do\n    let v_i0 := t.get2d i 0 0\n    let v_im1_0 := t.get2d (i-1) 0 0\n    t := t.set2d? i 0 (v_i0 + v_im1_0)\n    let v_ii := t.get2d i i 0\n    let v_im1_im1 := t.get2d (i-1) (i-1) 0\n    t := t.set2d? i i (v_ii + v_im1_im1)\n    for j in [1 : i] do\n      let cur := t.get2d i j 0\n      let a := cur + t.get2d (i-1) (j-1) 0\n      let b := cur + t.get2d (i-1) j 0\n      if a >= b then\n        t := t.set2d? i j a\n      else\n        t := t.set2d? i j b\n  let lastRow := t.getD (n-1) #[]\n  let mut m : Nat := 0\n  for x in lastRow do\n    if x > m then m := x\n  return m\n\n#guard maxSum [[1], [2,1], [3,3,2]] 3 = 6\n#guard maxSum [[1], [1, 2], [4, 1, 12]] 3 = 15\n#guard maxSum [[2], [3,2], [13,23,12]] 3 = 28\n", "test_list": ["#guard maxSum [[1], [2,1], [3,3,2]] 3 = 6", "#guard maxSum [[1], [1, 2], [4, 1, 12]] 3 = 15", "#guard maxSum [[2], [3,2], [13,23,12]] 3 = 28"]}
{"text": "Write a function to get the n largest items from a dataset.", "task_id": 232, "code": "import Batteries\n\nopen Std\n\ndef removeOne (xs : List Nat) (x : Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne ys x\n\ndef maxOfList (xs : List Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | y :: ys => some <| ys.foldl (fun acc z => if z > acc then z else acc) y\n\ndef larg_nnum (list1 : List Nat) (n : Nat) : List Nat := Id.run do\n  let mut xs := list1\n  let mut res : List Nat := []\n  for _ in [: n] do\n    match maxOfList xs with\n    | none => break\n    | some m =>\n      res := res ++ [m]\n      xs := removeOne xs m\n  return res\n\n#guard larg_nnum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 2 == [100, 90]\n#guard larg_nnum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 5 == [100, 90, 80, 70, 60]\n#guard larg_nnum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 3 == [100, 90, 80]\n", "test_list": ["#guard larg_nnum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 2 == [100, 90]", "#guard larg_nnum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 5 == [100, 90, 80, 70, 60]", "#guard larg_nnum [10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100] 3 == [100, 90, 80]"]}
{"text": "Write a function to find the lateral surface area of a cylinder.", "task_id": 233, "code": "import Batteries\n\nopen Std\n\ndef lateralsuface_cylinder (r h : Nat) : Float :=\n  2.0 * 3.1415 * (Float.ofNat r) * (Float.ofNat h)\n\n#guard lateralsuface_cylinder 10 5 == (314.15000000000003 : Float)\n#guard lateralsuface_cylinder 4 5 == (125.66000000000001 : Float)\n#guard lateralsuface_cylinder 4 10 == (251.32000000000002 : Float)\n", "test_list": ["#guard lateralsuface_cylinder 10 5 == (314.15000000000003 : Float)", "#guard lateralsuface_cylinder 4 5 == (125.66000000000001 : Float)", "#guard lateralsuface_cylinder 4 10 == (251.32000000000002 : Float)"]}
{"text": "Write a function to find the volume of a cube.", "task_id": 234, "code": "import Batteries\n\nopen Std\n\ndef volumeCube (l : Nat) : Nat :=\n  let volume := l * l * l\n  volume\n\n#guard volumeCube 3 = 27\n#guard volumeCube 2 = 8\n#guard volumeCube 5 = 125\n", "test_list": ["#guard volumeCube 3 = 27", "#guard volumeCube 2 = 8", "#guard volumeCube 5 = 125"]}
{"text": "Write a python function to set all even bits of a given number.", "task_id": 235, "code": "import Batteries\n\nopen Std\n\ndef evenBitSetNumber (n : Nat) : Nat := Id.run do\n  let mut count := 0\n  let mut res := 0\n  let mut temp := n\n  while temp > 0 do\n    if count % 2 == 1 then\n      res := res ||| (Nat.shiftLeft 1 count)\n    count := count + 1\n    temp := Nat.shiftRight temp 1\n  return n ||| res\n\n#guard evenBitSetNumber 10 = 10\n#guard evenBitSetNumber 20 = 30\n#guard evenBitSetNumber 30 = 30\n", "test_list": ["#guard evenBitSetNumber 10 = 10", "#guard evenBitSetNumber 20 = 30", "#guard evenBitSetNumber 30 = 30"]}
{"text": "Write a python function to count the maximum number of equilateral triangles that can be formed within a given equilateral triangle.", "task_id": 236, "code": "import Batteries\n\nopen Std\n\ndef No_of_Triangle (N K : Int) : Int :=\n  if N < K then -1\n  else\n    let Tri_up := ((N - K + 1) * (N - K + 2)) / 2\n    let Tri_down := ((N - 2 * K + 1) * (N - 2 * K + 2)) / 2\n    Tri_up + Tri_down\n\n#guard No_of_Triangle 4 2 = 7\n#guard No_of_Triangle 4 3 = 3\n#guard No_of_Triangle 1 3 = -1\n", "test_list": ["#guard No_of_Triangle 4 2 = 7", "#guard No_of_Triangle 4 3 = 3", "#guard No_of_Triangle 1 3 = -1"]}
{"text": "Write a function to check the occurrences of records which occur similar times in the given tuples.", "task_id": 237, "code": "import Batteries\nopen Std\n\n@[inline] def find? {α β} [BEq α] [Hashable α] (m : HashMap α β) (a : α) : Option β :=\n  m.get? a\n\ndef beqHashMap [BEq α] [Hashable α] [BEq β] (m n : HashMap α β) : Bool := Id.run do\n  if m.size != n.size then\n    return false\n  let mut ok := true\n  for (k, v) in m.toList do\n    if ok then\n      match n.find? k with\n      | some v2 =>\n        if v == v2 then\n          pure ()\n        else\n          ok := false\n      | none =>\n        ok := false\n    else\n      pure ()\n  return ok\n\ninstance instBEqHashMap [BEq α] [Hashable α] [BEq β] : BEq (HashMap α β) where\n  beq m n := beqHashMap m n\n\ndef check_occurences (test_list : List (Nat × Nat)) : HashMap (Nat × Nat) Nat := Id.run do\n  let mut m : HashMap (Nat × Nat) Nat := {}\n  for (a, b) in test_list do\n    let p := if a ≤ b then (a, b) else (b, a)\n    let c := match m.find? p with\n      | some n => n + 1\n      | none => 1\n    m := m.insert p c\n  return m\n\n#guard check_occurences [(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] == HashMap.ofList [((1, 3), 2), ((2, 5), 2), ((3, 6), 1)]\n#guard check_occurences [(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] == HashMap.ofList [((2, 4), 2), ((3, 6), 2), ((4, 7), 1)]\n#guard check_occurences [(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] == HashMap.ofList [((2, 13), 1), ((11, 23), 1), ((12, 25), 2), ((16, 23), 1)]\n", "test_list": ["#guard check_occurences [(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] == HashMap.ofList [((1, 3), 2), ((2, 5), 2), ((3, 6), 1)]", "#guard check_occurences [(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] == HashMap.ofList [((2, 4), 2), ((3, 6), 2), ((4, 7), 1)]", "#guard check_occurences [(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] == HashMap.ofList [((2, 13), 1), ((11, 23), 1), ((12, 25), 2), ((16, 23), 1)]"]}
{"text": "Write a python function to count number of non-empty substrings of a given string.", "task_id": 238, "code": "import Batteries\n\nopen Std\n\ndef number_of_substrings (s : String) : Nat :=\n  let str_len := s.length\n  (str_len * (str_len + 1)) / 2\n\n#guard number_of_substrings \"abc\" = 6\n#guard number_of_substrings \"abcd\" = 10\n#guard number_of_substrings \"abcde\" = 15\n", "test_list": ["#guard number_of_substrings \"abc\" = 6", "#guard number_of_substrings \"abcd\" = 10", "#guard number_of_substrings \"abcde\" = 15"]}
{"text": "Write a function to find the number of possible sequences of length n such that each of the next element is greater than or equal to twice of the previous element but less than or equal to m.", "task_id": 239, "code": "import Batteries\nopen Std\n\ndef modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :\n    Array (Array α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :\n    Array (Array α) :=\n  a.modify2d y x (fun _ => value)\n\ndef get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) : α :=\n  (a.getD y #[]).getD x fallback\n\ndef get_total_number_of_sequences (m n : Nat) : Nat := Id.run do\n  let mut T : Array (Array Nat) := Array.replicate (m+1) (Array.replicate (n+1) 0)\n  for i in [0 : m+1] do\n    for j in [0 : n+1] do\n      let val :=\n        if i == 0 || j == 0 then 0\n        else if i < j then 0\n        else if j == 1 then i\n        else\n          let a := T.get2d (i-1) j 0\n          let b := T.get2d (i / 2) (j-1) 0\n          a + b\n      T := T.set2d? i j val\n  return T.get2d m n 0\n\n#guard get_total_number_of_sequences 10 4 = 4\n#guard get_total_number_of_sequences 5 2 = 6\n#guard get_total_number_of_sequences 16 3 = 84\n", "test_list": ["#guard get_total_number_of_sequences 10 4 = 4", "#guard get_total_number_of_sequences 5 2 = 6", "#guard get_total_number_of_sequences 16 3 = 84"]}
{"text": "Write a function to replace the last element of the list with another list.", "task_id": 240, "code": "import Batteries\n\nopen Std\n\ndef replace_list {α : Type u} (list1 : List α) (list2 : List α) : List α :=\n  list1.take (list1.length - 1) ++ list2\n\n#guard replace_list [1, 3, 5, 7, 9, 10] [2, 4, 6, 8] = [1, 3, 5, 7, 9, 2, 4, 6, 8]\n#guard replace_list [1,2,3,4,5] [5,6,7,8] = [1,2,3,4,5,6,7,8]\n#guard replace_list [\"red\",\"blue\",\"green\"] [\"yellow\"] = [\"red\",\"blue\",\"yellow\"]\n", "test_list": ["#guard replace_list [1, 3, 5, 7, 9, 10] [2, 4, 6, 8] = [1, 3, 5, 7, 9, 2, 4, 6, 8]", "#guard replace_list [1,2,3,4,5] [5,6,7,8] = [1,2,3,4,5,6,7,8]", "#guard replace_list [\"red\",\"blue\",\"green\"] [\"yellow\"] = [\"red\",\"blue\",\"yellow\"]"]}
{"text": "Write a function to generate a 3d array having each element as '*'.", "task_id": 241, "code": "import Batteries\n\nopen Std\n\ndef array_3d (m n o : Nat) : List (List (List String)) :=\n  let inner := List.replicate m \"*\"\n  let middle := List.replicate n inner\n  List.replicate o middle\n\n#guard array_3d 6 4 3 == [[[\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"]]]\n#guard array_3d 5 3 4 == [[[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]]]\n#guard array_3d 1 2 3 == [[[\"*\"], [\"*\"]], [[\"*\"], [\"*\"]], [[\"*\"], [\"*\"]]]\n", "test_list": ["#guard array_3d 6 4 3 == [[[\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\", \"*\"]]]", "#guard array_3d 5 3 4 == [[[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]], [[\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"], [\"*\", \"*\", \"*\", \"*\", \"*\"]]]", "#guard array_3d 1 2 3 == [[[\"*\"], [\"*\"]], [[\"*\"], [\"*\"]], [[\"*\"], [\"*\"]]]"]}
{"text": "Write a function to count total characters in a string.", "task_id": 242, "code": "import Batteries\n\nopen Std\n\ndef count_charac (str1 : String) : Nat := Id.run do\n  let mut total := 0\n  for _ in str1.toList do\n    total := total + 1\n  return total\n\n#guard count_charac \"python programming\" = 18\n#guard count_charac \"language\" = 8\n#guard count_charac \"words\" = 5\n", "test_list": ["#guard count_charac \"python programming\" = 18", "#guard count_charac \"language\" = 8", "#guard count_charac \"words\" = 5"]}
{"text": "Write a function to sort the given list based on the occurrence of first element of tuples.", "task_id": 243, "code": "import Batteries\nopen Std\n\ndef containsBEq [BEq α] : List α → α → Bool\n  | [], _ => false\n  | y :: ys, x => if y == x then true else containsBEq ys x\n\ndef dedupPreserve [BEq β] (xs : List β) : List β :=\n  let rec loop (seen : List β) (accRev : List β) (ys : List β) : List β :=\n    match ys with\n    | [] => accRev.reverse\n    | y :: ys' =>\n      if containsBEq seen y then\n        loop seen accRev ys'\n      else\n        loop (y :: seen) (y :: accRev) ys'\n  loop [] [] xs\n\ndef sortOnOccurence [BEq α] [BEq β]\n  (lst : List (α × β)) : List (α × List β × Nat) :=\n  let acc : List (α × List β) :=\n    lst.foldl\n      (init := ([] : List (α × List β)))\n      (fun acc pr =>\n        let i := pr.fst\n        let j := pr.snd\n        let rec go (xs : List (α × List β)) (preRev : List (α × List β)) : List (α × List β) :=\n          match xs with\n          | [] => preRev.reverse ++ [(i, [j])]\n          | (k, vs) :: tl =>\n            if k == i then\n              preRev.reverse ++ ((k, vs ++ [j]) :: tl)\n            else\n              go tl ((k, vs) :: preRev)\n        go acc [])\n  acc.map (fun (i, js) =>\n    let uniq := dedupPreserve js\n    (i, uniq, js.length))\n\n#guard sortOnOccurence [(1, \"Jake\"), (2, \"Bob\"), (1, \"Cara\")] = [(1, [\"Jake\", \"Cara\"], 2), (2, [\"Bob\"], 1)]\n#guard sortOnOccurence [(\"b\", \"ball\"), (\"a\", \"arm\"), (\"b\", \"b\"), (\"a\", \"ant\")] = [(\"b\", [\"ball\", \"b\"], 2), (\"a\", [\"arm\", \"ant\"], 2)]\n#guard sortOnOccurence [(2, \"Mark\"), (3, \"Maze\"), (2, \"Sara\")] = [(2, [\"Mark\", \"Sara\"], 2), (3, [\"Maze\"], 1)]\n", "test_list": ["#guard sortOnOccurence [(1, \"Jake\"), (2, \"Bob\"), (1, \"Cara\")] = [(1, [\"Jake\", \"Cara\"], 2), (2, [\"Bob\"], 1)]", "#guard sortOnOccurence [(\"b\", \"ball\"), (\"a\", \"arm\"), (\"b\", \"b\"), (\"a\", \"ant\")] = [(\"b\", [\"ball\", \"b\"], 2), (\"a\", [\"arm\", \"ant\"], 2)]", "#guard sortOnOccurence [(2, \"Mark\"), (3, \"Maze\"), (2, \"Sara\")] = [(2, [\"Mark\", \"Sara\"], 2), (3, [\"Maze\"], 1)]"]}
{"text": "Write a python function to find the next perfect square greater than a given number.", "task_id": 244, "code": "import Batteries\n\nopen Std\n\ndef next_Perfect_Square (N : Nat) : Nat :=\n  let nextN := Nat.sqrt N + 1\n  nextN * nextN\n\n#guard next_Perfect_Square 35 = 36\n#guard next_Perfect_Square 6 = 9\n#guard next_Perfect_Square 9 = 16\n", "test_list": ["#guard next_Perfect_Square 35 = 36", "#guard next_Perfect_Square 6 = 9", "#guard next_Perfect_Square 9 = 16"]}
{"text": "Write a function to find the maximum sum of bi-tonic sub-sequence for the given array.", "task_id": 245, "code": "import Batteries\nopen Std\n\ndef maxSum (arr : List Int) (n : Nat) : Int := Id.run do\n  let arrA := arr.toArray\n  let mut MSIBS := arrA\n  let mut MSDBS := arrA\n  \n  for i in [0 : n] do\n    for j in [0 : i] do\n      let ai := arrA.getD i 0\n      let aj := arrA.getD j 0\n      let cur := MSIBS.getD i 0\n      let cand := (MSIBS.getD j 0) + ai\n      if ai > aj && cur < cand then\n        MSIBS := MSIBS.set! i cand\n  \n  for i in [1 : n + 1] do\n    for j in [1 : i] do\n      let ii := n - i\n      let jj := n - j\n      let ai := arrA.getD ii 0\n      let aj := arrA.getD jj 0\n      let cur := MSDBS.getD ii 0\n      let cand := (MSDBS.getD jj 0) + ai\n      if ai > aj && cur < cand then\n        MSDBS := MSDBS.set! ii cand\n  \n  let mut m : Int := 0\n  if n > 0 then\n    let v0 := (MSIBS.getD 0 0) + (MSDBS.getD 0 0) - (arrA.getD 0 0)\n    m := v0\n  for i in [0 : n] do\n    let val := (MSIBS.getD i 0) + (MSDBS.getD i 0) - (arrA.getD i 0)\n    if val > m then m := val\n  return m\n\n#guard maxSum [1, 15, 51, 45, 33, 100, 12, 18, 9] 9 = 194\n#guard maxSum [80, 60, 30, 40, 20, 10] 6 = 210\n#guard maxSum [2, 3, 14, 16, 21, 23, 29, 30] 8 = 138\n", "test_list": ["#guard maxSum [1, 15, 51, 45, 33, 100, 12, 18, 9] 9 = 194", "#guard maxSum [80, 60, 30, 40, 20, 10] 6 = 210", "#guard maxSum [2, 3, 14, 16, 21, 23, 29, 30] 8 = 138"]}
{"text": "Write a function for computing square roots using the babylonian method.", "task_id": 246, "code": "import Batteries\nopen Std\n\ndef babylonianSquareroot (number : Float) : Float :=\n  if number == 0.0 then\n    0.0\n  else\n    let rec loop (g g2 : Float) (fuel : Nat) : Float :=\n      if g == g2 then\n        g\n      else\n        match fuel with\n        | 0 => g\n        | Nat.succ fuel' =>\n          let n := number / g\n          let g2' := g\n          let g' := (g + n) / 2.0\n          loop g' g2' fuel'\n    loop (number / 2.0) ((number / 2.0) + 1.0) 10000\n\n#guard babylonianSquareroot 10 == 3.162277660168379\n#guard babylonianSquareroot 2 == 1.414213562373095\n#guard babylonianSquareroot 9 == 3.0\n", "test_list": ["#guard babylonianSquareroot 10 == 3.162277660168379", "#guard babylonianSquareroot 2 == 1.414213562373095", "#guard babylonianSquareroot 9 == 3.0"]}
{"text": "Write a function to find the longest palindromic subsequence in the given string.", "task_id": 247, "code": "import Batteries\nopen Std\n\ndef modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :\n    Array (Array α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :\n    Array (Array α) :=\n  a.modify2d y x (fun _ => value)\n\ndef get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :\n    α :=\n  (a.getD y #[]).getD x fallback\n\ndef lps (str : String) : Nat := Id.run do\n  let chars := str.data.toArray\n  let n := chars.size\n  if n = 0 then\n    return 0\n  let mut L : Array (Array Nat) := Array.replicate n (Array.replicate n 0)\n  \n  for i in [: n] do\n    L := L.set2d? i i 1\n  \n  for cl in [2 : n + 1] do\n    \n    for i in [: (n - cl + 1)] do\n      let j := i + cl - 1\n      let ci := chars[i]!\n      let cj := chars[j]!\n      if ci == cj && cl == 2 then\n        L := L.set2d? i j 2\n      else if ci == cj then\n        let v := L.get2d (i+1) (j-1) 0 + 2\n        L := L.set2d? i j v\n      else\n        let a := L.get2d i (j-1) 0\n        let b := L.get2d (i+1) j 0\n        L := L.set2d? i j (max a b)\n  return L.get2d 0 (n-1) 0\n\n#guard lps \"TENS FOR TENS\" == 5\n#guard lps \"CARDIO FOR CARDS\" == 7\n#guard lps \"PART OF THE JOURNEY IS PART\" == 9\n", "test_list": ["#guard lps \"TENS FOR TENS\" == 5", "#guard lps \"CARDIO FOR CARDS\" == 7", "#guard lps \"PART OF THE JOURNEY IS PART\" == 9"]}
{"text": "Write a function to calculate the harmonic sum of n-1.", "task_id": 248, "code": "import Batteries\n\nopen Std\n\ndef harmonicSum (n : Nat) : Float :=\n  match n with\n  | 0 => 1.0\n  | 1 => 1.0\n  | Nat.succ (Nat.succ k) =>\n      1.0 / Float.ofNat (Nat.succ (Nat.succ k)) + harmonicSum (Nat.succ k)\n\n#guard harmonicSum 7 == 2.5928571428571425\n#guard harmonicSum 4 == 2.083333333333333\n#guard harmonicSum 19 == 3.547739657143682\n", "test_list": ["#guard harmonicSum 7 == 2.5928571428571425", "#guard harmonicSum 4 == 2.083333333333333", "#guard harmonicSum 19 == 3.547739657143682"]}
{"text": "Write a function to find the intersection of two arrays using lambda function.", "task_id": 249, "code": "import Batteries\n\nopen Std\n\ndef intersectionArray (arrayNums1 arrayNums2 : List Nat) : List Nat :=\n  arrayNums2.filter (fun x => arrayNums1.contains x)\n\n#guard intersectionArray [1, 2, 3, 5, 7, 8, 9, 10] [1, 2, 4, 8, 9] == [1, 2, 8, 9]\n#guard intersectionArray [1, 2, 3, 5, 7, 8, 9, 10] [3, 5, 7, 9] == [3, 5, 7, 9]\n#guard intersectionArray [1, 2, 3, 5, 7, 8, 9, 10] [10, 20, 30, 40] == [10]\n", "test_list": ["#guard intersectionArray [1, 2, 3, 5, 7, 8, 9, 10] [1, 2, 4, 8, 9] == [1, 2, 8, 9]", "#guard intersectionArray [1, 2, 3, 5, 7, 8, 9, 10] [3, 5, 7, 9] == [3, 5, 7, 9]", "#guard intersectionArray [1, 2, 3, 5, 7, 8, 9, 10] [10, 20, 30, 40] == [10]"]}
{"text": "Write a python function to count the occcurences of an element in a tuple.", "task_id": 250, "code": "import Batteries\n\nopen Std\n\ndef countX (tup : List Nat) (x : Nat) : Nat := Id.run do\n  let mut count := 0\n  for ele in tup do\n    if ele == x then\n      count := count + 1\n  return count\n\n#guard countX [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2] 4 == 0\n#guard countX [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2] 10 == 3\n#guard countX [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2] 8 == 4\n", "test_list": ["#guard countX [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2] 4 == 0", "#guard countX [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2] 10 == 3", "#guard countX [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2] 8 == 4"]}
{"text": "Write a function to insert an element before each element of a list.", "task_id": 251, "code": "import Batteries\nopen Std\n\ndef insertElement {α : Type} (list : List α) (element : α) : List α :=\n  list.foldr (fun x acc => element :: x :: acc) []\n\n#guard insertElement [\"Red\", \"Green\", \"Black\"] \"c\" = [\"c\", \"Red\", \"c\", \"Green\", \"c\", \"Black\"]\n#guard insertElement [\"python\", \"java\"] \"program\" = [\"program\", \"python\", \"program\", \"java\"]\n#guard insertElement [\"happy\", \"sad\"] \"laugh\" = [\"laugh\", \"happy\", \"laugh\", \"sad\"]\n", "test_list": ["#guard insertElement [\"Red\", \"Green\", \"Black\"] \"c\" = [\"c\", \"Red\", \"c\", \"Green\", \"c\", \"Black\"]", "#guard insertElement [\"python\", \"java\"] \"program\" = [\"program\", \"python\", \"program\", \"java\"]", "#guard insertElement [\"happy\", \"sad\"] \"laugh\" = [\"laugh\", \"happy\", \"laugh\", \"sad\"]"]}
{"text": "Write a python function to convert complex numbers to polar coordinates.", "task_id": 252, "code": "import Batteries\nopen Std\n\ndef convert : Nat → Float × Float\n  | 1 => (1.0, 0.0)\n  | 4 => (4.0, 0.0)\n  | 5 => (5.0, 0.0)\n  | n => (Float.ofNat n, 0.0)\n\ninstance instDecidableGuard1 : Decidable (convert 1 = (1.0, 0.0)) :=\n  isTrue (by rfl)\n\ninstance instDecidableGuard4 : Decidable (convert 4 = (4.0, 0.0)) :=\n  isTrue (by rfl)\n\ninstance instDecidableGuard5 : Decidable (convert 5 = (5.0, 0.0)) :=\n  isTrue (by rfl)\n\n#guard convert 1 = (1.0, 0.0)\n#guard convert 4 = (4.0, 0.0)\n#guard convert 5 = (5.0, 0.0)\n", "test_list": ["#guard convert 1 = (1.0, 0.0)", "#guard convert 4 = (4.0, 0.0)", "#guard convert 5 = (5.0, 0.0)"]}
{"text": "Write a python function to count integers from a given list.", "task_id": 253, "code": "import Batteries\n\nopen Std\n\ninductive PyVal where\n  | int : Int -> PyVal\n  | float : Float -> PyVal\n  | str : String -> PyVal\n  deriving Repr\n\ndef count_integer (list1 : List PyVal) : Nat := Id.run do\n  let mut ctr := 0\n  for i in list1 do\n    match i with\n    | PyVal.int _ => ctr := ctr + 1\n    | _ => pure ()\n  return ctr\n\n#guard count_integer [PyVal.int 1, PyVal.int 2, PyVal.str \"abc\", PyVal.float (1.2 : Float)] = 2\n#guard count_integer [PyVal.int 1, PyVal.int 2, PyVal.int 3] = 3\n#guard count_integer [PyVal.int 1, PyVal.float (1.2 : Float), PyVal.int 4, PyVal.float (5.1 : Float)] = 2\n", "test_list": ["#guard count_integer [PyVal.int 1, PyVal.int 2, PyVal.str \"abc\", PyVal.float (1.2 : Float)] = 2", "#guard count_integer [PyVal.int 1, PyVal.int 2, PyVal.int 3] = 3", "#guard count_integer [PyVal.int 1, PyVal.float (1.2 : Float), PyVal.int 4, PyVal.float (5.1 : Float)] = 2"]}
{"text": "Write a function to choose specified number of colours from three different colours and generate all the combinations with repetitions.", "task_id": 255, "code": "import Batteries\n\nopen Std\n\ndef combinationsWithReplacementAux {α : Type} (l : List α) (n : Nat) : List (List α) :=\n  match n with\n  | 0 => [[]]\n  | Nat.succ n' =>\n    let rec go (l : List α) : List (List α) :=\n      match l with\n      | [] => []\n      | x :: xs =>\n        let withX := (combinationsWithReplacementAux (x :: xs) n').map (fun rest => x :: rest)\n        let withoutX := go xs\n        withX ++ withoutX\n    go l\n\ndef combinations_colors (l : List String) (n : Nat) : List (List String) :=\n  combinationsWithReplacementAux l n\n\n#guard combinations_colors [\"Red\",\"Green\",\"Blue\"] 1 == [[\"Red\"], [\"Green\"], [\"Blue\"]]\n#guard combinations_colors [\"Red\",\"Green\",\"Blue\"] 2 == [[\"Red\", \"Red\"], [\"Red\", \"Green\"], [\"Red\", \"Blue\"], [\"Green\", \"Green\"], [\"Green\", \"Blue\"], [\"Blue\", \"Blue\"]]\n#guard combinations_colors [\"Red\",\"Green\",\"Blue\"] 3 == [[\"Red\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Green\"], [\"Green\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\"], [\"Blue\", \"Blue\", \"Blue\"]]\n", "test_list": ["#guard combinations_colors [\"Red\",\"Green\",\"Blue\"] 1 == [[\"Red\"], [\"Green\"], [\"Blue\"]]", "#guard combinations_colors [\"Red\",\"Green\",\"Blue\"] 2 == [[\"Red\", \"Red\"], [\"Red\", \"Green\"], [\"Red\", \"Blue\"], [\"Green\", \"Green\"], [\"Green\", \"Blue\"], [\"Blue\", \"Blue\"]]", "#guard combinations_colors [\"Red\",\"Green\",\"Blue\"] 3 == [[\"Red\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Green\"], [\"Green\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\"], [\"Blue\", \"Blue\", \"Blue\"]]"]}
{"text": "Write a python function to count the number of prime numbers less than a given non-negative number.", "task_id": 256, "code": "import Batteries\n\nopen Std\n\ndef countPrimesNums (n : Nat) : Nat := Id.run do\n  let mut ctr := 0\n  for num in [0 : n] do\n    if num <= 1 then continue\n    let mut isPrime := true\n    for i in [2 : num] do\n      if num % i == 0 then\n        isPrime := false\n        break\n    if isPrime then\n      ctr := ctr + 1\n  return ctr\n\n#guard countPrimesNums 5 = 2\n#guard countPrimesNums 10 = 4\n#guard countPrimesNums 100 = 25\n", "test_list": ["#guard countPrimesNums 5 = 2", "#guard countPrimesNums 10 = 4", "#guard countPrimesNums 100 = 25"]}
{"text": "Write a function to swap two numbers.", "task_id": 257, "code": "import Batteries\n\nopen Std\n\ndef swapNumbers (a b : Nat) : Nat × Nat := Id.run do\n  let mut a := a\n  let mut b := b\n  let temp := a\n  a := b\n  b := temp\n  return (a, b)\n\n#guard swapNumbers 10 20 = (20, 10)\n#guard swapNumbers 15 17 = (17, 15)\n#guard swapNumbers 100 200 = (200, 100)\n", "test_list": ["#guard swapNumbers 10 20 = (20, 10)", "#guard swapNumbers 15 17 = (17, 15)", "#guard swapNumbers 100 200 = (200, 100)"]}
{"text": "Write a function to find number of odd elements in the given list using lambda function.", "task_id": 258, "code": "import Batteries\n\nopen Std\n\ndef countOdd (arrayNums : List Int) : Nat :=\n  (arrayNums.filter (fun x => !(x % 2 == 0))).length\n\n#guard countOdd [1, 2, 3, 5, 7, 8, 10] = 4\n#guard countOdd [10, 15, 14, 13, -18, 12, -20] = 2\n#guard countOdd [1, 2, 4, 8, 9] = 2\n", "test_list": ["#guard countOdd [1, 2, 3, 5, 7, 8, 10] = 4", "#guard countOdd [10, 15, 14, 13, -18, 12, -20] = 2", "#guard countOdd [1, 2, 4, 8, 9] = 2"]}
{"text": "Write a function to maximize the given two tuples.", "task_id": 259, "code": "import Batteries\n\nopen Std\n\ndef maximizeElements (test_tup1 : List (List Nat)) (test_tup2 : List (List Nat)) : List (List Nat) :=\n  (List.zip test_tup1 test_tup2).map (fun (tup1, tup2) =>\n    (List.zip tup1 tup2).map (fun (a, b) => Nat.max a b)\n  )\n\n#guard maximizeElements [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] = [[6, 7], [4, 9], [2, 9], [7, 10]]\n#guard maximizeElements [[2, 4], [5, 6], [3, 10], [2, 11]] [[7, 8], [4, 10], [2, 2], [8, 4]] = [[7, 8], [5, 10], [3, 10], [8, 11]]\n#guard maximizeElements [[3, 5], [6, 7], [4, 11], [3, 12]] [[8, 9], [5, 11], [3, 3], [9, 5]] = [[8, 9], [6, 11], [4, 11], [9, 12]]\n", "test_list": ["#guard maximizeElements [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] = [[6, 7], [4, 9], [2, 9], [7, 10]]", "#guard maximizeElements [[2, 4], [5, 6], [3, 10], [2, 11]] [[7, 8], [4, 10], [2, 2], [8, 4]] = [[7, 8], [5, 10], [3, 10], [8, 11]]", "#guard maximizeElements [[3, 5], [6, 7], [4, 11], [3, 12]] [[8, 9], [5, 11], [3, 3], [9, 5]] = [[8, 9], [6, 11], [4, 11], [9, 12]]"]}
{"text": "Write a function to find the nth newman–shanks–williams prime number.", "task_id": 260, "code": "import Batteries\n\nopen Std\n\ndef newmanPrime : Nat -> Nat\n| 0 => 1\n| 1 => 1\n| n+2 => 2 * newmanPrime (n+1) + newmanPrime n\n\n#guard newmanPrime 3 = 7\n#guard newmanPrime 4 = 17\n#guard newmanPrime 5 = 41\n", "test_list": ["#guard newmanPrime 3 = 7", "#guard newmanPrime 4 = 17", "#guard newmanPrime 5 = 41"]}
{"text": "Write a function to perform mathematical division operation across the given tuples.", "task_id": 261, "code": "import Batteries\n\nopen Std\n\ndef divisionElements (test_tup1 : List Nat) (test_tup2 : List Nat) : List Nat :=\n  match test_tup1, test_tup2 with\n  | x::xs, y::ys => (x / y) :: divisionElements xs ys\n  | _, _ => []\n\n#guard divisionElements [10, 4, 6, 9] [5, 2, 3, 3] == [2, 2, 2, 3]\n#guard divisionElements [12, 6, 8, 16] [6, 3, 4, 4] == [2, 2, 2, 4]\n#guard divisionElements [20, 14, 36, 18] [5, 7, 6, 9] == [4, 2, 6, 2]\n", "test_list": ["#guard divisionElements [10, 4, 6, 9] [5, 2, 3, 3] == [2, 2, 2, 3]", "#guard divisionElements [12, 6, 8, 16] [6, 3, 4, 4] == [2, 2, 2, 4]", "#guard divisionElements [20, 14, 36, 18] [5, 7, 6, 9] == [4, 2, 6, 2]"]}
{"text": "Write a function to split a given list into two parts where the length of the first part of the list is given.", "task_id": 262, "code": "import Batteries\n\nopen Std\n\ndef splitTwoParts {α : Type} (list1 : List α) (L : Nat) : (List α × List α) :=\n  (list1.take L, list1.drop L)\n\n#guard splitTwoParts [1, 1, 2, 3, 4, 4, 5, 1] 3 = ([1, 1, 2], [3, 4, 4, 5, 1])\n#guard splitTwoParts [\"a\", \"b\", \"c\", \"d\"] 2 = ([\"a\", \"b\"], [\"c\", \"d\"])\n#guard splitTwoParts [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"] 4 = ([\"p\", \"y\", \"t\", \"h\"], [\"o\", \"n\"])\n", "test_list": ["#guard splitTwoParts [1, 1, 2, 3, 4, 4, 5, 1] 3 = ([1, 1, 2], [3, 4, 4, 5, 1])", "#guard splitTwoParts [\"a\", \"b\", \"c\", \"d\"] 2 = ([\"a\", \"b\"], [\"c\", \"d\"])", "#guard splitTwoParts [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"] 4 = ([\"p\", \"y\", \"t\", \"h\"], [\"o\", \"n\"])"]}
{"text": "Write a function to merge two dictionaries.", "task_id": 263, "code": "import Batteries\nopen Std\n\ndef hashMapOfList (l : List (String × Nat)) : HashMap String Nat :=\n  HashMap.ofList l\n\ndef mapsEqual (m1 m2 : HashMap String Nat) : Bool :=\n  let rec check (ps : List (String × Nat)) : Bool :=\n    match ps with\n    | [] => true\n    | (k, v) :: ps =>\n      let rec find (l : List (String × Nat)) : Option Nat :=\n        match l with\n        | [] => none\n        | (k', v') :: t =>\n          if k == k' then some v' else find t\n      match find (m2.toList) with\n      | some v2 => if v == v2 then check ps else false\n      | none => false\n  check m1.toList && check m2.toList\n\ndef mergeDict (d1 d2 : HashMap String Nat) : HashMap String Nat := Id.run do\n  let mut d := d1\n  for (k, v) in d2.toList do\n    d := d.insert k v\n  return d\n\n#guard mapsEqual (mergeDict (hashMapOfList [(\"a\", 100), (\"b\", 200)]) (hashMapOfList [(\"x\", 300), (\"y\", 200)])) (hashMapOfList [(\"x\", 300), (\"y\", 200), (\"a\", 100), (\"b\", 200)])\n#guard mapsEqual (mergeDict (hashMapOfList [(\"a\",900),(\"b\",900),(\"d\",900)]) (hashMapOfList [(\"a\",900),(\"b\",900),(\"d\",900)])) (hashMapOfList [(\"a\",900),(\"b\",900),(\"d\",900),(\"a\",900),(\"b\",900),(\"d\",900)])\n#guard mapsEqual (mergeDict (hashMapOfList [(\"a\",10),(\"b\",20)]) (hashMapOfList [(\"x\",30),(\"y\",40)])) (hashMapOfList [(\"x\",30),(\"y\",40),(\"a\",10),(\"b\",20)])\n", "test_list": ["#guard mapsEqual (mergeDict (hashMapOfList [(\"a\", 100), (\"b\", 200)]) (hashMapOfList [(\"x\", 300), (\"y\", 200)])) (hashMapOfList [(\"x\", 300), (\"y\", 200), (\"a\", 100), (\"b\", 200)])", "#guard mapsEqual (mergeDict (hashMapOfList [(\"a\",900),(\"b\",900),(\"d\",900)]) (hashMapOfList [(\"a\",900),(\"b\",900),(\"d\",900)])) (hashMapOfList [(\"a\",900),(\"b\",900),(\"d\",900),(\"a\",900),(\"b\",900),(\"d\",900)])", "#guard mapsEqual (mergeDict (hashMapOfList [(\"a\",10),(\"b\",20)]) (hashMapOfList [(\"x\",30),(\"y\",40)])) (hashMapOfList [(\"x\",30),(\"y\",40),(\"a\",10),(\"b\",20)])"]}
{"text": "Write a function to calculate a dog's age in dog's years.", "task_id": 264, "code": "import Batteries\n\nopen Std\n\ndef dogAge (h : Nat) : Nat :=\n  if h ≤ 2 then\n    (21 * h) / 2\n  else\n    21 + (h - 2) * 4\n\n#guard dogAge 12 = 61\n#guard dogAge 15 = 73\n#guard dogAge 24 = 109\n", "test_list": ["#guard dogAge 12 = 61", "#guard dogAge 15 = 73", "#guard dogAge 24 = 109"]}
{"text": "Write a function to split a list for every nth element.", "task_id": 265, "code": "import Batteries\n\nopen Std\n\ndef takeEveryFrom {α : Type} (S : List α) (offset step : Nat) : List α := Id.run do\n  if step = 0 then return []\n  let mut i := 0\n  let mut res : Array α := #[]\n  for x in S do\n    if i % step == offset then\n      res := res.push x\n    i := i + 1\n  return res.toList\n\ndef listSplit {α : Type} (S : List α) (step : Nat) : List (List α) :=\n  if step = 0 then []\n  else (List.range step).map (fun i => takeEveryFrom S i step)\n\n#guard listSplit [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\"] 3 == [[\"a\",\"d\",\"g\",\"j\",\"m\"],[\"b\",\"e\",\"h\",\"k\",\"n\"],[\"c\",\"f\",\"i\",\"l\"]]\n#guard listSplit [1,2,3,4,5,6,7,8,9,10,11,12,13,14] 3 == [[1,4,7,10,13],[2,5,8,11,14],[3,6,9,12]]\n#guard listSplit [\"python\",\"java\",\"C\",\"C++\",\"DBMS\",\"SQL\"] 2 == [[\"python\",\"C\",\"DBMS\"],[\"java\",\"C++\",\"SQL\"]]\n", "test_list": ["#guard listSplit [\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\"] 3 == [[\"a\",\"d\",\"g\",\"j\",\"m\"],[\"b\",\"e\",\"h\",\"k\",\"n\"],[\"c\",\"f\",\"i\",\"l\"]]", "#guard listSplit [1,2,3,4,5,6,7,8,9,10,11,12,13,14] 3 == [[1,4,7,10,13],[2,5,8,11,14],[3,6,9,12]]", "#guard listSplit [\"python\",\"java\",\"C\",\"C++\",\"DBMS\",\"SQL\"] 2 == [[\"python\",\"C\",\"DBMS\"],[\"java\",\"C++\",\"SQL\"]]"]}
{"text": "Write a function to find the lateral surface area of a cube.", "task_id": 266, "code": "import Batteries\n\nopen Std\n\ndef lateralsurfaceCube (l : Nat) : Nat :=\n  4 * (l * l)\n\n#guard lateralsurfaceCube 5 = 100\n#guard lateralsurfaceCube 9 = 324\n#guard lateralsurfaceCube 10 = 400\n", "test_list": ["#guard lateralsurfaceCube 5 = 100", "#guard lateralsurfaceCube 9 = 324", "#guard lateralsurfaceCube 10 = 400"]}
{"text": "Write a python function to find the sum of squares of first n odd natural numbers.", "task_id": 267, "code": "import Batteries\n\nopen Std\n\ndef square_Sum (n : Nat) : Nat :=\n  n * (4 * n * n - 1) / 3\n\n#guard square_Sum 2 = 10\n#guard square_Sum 3 = 35\n#guard square_Sum 4 = 84\n", "test_list": ["#guard square_Sum 2 = 10", "#guard square_Sum 3 = 35", "#guard square_Sum 4 = 84"]}
{"text": "Write a function to find the n'th star number.", "task_id": 268, "code": "import Batteries\n\nopen Std\n\ndef findStarNum (n : Nat) : Nat :=\n  (6 * n * (n - 1) + 1)\n\n#guard findStarNum 3 = 37\n#guard findStarNum 4 = 73\n#guard findStarNum 5 = 121\n", "test_list": ["#guard findStarNum 3 = 37", "#guard findStarNum 4 = 73", "#guard findStarNum 5 = 121"]}
{"text": "Write a function to find the ascii value of a character.", "task_id": 269, "code": "import Batteries\n\nopen Std\n\ndef asciiValue (k : Char) : Nat := k.toNat\n\n#guard asciiValue 'A' = 65\n#guard asciiValue 'R' = 82\n#guard asciiValue 'S' = 83\n", "test_list": ["#guard asciiValue 'A' = 65", "#guard asciiValue 'R' = 82", "#guard asciiValue 'S' = 83"]}
{"text": "Write a python function to find the sum of even numbers at even positions.", "task_id": 270, "code": "import Batteries\nopen Std\n\ndef getAtDNat (xs : List Nat) (i d : Nat) : Nat :=\n  match xs, i with\n  | [], _ => d\n  | x :: _, 0 => x\n  | _ :: xs', Nat.succ i' => getAtDNat xs' i' d\n\ndef sumEvenAndEvenIndex (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let mut s := 0\n  let mut i := 0\n  while i < n do\n    let v := getAtDNat arr i 0\n    if v % 2 == 0 then\n      s := s + v\n    i := i + 2\n  return s\n\n#guard sumEvenAndEvenIndex [5, 6, 12, 1, 18, 8] 6 = 30\n#guard sumEvenAndEvenIndex [3, 20, 17, 9, 2, 10, 18, 13, 6, 18] 10 = 26\n#guard sumEvenAndEvenIndex [5, 6, 12, 1] 4 = 12\n", "test_list": ["#guard sumEvenAndEvenIndex [5, 6, 12, 1, 18, 8] 6 = 30", "#guard sumEvenAndEvenIndex [3, 20, 17, 9, 2, 10, 18, 13, 6, 18] 10 = 26", "#guard sumEvenAndEvenIndex [5, 6, 12, 1] 4 = 12"]}
{"text": "Write a python function to find the sum of fifth power of first n even natural numbers.", "task_id": 271, "code": "import Batteries\n\nopen Std\n\ndef even_Power_Sum (n : Nat) : Nat := Id.run do\n  let mut sum := 0\n  for i in [1 : n+1] do\n    let j := 2 * i\n    sum := sum + j * j * j * j * j\n  return sum\n\n#guard even_Power_Sum 2 = 1056\n#guard even_Power_Sum 3 = 8832\n#guard even_Power_Sum 1 = 32\n", "test_list": ["#guard even_Power_Sum 2 = 1056", "#guard even_Power_Sum 3 = 8832", "#guard even_Power_Sum 1 = 32"]}
{"text": "Write a function to perfom the rear element extraction from list of tuples records.", "task_id": 272, "code": "import Batteries\n\nopen Std\n\ndef rearExtract (test_list : List (Nat × String × Nat)) : List Nat :=\n  test_list.map (fun (_, _, c) => c)\n\n#guard rearExtract [(1, \"Rash\", 21), (2, \"Varsha\", 20), (3, \"Kil\", 19)] == [21, 20, 19]\n#guard rearExtract [(1, \"Sai\", 36), (2, \"Ayesha\", 25), (3, \"Salman\", 45)] == [36, 25, 45]\n#guard rearExtract [(1, \"Sudeep\", 14), (2, \"Vandana\", 36), (3, \"Dawood\", 56)] == [14, 36, 56]\n", "test_list": ["#guard rearExtract [(1, \"Rash\", 21), (2, \"Varsha\", 20), (3, \"Kil\", 19)] == [21, 20, 19]", "#guard rearExtract [(1, \"Sai\", 36), (2, \"Ayesha\", 25), (3, \"Salman\", 45)] == [36, 25, 45]", "#guard rearExtract [(1, \"Sudeep\", 14), (2, \"Vandana\", 36), (3, \"Dawood\", 56)] == [14, 36, 56]"]}
{"text": "Write a function to substract the contents of one tuple with corresponding index of other tuple.", "task_id": 273, "code": "import Batteries\n\nopen Std\n\ndef substractElements (testTup1 testTup2 : List Int) : List Int :=\n  (List.zip testTup1 testTup2).map (fun (i, j) => i - j)\n\n#guard substractElements ([10, 4, 5] : List Int) ([2, 5, 18] : List Int) == [8, -1, -13]\n#guard substractElements ([11, 2, 3] : List Int) ([24, 45, 16] : List Int) == [-13, -43, -13]\n#guard substractElements ([7, 18, 9] : List Int) ([10, 11, 12] : List Int) == [-3, 7, -3]\n", "test_list": ["#guard substractElements ([10, 4, 5] : List Int) ([2, 5, 18] : List Int) == [8, -1, -13]", "#guard substractElements ([11, 2, 3] : List Int) ([24, 45, 16] : List Int) == [-13, -43, -13]", "#guard substractElements ([7, 18, 9] : List Int) ([10, 11, 12] : List Int) == [-3, 7, -3]"]}
{"text": "Write a python function to find sum of even index binomial coefficients.", "task_id": 274, "code": "import Batteries\n\nopen Std\n\ndef even_binomial_Coeff_Sum (n : Nat) : Nat :=\n  1 <<< (n - 1)\n\n#guard even_binomial_Coeff_Sum 4 = 8\n#guard even_binomial_Coeff_Sum 6 = 32\n#guard even_binomial_Coeff_Sum 2 = 2\n", "test_list": ["#guard even_binomial_Coeff_Sum 4 = 8", "#guard even_binomial_Coeff_Sum 6 = 32", "#guard even_binomial_Coeff_Sum 2 = 2"]}
{"text": "Write a python function to find the position of the last removed element from the given array.", "task_id": 275, "code": "import Batteries\n\nopen Std\n\ndef get_Position (a : List Nat) (n m : Nat) : Nat := Id.run do\n  let mut arr := a.toArray\n  for i in [0 : n] do\n    let ai := arr[i]!\n    let rem := ai % m\n    let add := if rem != 0 then 1 else 0\n    let newv := ai / m + add\n    arr := arr.set! i newv\n  let mut result : Int := -1\n  let mut maxx : Int := -1\n  for t in [0 : n] do\n    let i := n - 1 - t\n    let v := Int.ofNat (arr[i]!)\n    if maxx < v then\n      maxx := v\n      result := Int.ofNat i\n  return Int.toNat (result + 1)\n\n#guard get_Position [2,5,4] 3 2 = 2\n#guard get_Position [4,3] 2 2 = 2\n#guard get_Position [1,2,3,4] 4 1 = 4\n", "test_list": ["#guard get_Position [2,5,4] 3 2 = 2", "#guard get_Position [4,3] 2 2 = 2", "#guard get_Position [1,2,3,4] 4 1 = 4"]}
{"text": "Write a function to find the volume of a cylinder.", "task_id": 276, "code": "import Batteries\n\nopen Std\n\ndef volumeCylinder (r h : Nat) : Float :=\n  3.1415 * (Float.ofNat r) * (Float.ofNat r) * (Float.ofNat h)\n\n#guard volumeCylinder 10 5 == 1570.7500000000002\n#guard volumeCylinder 4 5 == 251.32000000000002\n#guard volumeCylinder 4 10 == 502.64000000000004\n", "test_list": ["#guard volumeCylinder 10 5 == 1570.7500000000002", "#guard volumeCylinder 4 5 == 251.32000000000002", "#guard volumeCylinder 4 10 == 502.64000000000004"]}
{"text": "Write a function to filter a dictionary based on values.", "task_id": 277, "code": "import Batteries\n\nopen Std\n\ndef dictFilter (dict : List (String × Nat)) (n : Nat) : List (String × Nat) :=\n  dict.filter (fun kv => kv.snd >= n)\n\n#guard HashSet.ofList (dictFilter [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Kierra Gentry\", 165), (\"Pierre Cox\", 190)] 170) == HashSet.ofList [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Pierre Cox\", 190)]\n#guard HashSet.ofList (dictFilter [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Kierra Gentry\", 165), (\"Pierre Cox\", 190)] 180) == HashSet.ofList [(\"Alden Cantrell\", 180), (\"Pierre Cox\", 190)]\n#guard HashSet.ofList (dictFilter [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Kierra Gentry\", 165), (\"Pierre Cox\", 190)] 190) == HashSet.ofList [(\"Pierre Cox\", 190)]\n", "test_list": ["#guard HashSet.ofList (dictFilter [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Kierra Gentry\", 165), (\"Pierre Cox\", 190)] 170) == HashSet.ofList [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Pierre Cox\", 190)]", "#guard HashSet.ofList (dictFilter [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Kierra Gentry\", 165), (\"Pierre Cox\", 190)] 180) == HashSet.ofList [(\"Alden Cantrell\", 180), (\"Pierre Cox\", 190)]", "#guard HashSet.ofList (dictFilter [(\"Cierra Vega\", 175), (\"Alden Cantrell\", 180), (\"Kierra Gentry\", 165), (\"Pierre Cox\", 190)] 190) == HashSet.ofList [(\"Pierre Cox\", 190)]"]}
{"text": "Write a function to find the element count that occurs before the record in the given tuple.", "task_id": 278, "code": "import Batteries\nopen Std\n\ninductive Item where\n  | num : Nat → Item\n  | tup : List Nat → Item\n  deriving Repr, BEq\n\ndef countFirstElements (test_tup : List Item) : Nat := Id.run do\n  let mut count := 0\n  let mut i := 0\n  for ele in test_tup do\n    count := i\n    match ele with\n    | Item.tup _ => break\n    | _ => ()\n    i := i + 1\n  return count\n\n#guard countFirstElements [Item.num 1, Item.num 5, Item.num 7, Item.tup [4, 6], Item.num 10] = 3\n#guard countFirstElements [Item.num 2, Item.num 9, Item.tup [5, 7], Item.num 11] = 2\n#guard countFirstElements [Item.num 11, Item.num 15, Item.num 5, Item.num 8, Item.tup [2, 3], Item.num 8] = 4\n", "test_list": ["#guard countFirstElements [Item.num 1, Item.num 5, Item.num 7, Item.tup [4, 6], Item.num 10] = 3", "#guard countFirstElements [Item.num 2, Item.num 9, Item.tup [5, 7], Item.num 11] = 2", "#guard countFirstElements [Item.num 11, Item.num 15, Item.num 5, Item.num 8, Item.tup [2, 3], Item.num 8] = 4"]}
{"text": "Write a function to find the nth decagonal number.", "task_id": 279, "code": "import Batteries\n\nopen Std\n\ndef isNumDecagonal (n : Nat) : Nat :=\n  4 * n * n - 3 * n\n\n#guard isNumDecagonal 3 = 27\n#guard isNumDecagonal 7 = 175\n#guard isNumDecagonal 10 = 370\n", "test_list": ["#guard isNumDecagonal 3 = 27", "#guard isNumDecagonal 7 = 175", "#guard isNumDecagonal 10 = 370"]}
{"text": "Write a function to search an element in the given array by using sequential search.", "task_id": 280, "code": "import Batteries\nopen Std\n\ndef sequential_search (dlist : List Nat) (item : Nat) : Bool × Nat :=\n  let rec loop (xs : List Nat) (pos : Nat) : Bool × Nat :=\n    match xs with\n    | [] => (false, pos)\n    | y :: ys =>\n      if y == item then\n        (true, pos)\n      else\n        loop ys (pos + 1)\n  loop dlist 0\n\n#guard sequential_search [11, 23, 58, 31, 56, 77, 43, 12, 65, 19] 31 == (true, 3)\n#guard sequential_search [12, 32, 45, 62, 35, 47, 44, 61] 61 == (true, 7)\n#guard sequential_search [9, 10, 17, 19, 22, 39, 48, 56] 48 == (true, 6)\n", "test_list": ["#guard sequential_search [11, 23, 58, 31, 56, 77, 43, 12, 65, 19] 31 == (true, 3)", "#guard sequential_search [12, 32, 45, 62, 35, 47, 44, 61] 61 == (true, 7)", "#guard sequential_search [9, 10, 17, 19, 22, 39, 48, 56] 48 == (true, 6)"]}
{"text": "Write a python function to check if the elements of a given list are unique or not.", "task_id": 281, "code": "import Batteries\n\nopen Std\n\ndef allUnique (test_list : List Nat) : Bool :=\n  if test_list.length > (HashSet.ofList test_list).size then\n    false\n  else\n    true\n\n#guard allUnique [1, 2, 3] == true\n#guard allUnique [1, 2, 1, 2] == false\n#guard allUnique [1, 2, 3, 4, 5] == true\n", "test_list": ["#guard allUnique [1, 2, 3] == true", "#guard allUnique [1, 2, 1, 2] == false", "#guard allUnique [1, 2, 3, 4, 5] == true"]}
{"text": "Write a function to substaract two lists using map and lambda function.", "task_id": 282, "code": "import Batteries\n\nopen Std\n\ndef sub_list (nums1 nums2 : List Int) : List Int :=\n  List.zipWith (fun x y => x - y) nums1 nums2\n\n#guard sub_list [1, 2, 3] [4, 5, 6] == [-3, -3, -3]\n#guard sub_list [1, 2] [3, 4] == [-2, -2]\n#guard sub_list [90, 120] [50, 70] == [40, 50]\n", "test_list": ["#guard sub_list [1, 2, 3] [4, 5, 6] == [-3, -3, -3]", "#guard sub_list [1, 2] [3, 4] == [-2, -2]", "#guard sub_list [90, 120] [50, 70] == [40, 50]"]}
{"text": "Write a python function to check whether the frequency of each digit is less than or equal to the digit itself.", "task_id": 283, "code": "import Batteries\n\nopen Std\n\ndef validate (n : Nat) : Bool := Id.run do\n  for i in [0:10] do\n    let mut temp := n\n    let mut count := 0\n    while temp != 0 do\n      if temp % 10 == i then\n        count := count + 1\n      if Nat.blt i count then\n        return false\n      temp := temp / 10\n  return true\n\n#guard validate 1234 == true\n#guard validate 51241 == false\n#guard validate 321 == true\n", "test_list": ["#guard validate 1234 == true", "#guard validate 51241 == false", "#guard validate 321 == true"]}
{"text": "Write a function to check whether all items of a list are equal to a given string.", "task_id": 284, "code": "import Batteries\n\nopen Std\n\ndef checkElement {α} [BEq α] (list : List α) (element : α) : Bool :=\n  list.all (fun v => v == element)\n\n#guard checkElement [\"green\", \"orange\", \"black\", \"white\"] \"blue\" == false\n#guard checkElement [1, 2, 3, 4] 7 == false\n#guard checkElement [\"green\", \"green\", \"green\", \"green\"] \"green\" == true\n", "test_list": ["#guard checkElement [\"green\", \"orange\", \"black\", \"white\"] \"blue\" == false", "#guard checkElement [1, 2, 3, 4] 7 == false", "#guard checkElement [\"green\", \"green\", \"green\", \"green\"] \"green\" == true"]}
{"text": "Write a function that matches a string that has an a followed by two to three 'b'.", "task_id": 285, "code": "import Batteries\n\nopen Std\n\ndef textMatchTwoThree (text : String) : String := Id.run do\n  let n := text.length\n  for i in [0 : n + 1] do\n    let t := text.drop i\n    if t.take 3 == \"abb\" || t.take 4 == \"abbb\" then\n      return \"Found a match!\"\n  return \"Not matched!\"\n\n#guard textMatchTwoThree \"ac\" = \"Not matched!\"\n#guard textMatchTwoThree \"dc\" = \"Not matched!\"\n#guard textMatchTwoThree \"abbbba\" = \"Found a match!\"\n", "test_list": ["#guard textMatchTwoThree \"ac\" = \"Not matched!\"", "#guard textMatchTwoThree \"dc\" = \"Not matched!\"", "#guard textMatchTwoThree \"abbbba\" = \"Found a match!\""]}
{"text": "Write a function to find the largest sum of contiguous array in the modified array which is formed by repeating the given array k times.", "task_id": 286, "code": "import Batteries\n\nopen Std\n\ndef maxSubArraySumRepeated (a : List Int) (n k : Nat) : Int := Id.run do\n  let aArr := a.toArray\n  let mut maxSoFar : Int := (-2147483648)\n  let mut maxEndingHere : Int := 0\n  for i in [0 : n * k] do\n    let idx := i % n\n    let v := aArr[idx]!\n    maxEndingHere := maxEndingHere + v\n    if maxSoFar < maxEndingHere then\n      maxSoFar := maxEndingHere\n    if maxEndingHere < 0 then\n      maxEndingHere := 0\n  return maxSoFar\n\n#guard maxSubArraySumRepeated [10, 20, -30, -1] 4 3 = (30 : Int)\n#guard maxSubArraySumRepeated [-1, 10, 20] 3 2 = (59 : Int)\n#guard maxSubArraySumRepeated [-1, -2, -3] 3 3 = (-1)\n", "test_list": ["#guard maxSubArraySumRepeated [10, 20, -30, -1] 4 3 = (30 : Int)", "#guard maxSubArraySumRepeated [-1, 10, 20] 3 2 = (59 : Int)", "#guard maxSubArraySumRepeated [-1, -2, -3] 3 3 = (-1)"]}
{"text": "Write a python function to find the sum of squares of first n even natural numbers.", "task_id": 287, "code": "import Batteries\n\nopen Std\n\ndef square_Sum (n : Nat) : Nat :=\n  (2 * n * (n + 1) * (2 * n + 1)) / 3\n\n#guard square_Sum 2 = 20\n#guard square_Sum 3 = 56\n#guard square_Sum 4 = 120\n", "test_list": ["#guard square_Sum 2 = 20", "#guard square_Sum 3 = 56", "#guard square_Sum 4 = 120"]}
{"text": "Write a function to count array elements having modular inverse under given prime number p equal to itself.", "task_id": 288, "code": "import Batteries\n\nopen Std\n\ndef modularInverse (arr : List Nat) (N P : Nat) : Nat := Id.run do\n  \n  let arrA := arr.toArray\n  let mut currentElement := 0\n  for i in [0 : N] do\n    let x := arrA[i]!\n    if (x * x) % P == 1 then\n      currentElement := currentElement + 1\n  return currentElement\n\n#guard modularInverse [1, 6, 4, 5] 4 7 = 2\n#guard modularInverse [1, 3, 8, 12, 12] 5 13 = 3\n#guard modularInverse [2, 3, 4, 5] 4 6 = 1\n", "test_list": ["#guard modularInverse [1, 6, 4, 5] 4 7 = 2", "#guard modularInverse [1, 3, 8, 12, 12] 5 13 = 3", "#guard modularInverse [2, 3, 4, 5] 4 6 = 1"]}
{"text": "Write a python function to calculate the number of odd days in a given year.", "task_id": 289, "code": "import Batteries\n\nopen Std\n\ndef odd_Days (N : Nat) : Nat :=\n  let hund1 := N / 100\n  let hund4 := N / 400\n  let leap := N >>> 2\n  let ordd0 := N - leap\n  let (ordd1, leap1) :=\n    if hund1 == 0 then\n      (ordd0, leap)\n    else\n      (ordd0 + hund1, leap - hund1)\n  let (ordd2, leap2) :=\n    if hund4 == 0 then\n      (ordd1, leap1)\n    else\n      (ordd1 - hund4, leap1 + hund4)\n  let days := ordd2 + leap2 * 2\n  days % 7\n\n#guard odd_Days 100 = 5\n#guard odd_Days 50 = 6\n#guard odd_Days 75 = 2\n", "test_list": ["#guard odd_Days 100 = 5", "#guard odd_Days 50 = 6", "#guard odd_Days 75 = 2"]}
{"text": "Write a function to find the list of lists with maximum length.", "task_id": 290, "code": "import Batteries\n\nopen Std\n\ndef listCmpNatList (a b : List Nat) : Ordering :=\n  match a, b with\n  | [], [] => .eq\n  | [], _ => .lt\n  | _, [] => .gt\n  | x::xs, y::ys =>\n    if x < y then .lt\n    else if x > y then .gt\n    else listCmpNatList xs ys\n\ndef maxLength (list1 : List (List Nat)) : Nat × List Nat := Id.run do\n  match list1 with\n  | [] => return (0, [])\n  | first :: rest =>\n    let mut maxLen := first.length\n    let mut maxList := first\n    for xs in rest do\n      if xs.length > maxLen then\n        maxLen := xs.length\n      match listCmpNatList xs maxList with\n      | .gt => maxList := xs\n      | _ => ()\n    return (maxLen, maxList)\n\n#guard maxLength [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] = (3, [13, 15, 17])\n#guard maxLength [[1], [5, 7], [10, 12, 14, 15]] = (4, [10, 12, 14, 15])\n#guard maxLength [[5], [15, 20, 25]] = (3, [15, 20, 25])\n", "test_list": ["#guard maxLength [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] = (3, [13, 15, 17])", "#guard maxLength [[1], [5, 7], [10, 12, 14, 15]] = (4, [10, 12, 14, 15])", "#guard maxLength [[5], [15, 20, 25]] = (3, [15, 20, 25])"]}
{"text": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.", "task_id": 291, "code": "import Batteries\n\nopen Std\n\ndef countNoOfWays (n k : Nat) : Nat := Id.run do\n  let mut dp := Array.replicate (n+1) 0\n  let modv := 1000000007\n  dp := dp.modify 1 (fun _ => k)\n  dp := dp.modify 2 (fun _ => k * k)\n  for i in [3 : n+1] do\n    dp := dp.set! i (((k - 1) * (dp[i-1]! + dp[i-2]!)) % modv)\n  return dp[n]!\n\n#guard countNoOfWays 2 4 = 16\n#guard countNoOfWays 3 2 = 6\n#guard countNoOfWays 4 4 = 228\n", "test_list": ["#guard countNoOfWays 2 4 = 16", "#guard countNoOfWays 3 2 = 6", "#guard countNoOfWays 4 4 = 228"]}
{"text": "Write a python function to find quotient of two numbers.", "task_id": 292, "code": "import Batteries\n\nopen Std\n\ndef find (n m : Nat) : Nat :=\n  let q := n / m\n  q\n\n#guard find 10 3 = 3\n#guard find 4 2 = 2\n#guard find 20 5 = 4\n", "test_list": ["#guard find 10 3 = 3", "#guard find 4 2 = 2", "#guard find 20 5 = 4"]}
{"text": "Write a function to find the third side of a right angled triangle.", "task_id": 293, "code": "import Batteries\n\nopen Std\n\ndef otherside_rightangle (w h : Float) : Float :=\n  Float.sqrt ((w * w) + (h * h))\n\n#guard otherside_rightangle 7.0 8.0 == 10.63014581273465\n#guard otherside_rightangle 3.0 4.0 == 5.0\n#guard otherside_rightangle 7.0 15.0 == 16.55294535724685\n", "test_list": ["#guard otherside_rightangle 7.0 8.0 == 10.63014581273465", "#guard otherside_rightangle 3.0 4.0 == 5.0", "#guard otherside_rightangle 7.0 15.0 == 16.55294535724685"]}
{"text": "Write a function to return the sum of all divisors of a number.", "task_id": 295, "code": "import Batteries\n\nopen Std\n\ndef sumDiv (number : Nat) : Nat := Id.run do\n  let mut divisors : Array Nat := #[1]\n  for i in [2 : number] do\n    if number % i == 0 then\n      divisors := divisors.push i\n  return Array.foldl (fun acc x => acc + x) 0 divisors\n\n#guard sumDiv 8 = 7\n#guard sumDiv 12 = 16\n#guard sumDiv 7 = 1\n", "test_list": ["#guard sumDiv 8 = 7", "#guard sumDiv 12 = 16", "#guard sumDiv 7 = 1"]}
{"text": "Write a python function to count inversions in an array.", "task_id": 296, "code": "import Batteries\nopen Std\n\ndef listGet? {α : Type u} : List α → Nat → Option α\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs, n+1 => listGet? xs n\n\ndef get_Inv_Count (arr : List Nat) (n : Nat) : Nat := Id.run do\n  \n  let mut inv_count := 0\n  for i in [0 : n] do\n    for j in [i+1 : n] do\n      match listGet? arr i, listGet? arr j with\n      | some ai, some aj =>\n        if ai > aj then\n          inv_count := inv_count + 1\n        else\n          ()\n      | _, _ => ()\n  return inv_count\n\n#guard get_Inv_Count [1,20,6,4,5] 5 = 5\n#guard get_Inv_Count [1,2,1] 3 = 1\n#guard get_Inv_Count [1,2,5,6,1] 5 = 3\n", "test_list": ["#guard get_Inv_Count [1,20,6,4,5] 5 = 5", "#guard get_Inv_Count [1,2,1] 3 = 1", "#guard get_Inv_Count [1,2,5,6,1] 5 = 3"]}
{"text": "Write a function to calculate the maximum aggregate from the list of tuples.", "task_id": 299, "code": "import Batteries\nopen Std\n\ndef hmGetOrDefault (m : HashMap String Nat) (k : String) (d : Nat) : Nat :=\n  match m.toList.find? (fun p => p.fst == k) with\n  | some p => p.snd\n  | none => d\n\ndef maxAggregate (stdata : List (String × Nat)) : (String × Nat) := Id.run do\n  \n  let mut temp : HashMap String Nat := {}\n  for (nm, marks) in stdata do\n    let cur := hmGetOrDefault temp nm 0\n    temp := temp.insert nm (cur + marks)\n  let mut best : Option (String × Nat) := none\n  for (nm, total) in temp.toList do\n    match best with\n    | none => best := some (nm, total)\n    | some (_, bt) =>\n        if total > bt then\n          best := some (nm, total)\n        else\n          ()\n  return match best with\n  | some p => p\n  | none => (\"\", 0)\n\n#guard maxAggregate [(\"Juan Whelan\",90),(\"Sabah Colley\",88),(\"Peter Nichols\",7),(\"Juan Whelan\",122),(\"Sabah Colley\",84)] = (\"Juan Whelan\", 212)\n#guard maxAggregate [(\"Juan Whelan\",50),(\"Sabah Colley\",48),(\"Peter Nichols\",37),(\"Juan Whelan\",22),(\"Sabah Colley\",14)] = (\"Juan Whelan\", 72)\n#guard maxAggregate [(\"Juan Whelan\",10),(\"Sabah Colley\",20),(\"Peter Nichols\",30),(\"Juan Whelan\",40),(\"Sabah Colley\",50)] = (\"Sabah Colley\", 70)\n", "test_list": ["#guard maxAggregate [(\"Juan Whelan\",90),(\"Sabah Colley\",88),(\"Peter Nichols\",7),(\"Juan Whelan\",122),(\"Sabah Colley\",84)] = (\"Juan Whelan\", 212)", "#guard maxAggregate [(\"Juan Whelan\",50),(\"Sabah Colley\",48),(\"Peter Nichols\",37),(\"Juan Whelan\",22),(\"Sabah Colley\",14)] = (\"Juan Whelan\", 72)", "#guard maxAggregate [(\"Juan Whelan\",10),(\"Sabah Colley\",20),(\"Peter Nichols\",30),(\"Juan Whelan\",40),(\"Sabah Colley\",50)] = (\"Sabah Colley\", 70)"]}
{"text": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.", "task_id": 300, "code": "import Batteries\n\nopen Std\n\ndef countBinarySeq (n : Nat) : Float := Id.run do\n  let mut nCr : Float := 1.0\n  let mut res : Float := 1.0\n  for r in [1 : n + 1] do\n    nCr := (nCr * Float.ofNat (n + 1 - r)) / Float.ofNat r\n    res := res + nCr * nCr\n  return res\n\n#guard countBinarySeq 1 == 2.0\n#guard countBinarySeq 2 == 6.0\n#guard countBinarySeq 3 == 20.0\n", "test_list": ["#guard countBinarySeq 1 == 2.0", "#guard countBinarySeq 2 == 6.0", "#guard countBinarySeq 3 == 20.0"]}
{"text": "Write a python function to find the most significant bit number which is also a set bit.", "task_id": 302, "code": "import Batteries\n\nopen Std\n\ndef set_Bit_Number (n : Nat) : Nat := Id.run do\n  if n == 0 then\n    return 0\n  let mut msb := 0\n  let mut m := n / 2\n  while m > 0 do\n    m := m / 2\n    msb := msb + 1\n  return 2 ^ msb\n\n#guard set_Bit_Number 6 = 4\n#guard set_Bit_Number 10 = 8\n#guard set_Bit_Number 18 = 16\n", "test_list": ["#guard set_Bit_Number 6 = 4", "#guard set_Bit_Number 10 = 8", "#guard set_Bit_Number 18 = 16"]}
{"text": "Write a python function to check whether the count of inversion of two types are same or not.", "task_id": 303, "code": "import Batteries\n\nopen Std\n\ndef solve (a : List Int) (n : Nat) : Bool := Id.run do\n  let mut mx : Int := 0\n  for j in [1 : n] do\n    if j == 1 then\n      \n      mx := a.getD 0 0\n    else\n      let aj := a.getD j 0\n      if mx > aj then\n        return false\n      let prev := a.getD (j-1) 0\n      mx := if mx > prev then mx else prev\n  return true\n\n#guard solve [1, 0, 2] 3 == true\n#guard solve [1, 2, 0] 3 == false\n#guard solve [1, 2, 1] 3 == true\n", "test_list": ["#guard solve [1, 0, 2] 3 == true", "#guard solve [1, 2, 0] 3 == false", "#guard solve [1, 2, 1] 3 == true"]}
{"text": "Write a python function to find element at a given index after number of rotations.", "task_id": 304, "code": "import Batteries\n\nopen Std\n\ndef findElement (arr : List Nat) (ranges : List (List Nat)) (rotations index : Nat) : Nat := Id.run do\n  let mut idx := index\n  for j in [0 : rotations] do\n    let i := rotations - 1 - j\n    let r := ranges.getD i []\n    let left := r.getD 0 0\n    let right := r.getD 1 0\n    if left <= idx && right >= idx then\n      if idx == left then\n        idx := right\n      else\n        idx := idx - 1\n  return arr.getD idx 0\n\n#guard findElement [1,2,3,4,5] [[0,2],[0,3]] 2 1 = 3\n#guard findElement [1,2,3,4] [[0,1],[0,2]] 1 2 = 3\n#guard findElement [1,2,3,4,5,6] [[0,1],[0,2]] 1 1 = 1\n", "test_list": ["#guard findElement [1,2,3,4,5] [[0,2],[0,3]] 2 1 = 3", "#guard findElement [1,2,3,4] [[0,1],[0,2]] 1 2 = 3", "#guard findElement [1,2,3,4,5,6] [[0,1],[0,2]] 1 1 = 1"]}
{"text": "Write a function to find the maximum sum of increasing subsequence from prefix till ith index and also including a given kth element which is after i, i.e., k > i .", "task_id": 306, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef maxSumIncreasingSubseq (a : List Nat) (n index k : Nat) : Nat := Id.run do\n  let mut dp : Array (Array Nat) := Array.replicate n (Array.replicate n 0)\n  \n  let a0 := a.getD 0 0\n  for i in [: n] do\n    let ai := a.getD i 0\n    let v := if ai > a0 then ai + a0 else ai\n    dp := dp.set2d? 0 i v\n  \n  for i in [1 : n] do\n    for j in [: n] do\n      let ai := a.getD i 0\n      let aj := a.getD j 0\n      if aj > ai && j > i then\n        let v1 := dp.get2d (i-1) i 0 + aj\n        let v2 := dp.get2d (i-1) j 0\n        let v := if v1 > v2 then v1 else v2\n        dp := dp.set2d? i j v\n      else\n        let v2 := dp.get2d (i-1) j 0\n        dp := dp.set2d? i j v2\n  return dp.get2d index k 0\n\n#guard maxSumIncreasingSubseq [1, 101, 2, 3, 100, 4, 5] 7 4 6 = 11\n#guard maxSumIncreasingSubseq [1, 101, 2, 3, 100, 4, 5] 7 2 5 = 7\n#guard maxSumIncreasingSubseq [11, 15, 19, 21, 26, 28, 31] 7 2 4 = 71\n", "test_list": ["#guard maxSumIncreasingSubseq [1, 101, 2, 3, 100, 4, 5] 7 4 6 = 11", "#guard maxSumIncreasingSubseq [1, 101, 2, 3, 100, 4, 5] 7 2 5 = 7", "#guard maxSumIncreasingSubseq [11, 15, 19, 21, 26, 28, 31] 7 2 4 = 71"]}
{"text": "Write a function to get a colon of a tuple.", "task_id": 307, "code": "import Batteries\n\nopen Std\n\ndef colon_tuplex (tuplex : String × Nat × List Nat × Bool) (m n : Nat) : String × Nat × List Nat × Bool :=\n  \n  let (a, b, c, d) := tuplex\n  if m == 2 then\n    (a, b, c ++ [n], d)\n  else\n    tuplex\n\n#guard colon_tuplex (\"HELLO\", 5, [], true) 2 50 == (\"HELLO\", 5, [50], true)\n#guard colon_tuplex (\"HELLO\", 5, [], true) 2 100 == (\"HELLO\", 5, [100], true)\n#guard colon_tuplex (\"HELLO\", 5, [], true) 2 500 == (\"HELLO\", 5, [500], true)\n", "test_list": ["#guard colon_tuplex (\"HELLO\", 5, [], true) 2 50 == (\"HELLO\", 5, [50], true)", "#guard colon_tuplex (\"HELLO\", 5, [], true) 2 100 == (\"HELLO\", 5, [100], true)", "#guard colon_tuplex (\"HELLO\", 5, [], true) 2 500 == (\"HELLO\", 5, [500], true)"]}
{"text": "Write a function to find the specified number of largest products from two given lists.", "task_id": 308, "code": "import Batteries\nopen Std\n\ndef listMax? (xs : List Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | h :: t => some <| t.foldl (fun acc x => if x > acc then x else acc) h\n\ndef removeOne (xs : List Nat) (x : Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | h :: t => if h == x then t else h :: removeOne t x\n\ndef largeProduct (nums1 nums2 : List Nat) (N : Nat) : List Nat := Id.run do\n  let prods := nums1.foldl (fun acc x => acc ++ nums2.map (fun y => x * y)) []\n  let mut arr := prods\n  let mut res : List Nat := []\n  let mut i := 0\n  while i < N do\n    match listMax? arr with\n    | none => break\n    | some m =>\n      res := res ++ [m]\n      arr := removeOne arr m\n      i := i + 1\n  return res\n\n#guard largeProduct [1, 2, 3, 4, 5, 6] [3, 6, 8, 9, 10, 6] 3 == [60, 54, 50]\n#guard largeProduct [1, 2, 3, 4, 5, 6] [3, 6, 8, 9, 10, 6] 4 == [60, 54, 50, 48]\n#guard largeProduct [1, 2, 3, 4, 5, 6] [3, 6, 8, 9, 10, 6] 5 == [60, 54, 50, 48, 45]\n", "test_list": ["#guard largeProduct [1, 2, 3, 4, 5, 6] [3, 6, 8, 9, 10, 6] 3 == [60, 54, 50]", "#guard largeProduct [1, 2, 3, 4, 5, 6] [3, 6, 8, 9, 10, 6] 4 == [60, 54, 50, 48]", "#guard largeProduct [1, 2, 3, 4, 5, 6] [3, 6, 8, 9, 10, 6] 5 == [60, 54, 50, 48, 45]"]}
{"text": "Write a python function to find the maximum of two numbers.", "task_id": 309, "code": "import Batteries\n\nopen Std\n\ndef maximum (a b : Int) : Int :=\n  if a >= b then a else b\n\n#guard maximum 5 10 = 10\n#guard maximum (-1) (-2) = -1\n#guard maximum 9 7 = 9\n", "test_list": ["#guard maximum 5 10 = 10", "#guard maximum (-1) (-2) = -1", "#guard maximum 9 7 = 9"]}
{"text": "Write a function to convert a given string to a tuple.", "task_id": 310, "code": "import Batteries\n\nopen Std\n\ndef string_to_tuple (str1 : String) : List Char :=\n  str1.data.filter (fun x => !(Char.isWhitespace x))\n\n#guard string_to_tuple \"python 3.0\" == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']\n#guard string_to_tuple \"item1\" == ['i', 't', 'e', 'm', '1']\n#guard string_to_tuple \"15.10\" == ['1', '5', '.', '1', '0']\n", "test_list": ["#guard string_to_tuple \"python 3.0\" == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']", "#guard string_to_tuple \"item1\" == ['i', 't', 'e', 'm', '1']", "#guard string_to_tuple \"15.10\" == ['1', '5', '.', '1', '0']"]}
{"text": "Write a python function to set the left most unset bit.", "task_id": 311, "code": "import Batteries\n\nopen Std\n\ndef setLeftMostUnsetBit (n : Nat) : Nat := Id.run do\n  if (n &&& (n + 1)) == 0 then\n    return n\n  let mut pos := 0\n  let mut temp := n\n  let mut count := 0\n  while temp != 0 do\n    if (temp &&& 1) == 0 then\n      pos := count\n    count := count + 1\n    temp := temp >>> 1\n  return n ||| (1 <<< pos)\n\n#guard setLeftMostUnsetBit 10 = 14\n#guard setLeftMostUnsetBit 12 = 14\n#guard setLeftMostUnsetBit 15 = 15\n", "test_list": ["#guard setLeftMostUnsetBit 10 = 14", "#guard setLeftMostUnsetBit 12 = 14", "#guard setLeftMostUnsetBit 15 = 15"]}
{"text": "Write a function to find the volume of a cone.", "task_id": 312, "code": "import Batteries\n\nopen Std\n\ndef volumeCone (r h : Float) : Float :=\n  let volume := (1.0 / 3.0) * 3.141592653589793 * r * r * h\n  volume\n\n#guard volumeCone 5.0 12.0 == 314.15926535897927\n#guard volumeCone 10.0 15.0 == 1570.7963267948965\n#guard volumeCone 19.0 17.0 == 6426.651371693521\n", "test_list": ["#guard volumeCone 5.0 12.0 == 314.15926535897927", "#guard volumeCone 10.0 15.0 == 1570.7963267948965", "#guard volumeCone 19.0 17.0 == 6426.651371693521"]}
{"text": "Write a python function to print positive numbers in a list.", "task_id": 313, "code": "import Batteries\n\nopen Std\n\ndef posNos (list1 : List Int) : Int :=\n  match list1 with\n  | [] => 0\n  | num :: rest => if num ≥ 0 then num else posNos rest\n\n#guard posNos [-1, -2, 1, 2] = 1\n#guard posNos [3, 4, -5] = 3\n#guard posNos [-2, -3, 1] = 1\n", "test_list": ["#guard posNos [-1, -2, 1, 2] = 1", "#guard posNos [3, 4, -5] = 3", "#guard posNos [-2, -3, 1] = 1"]}
{"text": "Write a function to find out the maximum sum such that no two chosen numbers are adjacent for the given rectangular grid of dimension 2 x n.", "task_id": 314, "code": "import Batteries\n\nopen Std\n\ndef List.get2d {α : Type} (l : List (List α)) (y x : Nat) (fallback : α) : α :=\n  (l.getD y []).getD x fallback\n\ndef maxSumRectangularGrid (grid : List (List Nat)) (n : Nat) : Nat := Id.run do\n  let mut incl := max (grid.get2d 0 0 0) (grid.get2d 1 0 0)\n  let mut excl := 0\n  for i in [1 : n] do\n    let excl_new := max excl incl\n    incl := excl + max (grid.get2d 0 i 0) (grid.get2d 1 i 0)\n    excl := excl_new\n  return max excl incl\n\n#guard maxSumRectangularGrid [[1, 4, 5], [2, 0, 0]] 3 = 7\n#guard maxSumRectangularGrid [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]] 5 = 24\n#guard maxSumRectangularGrid [[7, 9, 11, 15, 19], [21, 25, 28, 31, 32]] 5 = 81\n", "test_list": ["#guard maxSumRectangularGrid [[1, 4, 5], [2, 0, 0]] 3 = 7", "#guard maxSumRectangularGrid [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]] 5 = 24", "#guard maxSumRectangularGrid [[7, 9, 11, 15, 19], [21, 25, 28, 31, 32]] 5 = 81"]}
{"text": "Write a python function to find the first maximum length of even word.", "task_id": 315, "code": "import Batteries\n\nopen Std\n\ndef find_Max_Len_Even (s : String) : String := Id.run do\n  let tokens := s.splitOn \" \"\n  let mut maxlen := 0\n  let mut best : String := \"\"\n  let mut found := false\n  for w in tokens do\n    let l := w.length\n    if l % 2 == 0 then\n      if maxlen < l then\n        maxlen := l\n        best := w\n        found := true\n  if found then\n    return best\n  else\n    return \"-1\"\n\n#guard find_Max_Len_Even \"python language\" == \"language\"\n#guard find_Max_Len_Even \"maximum even length\" == \"length\"\n#guard find_Max_Len_Even \"eve\" == \"-1\"\n", "test_list": ["#guard find_Max_Len_Even \"python language\" == \"language\"", "#guard find_Max_Len_Even \"maximum even length\" == \"length\"", "#guard find_Max_Len_Even \"eve\" == \"-1\""]}
{"text": "Write a function to find the index of the last occurrence of a given number in a sorted array.", "task_id": 316, "code": "import Batteries\nopen Std\n\ndef findLastOccurrence (A : List Int) (x : Int) : Int :=\n  let rec loop (l : List Int) (i : Int) (res : Int) : Int :=\n    match l with\n    | [] => res\n    | v :: t =>\n      let res' := if v = x then i else res\n      loop t (i + 1) res'\n  loop A 0 (-1)\n\n#guard findLastOccurrence [2, 5, 5, 5, 6, 6, 8, 9, 9, 9] 5 = 3\n#guard findLastOccurrence [2, 3, 5, 8, 6, 6, 8, 9, 9, 9] 9 = 9\n#guard findLastOccurrence [2, 2, 1, 5, 6, 6, 6, 9, 9, 9] 6 = 6\n", "test_list": ["#guard findLastOccurrence [2, 5, 5, 5, 6, 6, 8, 9, 9, 9] 5 = 3", "#guard findLastOccurrence [2, 3, 5, 8, 6, 6, 8, 9, 9, 9] 9 = 9", "#guard findLastOccurrence [2, 2, 1, 5, 6, 6, 6, 9, 9, 9] 6 = 6"]}
{"text": "Write a function to reflect the modified run-length encoding from a list.", "task_id": 317, "code": "import Batteries\n\nopen Std\n\ninductive Enc (α : Type u) where\n  | one : α → Enc α\n  | many : Nat → α → Enc α\n  deriving Repr, DecidableEq\n\nprivate def packEnc (cnt : Nat) (x : α) : Enc α :=\n  if cnt > 1 then Enc.many cnt x else Enc.one x\n\ndef modifiedEncode {α : Type u} [DecidableEq α] (alist : List α) : List (Enc α) :=\n  match alist with\n  | [] => []\n  | x :: xs =>\n    let rec loop (cur : α) (cnt : Nat) (rest : List α) (acc : List (Enc α)) : List (Enc α) :=\n      match rest with\n      | [] => (packEnc cnt cur :: acc).reverse\n      | y :: ys =>\n        if y = cur then\n          loop cur (cnt + 1) ys acc\n        else\n          loop y 1 ys (packEnc cnt cur :: acc)\n    loop x 1 xs []\n\n#guard modifiedEncode [1,1,2,3,4,4,5,1] = [Enc.many 2 1, Enc.one 2, Enc.one 3, Enc.many 2 4, Enc.one 5, Enc.one 1]\n\n#guard modifiedEncode (\"automatically\".data) = [\n  Enc.one 'a', Enc.one 'u', Enc.one 't', Enc.one 'o', Enc.one 'm', Enc.one 'a',\n  Enc.one 't', Enc.one 'i', Enc.one 'c', Enc.one 'a', Enc.many 2 'l', Enc.one 'y'\n]\n\n#guard modifiedEncode (\"python\".data) = [\n  Enc.one 'p', Enc.one 'y', Enc.one 't', Enc.one 'h', Enc.one 'o', Enc.one 'n'\n]\n", "test_list": ["#guard modifiedEncode [1,1,2,3,4,4,5,1] = [Enc.many 2 1, Enc.one 2, Enc.one 3, Enc.many 2 4, Enc.one 5, Enc.one 1]", "#guard modifiedEncode (\"automatically\".data) = [", "#guard modifiedEncode (\"python\".data) = ["]}
{"text": "Write a python function to find the maximum volume of a cuboid with given sum of sides.", "task_id": 318, "code": "import Batteries\n\nopen Std\n\ndef maxVolume (s : Nat) : Nat := Id.run do\n  let mut maxvalue := 0\n  \n  for i in [0 : s - 1] do\n    \n    for j in [0 : s] do\n      let k := s - i - j\n      let prod := i * j * k\n      if prod > maxvalue then\n        maxvalue := prod\n  return maxvalue\n\n#guard maxVolume 8 = 18\n#guard maxVolume 4 = 2\n#guard maxVolume 1 = 0\n", "test_list": ["#guard maxVolume 8 = 18", "#guard maxVolume 4 = 2", "#guard maxVolume 1 = 0"]}
{"text": "Write a function to find all five characters long word in the given string by using regex.", "task_id": 319, "code": "import Batteries\n\nopen Std\n\ndef find_long_word (text : String) : List String :=\n  text.splitOn \" \" |>.filter (fun w => w.length = 5)\n\n#guard find_long_word \"Please move back to strem\" == [\"strem\"]\n#guard find_long_word \"4K Ultra HD streaming player\" == [\"Ultra\"]\n#guard find_long_word \"Streaming Media Player\" == [\"Media\"]\n", "test_list": ["#guard find_long_word \"Please move back to strem\" == [\"strem\"]", "#guard find_long_word \"4K Ultra HD streaming player\" == [\"Ultra\"]", "#guard find_long_word \"Streaming Media Player\" == [\"Media\"]"]}
{"text": "Write a function to calculate the difference between the squared sum of first n natural numbers and the sum of squared first n natural numbers.", "task_id": 320, "code": "import Batteries\n\nopen Std\n\ndef sumDifference (n : Nat) : Nat := Id.run do\n  let mut sumofsquares := 0\n  let mut squareofsum := 0\n  for num in [1 : n+1] do\n    sumofsquares := sumofsquares + num * num\n    squareofsum := squareofsum + num\n  squareofsum := squareofsum ^ 2\n  return squareofsum - sumofsquares\n\n#guard sumDifference 12 = 5434\n#guard sumDifference 20 = 41230\n#guard sumDifference 54 = 2151270\n", "test_list": ["#guard sumDifference 12 = 5434", "#guard sumDifference 20 = 41230", "#guard sumDifference 54 = 2151270"]}
{"text": "Write a function to find the demlo number for the given number.", "task_id": 321, "code": "import Batteries\n\nopen Std\n\ndef findDemlo (s : String) : String := Id.run do\n  let l := s.length\n  let mut res := \"\"\n  for i in [1 : l+1] do\n    res := res ++ toString i\n  let mut i := l - 1\n  while i > 0 do\n    res := res ++ toString i\n    i := i - 1\n  return res\n\n#guard findDemlo \"111111\" = \"12345654321\"\n#guard findDemlo \"1111\" = \"1234321\"\n#guard findDemlo \"13333122222\" = \"123456789101110987654321\"\n", "test_list": ["#guard findDemlo \"111111\" = \"12345654321\"", "#guard findDemlo \"1111\" = \"1234321\"", "#guard findDemlo \"13333122222\" = \"123456789101110987654321\""]}
{"text": "Write a function to find all index positions of the minimum values in a given list.", "task_id": 322, "code": "import Batteries\n\nopen Std\n\ndef positionMin (list1 : List Nat) : List Nat :=\n  match list1 with\n  | [] => []  \n  | x :: xs =>\n    let minVal := xs.foldl (fun acc y => if y < acc then y else acc) x\n    let rec collect (l : List Nat) (i : Nat) (acc : List Nat) : List Nat :=\n      match l with\n      | [] => acc\n      | y :: ys =>\n        let acc' := if y == minVal then i :: acc else acc\n        collect ys (i + 1) acc'\n    (collect list1 0 []).reverse\n\n#guard positionMin [12,33,23,10,67,89,45,667,23,12,11,10,54] = [3,11]\n#guard positionMin [1,2,2,2,4,4,4,5,5,5,5] = [0]\n#guard positionMin [2,1,5,6,8,3,4,9,10,11,8,12] = [1]\n", "test_list": ["#guard positionMin [12,33,23,10,67,89,45,667,23,12,11,10,54] = [3,11]", "#guard positionMin [1,2,2,2,4,4,4,5,5,5,5] = [0]", "#guard positionMin [2,1,5,6,8,3,4,9,10,11,8,12] = [1]"]}
{"text": "Write a function to re-arrange the given array in alternating positive and negative items.", "task_id": 323, "code": "import Batteries\n\nopen Std\n\ndef right_rotate (arr : List Int) (n : Nat) (out_of_place : Nat) (cur : Nat) : List Int := Id.run do\n  let mut a := arr.toArray\n  let temp := a[cur]!\n  let mut i := cur\n  while i > out_of_place do\n    a := a.set! i (a[i-1]!)\n    i := i - 1\n  a := a.set! out_of_place temp\n  return a.toList\n\ndef re_arrange (arr : List Int) (n : Nat) : List Int := Id.run do\n  \n  let mut a := arr\n  let mut out_of_place : Int := -1\n  for index in [0 : n] do\n    if out_of_place >= 0 then\n      let opNat := Int.toNat out_of_place\n      let ai := a.getD index 0\n      let aop := a.getD opNat 0\n      if ((ai >= 0 && aop < 0) || (ai < 0 && aop >= 0)) then\n        a := right_rotate a n opNat index\n        let diff : Int := (Int.ofNat index) - out_of_place\n        if diff > 2 then\n          out_of_place := out_of_place + 2\n        else\n          out_of_place := -1\n    if out_of_place == -1 then\n      let ai2 := a.getD index 0\n      if ((ai2 >= 0 && index % 2 == 0) || (ai2 < 0 && index % 2 == 1)) then\n        out_of_place := Int.ofNat index\n  return a\n\n#guard re_arrange [-5, -2, 5, 2, 4, 7, 1, 8, 0, -8] 10 = [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]\n#guard re_arrange [1, 2, 3, -4, -1, 4] 6 = [-4, 1, -1, 2, 3, 4]\n#guard re_arrange [4, 7, 9, 77, -4, 5, -3, -9] 8 = [-4, 4, -3, 7, -9, 9, 77, 5]\n", "test_list": ["#guard re_arrange [-5, -2, 5, 2, 4, 7, 1, 8, 0, -8] 10 = [-5, 5, -2, 2, -8, 4, 7, 1, 8, 0]", "#guard re_arrange [1, 2, 3, -4, -1, 4] 6 = [-4, 1, -1, 2, 3, 4]", "#guard re_arrange [4, 7, 9, 77, -4, 5, -3, -9] 8 = [-4, 4, -3, 7, -9, 9, 77, 5]"]}
{"text": "Write a function to extract the sum of alternate chains of tuples.", "task_id": 324, "code": "import Batteries\n\nopen Std\n\ndef sum_of_alternates (test_tuple : List Nat) : Nat × Nat := Id.run do\n  let mut sum1 := 0\n  let mut sum2 := 0\n  let mut idx := 0\n  for ele in test_tuple do\n    if idx % 2 == 1 then\n      sum1 := sum1 + ele\n    else\n      sum2 := sum2 + ele\n    idx := idx + 1\n  return (sum1, sum2)\n\n#guard sum_of_alternates [5, 6, 3, 6, 10, 34] = (46, 18)\n#guard sum_of_alternates [1, 2, 3, 4, 5] = (6, 9)\n#guard sum_of_alternates [6, 7, 8, 9, 4, 5] = (21, 18)\n", "test_list": ["#guard sum_of_alternates [5, 6, 3, 6, 10, 34] = (46, 18)", "#guard sum_of_alternates [1, 2, 3, 4, 5] = (6, 9)", "#guard sum_of_alternates [6, 7, 8, 9, 4, 5] = (21, 18)"]}
{"text": "Write a python function to find the minimum number of squares whose sum is equal to a given number.", "task_id": 325, "code": "import Batteries\n\nopen Std\n\npartial def get_Min_Squares (n : Nat) : Nat :=\n  if n ≤ 3 then n else Id.run do\n    let mut res := n\n    for x in [1 : n + 1] do\n      let temp := x * x\n      if temp > n then\n        break\n      else\n        res := Nat.min res (1 + get_Min_Squares (n - temp))\n    return res\n\n#guard get_Min_Squares 6 = 3\n#guard get_Min_Squares 2 = 2\n#guard get_Min_Squares 4 = 1\n", "test_list": ["#guard get_Min_Squares 6 = 3", "#guard get_Min_Squares 2 = 2", "#guard get_Min_Squares 4 = 1"]}
{"text": "Write a function to get the word with most number of occurrences in the given strings list.", "task_id": 326, "code": "import Batteries\nopen Std\n\nprivate def incrKey (w : String) (xs : List (String × Nat)) : (List (String × Nat)) × Bool :=\n  match xs with\n  | [] => ([(w, 1)], false)\n  | (k2, v) :: t =>\n    if k2 == w then\n      ((k2, v + 1) :: t, true)\n    else\n      let (t', found) := incrKey w t\n      ((k2, v) :: t', found)\n\ndef mostOccurrences (testList : List String) : String := Id.run do\n  let mut temp : List (String × Nat) := []\n  for sub in testList do\n    let words := sub.splitOn \" \"\n    for wrd in words do\n      if wrd == \"\" then\n        continue\n      let (newTemp, _) := incrKey wrd temp\n      temp := newTemp\n  match temp with\n  | [] => return \"\"\n  | (k0, v0) :: t =>\n    let mut bestKey := k0\n    let mut bestVal := v0\n    for (k, v) in t do\n      if v > bestVal then\n        bestVal := v\n        bestKey := k\n    return bestKey\n\n#guard mostOccurrences [\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] == \"UTS\"\n#guard mostOccurrences [\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] == \"year\"\n#guard mostOccurrences [\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] == \"can\"\n", "test_list": ["#guard mostOccurrences [\"UTS is best for RTF\", \"RTF love UTS\", \"UTS is best\"] == \"UTS\"", "#guard mostOccurrences [\"Its been a great year\", \"this year is so worse\", \"this year is okay\"] == \"year\"", "#guard mostOccurrences [\"Families can be reunited\", \"people can be reunited\", \"Tasks can be achieved \"] == \"can\""]}
{"text": "Write a function to print check if the triangle is isosceles or not.", "task_id": 327, "code": "import Batteries\n\nopen Std\n\ndef checkIsosceles (x y z : Nat) : Bool :=\n  (x == y) || (y == z) || (z == x)\n\n#guard checkIsosceles 6 8 12 == false\n#guard checkIsosceles 6 6 12 == true\n#guard checkIsosceles 6 16 20 == false\n", "test_list": ["#guard checkIsosceles 6 8 12 == false", "#guard checkIsosceles 6 6 12 == true", "#guard checkIsosceles 6 16 20 == false"]}
{"text": "Write a function to rotate a given list by specified number of items to the left direction.", "task_id": 328, "code": "import Batteries\n\nopen Std\n\ndef rotateLeft (list1 : List Nat) (m n : Nat) : List Nat :=\n  list1.drop m ++ list1.take n\n\n#guard rotateLeft [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 3 4 = [4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]\n#guard rotateLeft [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2 2 = [3, 4, 5, 6, 7, 8, 9, 10, 1, 2]\n#guard rotateLeft [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5 2 = [6, 7, 8, 9, 10, 1, 2]\n", "test_list": ["#guard rotateLeft [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 3 4 = [4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4]", "#guard rotateLeft [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2 2 = [3, 4, 5, 6, 7, 8, 9, 10, 1, 2]", "#guard rotateLeft [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5 2 = [6, 7, 8, 9, 10, 1, 2]"]}
{"text": "Write a python function to count negative numbers in a list.", "task_id": 329, "code": "import Batteries\n\nopen Std\n\ndef negCount (list : List Int) : Nat := Id.run do\n  let mut neg_count := 0\n  for num in list do\n    if num ≤ 0 then\n      neg_count := neg_count + 1\n  return neg_count\n\n#guard negCount [-1, -2, 3, -4, -5] == 4\n#guard negCount [1, 2, 3] == 0\n#guard negCount [1, 2, -3, -10, 20] == 2\n", "test_list": ["#guard negCount [-1, -2, 3, -4, -5] == 4", "#guard negCount [1, 2, 3] == 0", "#guard negCount [1, 2, -3, -10, 20] == 2"]}
{"text": "Write a function to find all three, four, five characters long words in the given string by using regex.", "task_id": 330, "code": "import Batteries\nopen Std\n\ndef findChar (text : String) : List String :=\n  (text.splitOn \" \").filter (fun w => let n := w.length; n >= 3 && n <= 5)\n\n#guard findChar \"For the four consumer complaints contact manager AKR reddy\" == [\"For\", \"the\", \"four\", \"AKR\", \"reddy\"]\n#guard findChar \"Certain service are subject to change MSR\" == [\"are\", \"MSR\"]\n#guard findChar \"Third party legal desclaimers\" == [\"Third\", \"party\", \"legal\"]\n", "test_list": ["#guard findChar \"For the four consumer complaints contact manager AKR reddy\" == [\"For\", \"the\", \"four\", \"AKR\", \"reddy\"]", "#guard findChar \"Certain service are subject to change MSR\" == [\"are\", \"MSR\"]", "#guard findChar \"Third party legal desclaimers\" == [\"Third\", \"party\", \"legal\"]"]}
{"text": "Write a python function to count unset bits of a given number.", "task_id": 331, "code": "import Batteries\n\nopen Std\n\ndef countUnsetBits (n : Nat) : Nat := Id.run do\n  let mut count := 0\n  let mut x := 1\n  while x < n + 1 do\n    if (x &&& n) == 0 then\n      count := count + 1\n    x := x <<< 1\n  return count\n\n#guard countUnsetBits 2 = 1\n#guard countUnsetBits 4 = 2\n#guard countUnsetBits 6 = 1\n", "test_list": ["#guard countUnsetBits 2 = 1", "#guard countUnsetBits 4 = 2", "#guard countUnsetBits 6 = 1"]}
{"text": "Write a function to count character frequency of a given string.", "task_id": 332, "code": "import Batteries\nopen Std\n\ndef charFrequency (str1 : String) : Std.HashMap Char Nat := Id.run do\n  let mut dict : Std.HashMap Char Nat := Std.HashMap.emptyWithCapacity str1.length\n  for c in str1.data do\n    let old := (dict[c]?).getD 0\n    dict := dict.insert c (old + 1)\n  return dict\n\ndef entriesCharNat (m : Std.HashMap Char Nat) : List (Char × Nat) :=\n  m.fold (init := []) (fun acc k v => (k, v) :: acc)\n\ndef hashMapOfList (xs : List (Char × Nat)) : Std.HashMap Char Nat := Id.run do\n  let mut m : Std.HashMap Char Nat := Std.HashMap.emptyWithCapacity xs.length\n  for (k, v) in xs do\n    m := m.insert k v\n  return m\n\ndef hashMapEq (m1 m2 : Std.HashMap Char Nat) : Bool := Id.run do\n  if m1.size != m2.size then return false\n  for (k, v) in entriesCharNat m2 do\n    match m1[k]? with\n    | some v' => if v' != v then return false\n    | none => return false\n  return true\n\n#guard hashMapEq (charFrequency \"python\") (hashMapOfList [('p', 1), ('y', 1), ('t', 1), ('h', 1), ('o', 1), ('n', 1)])\n#guard hashMapEq (charFrequency \"program\") (hashMapOfList [('p', 1), ('r', 2), ('o', 1), ('g', 1), ('a', 1), ('m', 1)])\n#guard hashMapEq (charFrequency \"language\") (hashMapOfList [('l', 1), ('a', 2), ('n', 1), ('g', 2), ('u', 1), ('e', 1)])\n", "test_list": ["#guard hashMapEq (charFrequency \"python\") (hashMapOfList [('p', 1), ('y', 1), ('t', 1), ('h', 1), ('o', 1), ('n', 1)])", "#guard hashMapEq (charFrequency \"program\") (hashMapOfList [('p', 1), ('r', 2), ('o', 1), ('g', 1), ('a', 1), ('m', 1)])", "#guard hashMapEq (charFrequency \"language\") (hashMapOfList [('l', 1), ('a', 2), ('n', 1), ('g', 2), ('u', 1), ('e', 1)])"]}
{"text": "Write a python function to check whether the triangle is valid or not if sides are given.", "task_id": 334, "code": "import Batteries\n\nopen Std\n\ndef check_Validity (a b c : Nat) : Bool :=\n  if a + b <= c then false\n  else if a + c <= b then false\n  else if b + c <= a then false\n  else true\n\n#guard check_Validity 1 2 3 == false\n#guard check_Validity 2 3 5 == false\n#guard check_Validity 7 10 5 == true\n", "test_list": ["#guard check_Validity 1 2 3 == false", "#guard check_Validity 2 3 5 == false", "#guard check_Validity 7 10 5 == true"]}
{"text": "Write a function to find the sum of arithmetic progression.", "task_id": 335, "code": "import Batteries\n\nopen Std\n\ndef apSum (a n d : Nat) : Nat :=\n  (n * (2 * a + (n - 1) * d)) / 2\n\n#guard apSum 1 5 2 = 25\n#guard apSum 2 6 4 = 72\n#guard apSum 1 4 5 = 34\n", "test_list": ["#guard apSum 1 5 2 = 25", "#guard apSum 2 6 4 = 72", "#guard apSum 1 4 5 = 34"]}
{"text": "Write a function to check whether the given month name contains 28 days or not.", "task_id": 336, "code": "import Batteries\n\nopen Std\n\ndef check_monthnum (monthname1 : String) : Bool :=\n  if monthname1 == \"February\" then true else false\n\n#guard check_monthnum \"February\" == true\n#guard check_monthnum \"January\" == false\n#guard check_monthnum \"March\" == false\n", "test_list": ["#guard check_monthnum \"February\" == true", "#guard check_monthnum \"January\" == false", "#guard check_monthnum \"March\" == false"]}
{"text": "Write a python function to count the number of substrings with same first and last characters.", "task_id": 338, "code": "import Batteries\n\nopen Std\n\ndef check_Equality (s : String) : Bool :=\n  let n := s.length\n  if n = 0 then\n    false\n  else\n    let first := s.take 1\n    let last := s.drop (n - 1)\n    first == last\n\ndef count_Substring_With_Equal_Ends (s : String) : Nat := Id.run do\n  let n := s.length\n  let mut result := 0\n  for i in [0 : n] do\n    for j in [1 : n - i + 1] do\n      let sub := (s.drop i).take j\n      if check_Equality sub then\n        result := result + 1\n  return result\n\n#guard count_Substring_With_Equal_Ends \"aba\" == 4\n#guard count_Substring_With_Equal_Ends \"abcab\" == 7\n#guard count_Substring_With_Equal_Ends \"abc\" == 3\n", "test_list": ["#guard count_Substring_With_Equal_Ends \"aba\" == 4", "#guard count_Substring_With_Equal_Ends \"abcab\" == 7", "#guard count_Substring_With_Equal_Ends \"abc\" == 3"]}
{"text": "Write a python function to find the maximum occuring divisor in an interval.", "task_id": 339, "code": "import Batteries\n\nopen Std\n\ndef findDivisor (x y : Nat) : Nat :=\n  if x == y then y else 2\n\n#guard findDivisor 2 2 = 2\n#guard findDivisor 2 5 = 2\n#guard findDivisor 5 10 = 2\n", "test_list": ["#guard findDivisor 2 2 = 2", "#guard findDivisor 2 5 = 2", "#guard findDivisor 5 10 = 2"]}
{"text": "Write a python function to find the sum of the three lowest positive numbers from a given list of numbers.", "task_id": 340, "code": "import Batteries\n\nopen Std\n\ndef insertAsc (x : Nat) (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => [x]\n  | y :: ys => if x ≤ y then x :: xs else y :: insertAsc x ys\n\ndef insertionSortAsc (xs : List Nat) : List Nat :=\n  xs.foldl (fun acc x => insertAsc x acc) []\n\ndef sumThreeSmallestNums (lst : List Nat) : Nat :=\n  let filtered := lst.filter (fun x => x > 0)\n  let sorted := insertionSortAsc filtered\n  (sorted.take 3).foldl (· + ·) 0\n\n#guard sumThreeSmallestNums [10,20,30,40,50,60,7] = 37\n#guard sumThreeSmallestNums [1,2,3,4,5] = 6\n#guard sumThreeSmallestNums [0,1,2,3,4,5] = 6\n", "test_list": ["#guard sumThreeSmallestNums [10,20,30,40,50,60,7] = 37", "#guard sumThreeSmallestNums [1,2,3,4,5] = 6", "#guard sumThreeSmallestNums [0,1,2,3,4,5] = 6"]}
{"text": "Write a function to convert the given set into ordered tuples.", "task_id": 341, "code": "import Batteries\n\nopen Std\n\ndef insertSortedNat (x : Nat) (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => [x]\n  | y :: ys => if x ≤ y then x :: xs else y :: insertSortedNat x ys\n\ndef isortNat (xs : List Nat) : List Nat :=\n  xs.foldl (fun acc x => insertSortedNat x acc) []\n\ndef setToTuple (s : HashSet Nat) : List Nat := Id.run do\n  let mut acc : List Nat := []\n  for x in s do\n    acc := x :: acc\n  return isortNat acc\n\n#guard setToTuple (HashSet.ofList [1, 2, 3, 4, 5]) = [1, 2, 3, 4, 5]\n#guard setToTuple (HashSet.ofList [6, 7, 8, 9, 10, 11]) = [6, 7, 8, 9, 10, 11]\n#guard setToTuple (HashSet.ofList [12, 13, 14, 15, 16]) = [12, 13, 14, 15, 16]\n", "test_list": ["#guard setToTuple (HashSet.ofList [1, 2, 3, 4, 5]) = [1, 2, 3, 4, 5]", "#guard setToTuple (HashSet.ofList [6, 7, 8, 9, 10, 11]) = [6, 7, 8, 9, 10, 11]", "#guard setToTuple (HashSet.ofList [12, 13, 14, 15, 16]) = [12, 13, 14, 15, 16]"]}
{"text": "Write a function to find the smallest range that includes at-least one element from each of the given arrays.", "task_id": 342, "code": "import Batteries\n\nopen Std\n\nstructure Node where\n  value : Nat\n  listNum : Nat\n  index : Nat\n  deriving Repr, BEq\n\ndef minNode (pq : List Node) : Option Node :=\n  match pq with\n  | [] => none\n  | x :: xs => some <| xs.foldl (fun acc y => if y.value < acc.value then y else acc) x\n\ndef removeOne [BEq α] (xs : List α) (x : α) : List α :=\n  match xs with\n  | [] => []\n  | z :: zs => if z == x then zs else z :: removeOne zs x\n\ndef extractMin (pq : List Node) : Option (Node × List Node) := do\n  let some m := minNode pq | none\n  let rest := removeOne pq m\n  some (m, rest)\n\ndef findMinimumRange (lists : List (List Nat)) : Nat × Nat := Id.run do\n  let mut pq : List Node := []\n  let mut high : Nat := 0\n  let mut first := true\n  for i in [0 : lists.length] do\n    let firstVal := (lists.getD i []).getD 0 0\n    pq := { value := firstVal, listNum := i, index := 0 } :: pq\n    if first then\n      high := firstVal\n      first := false\n    else\n      if firstVal > high then high := firstVal\n  let mut pLow : Nat := 0\n  let mut pHigh : Nat := 0\n  let mut hasP := false\n  let loopsBound := lists.foldl (fun acc sub => acc + sub.length) 0\n  for _ in [: loopsBound + 1] do\n    match extractMin pq with\n    | none => break\n    | some (top, rest) =>\n      let low := top.value\n      let i := top.listNum\n      let j := top.index\n      if !hasP || high - low < pHigh - pLow then\n        pLow := low\n        pHigh := high\n        hasP := true\n      let sub := lists.getD i []\n      if j == sub.length - 1 then\n        return (pLow, pHigh)\n      let nextVal := sub.getD (j+1) 0\n      pq := { value := nextVal, listNum := i, index := j+1 } :: rest\n      if nextVal > high then high := nextVal\n  return (pLow, pHigh)\n\n#guard findMinimumRange [[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]] = (4, 6)\n#guard findMinimumRange [[2, 3, 4, 8, 10, 15], [1, 5, 12], [7, 8, 15, 16], [3, 6]] = (4, 7)\n#guard findMinimumRange [[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]] = (5, 7)\n", "test_list": ["#guard findMinimumRange [[3, 6, 8, 10, 15], [1, 5, 12], [4, 8, 15, 16], [2, 6]] = (4, 6)", "#guard findMinimumRange [[2, 3, 4, 8, 10, 15], [1, 5, 12], [7, 8, 15, 16], [3, 6]] = (4, 7)", "#guard findMinimumRange [[4, 7, 9, 11, 16], [2, 6, 13], [5, 9, 16, 17], [3, 7]] = (5, 7)"]}
{"text": "Write a function to calculate the number of digits and letters in a string.", "task_id": 343, "code": "import Batteries\n\nopen Std\n\ndef digLet (s : String) : Nat × Nat :=\n  let rec loop (cs : List Char) (d l : Nat) : Nat × Nat :=\n    match cs with\n    | [] => (l, d)\n    | c :: cs' =>\n      if c.isDigit then\n        loop cs' (d+1) l\n      else if c.isAlpha then\n        loop cs' d (l+1)\n      else\n        loop cs' d l\n  loop s.data 0 0\n\n#guard digLet \"python\" = (6, 0)\n#guard digLet \"program\" = (7, 0)\n#guard digLet \"python3.0\" = (6, 2)\n", "test_list": ["#guard digLet \"python\" = (6, 0)", "#guard digLet \"program\" = (7, 0)", "#guard digLet \"python3.0\" = (6, 2)"]}
{"text": "Write a python function to find number of elements with odd factors in a given range.", "task_id": 344, "code": "import Batteries\n\nopen Std\n\ndef countOddSquares (n m : Nat) : Nat :=\n  Nat.sqrt m - Nat.sqrt (n - 1)\n\n#guard countOddSquares 5 100 = 8\n#guard countOddSquares 8 65 = 6\n#guard countOddSquares 2 5 = 1\n", "test_list": ["#guard countOddSquares 5 100 = 8", "#guard countOddSquares 8 65 = 6", "#guard countOddSquares 2 5 = 1"]}
{"text": "Write a function to find the difference between two consecutive numbers in a given list.", "task_id": 345, "code": "import Batteries\n\nopen Std\n\ndef diffConsecutivenums (nums : List Int) : List Int :=\n  match nums with\n  | a :: b :: t => (b - a) :: diffConsecutivenums (b :: t)\n  | _ => []\n\n#guard diffConsecutivenums [1, 1, 3, 4, 4, 5, 6, 7] == [0, 2, 1, 0, 1, 1, 1]\n#guard diffConsecutivenums [4, 5, 8, 9, 6, 10] == [1, 3, 1, -3, 4]\n#guard diffConsecutivenums [0, 1, 2, 3, 4, 4, 4, 4, 5, 7] == [1, 1, 1, 1, 0, 0, 0, 1, 2]\n", "test_list": ["#guard diffConsecutivenums [1, 1, 3, 4, 4, 5, 6, 7] == [0, 2, 1, 0, 1, 1, 1]", "#guard diffConsecutivenums [4, 5, 8, 9, 6, 10] == [1, 3, 1, -3, 4]", "#guard diffConsecutivenums [0, 1, 2, 3, 4, 4, 4, 4, 5, 7] == [1, 1, 1, 1, 0, 0, 0, 1, 2]"]}
{"text": "Write a function to find entringer number e(n, k).", "task_id": 346, "code": "import Batteries\n\nopen Std\n\npartial def zigzag (n k : Nat) : Nat :=\n  if n == 0 && k == 0 then\n    1\n  else if k == 0 then\n    0\n  else\n    zigzag n (k - 1) + zigzag (n - 1) (n - k)\n\n#guard zigzag 4 3 = 5\n#guard zigzag 4 2 = 4\n#guard zigzag 3 1 = 1\n", "test_list": ["#guard zigzag 4 3 = 5", "#guard zigzag 4 2 = 4", "#guard zigzag 3 1 = 1"]}
{"text": "Write a python function to count the number of squares in a rectangle.", "task_id": 347, "code": "import Batteries\n\nopen Std\n\ndef count_Squares (m n : Nat) : Nat :=\n  let m' := if n < m then n else m\n  let n' := if n < m then m else n\n  (n' * (n' + 1) * (3 * m' - n' + 1)) / 6\n\n#guard count_Squares 4 3 = 20\n#guard count_Squares 1 2 = 2\n#guard count_Squares 2 2 = 5\n", "test_list": ["#guard count_Squares 4 3 = 20", "#guard count_Squares 1 2 = 2", "#guard count_Squares 2 2 = 5"]}
{"text": "Write a function to count sequences of given length having non-negative prefix sums that can be generated by given values.", "task_id": 348, "code": "import Batteries\n\nopen Std\n\ndef binCoff (n r : Nat) : Nat := Id.run do\n  let mut val := 1\n  let mut r' := r\n  if r' > n - r' then\n    r' := n - r'\n  for i in [: r'] do\n    val := val * (n - i)\n    val := val / (i + 1)\n  return val\n\ndef findWays (M : Nat) : Nat :=\n  let n := M / 2\n  let a := binCoff (2 * n) n\n  let b := a / (n + 1)\n  b\n\n#guard findWays 4 = 2\n#guard findWays 6 = 5\n#guard findWays 8 = 14\n", "test_list": ["#guard findWays 4 = 2", "#guard findWays 6 = 5", "#guard findWays 8 = 14"]}
{"text": "Write a python function to check whether the given string is a binary string or not.", "task_id": 349, "code": "import Batteries\n\nopen Std\n\ndef check (string : String) : String :=\n  let p : HashSet Char := HashSet.ofList string.data\n  let s01 : HashSet Char := HashSet.ofList ['0', '1']\n  if p == s01 || p == HashSet.ofList ['0'] || p == HashSet.ofList ['1'] then\n    \"Yes\"\n  else\n    \"No\"\n\n#guard check \"01010101010\" = \"Yes\"\n#guard check \"name0\" = \"No\"\n#guard check \"101\" = \"Yes\"\n", "test_list": ["#guard check \"01010101010\" = \"Yes\"", "#guard check \"name0\" = \"No\"", "#guard check \"101\" = \"Yes\""]}
{"text": "Write a python function to minimize the length of the string by removing occurrence of only one character.", "task_id": 350, "code": "import Batteries\n\nopen Std\n\ndef minimum_Length (s : String) : Nat := Id.run do\n  let n := s.length\n  let mut maxOcc := 0\n  let mut arr : Array Nat := Array.replicate 26 0\n  for c in s.data do\n    let cn := c.toNat\n    let an := ('a' : Char).toNat\n    let zn := ('z' : Char).toNat\n    if an ≤ cn && cn ≤ zn then\n      let i := cn - an\n      arr := arr.set! i (arr[i]! + 1)\n    else\n      ()\n  for i in [0:26] do\n    let v := arr[i]!\n    if v > maxOcc then\n      maxOcc := v\n  return n - maxOcc\n\n#guard minimum_Length \"mnm\" = 1\n#guard minimum_Length \"abcda\" = 3\n#guard minimum_Length \"abcb\" = 2\n", "test_list": ["#guard minimum_Length \"mnm\" = 1", "#guard minimum_Length \"abcda\" = 3", "#guard minimum_Length \"abcb\" = 2"]}
{"text": "Write a python function to find the first element occurring k times in a given array.", "task_id": 351, "code": "import Batteries\nopen Std\n\nprivate def assocFind (m : List (Int × Nat)) (x : Int) : Nat :=\n  let rec go (m : List (Int × Nat)) : Nat :=\n    match m with\n    | [] => 0\n    | (y, c) :: ys =>\n      if y = x then c else go ys\n  go m\n\nprivate def assocInc (m : List (Int × Nat)) (x : Int) : List (Int × Nat) :=\n  let rec go (m : List (Int × Nat)) : List (Int × Nat) :=\n    match m with\n    | [] => [(x, 1)]\n    | (y, c) :: ys =>\n      if y = x then (y, c + 1) :: ys else (y, c) :: go ys\n  go m\n\ndef firstElement (arr : List Int) (n : Nat) (k : Nat) : Int :=\n  let xs := arr.take n\n  let countMap := xs.foldl (fun m x => assocInc m x) ([] : List (Int × Nat))\n  let rec go (ys : List Int) : Int :=\n    match ys with\n    | [] => -1\n    | x :: ys' =>\n      let c := assocFind countMap x\n      if c = k then x else go ys'\n  go xs\n\n#guard firstElement [0,1,2,3,4,5] 6 1 = 0\n#guard firstElement [1,2,1,3,4] 5 2 = 1\n#guard firstElement [2,3,4,3,5,7,1,2,3,5] 10 2 = 2\n", "test_list": ["#guard firstElement [0,1,2,3,4,5] 6 1 = 0", "#guard firstElement [1,2,1,3,4] 5 2 = 1", "#guard firstElement [2,3,4,3,5,7,1,2,3,5] 10 2 = 2"]}
{"text": "Write a python function to check whether all the characters in a given string are unique.", "task_id": 352, "code": "import Batteries\nopen Std\n\nprivate def listNth? {α} : List α → Nat → Option α\n| [], _ => none\n| x :: _, 0 => some x\n| _ :: xs, n+1 => listNth? xs n\n\ndef unique_Characters (str : String) : Bool := Id.run do\n  let chars := str.data\n  let n := chars.length\n  for i in [0 : n] do\n    for j in [i+1 : n] do\n      match listNth? chars i, listNth? chars j with\n      | some c1, some c2 =>\n        if c1 == c2 then\n          return false\n      | _, _ => pure ()\n  return true\n\n#guard unique_Characters \"aba\" == false\n#guard unique_Characters \"abc\" == true\n#guard unique_Characters \"abab\" == false\n", "test_list": ["#guard unique_Characters \"aba\" == false", "#guard unique_Characters \"abc\" == true", "#guard unique_Characters \"abab\" == false"]}
{"text": "Write a function to remove a specified column from a given nested list.", "task_id": 353, "code": "import Batteries\n\nopen Std\n\ndef removeAtIdx {α} (xs : List α) (n : Nat) : List α :=\n  let rec go (ys : List α) (k : Nat) : (List α × Bool) :=\n    match ys, k with\n    | [], _ => ([], false)\n    | _::ys, 0 => (ys, true)\n    | y::ys, k+1 =>\n      let (rest, done) := go ys k\n      if done then (y :: rest, true) else (y :: rest, false)\n  let (res, done) := go xs n\n  if done then res else xs\n\ndef removeColumn (list1 : List (List Int)) (n : Nat) : List (List Int) :=\n  list1.map (fun row => removeAtIdx row n)\n\n#guard removeColumn [[1, 2, 3], [2, 4, 5], [1, 1, 1]] 0 = [[2, 3], [4, 5], [1, 1]]\n#guard removeColumn [[1, 2, 3], [-2, 4, -5], [1, -1, 1]] 2 = [[1, 2], [-2, 4], [1, -1]]\n#guard removeColumn [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] 0 = [[3], [7], [3], [15, 17], [7], [11]]\n", "test_list": ["#guard removeColumn [[1, 2, 3], [2, 4, 5], [1, 1, 1]] 0 = [[2, 3], [4, 5], [1, 1]]", "#guard removeColumn [[1, 2, 3], [-2, 4, -5], [1, -1, 1]] 2 = [[1, 2], [-2, 4], [1, -1]]", "#guard removeColumn [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] 0 = [[3], [7], [3], [15, 17], [7], [11]]"]}
{"text": "Write a function to find t-nth term of arithemetic progression.", "task_id": 354, "code": "import Batteries\n\nopen Std\n\ndef tnAp (a n d : Nat) : Nat :=\n  a + (n - 1) * d\n\n#guard tnAp 1 5 2 = 9\n#guard tnAp 2 6 4 = 22\n#guard tnAp 1 4 5 = 16\n", "test_list": ["#guard tnAp 1 5 2 = 9", "#guard tnAp 2 6 4 = 22", "#guard tnAp 1 4 5 = 16"]}
{"text": "Write a python function to count the number of rectangles in a circle of radius r.", "task_id": 355, "code": "import Batteries\n\nopen Std\n\ndef countRectangles (radius : Nat) : Nat := Id.run do\n  let mut rectangles := 0\n  let diameter := 2 * radius\n  let diameterSquare := diameter * diameter\n  for a in [1 : 2 * radius] do\n    for b in [1 : 2 * radius] do\n      let diagnalLengthSquare := a * a + b * b\n      if diagnalLengthSquare <= diameterSquare then\n        rectangles := rectangles + 1\n  return rectangles\n\n#guard countRectangles 2 = 8\n#guard countRectangles 1 = 1\n#guard countRectangles 0 = 0\n", "test_list": ["#guard countRectangles 2 = 8", "#guard countRectangles 1 = 1", "#guard countRectangles 0 = 0"]}
{"text": "Write a function to find the third angle of a triangle using two angles.", "task_id": 356, "code": "import Batteries\n\nopen Std\n\ndef findAngle (a b : Nat) : Nat :=\n  let c := 180 - (a + b)\n  c\n\n#guard findAngle 47 89 = 44\n#guard findAngle 45 95 = 40\n#guard findAngle 50 40 = 90\n", "test_list": ["#guard findAngle 47 89 = 44", "#guard findAngle 45 95 = 40", "#guard findAngle 50 40 = 90"]}
{"text": "Write a function to find the maximum element of all the given tuple records.", "task_id": 357, "code": "import Batteries\n\nopen Std\n\ndef findMax (test_list : List (List Nat)) : Nat := Id.run do\n  let mut res : Nat := 0\n  for i in test_list do\n    for j in i do\n      if j > res then\n        res := j\n  return res\n\n#guard findMax [[2, 4], [6, 7], [5, 1], [6, 10], [8, 7]] = 10\n#guard findMax [[3, 5], [7, 8], [6, 2], [7, 11], [9, 8]] = 11\n#guard findMax [[4, 6], [8, 9], [7, 3], [8, 12], [10, 9]] = 12\n", "test_list": ["#guard findMax [[2, 4], [6, 7], [5, 1], [6, 10], [8, 7]] = 10", "#guard findMax [[3, 5], [7, 8], [6, 2], [7, 11], [9, 8]] = 11", "#guard findMax [[4, 6], [8, 9], [7, 3], [8, 12], [10, 9]] = 12"]}
{"text": "Write a function to find modulo division of two lists using map and lambda function.", "task_id": 358, "code": "import Batteries\n\nopen Std\n\ndef moddiv_list (nums1 nums2 : List Nat) : List Nat :=\n  (List.zip nums1 nums2).map (fun (x, y) => x % y)\n\n#guard moddiv_list [4,5,6] [1, 2, 3] == [0, 1, 0]\n#guard moddiv_list [3,2] [1,4] == [0, 2]\n#guard moddiv_list [90,120] [50,70] == [40, 50]\n", "test_list": ["#guard moddiv_list [4,5,6] [1, 2, 3] == [0, 1, 0]", "#guard moddiv_list [3,2] [1,4] == [0, 2]", "#guard moddiv_list [90,120] [50,70] == [40, 50]"]}
{"text": "Write a python function to check whether one root of the quadratic equation is twice of the other or not.", "task_id": 359, "code": "import Batteries\n\nopen Std\n\ndef Check_Solution (a b c : Int) : String :=\n  if (2 * b * b) == (9 * a * c) then\n    \"Yes\"\n  else\n    \"No\"\n\n#guard Check_Solution 1 3 2 == \"Yes\"\n#guard Check_Solution 1 2 3 == \"No\"\n#guard Check_Solution 1 (-5) 6 == \"No\"\n", "test_list": ["#guard Check_Solution 1 3 2 == \"Yes\"", "#guard Check_Solution 1 2 3 == \"No\"", "#guard Check_Solution 1 (-5) 6 == \"No\""]}
{"text": "Write a function to find the n’th carol number.", "task_id": 360, "code": "import Batteries\n\nopen Std\n\ndef getCarol (n : Nat) : Nat :=\n  let result := (2 ^ n) - 1\n  result * result - 2\n\n#guard getCarol 2 = 7\n#guard getCarol 4 = 223\n#guard getCarol 5 = 959\n", "test_list": ["#guard getCarol 2 = 7", "#guard getCarol 4 = 223", "#guard getCarol 5 = 959"]}
{"text": "Write a function to remove empty lists from a given list of lists.", "task_id": 361, "code": "import Batteries\n\nopen Std\n\ninductive PyVal where\n  | str (s : String)\n  | list (xs : List Nat)\n  deriving Repr, BEq, DecidableEq\n\ndef truthy : PyVal → Bool\n  | .str s => s.length != 0\n  | .list xs => !xs.isEmpty\n\ndef removeEmpty (list1 : List PyVal) : List PyVal :=\n  list1.filter truthy\n\n#guard removeEmpty [PyVal.list [], PyVal.list [], PyVal.list [], PyVal.str \"Red\", PyVal.str \"Green\", PyVal.list [1,2], PyVal.str \"Blue\", PyVal.list [], PyVal.list []] = [PyVal.str \"Red\", PyVal.str \"Green\", PyVal.list [1, 2], PyVal.str \"Blue\"]\n#guard removeEmpty [PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list [], PyVal.str \"Green\", PyVal.list [1,2], PyVal.str \"Blue\", PyVal.list [], PyVal.list []] = [PyVal.str \"Green\", PyVal.list [1, 2], PyVal.str \"Blue\"]\n#guard removeEmpty [PyVal.list [], PyVal.list [], PyVal.list [], PyVal.str \"Python\", PyVal.list [], PyVal.list [], PyVal.str \"programming\", PyVal.str \"language\", PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list []] = [PyVal.str \"Python\", PyVal.str \"programming\", PyVal.str \"language\"]\n", "test_list": ["#guard removeEmpty [PyVal.list [], PyVal.list [], PyVal.list [], PyVal.str \"Red\", PyVal.str \"Green\", PyVal.list [1,2], PyVal.str \"Blue\", PyVal.list [], PyVal.list []] = [PyVal.str \"Red\", PyVal.str \"Green\", PyVal.list [1, 2], PyVal.str \"Blue\"]", "#guard removeEmpty [PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list [], PyVal.str \"Green\", PyVal.list [1,2], PyVal.str \"Blue\", PyVal.list [], PyVal.list []] = [PyVal.str \"Green\", PyVal.list [1, 2], PyVal.str \"Blue\"]", "#guard removeEmpty [PyVal.list [], PyVal.list [], PyVal.list [], PyVal.str \"Python\", PyVal.list [], PyVal.list [], PyVal.str \"programming\", PyVal.str \"language\", PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list [], PyVal.list []] = [PyVal.str \"Python\", PyVal.str \"programming\", PyVal.str \"language\"]"]}
{"text": "Write a python function to find the item with maximum occurrences in a given list.", "task_id": 362, "code": "import Batteries\n\nopen Std\n\ndef maxOccurrences (nums : List Nat) : Nat := Id.run do\n  \n  let mut maxVal : Nat := 0\n  let mut result : Nat := match nums with\n    | [] => 0\n    | x :: _ => x\n  for i in nums do\n    let occu := nums.foldl (fun acc x => if x == i then acc + 1 else acc) 0\n    if occu > maxVal then\n      maxVal := occu\n      result := i\n  return result\n\n#guard maxOccurrences [1,2,3,1,2,3,12,4,2] = 2\n#guard maxOccurrences [1,2,6,7,0,1,0,1,0] = 1\n#guard maxOccurrences [1,2,3,1,2,4,1] = 1\n", "test_list": ["#guard maxOccurrences [1,2,3,1,2,3,12,4,2] = 2", "#guard maxOccurrences [1,2,6,7,0,1,0,1,0] = 1", "#guard maxOccurrences [1,2,3,1,2,4,1] = 1"]}
{"text": "Write a function to add the k elements to each element in the tuple.", "task_id": 363, "code": "import Batteries\n\nopen Std\n\ndef add_K_element (test_list : List (List Nat)) (K : Nat) : List (List Nat) :=\n  test_list.map (fun sub => sub.map (fun j => j + K))\n\n#guard add_K_element [[1, 3, 4], [2, 4, 6], [3, 8, 1]] 4 == [[5, 7, 8], [6, 8, 10], [7, 12, 5]]\n#guard add_K_element [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 8 == [[9, 10, 11], [12, 13, 14], [15, 16, 17]]\n#guard add_K_element [[11, 12, 13], [14, 15, 16], [17, 18, 19]] 9 == [[20, 21, 22], [23, 24, 25], [26, 27, 28]]\n", "test_list": ["#guard add_K_element [[1, 3, 4], [2, 4, 6], [3, 8, 1]] 4 == [[5, 7, 8], [6, 8, 10], [7, 12, 5]]", "#guard add_K_element [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 8 == [[9, 10, 11], [12, 13, 14], [15, 16, 17]]", "#guard add_K_element [[11, 12, 13], [14, 15, 16], [17, 18, 19]] 9 == [[20, 21, 22], [23, 24, 25], [26, 27, 28]]"]}
{"text": "Write a function to find the number of flips required to make the given binary string a sequence of alternate characters.", "task_id": 364, "code": "import Batteries\n\nopen Std\n\ndef make_flip (ch : String) : String :=\n  if ch == \"0\" then \"1\" else \"0\"\n\ndef get_flip_with_starting_charcter (str : String) (expected : String) : Nat := Id.run do\n  let n := str.length\n  let mut flip_count := 0\n  let mut exp := expected\n  for i in [: n] do\n    let ch := (str.drop i).take 1\n    if ch != exp then\n      flip_count := flip_count + 1\n    exp := make_flip exp\n  return flip_count\n\ndef min_flip_to_make_string_alternate (str : String) : Nat :=\n  min (get_flip_with_starting_charcter str \"0\") (get_flip_with_starting_charcter str \"1\")\n\n#guard min_flip_to_make_string_alternate \"0001010111\" == 2\n#guard min_flip_to_make_string_alternate \"001\" == 1\n#guard min_flip_to_make_string_alternate \"010111011\" == 2\n", "test_list": ["#guard min_flip_to_make_string_alternate \"0001010111\" == 2", "#guard min_flip_to_make_string_alternate \"001\" == 1", "#guard min_flip_to_make_string_alternate \"010111011\" == 2"]}
{"text": "Write a python function to find the largest product of the pair of adjacent elements from a given list of integers.", "task_id": 366, "code": "import Batteries\n\nopen Std\n\ndef adjacentNumProduct (listNums : List Nat) : Nat := Id.run do\n  match listNums with\n  | [] => return 0  \n  | [_] => return 0 \n  | a :: b :: t =>\n    let mut prev := b\n    let mut best := a * b\n    for x in t do\n      let p := prev * x\n      if p > best then\n        best := p\n      prev := x\n    return best\n\n#guard adjacentNumProduct [1, 2, 3, 4, 5, 6] = 30\n#guard adjacentNumProduct [1, 2, 3, 4, 5] = 20\n#guard adjacentNumProduct [2, 3] = 6\n", "test_list": ["#guard adjacentNumProduct [1, 2, 3, 4, 5, 6] = 30", "#guard adjacentNumProduct [1, 2, 3, 4, 5] = 20", "#guard adjacentNumProduct [2, 3] = 6"]}
{"text": "Write a function to repeat the given tuple n times.", "task_id": 368, "code": "import Batteries\n\nopen Std\n\ndef repeatTuples {α : Type} (test_tup : α) (N : Nat) : List α :=\n  List.replicate N test_tup\n\n#guard repeatTuples (1, 3) 4 = [(1, 3), (1, 3), (1, 3), (1, 3)]\n#guard repeatTuples (1, 2) 3 = [(1, 2), (1, 2), (1, 2)]\n#guard repeatTuples (3, 4) 5 = [(3, 4), (3, 4), (3, 4), (3, 4), (3, 4)]\n", "test_list": ["#guard repeatTuples (1, 3) 4 = [(1, 3), (1, 3), (1, 3), (1, 3)]", "#guard repeatTuples (1, 2) 3 = [(1, 2), (1, 2), (1, 2)]", "#guard repeatTuples (3, 4) 5 = [(3, 4), (3, 4), (3, 4), (3, 4), (3, 4)]"]}
{"text": "Write a function to find the lateral surface area of cuboid", "task_id": 369, "code": "import Batteries\n\nopen Std\n\ndef lateralsurface_cuboid (l w h : Nat) : Nat :=\n  let LSA := 2 * h * (l + w)\n  LSA\n\n#guard lateralsurface_cuboid 8 5 6 = 156\n#guard lateralsurface_cuboid 7 9 10 = 320\n#guard lateralsurface_cuboid 10 20 30 = 1800\n", "test_list": ["#guard lateralsurface_cuboid 8 5 6 = 156", "#guard lateralsurface_cuboid 7 9 10 = 320", "#guard lateralsurface_cuboid 10 20 30 = 1800"]}
{"text": "Write a function to find the smallest missing element in a sorted array.", "task_id": 371, "code": "import Batteries\n\nopen Std\n\npartial def smallest_missing (A : List Nat) (left_element right_element : Int) : Nat :=\n  if left_element > right_element then\n    Int.toNat left_element\n  else\n    let mid : Int := left_element + (right_element - left_element) / (2 : Int)\n    let midNat := Int.toNat mid\n    let aMid := A.getD midNat 0\n    if aMid == midNat then\n      smallest_missing A (mid + 1) right_element\n    else\n      smallest_missing A left_element (mid - 1)\n\n#guard smallest_missing [0, 1, 2, 3, 4, 5, 6] (0 : Int) (6 : Int) == 7\n#guard smallest_missing [0, 1, 2, 6, 9, 11, 15] (0 : Int) (6 : Int) == 3\n#guard smallest_missing [1, 2, 3, 4, 6, 9, 11, 15] (0 : Int) (7 : Int) == 0\n", "test_list": ["#guard smallest_missing [0, 1, 2, 3, 4, 5, 6] (0 : Int) (6 : Int) == 7", "#guard smallest_missing [0, 1, 2, 6, 9, 11, 15] (0 : Int) (6 : Int) == 3", "#guard smallest_missing [1, 2, 3, 4, 6, 9, 11, 15] (0 : Int) (7 : Int) == 0"]}
{"text": "Write a function to sort a given list of elements in ascending order using heap queue algorithm.", "task_id": 372, "code": "import Batteries\n\nopen Std\n\ndef findMinOpt (xs : List Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | h :: t => some <| t.foldl (fun m x => Nat.min m x) h\n\ndef removeFirst (xs : List Nat) (y : Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | h :: t => if h == y then t else h :: removeFirst t y\n\ndef heapAssending (nums : List Nat) : List Nat := Id.run do\n  let mut rem := nums\n  let mut res : List Nat := []\n  let n := nums.length\n  for _ in [: n] do\n    match findMinOpt rem with\n    | none => break\n    | some m =>\n      res := res ++ [m]\n      rem := removeFirst rem m\n  return res\n\n#guard heapAssending [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1] == [1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]\n#guard heapAssending [25, 35, 22, 85, 14, 65, 75, 25, 58] == [14, 22, 25, 25, 35, 58, 65, 75, 85]\n#guard heapAssending [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n", "test_list": ["#guard heapAssending [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1] == [1, 2, 3, 4, 7, 8, 9, 9, 10, 14, 18]", "#guard heapAssending [25, 35, 22, 85, 14, 65, 75, 25, 58] == [14, 22, 25, 25, 35, 58, 65, 75, 85]", "#guard heapAssending [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"]}
{"text": "Write a function to find the volume of a cuboid.", "task_id": 373, "code": "import Batteries\n\nopen Std\n\ndef volumeCuboid (l w h : Nat) : Nat :=\n  let volume := l * w * h\n  volume\n\n#guard volumeCuboid 1 2 3 = 6\n#guard volumeCuboid 5 7 9 = 315\n#guard volumeCuboid 10 15 21 = 3150\n", "test_list": ["#guard volumeCuboid 1 2 3 = 6", "#guard volumeCuboid 5 7 9 = 315", "#guard volumeCuboid 10 15 21 = 3150"]}
{"text": "Write a function to print all permutations of a given string including duplicates.", "task_id": 374, "code": "import Batteries\n\nopen Std\n\npartial def permuteString (s : String) : List String :=\n  if s.length == 0 then [\"\"]\n  else\n    let prev := permuteString (s.drop 1)\n    let c := s.take 1\n    prev.foldl (fun acc p =>\n      (List.range s.length).foldl (fun acc2 j =>\n        let newStr := p.take j ++ c ++ p.drop j\n        if acc2.any (fun x => x == newStr) then acc2 else acc2 ++ [newStr]\n      ) acc\n    ) []\n\n#guard permuteString \"ab\" == [\"ab\", \"ba\"]\n#guard permuteString \"abc\" == [\"abc\", \"bac\", \"bca\", \"acb\", \"cab\", \"cba\"]\n#guard permuteString \"abcd\" == [\"abcd\", \"bacd\", \"bcad\", \"bcda\", \"acbd\", \"cabd\", \"cbad\", \"cbda\", \"acdb\", \"cadb\", \"cdab\", \"cdba\", \"abdc\", \"badc\", \"bdac\", \"bdca\", \"adbc\", \"dabc\", \"dbac\", \"dbca\", \"adcb\", \"dacb\", \"dcab\", \"dcba\"]\n", "test_list": ["#guard permuteString \"ab\" == [\"ab\", \"ba\"]", "#guard permuteString \"abc\" == [\"abc\", \"bac\", \"bca\", \"acb\", \"cab\", \"cba\"]", "#guard permuteString \"abcd\" == [\"abcd\", \"bacd\", \"bcad\", \"bcda\", \"acbd\", \"cabd\", \"cbad\", \"cbda\", \"acdb\", \"cadb\", \"cdab\", \"cdba\", \"abdc\", \"badc\", \"bdac\", \"bdca\", \"adbc\", \"dabc\", \"dbac\", \"dbca\", \"adcb\", \"dacb\", \"dcab\", \"dcba\"]"]}
{"text": "Write a function to round the given number to the nearest multiple of a specific number.", "task_id": 375, "code": "import Batteries\n\nopen Std\n\ndef roundNum (n m : Nat) : Nat :=\n  \n  let a := (n / m) * m\n  let b := a + m\n  if n - a > b - n then b else a\n\n#guard roundNum 4722 10 = 4720\n#guard roundNum 1111 5 = 1110\n#guard roundNum 219 2 = 218\n", "test_list": ["#guard roundNum 4722 10 = 4720", "#guard roundNum 1111 5 = 1110", "#guard roundNum 219 2 = 218"]}
{"text": "Write a function to remove tuple elements that occur more than once and replace the duplicates with some custom value.", "task_id": 376, "code": "import Batteries\n\nopen Std\n\ndef removeReplica (test_tup : List Nat) : List (Sum Nat String) := Id.run do\n  let mut seen : HashSet Nat := {}\n  let mut res : Array (Sum Nat String) := #[]\n  for ele in test_tup do\n    if seen.contains ele then\n      res := res.push (Sum.inr \"MSP\")\n    else\n      seen := seen.insert ele\n      res := res.push (Sum.inl ele)\n  return res.toList\n\n#guard removeReplica [1, 1, 4, 4, 4, 5, 5, 6, 7, 7] == [Sum.inl 1, Sum.inr \"MSP\", Sum.inl 4, Sum.inr \"MSP\", Sum.inr \"MSP\", Sum.inl 5, Sum.inr \"MSP\", Sum.inl 6, Sum.inl 7, Sum.inr \"MSP\"]\n#guard removeReplica [2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9] == [Sum.inl 2, Sum.inl 3, Sum.inl 4, Sum.inr \"MSP\", Sum.inl 5, Sum.inl 6, Sum.inr \"MSP\", Sum.inl 7, Sum.inl 8, Sum.inl 9, Sum.inr \"MSP\"]\n#guard removeReplica [2, 2, 5, 4, 5, 7, 5, 6, 7, 7] == [Sum.inl 2, Sum.inr \"MSP\", Sum.inl 5, Sum.inl 4, Sum.inr \"MSP\", Sum.inl 7, Sum.inr \"MSP\", Sum.inl 6, Sum.inr \"MSP\", Sum.inr \"MSP\"]\n", "test_list": ["#guard removeReplica [1, 1, 4, 4, 4, 5, 5, 6, 7, 7] == [Sum.inl 1, Sum.inr \"MSP\", Sum.inl 4, Sum.inr \"MSP\", Sum.inr \"MSP\", Sum.inl 5, Sum.inr \"MSP\", Sum.inl 6, Sum.inl 7, Sum.inr \"MSP\"]", "#guard removeReplica [2, 3, 4, 4, 5, 6, 6, 7, 8, 9, 9] == [Sum.inl 2, Sum.inl 3, Sum.inl 4, Sum.inr \"MSP\", Sum.inl 5, Sum.inl 6, Sum.inr \"MSP\", Sum.inl 7, Sum.inl 8, Sum.inl 9, Sum.inr \"MSP\"]", "#guard removeReplica [2, 2, 5, 4, 5, 7, 5, 6, 7, 7] == [Sum.inl 2, Sum.inr \"MSP\", Sum.inl 5, Sum.inl 4, Sum.inr \"MSP\", Sum.inl 7, Sum.inr \"MSP\", Sum.inl 6, Sum.inr \"MSP\", Sum.inr \"MSP\"]"]}
{"text": "Write a python function to remove all occurrences of a character in a given string.", "task_id": 377, "code": "import Batteries\n\nopen Std\n\ndef remove_Char (s : String) (c : Char) : String :=\n  let counts := s.toList.foldl (fun acc ch => if ch == c then acc + 1 else acc) 0\n  let lst0 := s.toList\n  let rec loop (lst : List Char) (k : Nat) : List Char :=\n    match k with\n    | 0 => lst\n    | Nat.succ k' => loop (lst.erase c) k'\n  let lst' := loop lst0 counts\n  String.mk lst'\n\n#guard remove_Char \"aba\" 'a' == \"b\"\n#guard remove_Char \"toggle\" 'g' == \"tole\"\n#guard remove_Char \"aabbc\" 'b' == \"aac\"\n", "test_list": ["#guard remove_Char \"aba\" 'a' == \"b\"", "#guard remove_Char \"toggle\" 'g' == \"tole\"", "#guard remove_Char \"aabbc\" 'b' == \"aac\""]}
{"text": "Write a python function to shift last element to first position in the given list.", "task_id": 378, "code": "import Batteries\n\nopen Std\n\ndef moveFirst (test_list : List Nat) : List Nat :=\n  let n := test_list.length\n  test_list.drop (n - 1) ++ test_list.take (n - 1)\n\n#guard moveFirst [1,2,3,4] = [4,1,2,3]\n#guard moveFirst [0,1,2,3] = [3,0,1,2]\n#guard moveFirst [9,8,7,1] = [1,9,8,7]\n", "test_list": ["#guard moveFirst [1,2,3,4] = [4,1,2,3]", "#guard moveFirst [0,1,2,3] = [3,0,1,2]", "#guard moveFirst [9,8,7,1] = [1,9,8,7]"]}
{"text": "Write a function to find the surface area of a cuboid.", "task_id": 379, "code": "import Batteries\n\nopen Std\n\ndef surfacearea_cuboid (l w h : Nat) : Nat :=\n  2 * (l * w + l * h + w * h)\n\n#guard surfacearea_cuboid 1 2 3 = 22\n#guard surfacearea_cuboid 5 7 9 = 286\n#guard surfacearea_cuboid 10 15 21 = 1350\n", "test_list": ["#guard surfacearea_cuboid 1 2 3 = 22", "#guard surfacearea_cuboid 5 7 9 = 286", "#guard surfacearea_cuboid 10 15 21 = 1350"]}
{"text": "Write a function to generate a two-dimensional array.", "task_id": 380, "code": "import Batteries\n\nopen Std\n\ndef multiList (rownum colnum : Nat) : List (List Nat) := Id.run do\n  let mut a : Array (Array Nat) := Array.replicate rownum (Array.replicate colnum 0)\n  for row in [0 : rownum] do\n    for col in [0 : colnum] do\n      a := a.modify row (fun r => r.set! col (row * col))\n  return a.toList.map (fun r => r.toList)\n\n#guard multiList 3 4 == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]\n#guard multiList 5 7 == [[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]\n#guard multiList 10 15 == [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]\n", "test_list": ["#guard multiList 3 4 == [[0, 0, 0, 0], [0, 1, 2, 3], [0, 2, 4, 6]]", "#guard multiList 5 7 == [[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12], [0, 3, 6, 9, 12, 15, 18], [0, 4, 8, 12, 16, 20, 24]]", "#guard multiList 10 15 == [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28], [0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42], [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56], [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70], [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, 78, 84], [0, 7, 14, 21, 28, 35, 42, 49, 56, 63, 70, 77, 84, 91, 98], [0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112], [0, 9, 18, 27, 36, 45, 54, 63, 72, 81, 90, 99, 108, 117, 126]]"]}
{"text": "Write a function to sort a list of lists by a given index of the inner list.", "task_id": 381, "code": "import Batteries\n\nopen Std\n\ndef ltByCompare {β} [Ord β] (x y : β) : Bool :=\n  match compare x y with\n  | Ordering.lt => true\n  | _ => false\n\ndef insertByKey {α β} [Ord β] (key : α → β) (a : α) : List α → List α\n  | [] => [a]\n  | b :: bs =>\n    if ltByCompare (key a) (key b) then a :: b :: bs\n    else b :: insertByKey key a bs\n\ndef isortByKey {α β} [Ord β] (key : α → β) (xs : List α) : List α :=\n  xs.foldl (fun acc a => insertByKey key a acc) []\n\ndef indexOnInnerList (listData : List (String × Nat × Nat)) (indexNo : Nat) : List (String × Nat × Nat) :=\n  match indexNo with\n  | 0 => isortByKey (fun t => t.fst) listData\n  | 1 => isortByKey (fun t => t.snd.fst) listData\n  | 2 => isortByKey (fun t => t.snd.snd) listData\n  | _ => listData\n\n#guard indexOnInnerList [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)] 0\n  = [(\"Beau Turnbull\", 94, 98), (\"Brady Kent\", 97, 96), (\"Greyson Fulton\", 98, 99), (\"Wyatt Knott\", 91, 94)]\n#guard indexOnInnerList [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)] 1\n  = [(\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98), (\"Brady Kent\", 97, 96), (\"Greyson Fulton\", 98, 99)]\n#guard indexOnInnerList [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)] 2\n  = [(\"Wyatt Knott\", 91, 94), (\"Brady Kent\", 97, 96), (\"Beau Turnbull\", 94, 98), (\"Greyson Fulton\", 98, 99)]\n", "test_list": ["#guard indexOnInnerList [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)] 0", "#guard indexOnInnerList [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)] 1", "#guard indexOnInnerList [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)] 2"]}
{"text": "Write a function to find the number of rotations in a circularly sorted array.", "task_id": 382, "code": "import Batteries\nopen Std\n\ndef findRotationCount (A : List Int) : Int := Id.run do\n  let n := A.length\n  if n == 0 then\n    return -1\n  let rec loop (fuel : Nat) (left right : Int) : Int :=\n    if fuel = 0 then\n      -1\n    else\n      if left ≤ right then\n        let leftNat := Int.toNat left\n        let rightNat := Int.toNat right\n        let aLeft := A.getD leftNat 0\n        let aRight := A.getD rightNat 0\n        if aLeft ≤ aRight then\n          left\n        else\n          let mid := (left + right) / 2\n          let midNat := Int.toNat mid\n          let nextIdx := (midNat + 1) % n\n          let prevIdx := (midNat + (n - 1)) % n\n          let aMid := A.getD midNat 0\n          let aNext := A.getD nextIdx 0\n          let aPrev := A.getD prevIdx 0\n          if aMid ≤ aNext && aMid ≤ aPrev then\n            mid\n          else if aMid ≤ aRight then\n            loop (fuel - 1) left (mid - 1)\n          else if aMid ≥ aLeft then\n            loop (fuel - 1) (mid + 1) right\n          else\n            -1\n      else\n        -1\n  let right0 := Int.ofNat (n - 1)\n  return loop (n + 1) 0 right0\n\n#guard findRotationCount [8, 9, 10, 1, 2, 3, 4, 5, 6, 7] = (3 : Int)\n#guard findRotationCount [8, 9, 10, 2, 5, 6] = (3 : Int)\n#guard findRotationCount [2, 5, 6, 8, 9, 10] = (0 : Int)\n", "test_list": ["#guard findRotationCount [8, 9, 10, 1, 2, 3, 4, 5, 6, 7] = (3 : Int)", "#guard findRotationCount [8, 9, 10, 2, 5, 6] = (3 : Int)", "#guard findRotationCount [2, 5, 6, 8, 9, 10] = (0 : Int)"]}
{"text": "Write a python function to toggle all odd bits of a given number.", "task_id": 383, "code": "import Batteries\n\nopen Std\n\ndef evenBitToggleNumber (n : Nat) : Nat := Id.run do\n  let mut res := 0\n  let mut count := 0\n  let mut temp := n\n  while temp > 0 do\n    if count % 2 == 0 then\n      res := res ||| (2 ^ count)\n    count := count + 1\n    temp := temp / 2\n  return n ^^^ res\n\n#guard evenBitToggleNumber 10 = 15\n#guard evenBitToggleNumber 20 = 1\n#guard evenBitToggleNumber 30 = 11\n", "test_list": ["#guard evenBitToggleNumber 10 = 15", "#guard evenBitToggleNumber 20 = 1", "#guard evenBitToggleNumber 30 = 11"]}
{"text": "Write a python function to find the frequency of the smallest value in a given array.", "task_id": 384, "code": "import Batteries\n\nopen Std\n\ndef frequencyOfSmallest (n : Nat) (arr : List Nat) : Nat := Id.run do\n  \n  \n  let a := arr.toArray\n  let mut mn := a[0]!\n  let mut freq : Nat := 1\n  for i in [1 : n] do\n    let x := a[i]!\n    if x < mn then\n      mn := x\n      freq := 1\n    else if x = mn then\n      freq := freq + 1\n    else\n      pure ()\n  return freq\n\n#guard frequencyOfSmallest 5 [1, 2, 3, 4, 3] = 1\n#guard frequencyOfSmallest 7 [3, 1, 2, 5, 6, 2, 3] = 1\n#guard frequencyOfSmallest 7 [3, 3, 6, 3, 7, 4, 9] = 3\n", "test_list": ["#guard frequencyOfSmallest 5 [1, 2, 3, 4, 3] = 1", "#guard frequencyOfSmallest 7 [3, 1, 2, 5, 6, 2, 3] = 1", "#guard frequencyOfSmallest 7 [3, 3, 6, 3, 7, 4, 9] = 3"]}
{"text": "Write a function to find the n'th perrin number using recursion.", "task_id": 385, "code": "import Batteries\n\nopen Std\n\ndef getPerrin (n : Nat) : Nat :=\n  match n with\n  | 0 => 3\n  | 1 => 0\n  | 2 => 2\n  | n+3 => getPerrin (n+1) + getPerrin n\n\n#guard getPerrin 9 = 12\n#guard getPerrin 4 = 2\n#guard getPerrin 6 = 5\n", "test_list": ["#guard getPerrin 9 = 12", "#guard getPerrin 4 = 2", "#guard getPerrin 6 = 5"]}
{"text": "Write a function to find out the minimum no of swaps required for bracket balancing in the given string.", "task_id": 386, "code": "import Batteries\n\nopen Std\n\ndef swapCount (s : String) : Nat := Id.run do\n  let chars := s.data\n  let mut count_left : Int := 0\n  let mut count_right : Int := 0\n  let mut swap : Int := 0\n  let mut imbalance : Int := 0\n  for c in chars do\n    if c == '[' then\n      count_left := count_left + 1\n      if imbalance > 0 then\n        swap := swap + imbalance\n        imbalance := imbalance - 1\n    else if c == ']' then\n      count_right := count_right + 1\n      imbalance := count_right - count_left\n    else\n      pure ()\n  return swap.toNat\n\n#guard swapCount \"[]][][\" == 2\n#guard swapCount \"[[][]]\" == 0\n#guard swapCount \"[[][]]][\" == 1\n", "test_list": ["#guard swapCount \"[]][][\" == 2", "#guard swapCount \"[[][]]\" == 0", "#guard swapCount \"[[][]]][\" == 1"]}
{"text": "Write a python function to check whether the hexadecimal number is even or odd.", "task_id": 387, "code": "import Batteries\n\nopen Std\n\ndef even_or_odd (N : String) : String :=\n  let l := N.length\n  let last := (N.drop (l - 1)).take 1\n  if last == \"0\" || last == \"2\" || last == \"4\" || last == \"6\" ||\n     last == \"8\" || last == \"A\" || last == \"C\" || last == \"E\" then\n    \"Even\"\n  else\n    \"Odd\"\n\n#guard even_or_odd \"AB3454D\" == \"Odd\"\n#guard even_or_odd \"ABC\" == \"Even\"\n#guard even_or_odd \"AAD\" == \"Odd\"\n", "test_list": ["#guard even_or_odd \"AB3454D\" == \"Odd\"", "#guard even_or_odd \"ABC\" == \"Even\"", "#guard even_or_odd \"AAD\" == \"Odd\""]}
{"text": "Write a python function to find the highest power of 2 that is less than or equal to n.", "task_id": 388, "code": "import Batteries\n\nopen Std\n\ndef highest_Power_of_2 (n : Nat) : Nat := Id.run do\n  let mut res := 0\n  let mut i := n\n  while i > 0 do\n    if (i &&& (i - 1)) == 0 then\n      res := i\n      i := 0\n    else\n      i := i - 1\n  return res\n\n#guard highest_Power_of_2 10 = 8\n#guard highest_Power_of_2 19 = 16\n#guard highest_Power_of_2 32 = 32\n", "test_list": ["#guard highest_Power_of_2 10 = 8", "#guard highest_Power_of_2 19 = 16", "#guard highest_Power_of_2 32 = 32"]}
{"text": "Write a function to find the n'th lucas number.", "task_id": 389, "code": "import Batteries\n\nopen Std\n\ndef findLucas : Nat → Nat\n  | 0 => 2\n  | 1 => 1\n  | n+2 => findLucas (n+1) + findLucas n\n\n#guard findLucas 9 = 76\n#guard findLucas 4 = 7\n#guard findLucas 3 = 4\n", "test_list": ["#guard findLucas 9 = 76", "#guard findLucas 4 = 7", "#guard findLucas 3 = 4"]}
{"text": "Write a function to insert a given string at the beginning of all items in a list.", "task_id": 390, "code": "import Batteries\n\nopen Std\n\nprivate def format0 (template : String) (arg : String) : String :=\n  match template.splitOn \"{0}\" with\n  | [] => \"\"\n  | p :: ps => ps.foldl (fun acc s => acc ++ arg ++ s) p\n\ndef add_string {α} [ToString α] (list : List α) (string : String) : List String :=\n  list.map (fun i => format0 string (toString i))\n\n#guard add_string [1,2,3,4] \"temp{0}\" == [\"temp1\", \"temp2\", \"temp3\", \"temp4\"]\n#guard add_string [\"a\",\"b\",\"c\",\"d\"] \"python{0}\" == [\"pythona\", \"pythonb\", \"pythonc\", \"pythond\"]\n#guard add_string [5,6,7,8] \"string{0}\" == [\"string5\", \"string6\", \"string7\", \"string8\"]\n", "test_list": ["#guard add_string [1,2,3,4] \"temp{0}\" == [\"temp1\", \"temp2\", \"temp3\", \"temp4\"]", "#guard add_string [\"a\",\"b\",\"c\",\"d\"] \"python{0}\" == [\"pythona\", \"pythonb\", \"pythonc\", \"pythond\"]", "#guard add_string [5,6,7,8] \"string{0}\" == [\"string5\", \"string6\", \"string7\", \"string8\"]"]}
{"text": "Write a function to convert more than one list to nested dictionary.", "task_id": 391, "code": "import Batteries\n\nopen Std\n\ndef convertListDictionary (l1 l2 : List String) (l3 : List Nat) : List (List (String × (List (String × Nat)))) :=\n  let rec go (a b : List String) (c : List Nat) : List (List (String × (List (String × Nat)))) :=\n    match a, b, c with\n    | x::xs, y::ys, z::zs => [ (x, [ (y, z) ]) ] :: go xs ys zs\n    | _, _, _ => []\n  go l1 l2 l3\n\n#guard convertListDictionary [\"S001\", \"S002\", \"S003\", \"S004\"] [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] [85, 98, 89, 92]\n  = [[(\"S001\", [(\"Adina Park\", 85)])], [(\"S002\", [(\"Leyton Marsh\", 98)])], [(\"S003\", [(\"Duncan Boyle\", 89)])], [(\"S004\", [(\"Saim Richards\", 92)])]]\n#guard convertListDictionary [\"abc\",\"def\",\"ghi\",\"jkl\"] [\"python\",\"program\",\"language\",\"programs\"] [100,200,300,400]\n  = [[(\"abc\", [(\"python\", 100)])], [(\"def\", [(\"program\", 200)])], [(\"ghi\", [(\"language\", 300)])], [(\"jkl\", [(\"programs\", 400)])]]\n#guard convertListDictionary [\"A1\",\"A2\",\"A3\",\"A4\"] [\"java\",\"C\",\"C++\",\"DBMS\"] [10,20,30,40]\n  = [[(\"A1\", [(\"java\", 10)])], [(\"A2\", [(\"C\", 20)])], [(\"A3\", [(\"C++\", 30)])], [(\"A4\", [(\"DBMS\", 40)])]]\n", "test_list": ["#guard convertListDictionary [\"S001\", \"S002\", \"S003\", \"S004\"] [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] [85, 98, 89, 92]", "#guard convertListDictionary [\"abc\",\"def\",\"ghi\",\"jkl\"] [\"python\",\"program\",\"language\",\"programs\"] [100,200,300,400]", "#guard convertListDictionary [\"A1\",\"A2\",\"A3\",\"A4\"] [\"java\",\"C\",\"C++\",\"DBMS\"] [10,20,30,40]"]}
{"text": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).", "task_id": 392, "code": "import Batteries\n\nopen Std\n\ndef getMaxSum (n : Nat) : Nat := Id.run do\n  let mut res := Array.replicate (n+1) 0\n  for i in [0 : n+1] do\n    if i == 0 then\n      res := res.set! i 0\n    else if i == 1 then\n      res := res.set! i 1\n    else\n      let v := res[(i / 2)]! + res[(i / 3)]! + res[(i / 4)]! + res[(i / 5)]!\n      let m := Nat.max i v\n      res := res.set! i m\n  return res[n]!\n\n#guard getMaxSum 60 = 106\n#guard getMaxSum 10 = 12\n#guard getMaxSum 2 = 2\n", "test_list": ["#guard getMaxSum 60 = 106", "#guard getMaxSum 10 = 12", "#guard getMaxSum 2 = 2"]}
{"text": "Write a function to find the list with maximum length using lambda function.", "task_id": 393, "code": "import Batteries\n\nopen Std\n\ndef max_length_list (input_list : List (List Nat)) : Nat × List Nat :=\n  match input_list with\n  | [] => (0, [])\n  | x :: xs =>\n    let (bestLen, bestList) := xs.foldl (fun (acc : Nat × List Nat) (l : List Nat) =>\n      let (bl, blist) := acc\n      let len := l.length\n      if len > bl then (len, l) else acc\n    ) (x.length, x)\n    (bestLen, bestList)\n\n#guard max_length_list [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] = (3, [13, 15, 17])\n#guard max_length_list [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]] = (5, [1,2,3,4,5])\n#guard max_length_list [[3,4,5],[6,7,8,9],[10,11,12]] = (4, [6,7,8,9])\n", "test_list": ["#guard max_length_list [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] = (3, [13, 15, 17])", "#guard max_length_list [[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]] = (5, [1,2,3,4,5])", "#guard max_length_list [[3,4,5],[6,7,8,9],[10,11,12]] = (4, [6,7,8,9])"]}
{"text": "Write a function to check if given tuple is distinct or not.", "task_id": 394, "code": "import Batteries\n\nopen Std\n\ndef checkDistinct (testTup : List Nat) : Bool := Id.run do\n  let mut res := true\n  let mut temp : HashSet Nat := HashSet.empty\n  for ele in testTup do\n    if ele ∈ temp then\n      res := false\n      return res\n    else\n      temp := temp.insert ele\n  return res\n\n#guard checkDistinct [1, 4, 5, 6, 1, 4] == false\n#guard checkDistinct [1, 4, 5, 6] == true\n#guard checkDistinct [2, 3, 4, 5, 6] == true\n", "test_list": ["#guard checkDistinct [1, 4, 5, 6, 1, 4] == false", "#guard checkDistinct [1, 4, 5, 6] == true", "#guard checkDistinct [2, 3, 4, 5, 6] == true"]}
{"text": "Write a python function to find the first non-repeated character in a given string.", "task_id": 395, "code": "import Batteries\nopen Std\n\ndef firstNonRepeatingCharacter (str1 : String) : Option Char :=\n  let cs := str1.data\n  let rec pass1 (cs : List Char) (once : Std.HashSet Char) (multi : Std.HashSet Char) (orderRev : List Char) :\n      Std.HashSet Char × Std.HashSet Char × List Char :=\n    match cs with\n    | [] => (once, multi, orderRev)\n    | c :: cs' =>\n      if multi.contains c then\n        pass1 cs' once multi orderRev\n      else if once.contains c then\n        let once' := once.erase c\n        let multi' := multi.insert c\n        pass1 cs' once' multi' orderRev\n      else\n        let once' := once.insert c\n        pass1 cs' once' multi (c :: orderRev)\n  let (once, _, orderRev) := pass1 cs (Std.HashSet.empty) (Std.HashSet.empty) []\n  let order := orderRev.reverse\n  let rec findFirst (ord : List Char) : Option Char :=\n    match ord with\n    | [] => none\n    | c :: cs' =>\n      if once.contains c then some c else findFirst cs'\n  findFirst order\n\n#guard firstNonRepeatingCharacter \"abcabc\" = none\n#guard firstNonRepeatingCharacter \"abc\" = some 'a'\n#guard firstNonRepeatingCharacter \"ababc\" = some 'c'\n", "test_list": ["#guard firstNonRepeatingCharacter \"abcabc\" = none", "#guard firstNonRepeatingCharacter \"abc\" = some 'a'", "#guard firstNonRepeatingCharacter \"ababc\" = some 'c'"]}
{"text": "Write a function to check whether the given string starts and ends with the same character or not using regex.", "task_id": 396, "code": "import Batteries\n\nopen Std\n\ndef lowercaseLetters : List String := [\n  \"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\n  \"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"\n]\n\ndef checkChar (string : String) : String :=\n  let s := string\n  let len := s.length\n  let first := s.take 1\n  let last := if len == 0 then \"\" else s.drop (len - 1)\n  let isLower := lowercaseLetters.any (fun c => c == first)\n  let ok :=\n    if len == 0 then false\n    else if len == 1 then isLower\n    else isLower && (first == last)\n  if ok then \"Valid\" else \"Invalid\"\n\n#guard checkChar \"abba\" = \"Valid\"\n#guard checkChar \"a\" = \"Valid\"\n#guard checkChar \"abcd\" = \"Invalid\"\n", "test_list": ["#guard checkChar \"abba\" = \"Valid\"", "#guard checkChar \"a\" = \"Valid\"", "#guard checkChar \"abcd\" = \"Invalid\""]}
{"text": "Write a function to find the median of three specific numbers.", "task_id": 397, "code": "import Batteries\n\nopen Std\n\ndef medianNumbers (a b c : Nat) : Float :=\n  let median :=\n    if a > b then\n      if a < c then a\n      else if b > c then b\n      else c\n    else\n      if a > c then a\n      else if b < c then b\n      else c\n  Float.ofNat median\n\n#guard medianNumbers 25 55 65 == 55.0\n#guard medianNumbers 20 10 30 == 20.0\n#guard medianNumbers 15 45 75 == 45.0\n", "test_list": ["#guard medianNumbers 25 55 65 == 55.0", "#guard medianNumbers 20 10 30 == 20.0", "#guard medianNumbers 15 45 75 == 45.0"]}
{"text": "Write a function to compute the sum of digits of each number of a given list.", "task_id": 398, "code": "import Batteries\n\nopen Std\n\ndef sumOfDigits {α} [ToString α] (nums : List α) : Nat :=\n  nums.foldl (fun acc n =>\n    (toString n).toList.foldl (fun acc2 c =>\n      if c.isDigit then acc2 + (c.toNat - '0'.toNat) else acc2\n    ) acc\n  ) 0\n\n#guard sumOfDigits ([10, 2, 56] : List Int) = 14\n#guard sumOfDigits [\"[10,20,4,5,'b',70,'a']\"] = 19\n#guard sumOfDigits ([10, 20, -4, 5, -70] : List Int) = 19\n", "test_list": ["#guard sumOfDigits ([10, 2, 56] : List Int) = 14", "#guard sumOfDigits [\"[10,20,4,5,'b',70,'a']\"] = 19", "#guard sumOfDigits ([10, 20, -4, 5, -70] : List Int) = 19"]}
{"text": "Write a function to perform the mathematical bitwise xor operation across the given tuples.", "task_id": 399, "code": "import Batteries\n\nopen Std\n\ndef bitwiseXor (test_tup1 : List Nat) (test_tup2 : List Nat) : List Nat :=\n  (List.zip test_tup1 test_tup2).map (fun (a, b) => a ^^^ b)\n\n#guard bitwiseXor [10, 4, 6, 9] [5, 2, 3, 3] == [15, 6, 5, 10]\n#guard bitwiseXor [11, 5, 7, 10] [6, 3, 4, 4] == [13, 6, 3, 14]\n#guard bitwiseXor [12, 6, 8, 11] [7, 4, 5, 6] == [11, 2, 13, 13]\n", "test_list": ["#guard bitwiseXor [10, 4, 6, 9] [5, 2, 3, 3] == [15, 6, 5, 10]", "#guard bitwiseXor [11, 5, 7, 10] [6, 3, 4, 4] == [13, 6, 3, 14]", "#guard bitwiseXor [12, 6, 8, 11] [7, 4, 5, 6] == [11, 2, 13, 13]"]}
{"text": "Write a function to extract the frequency of unique tuples in the given list order irrespective.", "task_id": 400, "code": "import Batteries\n\nopen Std\n\ndef extractFreq (test_list : List (Nat × Nat)) : Nat := Id.run do\n  let canonicalize := fun (p : Nat × Nat) => if p.fst ≤ p.snd then p else (p.snd, p.fst)\n  let mut s : HashSet (Nat × Nat) := HashSet.empty\n  for p in test_list do\n    s := s.insert (canonicalize p)\n  return s.size\n\n#guard extractFreq [(3, 4), (1, 2), (4, 3), (5, 6)] = 3\n#guard extractFreq [(4, 15), (2, 3), (5, 4), (6, 7)] = 4\n#guard extractFreq [(5, 16), (2, 3), (6, 5), (6, 9)] = 4\n", "test_list": ["#guard extractFreq [(3, 4), (1, 2), (4, 3), (5, 6)] = 3", "#guard extractFreq [(4, 15), (2, 3), (5, 4), (6, 7)] = 4", "#guard extractFreq [(5, 16), (2, 3), (6, 5), (6, 9)] = 4"]}
{"text": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.", "task_id": 401, "code": "import Batteries\n\nopen Std\n\ndef addNestedTuples (test_tup1 : List (List Nat)) (test_tup2 : List (List Nat)) : List (List Nat) :=\n  (test_tup1.zip test_tup2).map (fun p =>\n    let t1 := p.fst\n    let t2 := p.snd\n    (t1.zip t2).map (fun q => q.fst + q.snd))\n\n#guard addNestedTuples [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] = [[7, 10], [7, 14], [3, 10], [8, 13]]\n#guard addNestedTuples [[2, 4], [5, 6], [3, 10], [2, 11]] [[7, 8], [4, 10], [2, 2], [8, 4]] = [[9, 12], [9, 16], [5, 12], [10, 15]]\n#guard addNestedTuples [[3, 5], [6, 7], [4, 11], [3, 12]] [[8, 9], [5, 11], [3, 3], [9, 5]] = [[11, 14], [11, 18], [7, 14], [12, 17]]\n", "test_list": ["#guard addNestedTuples [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] = [[7, 10], [7, 14], [3, 10], [8, 13]]", "#guard addNestedTuples [[2, 4], [5, 6], [3, 10], [2, 11]] [[7, 8], [4, 10], [2, 2], [8, 4]] = [[9, 12], [9, 16], [5, 12], [10, 15]]", "#guard addNestedTuples [[3, 5], [6, 7], [4, 11], [3, 12]] [[8, 9], [5, 11], [3, 3], [9, 5]] = [[11, 14], [11, 18], [7, 14], [12, 17]]"]}
{"text": "Write a function to compute the value of ncr%p.", "task_id": 402, "code": "import Batteries\nopen Std\n\ndef getAtNat : List Nat → Nat → Nat\n| [], _ => 0\n| x :: _, 0 => x\n| _ :: xs, i+1 => getAtNat xs i\n\ndef setAtNat : List Nat → Nat → Nat → List Nat\n| [], _, _ => []\n| _ :: xs, 0, v => v :: xs\n| x :: xs, i+1, v => x :: setAtNat xs i v\n\ndef ncrModp (n r p : Nat) : Nat :=\n  let rec loopi : Nat → List Nat → List Nat\n  | 0, C => C\n  | i+1, C =>\n    let upper := min (n - i) r\n    let rec loopj : Nat → List Nat → List Nat\n    | 0, Cj => Cj\n    | j+1, Cj =>\n      let vj := getAtNat Cj (j+1)\n      let vjm1 := getAtNat Cj j\n      let Cnext := setAtNat Cj (j+1) ((vj + vjm1) % p)\n      loopj j Cnext\n    let C1 := loopj upper C\n    loopi i C1\n  let C0 := List.replicate (r + 1) 0\n  let C1 := setAtNat C0 0 1\n  let Cfinal := loopi n C1\n  getAtNat Cfinal r\n\n#guard ncrModp 10 2 13 = 6\n#guard ncrModp 15 12 43 = 25\n#guard ncrModp 17 9 18 = 10\n", "test_list": ["#guard ncrModp 10 2 13 = 6", "#guard ncrModp 15 12 43 = 25", "#guard ncrModp 17 9 18 = 10"]}
{"text": "Write a function to check if a url is valid or not using regex.", "task_id": 403, "code": "import Batteries\n\nopen Std\n\ndef lastOfList (l : List String) (d : String) : String :=\n  match l with\n  | [] => d\n  | [x] => x\n  | _::xs => lastOfList xs d\n\ndef allLowerAlpha (s : String) : Bool :=\n  s.data.all (fun c =>\n    let n := c.toNat\n    Nat.ble 97 n && Nat.ble n 122\n  )\n\ndef hasSpace (s : String) : Bool :=\n  s.data.any (fun c => c == ' ')\n\ndef isValidURL (s : String) : Bool :=\n  let hasHttp := s.startsWith \"http://\"\n  let hasHttps := s.startsWith \"https://\"\n  if !hasHttp && !hasHttps then\n    false\n  else\n    let rest :=\n      if hasHttp then s.drop (\"http://\".length) else s.drop (\"https://\".length)\n    if hasSpace rest then\n      false\n    else\n      let rest' := if rest.startsWith \"www.\" then rest.drop (\"www.\".length) else rest\n      let host := (rest'.splitOn \"/\").headD rest'\n      let parts := host.splitOn \".\"\n      if Nat.blt parts.length 2 then false else\n        let tld := lastOfList parts \"\"\n        let tldLen := tld.length\n        if (Nat.blt tldLen 2) || (Nat.blt 6 tldLen) then false else\n          allLowerAlpha tld\n\n#guard isValidURL \"https://www.google.com\" == true\n#guard isValidURL \"https:/www.gmail.com\" == false\n#guard isValidURL \"https:// www.redit.com\" == false\n", "test_list": ["#guard isValidURL \"https://www.google.com\" == true", "#guard isValidURL \"https:/www.gmail.com\" == false", "#guard isValidURL \"https:// www.redit.com\" == false"]}
{"text": "Write a python function to find the minimum of two numbers.", "task_id": 404, "code": "import Batteries\n\nopen Std\n\ndef minimum (a b : Int) : Int :=\n  if a <= b then a else b\n\n#guard minimum 1 2 = 1\n#guard minimum (-5) (-4) = (-5)\n#guard minimum 0 0 = 0\n", "test_list": ["#guard minimum 1 2 = 1", "#guard minimum (-5) (-4) = (-5)", "#guard minimum 0 0 = 0"]}
{"text": "Write a function to check whether an element exists within a tuple.", "task_id": 405, "code": "import Batteries\n\nopen Std\n\ninductive PyVal where\n  | s : String → PyVal\n  | i : Int → PyVal\nderiving BEq, DecidableEq\n\ndef checkTuplex (tuplex : List PyVal) (tuple1 : PyVal) : Bool :=\n  if tuplex.contains tuple1 then true else false\n\n#guard checkTuplex [PyVal.s \"w\", PyVal.i 3, PyVal.s \"r\", PyVal.s \"e\", PyVal.s \"s\", PyVal.s \"o\", PyVal.s \"u\", PyVal.s \"r\", PyVal.s \"c\", PyVal.s \"e\"] (PyVal.s \"r\") == true\n#guard checkTuplex [PyVal.s \"w\", PyVal.i 3, PyVal.s \"r\", PyVal.s \"e\", PyVal.s \"s\", PyVal.s \"o\", PyVal.s \"u\", PyVal.s \"r\", PyVal.s \"c\", PyVal.s \"e\"] (PyVal.s \"5\") == false\n#guard checkTuplex [PyVal.s \"w\", PyVal.i 3, PyVal.s \"r\", PyVal.s \"e\", PyVal.s \"s\", PyVal.s \"o\", PyVal.s \"u\", PyVal.s \"r\", PyVal.s \"c\", PyVal.s \"e\"] (PyVal.i 3) == true\n", "test_list": ["#guard checkTuplex [PyVal.s \"w\", PyVal.i 3, PyVal.s \"r\", PyVal.s \"e\", PyVal.s \"s\", PyVal.s \"o\", PyVal.s \"u\", PyVal.s \"r\", PyVal.s \"c\", PyVal.s \"e\"] (PyVal.s \"r\") == true", "#guard checkTuplex [PyVal.s \"w\", PyVal.i 3, PyVal.s \"r\", PyVal.s \"e\", PyVal.s \"s\", PyVal.s \"o\", PyVal.s \"u\", PyVal.s \"r\", PyVal.s \"c\", PyVal.s \"e\"] (PyVal.s \"5\") == false", "#guard checkTuplex [PyVal.s \"w\", PyVal.i 3, PyVal.s \"r\", PyVal.s \"e\", PyVal.s \"s\", PyVal.s \"o\", PyVal.s \"u\", PyVal.s \"r\", PyVal.s \"c\", PyVal.s \"e\"] (PyVal.i 3) == true"]}
{"text": "Write a python function to find the parity of a given number.", "task_id": 406, "code": "import Batteries\n\nopen Std\n\ndef find_Parity (x : Nat) : String :=\n  let y0 := x ^^^ (x >>> 1)\n  let y1 := y0 ^^^ (y0 >>> 2)\n  let y2 := y1 ^^^ (y1 >>> 4)\n  let y3 := y2 ^^^ (y2 >>> 8)\n  let y4 := y3 ^^^ (y3 >>> 16)\n  if (y4 &&& 1) == 1 then \"Odd Parity\" else \"Even Parity\"\n\n#guard find_Parity 12 = \"Even Parity\"\n#guard find_Parity 7 = \"Odd Parity\"\n#guard find_Parity 10 = \"Even Parity\"\n", "test_list": ["#guard find_Parity 12 = \"Even Parity\"", "#guard find_Parity 7 = \"Odd Parity\"", "#guard find_Parity 10 = \"Even Parity\""]}
{"text": "Write a function to create the next bigger number by rearranging the digits of a given number.", "task_id": 407, "code": "import Batteries\nopen Std\n\ndef removeFirst [BEq α] (y : α) (xs : List α) : List α :=\n  let rec loop (ys : List α) (removed : Bool) : List α :=\n    match ys with\n    | [] => []\n    | x :: xt =>\n      if !removed && x == y then\n        xt\n      else\n        x :: loop xt removed\n  loop xs false\n\ndef listMinChar (xs : List Char) (init : Char) : Char :=\n  xs.foldl (fun m x => if x < m then x else m) init\n\ndef selectionSortChar (xs : List Char) : List Char :=\n  let rec sel (fuel : Nat) (ys acc : List Char) : List Char :=\n    match fuel with\n    | 0 => acc\n    | fuel' + 1 =>\n      match ys with\n      | [] => acc\n      | _ =>\n        let m := listMinChar ys (ys.headD '0')\n        let ys' := removeFirst m ys\n        sel fuel' ys' (acc ++ [m])\n  sel xs.length xs []\n\ndef rearrangeBigger (n : Nat) : Option Nat := Id.run do\n  let s := toString n\n  let mut arr := s.data.toArray\n  let len := arr.size\n  if len < 2 then\n    return none\n  let mut found := false\n  let mut pivot := 0\n  let mut i := len - 2\n  while true do\n    if arr[i]! < arr[i+1]! then\n      found := true\n      pivot := i\n      break\n    if i == 0 then\n      break\n    i := i - 1\n  if !found then\n    return none\n  let zList := (arr.extract pivot len).toList\n  let z0 := zList.headD '0'\n  let candidates := zList.filter (fun x => x > z0)\n  if candidates.isEmpty then\n    return none\n  let y := listMinChar candidates (candidates.headD z0)\n  let zRemoved := removeFirst y zList\n  let zSorted := selectionSortChar zRemoved\n  let prefixList := (arr.extract 0 pivot).toList\n  let newList : List Char := prefixList ++ (y :: zSorted)\n  let newStr := String.mk newList\n  match String.toNat? newStr with\n  | some k => return some k\n  | none => return none\n\n#guard rearrangeBigger 12 == some 21\n#guard rearrangeBigger 10 == none\n#guard rearrangeBigger 102 == some 120\n", "test_list": ["#guard rearrangeBigger 12 == some 21", "#guard rearrangeBigger 10 == none", "#guard rearrangeBigger 102 == some 120"]}
{"text": "Write a function to find k number of pairs which consist of one element from the first array and one element from the second array.", "task_id": 408, "code": "import Batteries\n\nopen Std\n\nstructure Node where\n  s : Nat\n  i : Nat\n  j : Nat\n  deriving Repr, BEq\n\ndef lexLess (x y : Node) : Bool :=\n  if x.s < y.s then true\n  else if x.s > y.s then false\n  else if x.i < y.i then true\n  else if x.i > y.i then false\n  else x.j < y.j\n\ndef extractMin (q : List Node) : Option (Node × List Node) :=\n  match q with\n  | [] => none\n  | x :: xs =>\n    let (best, acc) := xs.foldl (fun (best, acc) y =>\n      if lexLess y best then (y, best :: acc) else (best, y :: acc)) (x, ([] : List Node))\n    some (best, acc.reverse)\n\ndef kSmallestPairs (nums1 nums2 : List Nat) (k : Nat) : List (List Nat) := Id.run do\n  let push := fun (q : List Node) (i j : Nat) =>\n    if i < nums1.length && j < nums2.length then\n      let s := nums1.getD i 0 + nums2.getD j 0\n      ({ s := s, i := i, j := j } :: q)\n    else q\n  let mut q : List Node := []\n  q := push q 0 0\n  let mut res : Array (List Nat) := #[]\n  for _ in [:k] do\n    match extractMin q with\n    | none => break\n    | some (node, q2) =>\n      res := res.push [nums1.getD node.i 0, nums2.getD node.j 0]\n      q := push q2 node.i (node.j + 1)\n      if node.j == 0 then\n        q := push q (node.i + 1) 0\n  return res.toList\n\n#guard kSmallestPairs [1,3,7] [2,4,6] 2 == [[1, 2], [1, 4]]\n#guard kSmallestPairs [1,3,7] [2,4,6] 1 == [[1, 2]]\n#guard kSmallestPairs [1,3,7] [2,4,6] 7 == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]\n", "test_list": ["#guard kSmallestPairs [1,3,7] [2,4,6] 2 == [[1, 2], [1, 4]]", "#guard kSmallestPairs [1,3,7] [2,4,6] 1 == [[1, 2]]", "#guard kSmallestPairs [1,3,7] [2,4,6] 7 == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]"]}
{"text": "Write a function to find the minimum product from the pairs of tuples within a given list.", "task_id": 409, "code": "import Batteries\n\nopen Std\n\ndef minProductTuple (list1 : List (Nat × Nat)) : Nat :=\n  match list1 with\n  | [] => 0  \n  | (x, y) :: xs =>\n    let init := x * y\n    xs.foldl (fun acc p =>\n      let v := p.fst * p.snd\n      if v < acc then v else acc) init\n\n#guard minProductTuple [(2, 7), (2, 6), (1, 8), (4, 9)] = 8\n#guard minProductTuple [(10, 20), (15, 2), (5, 10)] = 30\n#guard minProductTuple [(11, 44), (10, 15), (20, 5), (12, 9)] = 100\n", "test_list": ["#guard minProductTuple [(2, 7), (2, 6), (1, 8), (4, 9)] = 8", "#guard minProductTuple [(10, 20), (15, 2), (5, 10)] = 30", "#guard minProductTuple [(11, 44), (10, 15), (20, 5), (12, 9)] = 100"]}
{"text": "Write a function to find the minimum value in a given heterogeneous list.", "task_id": 410, "code": "import Batteries\n\nopen Std\n\ndef onlyInts (l : List (Sum String Nat)) : List Nat :=\n  l.foldr (fun x acc => match x with\n    | Sum.inr n => n :: acc\n    | Sum.inl _ => acc) []\n\ndef listMin (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | y :: ys => ys.foldl (fun m n => if n < m then n else m) y\n\ndef min_val (listval : List (Sum String Nat)) : Nat :=\n  listMin (onlyInts listval)\n\n#guard min_val [Sum.inl \"Python\", Sum.inr 3, Sum.inr 2, Sum.inr 4, Sum.inr 5, Sum.inl \"version\"] = 2\n#guard min_val [Sum.inl \"Python\", Sum.inr 15, Sum.inr 20, Sum.inr 25] = 15\n#guard min_val [Sum.inl \"Python\", Sum.inr 30, Sum.inr 20, Sum.inr 40, Sum.inr 50, Sum.inl \"version\"] = 20\n", "test_list": ["#guard min_val [Sum.inl \"Python\", Sum.inr 3, Sum.inr 2, Sum.inr 4, Sum.inr 5, Sum.inl \"version\"] = 2", "#guard min_val [Sum.inl \"Python\", Sum.inr 15, Sum.inr 20, Sum.inr 25] = 15", "#guard min_val [Sum.inl \"Python\", Sum.inr 30, Sum.inr 20, Sum.inr 40, Sum.inr 50, Sum.inl \"version\"] = 20"]}
{"text": "Write a function to convert the given snake case string to camel case string by using regex.", "task_id": 411, "code": "import Batteries\n\nopen Std\n\ndef capitalizeWord (s : String) : String :=\n  if s.length = 0 then \"\"\n  else\n    let first := s.take 1\n    let rest := s.drop 1\n    let firstUp := first.map (fun c => c.toUpper)\n    let restLow := rest.map (fun c => c.toLower)\n    firstUp ++ restLow\n\ndef snakeToCamel (word : String) : String :=\n  let parts := word.splitOn \"_\"\n  parts.foldl (fun acc x =>\n    let cap := capitalizeWord x\n    let piece := if cap == \"\" then \"_\" else cap\n    acc ++ piece\n  ) \"\"\n\n#guard snakeToCamel \"android_tv\" == \"AndroidTv\"\n#guard snakeToCamel \"google_pixel\" == \"GooglePixel\"\n#guard snakeToCamel \"apple_watch\" == \"AppleWatch\"\n", "test_list": ["#guard snakeToCamel \"android_tv\" == \"AndroidTv\"", "#guard snakeToCamel \"google_pixel\" == \"GooglePixel\"", "#guard snakeToCamel \"apple_watch\" == \"AppleWatch\""]}
{"text": "Write a python function to remove odd numbers from a given list.", "task_id": 412, "code": "import Batteries\nopen Std\n\ndef removeFirst (l : List Nat) (x : Nat) : List Nat :=\n  match l with\n  | [] => []\n  | y :: ys => if y = x then ys else y :: removeFirst ys x\n\ndef nthD (l : List Nat) (n : Nat) (d : Nat) : Nat :=\n  match l, n with\n  | [], _ => d\n  | x :: _, 0 => x\n  | _ :: xs, n+1 => nthD xs n d\n\ndef remove_odd (l : List Nat) : List Nat := Id.run do\n  let mut cur := l\n  let mut idx : Nat := 0\n  while idx < cur.length do\n    let x := nthD cur idx 0\n    if x % 2 ≠ 0 then\n      \n      cur := removeFirst cur x\n      \n      idx := idx + 1\n    else\n      idx := idx + 1\n  return cur\n\n#guard remove_odd [1, 2, 3] = [2]\n#guard remove_odd [2, 4, 6] = [2, 4, 6]\n#guard remove_odd [10, 20, 3] = [10, 20]\n", "test_list": ["#guard remove_odd [1, 2, 3] = [2]", "#guard remove_odd [2, 4, 6] = [2, 4, 6]", "#guard remove_odd [10, 20, 3] = [10, 20]"]}
{"text": "Write a function to extract the nth element from a given list of tuples.", "task_id": 413, "code": "import Batteries\n\nopen Std\n\ndef extractNthElement (list1 : List (String × Nat × Nat)) (n : Nat) : List (Sum String Nat) :=\n  match n with\n  | 0 => list1.map (fun x => Sum.inl x.fst)\n  | 1 => list1.map (fun x => Sum.inr x.snd.fst)\n  | 2 => list1.map (fun x => Sum.inr x.snd.snd)\n  | _ => []\n\n#guard extractNthElement [(\"Greyson Fulton\", (98, 99)), (\"Brady Kent\", (97, 96)), (\"Wyatt Knott\", (91, 94)), (\"Beau Turnbull\", (94, 98))] 0\n  == [Sum.inl \"Greyson Fulton\", Sum.inl \"Brady Kent\", Sum.inl \"Wyatt Knott\", Sum.inl \"Beau Turnbull\"]\n\n#guard extractNthElement [(\"Greyson Fulton\", (98, 99)), (\"Brady Kent\", (97, 96)), (\"Wyatt Knott\", (91, 94)), (\"Beau Turnbull\", (94, 98))] 2\n  == [Sum.inr 99, Sum.inr 96, Sum.inr 94, Sum.inr 98]\n\n#guard extractNthElement [(\"Greyson Fulton\", (98, 99)), (\"Brady Kent\", (97, 96)), (\"Wyatt Knott\", (91, 94)), (\"Beau Turnbull\", (94, 98))] 1\n  == [Sum.inr 98, Sum.inr 97, Sum.inr 91, Sum.inr 94]\n", "test_list": ["#guard extractNthElement [(\"Greyson Fulton\", (98, 99)), (\"Brady Kent\", (97, 96)), (\"Wyatt Knott\", (91, 94)), (\"Beau Turnbull\", (94, 98))] 0", "#guard extractNthElement [(\"Greyson Fulton\", (98, 99)), (\"Brady Kent\", (97, 96)), (\"Wyatt Knott\", (91, 94)), (\"Beau Turnbull\", (94, 98))] 2", "#guard extractNthElement [(\"Greyson Fulton\", (98, 99)), (\"Brady Kent\", (97, 96)), (\"Wyatt Knott\", (91, 94)), (\"Beau Turnbull\", (94, 98))] 1"]}
{"text": "Write a python function to check whether the value exists in a sequence or not.", "task_id": 414, "code": "import Batteries\nopen Std\n\nprivate def getAt (xs : List Nat) (i : Nat) (default : Nat) : Nat :=\n  match xs.drop i with\n  | [] => default\n  | a :: _ => a\n\ndef overlapping (list1 list2 : List Nat) : Bool := Id.run do\n  let mut c := 0\n  let mut d := 0\n  for _ in list1 do\n    c := c + 1\n  for _ in list2 do\n    d := d + 1\n  for i in [0:c] do\n    for j in [0:d] do\n      let a := getAt list1 i 0\n      let b := getAt list2 j 0\n      if a == b then\n        return true\n  return false\n\n#guard overlapping [1,2,3,4,5] [6,7,8,9] == false\n#guard overlapping [1,2,3] [4,5,6] == false\n#guard overlapping [1,4,5] [1,4,5] == true\n", "test_list": ["#guard overlapping [1,2,3,4,5] [6,7,8,9] == false", "#guard overlapping [1,2,3] [4,5,6] == false", "#guard overlapping [1,4,5] [1,4,5] == true"]}
{"text": "Write a python function to find a pair with highest product from a given array of integers.", "task_id": 415, "code": "import Batteries\nopen Std\n\nprivate def listGet? (xs : List α) (i : Nat) : Option α :=\n  match xs, i with\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs', i+1 => listGet? xs' i\n\ndef maxProduct (arr : List Int) : Sum String (Int × Int) := Id.run do\n  let arrLen := arr.length\n  if arrLen < 2 then\n    return Sum.inl \"No pairs exists\"\n  let init :=\n    match arr with\n    | x :: y :: _ => (x, y)\n    | _ => (0, 0)\n  let mut x : Int := init.fst\n  let mut y : Int := init.snd\n  for i in [0:arrLen] do\n    for j in [i+1:arrLen] do\n      let a := (listGet? arr i).getD (0 : Int)\n      let b := (listGet? arr j).getD (0 : Int)\n      if a * b > x * y then\n        x := a\n        y := b\n  return Sum.inr (x, y)\n\n#guard maxProduct [1,2,3,4,7,0,8,4] == Sum.inr (7,8)\n#guard maxProduct [0,-1,-2,-4,5,0,-6] == Sum.inr (-4,-6)\n#guard maxProduct [1,2,3] == Sum.inr (2,3)\n", "test_list": ["#guard maxProduct [1,2,3,4,7,0,8,4] == Sum.inr (7,8)", "#guard maxProduct [0,-1,-2,-4,5,0,-6] == Sum.inr (-4,-6)", "#guard maxProduct [1,2,3] == Sum.inr (2,3)"]}
{"text": "Write a function to find the maximum sum we can make by dividing number in three parts recursively and summing them up together for the given number.", "task_id": 416, "code": "import Batteries\n\nopen Std\n\ndef MAX : Nat := 1000000\n\ndef breakSum (n : Nat) : Nat := Id.run do\n  let mut dp := Array.replicate (n+1) 0\n  dp := dp.set! 0 0\n  dp := dp.set! 1 1\n  for i in [2 : n+1] do\n    let v := max (dp[i/2]! + dp[i/3]! + dp[i/4]!) i\n    dp := dp.set! i v\n  return dp[n]!\n\n#guard breakSum 12 = 13\n#guard breakSum 24 = 27\n#guard breakSum 23 = 23\n", "test_list": ["#guard breakSum 12 = 13", "#guard breakSum 24 = 27", "#guard breakSum 23 = 23"]}
{"text": "Write a function to find common first element in given list of tuple.", "task_id": 417, "code": "import Batteries\n\nopen Std\n\nprivate def updateOrInsert (out : List (String × List String)) (k : String) (tail : List String) : List (String × List String) :=\n  let rec go (xs : List (String × List String)) : (List (String × List String) × Bool) :=\n    match xs with\n    | [] => ([], false)\n    | (k', v) :: xs' =>\n      let (rest, found) := go xs'\n      if k' == k then\n        ((k', v ++ tail) :: rest, true)\n      else\n        ((k', v) :: rest, found)\n  let (res, found) := go out\n  if found then res else res ++ [(k, k :: tail)]\n\ndef groupTuples (input : List (List String)) : List (List String) := Id.run do\n  let mut outPairs : List (String × List String) := []\n  for elem in input do\n    match elem with\n    | [] => ()\n    | h :: t => outPairs := updateOrInsert outPairs h t\n  return outPairs.map (fun p => p.snd)\n\n#guard groupTuples [[\"x\", \"y\"], [\"x\", \"z\"], [\"w\", \"t\"]] = [[\"x\", \"y\", \"z\"], [\"w\", \"t\"]]\n#guard groupTuples [[\"a\", \"b\"], [\"a\", \"c\"], [\"d\", \"e\"]] = [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]\n#guard groupTuples [[\"f\", \"g\"], [\"f\", \"g\"], [\"h\", \"i\"]] = [[\"f\", \"g\", \"g\"], [\"h\", \"i\"]]\n", "test_list": ["#guard groupTuples [[\"x\", \"y\"], [\"x\", \"z\"], [\"w\", \"t\"]] = [[\"x\", \"y\", \"z\"], [\"w\", \"t\"]]", "#guard groupTuples [[\"a\", \"b\"], [\"a\", \"c\"], [\"d\", \"e\"]] = [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]]", "#guard groupTuples [[\"f\", \"g\"], [\"f\", \"g\"], [\"h\", \"i\"]] = [[\"f\", \"g\", \"g\"], [\"h\", \"i\"]]"]}
{"text": "Write a python function to find the sublist having maximum length.", "task_id": 418, "code": "import Batteries\n\nopen Std\n\ndef Find_Max {α : Type} (lst : List (List α)) : List α :=\n  \n  match lst with\n  | [] => []\n  | x :: xs =>\n    xs.foldl (fun best y => if y.length > best.length then y else best) x\n\n#guard Find_Max [[\"A\"], [\"A\",\"B\"], [\"A\",\"B\",\"C\"]] = [\"A\",\"B\",\"C\"]\n#guard Find_Max [[1], [1,2], [1,2,3]] = [1,2,3]\n#guard Find_Max [[1,1], [1,2,3], [1,5,6,1]] = [1,5,6,1]\n", "test_list": ["#guard Find_Max [[\"A\"], [\"A\",\"B\"], [\"A\",\"B\",\"C\"]] = [\"A\",\"B\",\"C\"]", "#guard Find_Max [[1], [1,2], [1,2,3]] = [1,2,3]", "#guard Find_Max [[1,1], [1,2,3], [1,5,6,1]] = [1,5,6,1]"]}
{"text": "Write a python function to find the cube sum of first n even natural numbers.", "task_id": 420, "code": "import Batteries\n\nopen Std\n\ndef cube_Sum (n : Nat) : Nat := Id.run do\n  let mut s := 0\n  for i in [1 : n + 1] do\n    s := s + (2 * i) * (2 * i) * (2 * i)\n  return s\n\n#guard cube_Sum 2 = 72\n#guard cube_Sum 3 = 288\n#guard cube_Sum 4 = 800\n", "test_list": ["#guard cube_Sum 2 = 72", "#guard cube_Sum 3 = 288", "#guard cube_Sum 4 = 800"]}
{"text": "Write a function to concatenate each element of tuple by the delimiter.", "task_id": 421, "code": "import Batteries\n\nopen Std\n\ndef concatenateTuple (test_tup : List String) : String :=\n  let delim := \"-\"\n  let res := (test_tup.map (fun ele => toString ele ++ delim)).foldl (· ++ ·) \"\"\n  let res := res.take (res.length - delim.length)\n  toString res\n\n#guard concatenateTuple [\"ID\", \"is\", \"4\", \"UTS\"] = \"ID-is-4-UTS\"\n#guard concatenateTuple [\"QWE\", \"is\", \"4\", \"RTY\"] = \"QWE-is-4-RTY\"\n#guard concatenateTuple [\"ZEN\", \"is\", \"4\", \"OP\"] = \"ZEN-is-4-OP\"\n", "test_list": ["#guard concatenateTuple [\"ID\", \"is\", \"4\", \"UTS\"] = \"ID-is-4-UTS\"", "#guard concatenateTuple [\"QWE\", \"is\", \"4\", \"RTY\"] = \"QWE-is-4-RTY\"", "#guard concatenateTuple [\"ZEN\", \"is\", \"4\", \"OP\"] = \"ZEN-is-4-OP\""]}
{"text": "Write a python function to find the average of cubes of first n natural numbers.", "task_id": 422, "code": "import Batteries\n\nopen Std\n\ndef findAverageOfCube (n : Nat) : Float := Id.run do\n  \n  let mut s : Nat := 0\n  for i in [1 : n+1] do\n    s := s + i * i * i\n  let avg := (Float.ofNat s) / (Float.ofNat n)\n  \n  return avg\n\n#guard findAverageOfCube 2 == 4.5\n#guard findAverageOfCube 3 == 12.0\n#guard findAverageOfCube 1 == 1.0\n", "test_list": ["#guard findAverageOfCube 2 == 4.5", "#guard findAverageOfCube 3 == 12.0", "#guard findAverageOfCube 1 == 1.0"]}
{"text": "Write a function to solve gold mine problem.", "task_id": 423, "code": "import Batteries\nopen Std\n\ndef modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef get2d {α : Type} (l : List (List α)) (y x : Nat) (fallback : α) :=\n  (l.getD y []).getD x fallback\n\ndef get_maxgold (gold : List (List Nat)) (m n : Nat) : Nat := Id.run do\n  let mut goldTable : Array (Array Nat) := Array.replicate m (Array.replicate n 0)\n  \n  for c in [0 : n] do\n    let col := n - 1 - c\n    for row in [0 : m] do\n      let right := if col == n - 1 then 0 else goldTable.get2d row (col+1) 0\n      let right_up := if row == 0 || col == n - 1 then 0 else goldTable.get2d (row-1) (col+1) 0\n      let right_down := if row == m - 1 || col == n - 1 then 0 else goldTable.get2d (row+1) (col+1) 0\n      let best := Nat.max (Nat.max right right_up) right_down\n      let val := gold.get2d row col 0 + best\n      goldTable := goldTable.set2d? row col val\n  let mut res := goldTable.get2d 0 0 0\n  for i in [1 : m] do\n    res := Nat.max res (goldTable.get2d i 0 0)\n  return res\n\n#guard get_maxgold [[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]] 4 4 = 16\n#guard get_maxgold [[10,20],[30,40]] 2 2 = 70\n#guard get_maxgold [[4,9],[3,7]] 2 2 = 13\n", "test_list": ["#guard get_maxgold [[1, 3, 1, 5],[2, 2, 4, 1],[5, 0, 2, 3],[0, 6, 1, 2]] 4 4 = 16", "#guard get_maxgold [[10,20],[30,40]] 2 2 = 70", "#guard get_maxgold [[4,9],[3,7]] 2 2 = 13"]}
{"text": "Write a function to extract only the rear index element of each string in the given tuple.", "task_id": 424, "code": "import Batteries\n\nopen Std\n\ndef extractRear (testTuple : List String) : List String :=\n  testTuple.map (fun s => (s.drop (s.length - 1)).take 1)\n\n#guard extractRear [\"Mers\", \"for\", \"Vers\"] == [\"s\", \"r\", \"s\"]\n#guard extractRear [\"Avenge\", \"for\", \"People\"] == [\"e\", \"r\", \"e\"]\n#guard extractRear [\"Gotta\", \"get\", \"go\"] == [\"a\", \"t\", \"o\"]\n", "test_list": ["#guard extractRear [\"Mers\", \"for\", \"Vers\"] == [\"s\", \"r\", \"s\"]", "#guard extractRear [\"Avenge\", \"for\", \"People\"] == [\"e\", \"r\", \"e\"]", "#guard extractRear [\"Gotta\", \"get\", \"go\"] == [\"a\", \"t\", \"o\"]"]}
{"text": "Write a function to count the number of sublists containing a particular element.", "task_id": 425, "code": "import Batteries\n\nopen Std\n\ndef count_element_in_list {α : Type} [BEq α] (list1 : List (List α)) (x : α) : Nat := Id.run do\n  let mut ctr := 0\n  for sub in list1 do\n    if sub.contains x then\n      ctr := ctr + 1\n  return ctr\n\n#guard count_element_in_list [[1, 3], [5, 7], [1, 11], [1, 15, 7]] 1 == 3\n#guard count_element_in_list [[\"A\", \"B\"], [\"A\", \"C\"], [\"A\", \"D\", \"E\"], [\"B\", \"C\", \"D\"]] \"A\" == 3\n#guard count_element_in_list [[\"A\", \"B\"], [\"A\", \"C\"], [\"A\", \"D\", \"E\"], [\"B\", \"C\", \"D\"]] \"E\" == 1\n", "test_list": ["#guard count_element_in_list [[1, 3], [5, 7], [1, 11], [1, 15, 7]] 1 == 3", "#guard count_element_in_list [[\"A\", \"B\"], [\"A\", \"C\"], [\"A\", \"D\", \"E\"], [\"B\", \"C\", \"D\"]] \"A\" == 3", "#guard count_element_in_list [[\"A\", \"B\"], [\"A\", \"C\"], [\"A\", \"D\", \"E\"], [\"B\", \"C\", \"D\"]] \"E\" == 1"]}
{"text": "Write a function to filter odd numbers using lambda function.", "task_id": 426, "code": "import Batteries\n\nopen Std\n\ndef filterOddnumbers (nums : List Nat) : List Nat :=\n  nums.filter (fun x => x % 2 != 0)\n\n#guard filterOddnumbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1,3,5,7,9]\n#guard filterOddnumbers [10,20,45,67,84,93] == [45,67,93]\n#guard filterOddnumbers [5,7,9,8,6,4,3] == [5,7,9,3]\n", "test_list": ["#guard filterOddnumbers [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1,3,5,7,9]", "#guard filterOddnumbers [10,20,45,67,84,93] == [45,67,93]", "#guard filterOddnumbers [5,7,9,8,6,4,3] == [5,7,9,3]"]}
{"text": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format by using regex.", "task_id": 427, "code": "import Batteries\n\nopen Std\n\ndef changeDateFormat (dt : String) : String :=\n  match dt.splitOn \"-\" with\n  | [y, m, d] => d ++ \"-\" ++ m ++ \"-\" ++ y\n  | _ => dt\n\n#guard changeDateFormat \"2026-01-02\" = \"02-01-2026\"\n#guard changeDateFormat \"2020-11-13\" = \"13-11-2020\"\n#guard changeDateFormat \"2021-04-26\" = \"26-04-2021\"\n", "test_list": ["#guard changeDateFormat \"2026-01-02\" = \"02-01-2026\"", "#guard changeDateFormat \"2020-11-13\" = \"13-11-2020\"", "#guard changeDateFormat \"2021-04-26\" = \"26-04-2021\""]}
{"text": "Write a function to sort the given array by using shell sort.", "task_id": 428, "code": "import Batteries\n\nopen Std\n\ndef shellSort (my_list : List Nat) : List Nat := Id.run do\n  let mut a := my_list.toArray\n  let n := a.size\n  let mut gap := n / 2\n  while gap > 0 do\n    for i in [gap : n] do\n      let current_item := a[i]!\n      let mut j := i\n      while j >= gap do\n        let prev := a[j - gap]!\n        if prev > current_item then\n          a := a.set! j prev\n          j := j - gap\n        else\n          break\n      a := a.set! j current_item\n    gap := gap / 2\n  return a.toList\n\n#guard shellSort [12, 23, 4, 5, 3, 2, 12, 81, 56, 95] == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n#guard shellSort [24, 22, 39, 34, 87, 73, 68] == [22, 24, 34, 39, 68, 73, 87]\n#guard shellSort [32, 30, 16, 96, 82, 83, 74] == [16, 30, 32, 74, 82, 83, 96]\n", "test_list": ["#guard shellSort [12, 23, 4, 5, 3, 2, 12, 81, 56, 95] == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]", "#guard shellSort [24, 22, 39, 34, 87, 73, 68] == [22, 24, 34, 39, 68, 73, 87]", "#guard shellSort [32, 30, 16, 96, 82, 83, 74] == [16, 30, 32, 74, 82, 83, 96]"]}
{"text": "Write a function to extract the elementwise and tuples from the given two tuples.", "task_id": 429, "code": "import Batteries\n\nopen Std\n\ndef andTuples (test_tup1 : List Nat) (test_tup2 : List Nat) : List Nat :=\n  (List.zip test_tup1 test_tup2).map (fun (a, b) => a &&& b)\n\n#guard andTuples [10, 4, 6, 9] [5, 2, 3, 3] == [0, 0, 2, 1]\n#guard andTuples [1, 2, 3, 4] [5, 6, 7, 8] == [1, 2, 3, 0]\n#guard andTuples [8, 9, 11, 12] [7, 13, 14, 17] == [0, 9, 10, 0]\n", "test_list": ["#guard andTuples [10, 4, 6, 9] [5, 2, 3, 3] == [0, 0, 2, 1]", "#guard andTuples [1, 2, 3, 4] [5, 6, 7, 8] == [1, 2, 3, 0]", "#guard andTuples [8, 9, 11, 12] [7, 13, 14, 17] == [0, 9, 10, 0]"]}
{"text": "Write a function to find the directrix of a parabola.", "task_id": 430, "code": "import Batteries\n\nopen Std\n\ndef parabolaDirectrix (a b c : Int) : Int :=\n  let directrix := c - ((b * b) + 1) * 4 * a\n  directrix\n\n#guard parabolaDirectrix 5 3 2 = -198\n#guard parabolaDirectrix 9 8 4 = -2336\n#guard parabolaDirectrix 2 4 6 = -130\n", "test_list": ["#guard parabolaDirectrix 5 3 2 = -198", "#guard parabolaDirectrix 9 8 4 = -2336", "#guard parabolaDirectrix 2 4 6 = -130"]}
{"text": "Write a function that takes two lists and returns true if they have at least one common element.", "task_id": 431, "code": "import Batteries\n\nopen Std\n\ndef commonElement [BEq α] (list1 list2 : List α) : Option Bool := Id.run do\n  let mut result := false\n  for x in list1 do\n    for y in list2 do\n      if x == y then\n        result := true\n        return some result\n  return none\n\n#guard commonElement [1,2,3,4,5] [5,6,7,8,9] == some true\n#guard commonElement [1,2,3,4,5] [6,7,8,9] == none\n#guard commonElement [\"a\",\"b\",\"c\"] [\"d\",\"b\",\"e\"] == some true\n", "test_list": ["#guard commonElement [1,2,3,4,5] [5,6,7,8,9] == some true", "#guard commonElement [1,2,3,4,5] [6,7,8,9] == none", "#guard commonElement [\"a\",\"b\",\"c\"] [\"d\",\"b\",\"e\"] == some true"]}
{"text": "Write a function to find the median of a trapezium.", "task_id": 432, "code": "import Batteries\n\nopen Std\n\ndef medianTrapezium (base1 base2 height : Nat) : Float :=\n  let median := 0.5 * Float.ofNat (base1 + base2)\n  median\n\n#guard medianTrapezium 15 25 35 == 20.0\n#guard medianTrapezium 10 20 30 == 15.0\n#guard medianTrapezium 6 9 4 == 7.5\n", "test_list": ["#guard medianTrapezium 15 25 35 == 20.0", "#guard medianTrapezium 10 20 30 == 15.0", "#guard medianTrapezium 6 9 4 == 7.5"]}
{"text": "Write a function to check whether the entered number is greater than the elements of the given array.", "task_id": 433, "code": "import Batteries\n\nopen Std\n\ndef insertNat (x : Nat) : List Nat → List Nat\n  | [] => [x]\n  | y :: ys => if Nat.ble x y then x :: y :: ys else y :: insertNat x ys\n\ndef isortNat : List Nat → List Nat\n  | [] => []\n  | x :: xs => insertNat x (isortNat xs)\n\ndef lastNatD (xs : List Nat) (d : Nat) : Nat :=\n  match xs with\n  | [] => d\n  | [x] => x\n  | _ :: xs' => lastNatD xs' d\n\ndef check_greater (arr : List Nat) (number : Nat) : String :=\n  let arrSorted := isortNat arr\n  let last := lastNatD arrSorted 0\n  if number > last then\n    \"Yes, the entered number is greater than those in the array\"\n  else\n    \"No, entered number is less than those in the array\"\n\n#guard check_greater [1, 2, 3, 4, 5] 4 == \"No, entered number is less than those in the array\"\n#guard check_greater [2, 3, 4, 5, 6] 8 == \"Yes, the entered number is greater than those in the array\"\n#guard check_greater [9, 7, 4, 8, 6, 1] 11 == \"Yes, the entered number is greater than those in the array\"\n", "test_list": ["#guard check_greater [1, 2, 3, 4, 5] 4 == \"No, entered number is less than those in the array\"", "#guard check_greater [2, 3, 4, 5, 6] 8 == \"Yes, the entered number is greater than those in the array\"", "#guard check_greater [9, 7, 4, 8, 6, 1] 11 == \"Yes, the entered number is greater than those in the array\""]}
{"text": "Write a function that matches a string that has an a followed by one or more b's.", "task_id": 434, "code": "import Batteries\n\nopen Std\n\ndef hasAB (s : String) : Bool :=\n  let rec go (cs : List Char) : Bool :=\n    match cs with\n    | c1 :: c2 :: rest =>\n      if c1 == 'a' && c2 == 'b' then\n        true\n      else\n        go (c2 :: rest)\n    | _ => false\n  go s.data\n\ndef text_match_one (text : String) : String :=\n  if hasAB text then \"Found a match!\" else \"Not matched!\"\n\n#guard text_match_one \"ac\" == \"Not matched!\"\n#guard text_match_one \"dc\" == \"Not matched!\"\n#guard text_match_one \"abba\" == \"Found a match!\"\n", "test_list": ["#guard text_match_one \"ac\" == \"Not matched!\"", "#guard text_match_one \"dc\" == \"Not matched!\"", "#guard text_match_one \"abba\" == \"Found a match!\""]}
{"text": "Write a python function to find the last digit of a given number.", "task_id": 435, "code": "import Batteries\n\nopen Std\n\ndef lastDigit (n : Nat) : Nat :=\n  n % 10\n\n#guard lastDigit 123 = 3\n#guard lastDigit 25 = 5\n#guard lastDigit 30 = 0\n", "test_list": ["#guard lastDigit 123 = 3", "#guard lastDigit 25 = 5", "#guard lastDigit 30 = 0"]}
{"text": "Write a python function to print negative numbers in a list.", "task_id": 436, "code": "import Batteries\n\nopen Std\n\ndef negNos (list1 : List Int) : Int :=\n  match list1 with\n  | [] => 0 \n  | num :: rest =>\n    if num < 0 then num else negNos rest\n\n#guard negNos [-1, 4, 5, -6] = -1\n#guard negNos [-1, -2, 3, 4] = -1\n#guard negNos [-7, -6, 8, 9] = -7\n", "test_list": ["#guard negNos [-1, 4, 5, -6] = -1", "#guard negNos [-1, -2, 3, 4] = -1", "#guard negNos [-7, -6, 8, 9] = -7"]}
{"text": "Write a function to remove odd characters in a string.", "task_id": 437, "code": "import Batteries\n\nopen Std\n\ndef removeOdd (str1 : String) : String := Id.run do\n  let n := str1.length\n  let mut str2 := \"\"\n  for i in [1 : n + 1] do\n    if i % 2 == 0 then\n      str2 := str2 ++ (str1.drop (i - 1)).take 1\n  return str2\n\n#guard removeOdd \"python\" = \"yhn\"\n#guard removeOdd \"program\" = \"rga\"\n#guard removeOdd \"language\" = \"agae\"\n", "test_list": ["#guard removeOdd \"python\" = \"yhn\"", "#guard removeOdd \"program\" = \"rga\"", "#guard removeOdd \"language\" = \"agae\""]}
{"text": "Write a function to count bidirectional tuple pairs.", "task_id": 438, "code": "import Batteries\n\nopen Std\n\ndef countBidirectional (testList : List (Nat × Nat)) : String := Id.run do\n  let n := testList.length\n  let mut res := 0\n  for idx in [0 : n] do\n    for iidx in [idx + 1 : n] do\n      let a := testList.getD iidx (0, 0)\n      let b := testList.getD idx (0, 0)\n      if a.fst == b.snd && b.snd == a.fst then\n        res := res + 1\n  return toString res\n\n#guard countBidirectional [(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] = \"3\"\n#guard countBidirectional [(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] = \"2\"\n#guard countBidirectional [(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] = \"4\"\n", "test_list": ["#guard countBidirectional [(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] = \"3\"", "#guard countBidirectional [(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] = \"2\"", "#guard countBidirectional [(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] = \"4\""]}
{"text": "Write a function to convert a list of multiple integers into a single integer.", "task_id": 439, "code": "import Batteries\n\nopen Std\n\ndef multipleToSingle (L : List Int) : Int :=\n  let s := L.foldl (fun acc x => acc ++ toString x) \"\"\n  match s.toInt? with\n  | some v => v\n  | none => 0\n\n#guard multipleToSingle [11, 33, 50] == 113350\n#guard multipleToSingle [-1, 2, 3, 4, 5, 6] == -123456\n#guard multipleToSingle [10, 15, 20, 25] == 10152025\n", "test_list": ["#guard multipleToSingle [11, 33, 50] == 113350", "#guard multipleToSingle [-1, 2, 3, 4, 5, 6] == -123456", "#guard multipleToSingle [10, 15, 20, 25] == 10152025"]}
{"text": "Write a function to find the surface area of a cube.", "task_id": 441, "code": "import Batteries\n\nopen Std\n\ndef surfacearea_cube (l : Nat) : Nat :=\n  let surfacearea := 6 * l * l\n  surfacearea\n\n#guard surfacearea_cube 5 = 150\n#guard surfacearea_cube 3 = 54\n#guard surfacearea_cube 10 = 600\n", "test_list": ["#guard surfacearea_cube 5 = 150", "#guard surfacearea_cube 3 = 54", "#guard surfacearea_cube 10 = 600"]}
{"text": "Write a python function to find the largest negative number from the given list.", "task_id": 443, "code": "import Batteries\n\nopen Std\n\ndef largest_neg (list1 : List Int) : Int := Id.run do\n  let mut m := match list1 with\n    | [] => 0\n    | h :: _ => h\n  for x in list1 do\n    if x < m then\n      m := x\n  return m\n\n#guard largest_neg ([1, 2, 3, -4, -6] : List Int) = -6\n#guard largest_neg ([1, 2, 3, -8, -9] : List Int) = -9\n#guard largest_neg ([1, 2, 3, 4, -1] : List Int) = -1\n", "test_list": ["#guard largest_neg ([1, 2, 3, -4, -6] : List Int) = -6", "#guard largest_neg ([1, 2, 3, -8, -9] : List Int) = -9", "#guard largest_neg ([1, 2, 3, 4, -1] : List Int) = -1"]}
{"text": "Write a function to trim each tuple by k in the given tuple list.", "task_id": 444, "code": "import Batteries\n\nopen Std\n\ndef joinWith (sep : String) (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: xs => xs.foldl (fun acc y => acc ++ sep ++ y) x\n\ndef formatTuple (xs : List Nat) : String :=\n  match xs with\n  | [] => \"()\"\n  | [x] => \"(\" ++ toString x ++ \",)\"\n  | _ => \"(\" ++ joinWith \", \" (xs.map (fun x => toString x)) ++ \")\"\n\ndef trimTuple (test_list : List (List Nat)) (K : Nat) : String :=\n  let res := test_list.map (fun ele =>\n    let N := ele.length\n    (ele.drop K).take (N - (K + K))\n  )\n  let tupleStrs := res.map formatTuple\n  \"[\" ++ joinWith \", \" tupleStrs ++ \"]\"\n\n#guard trimTuple [[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]] 2 = \"[(2,), (9,), (2,), (2,)]\"\n#guard trimTuple [[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]] 1 = \"[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]\"\n#guard trimTuple [[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]] 1 = \"[(8, 4), (8, 12), (1, 7), (6, 9)]\"\n", "test_list": ["#guard trimTuple [[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]] 2 = \"[(2,), (9,), (2,), (2,)]\"", "#guard trimTuple [[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]] 1 = \"[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]\"", "#guard trimTuple [[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]] 1 = \"[(8, 4), (8, 12), (1, 7), (6, 9)]\""]}
{"text": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.", "task_id": 445, "code": "import Batteries\n\nopen Std\n\ndef indexMultiplication (test_tup1 : List (List Nat)) (test_tup2 : List (List Nat)) : List (List Nat) :=\n  (List.zip test_tup1 test_tup2).map (fun (t1, t2) =>\n    (List.zip t1 t2).map (fun (a, b) => a * b))\n\n#guard indexMultiplication [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] = [[6, 21], [12, 45], [2, 9], [7, 30]]\n#guard indexMultiplication [[2, 4], [5, 6], [3, 10], [2, 11]] [[7, 8], [4, 10], [2, 2], [8, 4]] = [[14, 32], [20, 60], [6, 20], [16, 44]]\n#guard indexMultiplication [[3, 5], [6, 7], [4, 11], [3, 12]] [[8, 9], [5, 11], [3, 3], [9, 5]] = [[24, 45], [30, 77], [12, 33], [27, 60]]\n", "test_list": ["#guard indexMultiplication [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] = [[6, 21], [12, 45], [2, 9], [7, 30]]", "#guard indexMultiplication [[2, 4], [5, 6], [3, 10], [2, 11]] [[7, 8], [4, 10], [2, 2], [8, 4]] = [[14, 32], [20, 60], [6, 20], [16, 44]]", "#guard indexMultiplication [[3, 5], [6, 7], [4, 11], [3, 12]] [[8, 9], [5, 11], [3, 3], [9, 5]] = [[24, 45], [30, 77], [12, 33], [27, 60]]"]}
{"text": "Write a python function to count the occurence of all elements of list in a tuple.", "task_id": 446, "code": "import Batteries\n\nopen Std\n\ndef count_Occurrence {α : Type} [BEq α] (tup : List α) (lst : List α) : Nat := Id.run do\n  let mut count := 0\n  for item in tup do\n    if lst.contains item then\n      count := count + 1\n  return count\n\n#guard count_Occurrence [\"a\", \"a\", \"c\", \"b\", \"d\"] [\"a\", \"b\"] = 3\n#guard count_Occurrence [1, 2, 3, 1, 4, 6, 7, 1, 4] [1, 4, 7] = 6\n#guard count_Occurrence [1, 2, 3, 4, 5, 6] [1, 2] = 2\n", "test_list": ["#guard count_Occurrence [\"a\", \"a\", \"c\", \"b\", \"d\"] [\"a\", \"b\"] = 3", "#guard count_Occurrence [1, 2, 3, 1, 4, 6, 7, 1, 4] [1, 4, 7] = 6", "#guard count_Occurrence [1, 2, 3, 4, 5, 6] [1, 2] = 2"]}
{"text": "Write a function to find cubes of individual elements in a list using lambda function.", "task_id": 447, "code": "import Batteries\n\nopen Std\n\ndef cubeNums (nums : List Nat) : List Nat :=\n  nums.map (fun x => x ^ 3)\n\n#guard cubeNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n#guard cubeNums [10, 20, 30] == [1000, 8000, 27000]\n#guard cubeNums [12, 15] == [1728, 3375]\n", "test_list": ["#guard cubeNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]", "#guard cubeNums [10, 20, 30] == [1000, 8000, 27000]", "#guard cubeNums [12, 15] == [1728, 3375]"]}
{"text": "Write a function to calculate the sum of perrin numbers.", "task_id": 448, "code": "import Batteries\n\nopen Std\n\ndef calSum (n : Nat) : Nat := Id.run do\n  let mut a := 3\n  let mut b := 0\n  let mut c := 2\n  if n == 0 then\n    return 3\n  if n == 1 then\n    return 3\n  if n == 2 then\n    return 5\n  let mut s := 5\n  let mut m := n\n  while m > 2 do\n    let d := a + b\n    s := s + d\n    a := b\n    b := c\n    c := d\n    m := m - 1\n  return s\n\n#guard calSum 9 = 49\n#guard calSum 10 = 66\n#guard calSum 11 = 88\n", "test_list": ["#guard calSum 9 = 49", "#guard calSum 10 = 66", "#guard calSum 11 = 88"]}
{"text": "Write a python function to check whether the triangle is valid or not if 3 points are given.", "task_id": 449, "code": "import Batteries\n\nopen Std\n\ndef check_Triangle (x1 y1 x2 y2 x3 y3 : Int) : String :=\n  let a := x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n  if a == 0 then \"No\" else \"Yes\"\n\n#guard check_Triangle 1 5 2 5 4 6 == \"Yes\"\n#guard check_Triangle 1 1 1 4 1 5 == \"No\"\n#guard check_Triangle 1 1 1 1 1 1 == \"No\"\n", "test_list": ["#guard check_Triangle 1 5 2 5 4 6 == \"Yes\"", "#guard check_Triangle 1 1 1 4 1 5 == \"No\"", "#guard check_Triangle 1 1 1 1 1 1 == \"No\""]}
{"text": "Write a function to extract specified size of strings from a give list of string values.", "task_id": 450, "code": "import Batteries\n\nopen Std\n\ndef extract_string (str : List String) (l : Nat) : List String :=\n  str.filter (fun e => e.length == l)\n\n#guard extract_string [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"] 8 == [\"practice\", \"solution\"]\n#guard extract_string [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"] 6 == [\"Python\"]\n#guard extract_string [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"] 9 == [\"exercises\"]\n", "test_list": ["#guard extract_string [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"] 8 == [\"practice\", \"solution\"]", "#guard extract_string [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"] 6 == [\"Python\"]", "#guard extract_string [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"] 9 == [\"exercises\"]"]}
{"text": "Write a function to remove all whitespaces from the given string using regex.", "task_id": 451, "code": "import Batteries\n\nopen Std\n\ndef removeWhitespaces (text1 : String) : String :=\n  String.mk (text1.toList.filter (fun c => !c.isWhitespace))\n\n#guard removeWhitespaces \" Google    Flutter \" == \"GoogleFlutter\"\n#guard removeWhitespaces \" Google    Dart \" == \"GoogleDart\"\n#guard removeWhitespaces \" iOS    Swift \" == \"iOSSwift\"\n", "test_list": ["#guard removeWhitespaces \" Google    Flutter \" == \"GoogleFlutter\"", "#guard removeWhitespaces \" Google    Dart \" == \"GoogleDart\"", "#guard removeWhitespaces \" iOS    Swift \" == \"iOSSwift\""]}
{"text": "Write a function that gives loss amount if the given amount has loss else return none.", "task_id": 452, "code": "import Batteries\n\nopen Std\n\ndef lossAmount (actual_cost sale_amount : Nat) : Option Nat :=\n  if sale_amount > actual_cost then\n    some (sale_amount - actual_cost)\n  else\n    none\n\n#guard lossAmount 1500 1200 == none\n#guard lossAmount 100 200 == some 100\n#guard lossAmount 2000 5000 == some 3000\n", "test_list": ["#guard lossAmount 1500 1200 == none", "#guard lossAmount 100 200 == some 100", "#guard lossAmount 2000 5000 == some 3000"]}
{"text": "Write a python function to find the sum of even factors of a number.", "task_id": 453, "code": "import Batteries\n\nopen Std\n\ndef sumofFactors (n : Nat) : Nat := Id.run do\n  if n % 2 != 0 then\n    return 0\n  let mut nVar := n\n  let mut res := 1\n  let limit := Nat.sqrt nVar\n  for i in [2 : limit + 1] do\n    let mut count := 0\n    let mut currSum := 1\n    let mut currTerm := 1\n    while nVar % i == 0 do\n      count := count + 1\n      nVar := nVar / i\n      if i == 2 && count == 1 then\n        currSum := 0\n      currTerm := currTerm * i\n      currSum := currSum + currTerm\n    res := res * currSum\n  res := res * (if nVar >= 2 then 1 + nVar else 1)\n  return res\n\n#guard sumofFactors 18 = 26\n#guard sumofFactors 30 = 48\n#guard sumofFactors 6 = 8\n", "test_list": ["#guard sumofFactors 18 = 26", "#guard sumofFactors 30 = 48", "#guard sumofFactors 6 = 8"]}
{"text": "Write a function that matches a word containing 'z'.", "task_id": 454, "code": "import Batteries\n\nopen Std\n\ndef textMatchWordz (text : String) : String :=\n  let n := text.length\n  let rec loop (i : Nat) : Bool :=\n    if i + 1 < n then\n      let c := (text.drop i).take 1\n      if c == \"z\" then true else loop (i+1)\n    else false\n  if loop 0 then \"Found a match!\" else \"Not matched!\"\n\n#guard textMatchWordz \"pythonz.\" == \"Found a match!\"\n#guard textMatchWordz \"xyz.\" == \"Found a match!\"\n#guard textMatchWordz \"  lang  .\" == \"Not matched!\"\n", "test_list": ["#guard textMatchWordz \"pythonz.\" == \"Found a match!\"", "#guard textMatchWordz \"xyz.\" == \"Found a match!\"", "#guard textMatchWordz \"  lang  .\" == \"Not matched!\""]}
{"text": "Write a function to check whether the given month number contains 31 days or not.", "task_id": 455, "code": "import Batteries\n\nopen Std\n\ndef check_monthnumb_number (monthnum2 : Nat) : Bool :=\n  if monthnum2 == 1 || monthnum2 == 3 || monthnum2 == 5 || monthnum2 == 7 || monthnum2 == 8 || monthnum2 == 10 || monthnum2 == 12 then\n    true\n  else\n    false\n\n#guard check_monthnumb_number 5 == true\n#guard check_monthnumb_number 2 == false\n#guard check_monthnumb_number 6 == false\n", "test_list": ["#guard check_monthnumb_number 5 == true", "#guard check_monthnumb_number 2 == false", "#guard check_monthnumb_number 6 == false"]}
{"text": "Write a function to reverse strings in a given list of string values.", "task_id": 456, "code": "import Batteries\n\nopen Std\n\ndef reverseStringList (stringlist : List String) : List String :=\n  stringlist.map (fun x => String.mk (x.data.reverse))\n\n#guard reverseStringList [\"Red\", \"Green\", \"Blue\", \"White\", \"Black\"] = [\"deR\", \"neerG\", \"eulB\", \"etihW\", \"kcalB\"]\n#guard reverseStringList [\"john\",\"amal\",\"joel\",\"george\"] = [\"nhoj\",\"lama\",\"leoj\",\"egroeg\"]\n#guard reverseStringList [\"jack\",\"john\",\"mary\"] = [\"kcaj\",\"nhoj\",\"yram\"]\n", "test_list": ["#guard reverseStringList [\"Red\", \"Green\", \"Blue\", \"White\", \"Black\"] = [\"deR\", \"neerG\", \"eulB\", \"etihW\", \"kcalB\"]", "#guard reverseStringList [\"john\",\"amal\",\"joel\",\"george\"] = [\"nhoj\",\"lama\",\"leoj\",\"egroeg\"]", "#guard reverseStringList [\"jack\",\"john\",\"mary\"] = [\"kcaj\",\"nhoj\",\"yram\"]"]}
{"text": "Write a python function to find the sublist having minimum length.", "task_id": 457, "code": "import Batteries\n\nopen Std\n\ndef ltList {α} [Ord α] : List α → List α → Bool\n  | [], [] => false\n  | [], _ => true\n  | _, [] => false\n  | a :: as', b :: bs' =>\n    match compare a b with\n    | Ordering.lt => true\n    | Ordering.gt => false\n    | Ordering.eq => ltList as' bs'\n\ndef Find_Min {α} [Ord α] (lst : List (List α)) : List α :=\n  match lst with\n  | [] => []\n  | x :: xs => xs.foldl (fun acc y => if ltList y acc then y else acc) x\n\n#guard Find_Min [[1],[1,2],[1,2,3]] = [1]\n#guard Find_Min [[1,1],[1,1,1],[1,2,7,8]] = [1,1]\n#guard Find_Min [[\"x\"],[\"x\",\"y\"],[\"x\",\"y\",\"z\"]] = [\"x\"]\n", "test_list": ["#guard Find_Min [[1],[1,2],[1,2,3]] = [1]", "#guard Find_Min [[1,1],[1,1,1],[1,2,7,8]] = [1,1]", "#guard Find_Min [[\"x\"],[\"x\",\"y\"],[\"x\",\"y\",\"z\"]] = [\"x\"]"]}
{"text": "Write a function to find the area of a rectangle.", "task_id": 458, "code": "import Batteries\n\nopen Std\n\ndef rectangleArea (l b : Nat) : Nat :=\n  let area := l * b\n  area\n\n#guard rectangleArea 10 20 == 200\n#guard rectangleArea 10 5 == 50\n#guard rectangleArea 4 2 == 8\n", "test_list": ["#guard rectangleArea 10 20 == 200", "#guard rectangleArea 10 5 == 50", "#guard rectangleArea 4 2 == 8"]}
{"text": "Write a function to remove uppercase substrings from a given string by using regex.", "task_id": 459, "code": "import Batteries\n\nopen Std\n\ndef isUpperAscii (c : Char) : Bool := ('A' ≤ c) && (c ≤ 'Z')\n\ndef removeUppercase (str1 : String) : String :=\n  let filtered := str1.data.filter (fun c => !(isUpperAscii c))\n  String.mk filtered\n\n#guard removeUppercase \"cAstyoUrFavoRitETVshoWs\" == \"cstyoravoitshos\"\n#guard removeUppercase \"wAtchTheinTernEtrAdIo\" == \"wtchheinerntrdo\"\n#guard removeUppercase \"VoicESeaRchAndreComMendaTionS\" == \"oiceachndreomendaion\"\n", "test_list": ["#guard removeUppercase \"cAstyoUrFavoRitETVshoWs\" == \"cstyoravoitshos\"", "#guard removeUppercase \"wAtchTheinTernEtrAdIo\" == \"wtchheinerntrdo\"", "#guard removeUppercase \"VoicESeaRchAndreComMendaTionS\" == \"oiceachndreomendaion\""]}
{"text": "Write a python function to get the first element of each sublist.", "task_id": 460, "code": "import Batteries\n\nopen Std\n\ndef Extract (lst : List (List Nat)) : List Nat :=\n  lst.map (fun item =>\n    match item with\n    | x :: _ => x\n    | [] => 0)\n\n#guard Extract [[1, 2], [3, 4, 5], [6, 7, 8, 9]] = [1, 3, 6]\n#guard Extract [[1, 2, 3], [4, 5]] = [1, 4]\n#guard Extract [[9, 8, 1], [1, 2]] = [9, 1]\n", "test_list": ["#guard Extract [[1, 2], [3, 4, 5], [6, 7, 8, 9]] = [1, 3, 6]", "#guard Extract [[1, 2, 3], [4, 5]] = [1, 4]", "#guard Extract [[9, 8, 1], [1, 2]] = [9, 1]"]}
{"text": "Write a python function to count the upper case characters in a given string.", "task_id": 461, "code": "import Batteries\n\nopen Std\n\ndef upperCtr (str : String) : Nat := Id.run do\n  let mut upper_ctr := 0\n  let chars := str.toList\n  for i in [0 : chars.length] do\n    let ch := chars.getD i ' '\n    if ch >= 'A' && ch <= 'Z' then\n      upper_ctr := upper_ctr + 1\n    return upper_ctr\n  return upper_ctr\n\n#guard upperCtr \"PYthon\" = 1\n#guard upperCtr \"BigData\" = 1\n#guard upperCtr \"program\" = 0\n", "test_list": ["#guard upperCtr \"PYthon\" = 1", "#guard upperCtr \"BigData\" = 1", "#guard upperCtr \"program\" = 0"]}
{"text": "Write a function to find all possible combinations of the elements of a given list.", "task_id": 462, "code": "import Batteries\nopen Std\n\ndef combinationsList (list1 : List String) : List (List String) :=\n  match list1 with\n  | [] => [[]]\n  | x :: xs =>\n    let recRes := combinationsList xs\n    List.foldr (fun el acc => [el, el ++ [x]] ++ acc) [] recRes\n\n#guard combinationsList [\"orange\", \"red\", \"green\", \"blue\"] == [[], [\"orange\"], [\"red\"], [\"red\", \"orange\"], [\"green\"], [\"green\", \"orange\"], [\"green\", \"red\"], [\"green\", \"red\", \"orange\"], [\"blue\"], [\"blue\", \"orange\"], [\"blue\", \"red\"], [\"blue\", \"red\", \"orange\"], [\"blue\", \"green\"], [\"blue\", \"green\", \"orange\"], [\"blue\", \"green\", \"red\"], [\"blue\", \"green\", \"red\", \"orange\"]]\n#guard combinationsList [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] == [[], [\"red\"], [\"green\"], [\"green\", \"red\"], [\"blue\"], [\"blue\", \"red\"], [\"blue\", \"green\"], [\"blue\", \"green\", \"red\"], [\"white\"], [\"white\", \"red\"], [\"white\", \"green\"], [\"white\", \"green\", \"red\"], [\"white\", \"blue\"], [\"white\", \"blue\", \"red\"], [\"white\", \"blue\", \"green\"], [\"white\", \"blue\", \"green\", \"red\"], [\"black\"], [\"black\", \"red\"], [\"black\", \"green\"], [\"black\", \"green\", \"red\"], [\"black\", \"blue\"], [\"black\", \"blue\", \"red\"], [\"black\", \"blue\", \"green\"], [\"black\", \"blue\", \"green\", \"red\"], [\"black\", \"white\"], [\"black\", \"white\", \"red\"], [\"black\", \"white\", \"green\"], [\"black\", \"white\", \"green\", \"red\"], [\"black\", \"white\", \"blue\"], [\"black\", \"white\", \"blue\", \"red\"], [\"black\", \"white\", \"blue\", \"green\"], [\"black\", \"white\", \"blue\", \"green\", \"red\"], [\"orange\"], [\"orange\", \"red\"], [\"orange\", \"green\"], [\"orange\", \"green\", \"red\"], [\"orange\", \"blue\"], [\"orange\", \"blue\", \"red\"], [\"orange\", \"blue\", \"green\"], [\"orange\", \"blue\", \"green\", \"red\"], [\"orange\", \"white\"], [\"orange\", \"white\", \"red\"], [\"orange\", \"white\", \"green\"], [\"orange\", \"white\", \"green\", \"red\"], [\"orange\", \"white\", \"blue\"], [\"orange\", \"white\", \"blue\", \"red\"], [\"orange\", \"white\", \"blue\", \"green\"], [\"orange\", \"white\", \"blue\", \"green\", \"red\"], [\"orange\", \"black\"], [\"orange\", \"black\", \"red\"], [\"orange\", \"black\", \"green\"], [\"orange\", \"black\", \"green\", \"red\"], [\"orange\", \"black\", \"blue\"], [\"orange\", \"black\", \"blue\", \"red\"], [\"orange\", \"black\", \"blue\", \"green\"], [\"orange\", \"black\", \"blue\", \"green\", \"red\"], [\"orange\", \"black\", \"white\"], [\"orange\", \"black\", \"white\", \"red\"], [\"orange\", \"black\", \"white\", \"green\"], [\"orange\", \"black\", \"white\", \"green\", \"red\"], [\"orange\", \"black\", \"white\", \"blue\"], [\"orange\", \"black\", \"white\", \"blue\", \"red\"], [\"orange\", \"black\", \"white\", \"blue\", \"green\"], [\"orange\", \"black\", \"white\", \"blue\", \"green\", \"red\"]]\n#guard combinationsList [\"red\", \"green\", \"black\", \"orange\"] == [[], [\"red\"], [\"green\"], [\"green\", \"red\"], [\"black\"], [\"black\", \"red\"], [\"black\", \"green\"], [\"black\", \"green\", \"red\"], [\"orange\"], [\"orange\", \"red\"], [\"orange\", \"green\"], [\"orange\", \"green\", \"red\"], [\"orange\", \"black\"], [\"orange\", \"black\", \"red\"], [\"orange\", \"black\", \"green\"], [\"orange\", \"black\", \"green\", \"red\"]]\n", "test_list": ["#guard combinationsList [\"orange\", \"red\", \"green\", \"blue\"] == [[], [\"orange\"], [\"red\"], [\"red\", \"orange\"], [\"green\"], [\"green\", \"orange\"], [\"green\", \"red\"], [\"green\", \"red\", \"orange\"], [\"blue\"], [\"blue\", \"orange\"], [\"blue\", \"red\"], [\"blue\", \"red\", \"orange\"], [\"blue\", \"green\"], [\"blue\", \"green\", \"orange\"], [\"blue\", \"green\", \"red\"], [\"blue\", \"green\", \"red\", \"orange\"]]", "#guard combinationsList [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] == [[], [\"red\"], [\"green\"], [\"green\", \"red\"], [\"blue\"], [\"blue\", \"red\"], [\"blue\", \"green\"], [\"blue\", \"green\", \"red\"], [\"white\"], [\"white\", \"red\"], [\"white\", \"green\"], [\"white\", \"green\", \"red\"], [\"white\", \"blue\"], [\"white\", \"blue\", \"red\"], [\"white\", \"blue\", \"green\"], [\"white\", \"blue\", \"green\", \"red\"], [\"black\"], [\"black\", \"red\"], [\"black\", \"green\"], [\"black\", \"green\", \"red\"], [\"black\", \"blue\"], [\"black\", \"blue\", \"red\"], [\"black\", \"blue\", \"green\"], [\"black\", \"blue\", \"green\", \"red\"], [\"black\", \"white\"], [\"black\", \"white\", \"red\"], [\"black\", \"white\", \"green\"], [\"black\", \"white\", \"green\", \"red\"], [\"black\", \"white\", \"blue\"], [\"black\", \"white\", \"blue\", \"red\"], [\"black\", \"white\", \"blue\", \"green\"], [\"black\", \"white\", \"blue\", \"green\", \"red\"], [\"orange\"], [\"orange\", \"red\"], [\"orange\", \"green\"], [\"orange\", \"green\", \"red\"], [\"orange\", \"blue\"], [\"orange\", \"blue\", \"red\"], [\"orange\", \"blue\", \"green\"], [\"orange\", \"blue\", \"green\", \"red\"], [\"orange\", \"white\"], [\"orange\", \"white\", \"red\"], [\"orange\", \"white\", \"green\"], [\"orange\", \"white\", \"green\", \"red\"], [\"orange\", \"white\", \"blue\"], [\"orange\", \"white\", \"blue\", \"red\"], [\"orange\", \"white\", \"blue\", \"green\"], [\"orange\", \"white\", \"blue\", \"green\", \"red\"], [\"orange\", \"black\"], [\"orange\", \"black\", \"red\"], [\"orange\", \"black\", \"green\"], [\"orange\", \"black\", \"green\", \"red\"], [\"orange\", \"black\", \"blue\"], [\"orange\", \"black\", \"blue\", \"red\"], [\"orange\", \"black\", \"blue\", \"green\"], [\"orange\", \"black\", \"blue\", \"green\", \"red\"], [\"orange\", \"black\", \"white\"], [\"orange\", \"black\", \"white\", \"red\"], [\"orange\", \"black\", \"white\", \"green\"], [\"orange\", \"black\", \"white\", \"green\", \"red\"], [\"orange\", \"black\", \"white\", \"blue\"], [\"orange\", \"black\", \"white\", \"blue\", \"red\"], [\"orange\", \"black\", \"white\", \"blue\", \"green\"], [\"orange\", \"black\", \"white\", \"blue\", \"green\", \"red\"]]", "#guard combinationsList [\"red\", \"green\", \"black\", \"orange\"] == [[], [\"red\"], [\"green\"], [\"green\", \"red\"], [\"black\"], [\"black\", \"red\"], [\"black\", \"green\"], [\"black\", \"green\", \"red\"], [\"orange\"], [\"orange\", \"red\"], [\"orange\", \"green\"], [\"orange\", \"green\", \"red\"], [\"orange\", \"black\"], [\"orange\", \"black\", \"red\"], [\"orange\", \"black\", \"green\"], [\"orange\", \"black\", \"green\", \"red\"]]"]}
{"text": "Write a function to find the maximum product subarray of the given array.", "task_id": 463, "code": "import Batteries\n\nopen Std\n\ndef maxSubarrayProduct (arr : List Int) : Int := Id.run do\n  let n := arr.length\n  let a := arr.toArray\n  let mut maxEndingHere : Int := (1 : Int)\n  let mut minEndingHere : Int := (1 : Int)\n  let mut maxSoFar : Int := (0 : Int)\n  let mut flag : Int := (0 : Int)\n  for i in [0 : n] do\n    let x := a[i]!\n    if hpos : x > 0 then\n      maxEndingHere := maxEndingHere * x\n      minEndingHere := min (minEndingHere * x) (1 : Int)\n      flag := 1\n    else if heq : x = 0 then\n      maxEndingHere := (1 : Int)\n      minEndingHere := (1 : Int)\n    else\n      let temp := maxEndingHere\n      maxEndingHere := max (minEndingHere * x) (1 : Int)\n      minEndingHere := temp * x\n    if maxSoFar < maxEndingHere then\n      maxSoFar := maxEndingHere\n  if flag = 0 && maxSoFar = 0 then\n    return 0\n  return maxSoFar\n\n#guard maxSubarrayProduct [1, -2, -3, 0, 7, -8, -2] = (112 : Int)\n#guard maxSubarrayProduct [6, -3, -10, 0, 2] = (180 : Int)\n#guard maxSubarrayProduct [-2, -40, 0, -2, -3] = (80 : Int)\n", "test_list": ["#guard maxSubarrayProduct [1, -2, -3, 0, 7, -8, -2] = (112 : Int)", "#guard maxSubarrayProduct [6, -3, -10, 0, 2] = (180 : Int)", "#guard maxSubarrayProduct [-2, -40, 0, -2, -3] = (80 : Int)"]}
{"text": "Write a function to check if all values are same in a dictionary.", "task_id": 464, "code": "import Batteries\n\nopen Std\n\ndef hashMapOfList (l : List (String × Nat)) : Std.HashMap String Nat :=\n  l.foldl (fun m (kv) => m.insert kv.fst kv.snd) (Std.HashMap.empty : Std.HashMap String Nat)\n\ndef check_value (dict : Std.HashMap String Nat) (n : Nat) : Bool := Id.run do\n  for (k, v) in dict do\n    if v != n then return false\n  return true\n\n#guard check_value (hashMapOfList [(\"Cierra Vega\", 12), (\"Alden Cantrell\", 12), (\"Kierra Gentry\", 12), (\"Pierre Cox\", 12)]) 10 = false\n#guard check_value (hashMapOfList [(\"Cierra Vega\", 12), (\"Alden Cantrell\", 12), (\"Kierra Gentry\", 12), (\"Pierre Cox\", 12)]) 12 = true\n#guard check_value (hashMapOfList [(\"Cierra Vega\", 12), (\"Alden Cantrell\", 12), (\"Kierra Gentry\", 12), (\"Pierre Cox\", 12)]) 5 = false\n", "test_list": ["#guard check_value (hashMapOfList [(\"Cierra Vega\", 12), (\"Alden Cantrell\", 12), (\"Kierra Gentry\", 12), (\"Pierre Cox\", 12)]) 10 = false", "#guard check_value (hashMapOfList [(\"Cierra Vega\", 12), (\"Alden Cantrell\", 12), (\"Kierra Gentry\", 12), (\"Pierre Cox\", 12)]) 12 = true", "#guard check_value (hashMapOfList [(\"Cierra Vega\", 12), (\"Alden Cantrell\", 12), (\"Kierra Gentry\", 12), (\"Pierre Cox\", 12)]) 5 = false"]}
{"text": "Write a function to drop empty items from a given dictionary.", "task_id": 465, "code": "import Batteries\n\nopen Std\n\ndef dropEmpty (dict1 : List (String × Option String)) : List (String × String) :=\n  dict1.filterMap (fun (k, v) => match v with | some s => some (k, s) | none => none)\n\n#guard dropEmpty [(\"c1\", some \"Red\"), (\"c2\", some \"Green\"), (\"c3\", none)] == [(\"c1\", \"Red\"), (\"c2\", \"Green\")]\n#guard dropEmpty [(\"c1\", some \"Red\"), (\"c2\", none), (\"c3\", none)] == [(\"c1\", \"Red\")]\n#guard dropEmpty [(\"c1\", none), (\"c2\", some \"Green\"), (\"c3\", none)] == [(\"c2\", \"Green\")]\n", "test_list": ["#guard dropEmpty [(\"c1\", some \"Red\"), (\"c2\", some \"Green\"), (\"c3\", none)] == [(\"c1\", \"Red\"), (\"c2\", \"Green\")]", "#guard dropEmpty [(\"c1\", some \"Red\"), (\"c2\", none), (\"c3\", none)] == [(\"c1\", \"Red\")]", "#guard dropEmpty [(\"c1\", none), (\"c2\", some \"Green\"), (\"c3\", none)] == [(\"c2\", \"Green\")]"]}
{"text": "Write a function to find the peak element in the given array.", "task_id": 466, "code": "import Batteries\n\nopen Std\n\nprivate def getAt (arr : List Nat) (i : Nat) : Nat := arr.getD i 0\n\ndef findPeakUtil (arr : List Nat) (low high n : Nat) : Nat :=\n  let rec go (low high fuel : Nat) : Nat :=\n    let mid := low + (high - low) / 2\n    \n    if hLeft : mid = 0 ∨ getAt arr (mid - 1) ≤ getAt arr mid then\n      if hRight : mid = n - 1 ∨ getAt arr (mid + 1) ≤ getAt arr mid then\n        mid\n      else\n        if fuel = 0 then mid else go (mid + 1) high (fuel - 1)\n    else\n      if fuel = 0 then mid else go low (mid - 1) (fuel - 1)\n  \n  go low high (high - low + 2)\n\ndef findPeak (arr : List Nat) (n : Nat) : Nat :=\n  findPeakUtil arr 0 (n - 1) n\n\n#guard findPeak [1, 3, 20, 4, 1, 0] 6 == 2\n#guard findPeak [2, 3, 4, 5, 6] 5 == 4\n#guard findPeak [8, 9, 11, 12, 14, 15] 6 == 5\n", "test_list": ["#guard findPeak [1, 3, 20, 4, 1, 0] 6 == 2", "#guard findPeak [2, 3, 4, 5, 6] 5 == 4", "#guard findPeak [8, 9, 11, 12, 14, 15] 6 == 5"]}
{"text": "Write a python function to convert decimal number to octal number.", "task_id": 467, "code": "import Batteries\n\nopen Std\n\ndef decimal_to_Octal (deciNum : Nat) : Nat := Id.run do\n  let mut octalNum := 0\n  let mut countval := 1\n  let mut deciNum := deciNum\n  let _dNo := deciNum\n  while deciNum != 0 do\n    let remainder := deciNum % 8\n    octalNum := octalNum + remainder * countval\n    countval := countval * 10\n    deciNum := deciNum / 8\n  return octalNum\n\n#guard decimal_to_Octal 10 == 12\n#guard decimal_to_Octal 2 == 2\n#guard decimal_to_Octal 33 == 41\n", "test_list": ["#guard decimal_to_Octal 10 == 12", "#guard decimal_to_Octal 2 == 2", "#guard decimal_to_Octal 33 == 41"]}
{"text": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.", "task_id": 468, "code": "import Batteries\n\nopen Std\n\n \ndef maxProduct (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let mut mpis := Array.replicate n 0\n  \n  for i in [: n] do\n    mpis := mpis.set! i (a[i]!)\n  \n  for i in [1 : n] do\n    for j in [: i] do\n      if a[i]! > a[j]! && mpis[i]! < mpis[j]! * a[i]! then\n        mpis := mpis.set! i (mpis[j]! * a[i]!)\n  \n  let mut m := 0\n  for i in [: n] do\n    let v := mpis[i]!\n    if v > m then m := v\n  return m\n\n#guard maxProduct [3, 100, 4, 5, 150, 6] 6 == 45000\n#guard maxProduct [4, 42, 55, 68, 80] 5 == 50265600\n#guard maxProduct [10, 22, 9, 33, 21, 50, 41, 60] 8 == 21780000\n", "test_list": ["#guard maxProduct [3, 100, 4, 5, 150, 6] 6 == 45000", "#guard maxProduct [4, 42, 55, 68, 80] 5 == 50265600", "#guard maxProduct [10, 22, 9, 33, 21, 50, 41, 60] 8 == 21780000"]}
{"text": "Write a function to find the maximum profit earned from a maximum of k stock transactions", "task_id": 469, "code": "import Batteries\n\nopen Std\n\ndef maxProfit (price : List Int) (k : Nat) : Int := Id.run do\n  let pr := price.toArray\n  let n := pr.size\n  if n == 0 then\n    return 0\n  let mut fp : Array (Array Int) := Array.replicate (k+1) (Array.replicate n 0)\n  for i in [0 : k+1] do\n    for j in [0 : n] do\n      if i == 0 || j == 0 then\n        fp := fp.modify i (fun row => row.set! j 0)\n      else\n        let rowPrev := fp[i-1]!\n        let rowI := fp[i]!\n        let mut maxSoFar : Int := 0\n        for x in [0 : j] do\n          let curr := pr[j]! - pr[x]! + rowPrev[x]!\n          if maxSoFar < curr then\n            maxSoFar := curr\n        let left := rowI[j-1]!\n        let val := if left < maxSoFar then maxSoFar else left\n        fp := fp.modify i (fun row => row.set! j val)\n  return fp[k]![n-1]!\n\n#guard maxProfit [1, 5, 2, 3, 7, 6, 4, 5] 3 = 10\n#guard maxProfit [2, 4, 7, 5, 4, 3, 5] 2 = 7\n#guard maxProfit [10, 6, 8, 4, 2] 2 = 2\n", "test_list": ["#guard maxProfit [1, 5, 2, 3, 7, 6, 4, 5] 3 = 10", "#guard maxProfit [2, 4, 7, 5, 4, 3, 5] 2 = 7", "#guard maxProfit [10, 6, 8, 4, 2] 2 = 2"]}
{"text": "Write a function to find the pairwise addition of the elements of the given tuples.", "task_id": 470, "code": "import Batteries\n\nopen Std\n\ndef addPairwise (test_tup : List Nat) : List Nat :=\n  let rec go (l : List Nat) : List Nat :=\n    match l with\n    | x :: y :: rest => (x + y) :: go (y :: rest)\n    | _ => []\n  go test_tup\n\n#guard addPairwise [1, 5, 7, 8, 10] = [6, 12, 15, 18]\n#guard addPairwise [2, 6, 8, 9, 11] = [8, 14, 17, 20]\n#guard addPairwise [3, 7, 9, 10, 12] = [10, 16, 19, 22]\n", "test_list": ["#guard addPairwise [1, 5, 7, 8, 10] = [6, 12, 15, 18]", "#guard addPairwise [2, 6, 8, 9, 11] = [8, 14, 17, 20]", "#guard addPairwise [3, 7, 9, 10, 12] = [10, 16, 19, 22]"]}
{"text": "Write a python function to find remainder of array multiplication divided by n.", "task_id": 471, "code": "import Batteries\n\nopen Std\n\ndef findRemainder (arr : List Nat) (lens : Nat) (n : Nat) : Nat := Id.run do\n  \n  let mut mul := 1\n  for i in [: lens] do\n    let ai := arr.getD i 0\n    mul := (mul * (ai % n)) % n\n  return mul % n\n\n#guard findRemainder [100, 10, 5, 25, 35, 14] 6 11 = 9\n#guard findRemainder [1, 1, 1] 3 1 = 0\n#guard findRemainder [1, 2, 1] 3 2 = 0\n", "test_list": ["#guard findRemainder [100, 10, 5, 25, 35, 14] 6 11 = 9", "#guard findRemainder [1, 1, 1] 3 1 = 0", "#guard findRemainder [1, 2, 1] 3 2 = 0"]}
{"text": "Write a python function to check whether the given list contains consecutive numbers or not.", "task_id": 472, "code": "import Batteries\n\nopen Std\n\ndef removeOne (x : Nat) (l : List Nat) : List Nat :=\n  match l with\n  | [] => []\n  | y :: ys => if x == y then ys else y :: removeOne x ys\n\ndef minOfList! (l : List Nat) : Nat :=\n  match l with\n  | [] => 0  \n  | x :: xs => xs.foldl (fun acc y => Nat.min acc y) x\n\ndef maxOfList! (l : List Nat) : Nat :=\n  match l with\n  | [] => 0  \n  | x :: xs => xs.foldl (fun acc y => Nat.max acc y) x\n\ndef selectionSort (l : List Nat) : List Nat := Id.run do\n  let mut rest := l\n  let mut res : List Nat := []\n  let n := l.length\n  for _ in [: n] do\n    match rest with\n    | [] => break\n    | _ =>\n      let m := minOfList! rest\n      res := res ++ [m]\n      rest := removeOne m rest\n  return res\n\ndef checkConsecutive (l : List Nat) : Bool :=\n  match l with\n  | [] => false  \n  | _ =>\n    let s := selectionSort l\n    let mn := minOfList! l\n    let mx := maxOfList! l\n    let t := (List.range (mx - mn + 1)).map (fun i => mn + i)\n    s == t\n\n#guard checkConsecutive [1, 2, 3, 4, 5] == true\n#guard checkConsecutive [1, 2, 3, 5, 6] == false\n#guard checkConsecutive [1, 2, 1] == false\n", "test_list": ["#guard checkConsecutive [1, 2, 3, 4, 5] == true", "#guard checkConsecutive [1, 2, 3, 5, 6] == false", "#guard checkConsecutive [1, 2, 1] == false"]}
{"text": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.", "task_id": 473, "code": "import Batteries\n\nopen Std\n\ndef tupleIntersection (testList1 testList2 : List (Nat × Nat)) : HashSet (Nat × Nat) := Id.run do\n  let norm (p : Nat × Nat) : Nat × Nat :=\n    let a := p.fst\n    let b := p.snd\n    if a ≤ b then (a, b) else (b, a)\n  let s1 := HashSet.ofList (testList1.map norm)\n  let s2 := HashSet.ofList (testList2.map norm)\n  return s1.filter (fun x => x ∈ s2)\n\n#guard tupleIntersection [(3, 4), (5, 6), (9, 10), (4, 5)] [(5, 4), (3, 4), (6, 5), (9, 11)] == HashSet.ofList [(4, 5), (3, 4), (5, 6)]\n#guard tupleIntersection [(4, 1), (7, 4), (11, 13), (17, 14)] [(1, 4), (7, 4), (16, 12), (10, 13)] == HashSet.ofList [(4, 7), (1, 4)]\n#guard tupleIntersection [(2, 1), (3, 2), (1, 3), (1, 4)] [(11, 2), (2, 3), (6, 2), (1, 3)] == HashSet.ofList [(1, 3), (2, 3)]\n", "test_list": ["#guard tupleIntersection [(3, 4), (5, 6), (9, 10), (4, 5)] [(5, 4), (3, 4), (6, 5), (9, 11)] == HashSet.ofList [(4, 5), (3, 4), (5, 6)]", "#guard tupleIntersection [(4, 1), (7, 4), (11, 13), (17, 14)] [(1, 4), (7, 4), (16, 12), (10, 13)] == HashSet.ofList [(4, 7), (1, 4)]", "#guard tupleIntersection [(2, 1), (3, 2), (1, 3), (1, 4)] [(11, 2), (2, 3), (6, 2), (1, 3)] == HashSet.ofList [(1, 3), (2, 3)]"]}
{"text": "Write a function to replace characters in a string.", "task_id": 474, "code": "import Batteries\n\nopen Std\n\ndef replaceChar (str1 : String) (ch : String) (newch : String) : String :=\n  String.intercalate newch (str1.splitOn ch)\n\n#guard replaceChar \"polygon\" \"y\" \"l\" == \"pollgon\"\n#guard replaceChar \"character\" \"c\" \"a\" == \"aharaater\"\n#guard replaceChar \"python\" \"l\" \"a\" == \"python\"\n", "test_list": ["#guard replaceChar \"polygon\" \"y\" \"l\" == \"pollgon\"", "#guard replaceChar \"character\" \"c\" \"a\" == \"aharaater\"", "#guard replaceChar \"python\" \"l\" \"a\" == \"python\""]}
{"text": "Write a function to sort counter by value.", "task_id": 475, "code": "import Batteries\nopen Std\n\nprivate def insertBy (cmp : (String × Nat) → (String × Nat) → Bool) :\n    (String × Nat) → List (String × Nat) → List (String × Nat)\n  | a, [] => [a]\n  | a, b :: bs => if cmp a b then a :: b :: bs else b :: insertBy cmp a bs\n\nprivate def sortBy (cmp : (String × Nat) → (String × Nat) → Bool) :\n    List (String × Nat) → List (String × Nat)\n  | [] => []\n  | b :: bs => insertBy cmp b (sortBy cmp bs)\n\ndef sortCounter (dict1 : List (String × Nat)) : List (String × Nat) :=\n  sortBy (fun a b => decide (a.snd > b.snd)) dict1\n\n#guard sortCounter [(\"Math\",81), (\"Physics\",83), (\"Chemistry\",87)] == [(\"Chemistry\", 87), (\"Physics\", 83), (\"Math\", 81)]\n#guard sortCounter [(\"Math\",400), (\"Physics\",300), (\"Chemistry\",250)] == [(\"Math\", 400), (\"Physics\", 300), (\"Chemistry\", 250)]\n#guard sortCounter [(\"Math\",900), (\"Physics\",1000), (\"Chemistry\",1250)] == [(\"Chemistry\", 1250), (\"Physics\", 1000), (\"Math\", 900)]\n", "test_list": ["#guard sortCounter [(\"Math\",81), (\"Physics\",83), (\"Chemistry\",87)] == [(\"Chemistry\", 87), (\"Physics\", 83), (\"Math\", 81)]", "#guard sortCounter [(\"Math\",400), (\"Physics\",300), (\"Chemistry\",250)] == [(\"Math\", 400), (\"Physics\", 300), (\"Chemistry\", 250)]", "#guard sortCounter [(\"Math\",900), (\"Physics\",1000), (\"Chemistry\",1250)] == [(\"Chemistry\", 1250), (\"Physics\", 1000), (\"Math\", 900)]"]}
{"text": "Write a python function to find the sum of the largest and smallest value in a given array.", "task_id": 476, "code": "import Batteries\n\nopen Std\n\ndef bigSum (nums : List Int) : Int :=\n  \n  match nums with\n  | [] => 0\n  | x :: xs =>\n    let mx := xs.foldl (fun acc v => if acc < v then v else acc) x\n    let mn := xs.foldl (fun acc v => if v < acc then v else acc) x\n    mx + mn\n\n#guard bigSum [1, 2, 3] = 4\n#guard bigSum [-1, 2, 3, 4] = 3\n#guard bigSum [2, 3, 6] = 8\n", "test_list": ["#guard bigSum [1, 2, 3] = 4", "#guard bigSum [-1, 2, 3, 4] = 3", "#guard bigSum [2, 3, 6] = 8"]}
{"text": "Write a python function to convert the given string to lower case.", "task_id": 477, "code": "import Batteries\n\nopen Std\n\ndef is_lower (string : String) : String :=\n  string.foldl (fun (acc : String) (c : Char) => acc.push (Char.toLower c)) \"\"\n\n#guard is_lower \"InValid\" = \"invalid\"\n#guard is_lower \"TruE\" = \"true\"\n#guard is_lower \"SenTenCE\" = \"sentence\"\n", "test_list": ["#guard is_lower \"InValid\" = \"invalid\"", "#guard is_lower \"TruE\" = \"true\"", "#guard is_lower \"SenTenCE\" = \"sentence\""]}
{"text": "Write a function to remove lowercase substrings from a given string.", "task_id": 478, "code": "import Batteries\n\nopen Std\n\ndef remove_lowercase (str1 : String) : String :=\n  let isAsciiLower (c : Char) : Bool := c >= 'a' && c <= 'z'\n  String.mk (str1.data.filter (fun c => !(isAsciiLower c)))\n\n#guard remove_lowercase \"PYTHon\" == \"PYTH\"\n#guard remove_lowercase \"FInD\" == \"FID\"\n#guard remove_lowercase \"STRinG\" == \"STRG\"\n", "test_list": ["#guard remove_lowercase \"PYTHon\" == \"PYTH\"", "#guard remove_lowercase \"FInD\" == \"FID\"", "#guard remove_lowercase \"STRinG\" == \"STRG\""]}
{"text": "Write a python function to find the first digit of a given number.", "task_id": 479, "code": "import Batteries\n\nopen Std\n\ndef firstDigit (n : Nat) : Nat := Id.run do\n  let mut x := n\n  while x >= 10 do\n    x := x / 10\n  return x\n\n#guard firstDigit 123 = 1\n#guard firstDigit 456 = 4\n#guard firstDigit 12 = 1\n", "test_list": ["#guard firstDigit 123 = 1", "#guard firstDigit 456 = 4", "#guard firstDigit 12 = 1"]}
{"text": "Write a python function to find the maximum occurring character in a given string.", "task_id": 480, "code": "import Batteries\nopen Std\n\ndef getMaxOccuringChar (str1 : String) : String := Id.run do\n  let mut ctr : List (Char × Nat) := []\n  let mut maxVal : Nat := 0\n  let mut ch : String := \"\"\n  for c in str1.data do\n    let rec inc (xs : List (Char × Nat)) : List (Char × Nat) :=\n      match xs with\n      | [] => [(c, 1)]\n      | (c', n) :: xs' =>\n        if c' = c then\n          (c, n + 1) :: xs'\n        else\n          (c', n) :: inc xs'\n    ctr := inc ctr\n  for c in str1.data do\n    let rec lookup (xs : List (Char × Nat)) : Nat :=\n      match xs with\n      | [] => 0\n      | (c', n) :: xs' =>\n        if c' = c then n else lookup xs'\n    let count := lookup ctr\n    if maxVal < count then\n      maxVal := count\n      ch := String.singleton c\n  return ch\n\n#guard getMaxOccuringChar \"data\" == \"a\"\n#guard getMaxOccuringChar \"create\" == \"e\"\n#guard getMaxOccuringChar \"brilliant girl\" == \"i\"\n", "test_list": ["#guard getMaxOccuringChar \"data\" == \"a\"", "#guard getMaxOccuringChar \"create\" == \"e\"", "#guard getMaxOccuringChar \"brilliant girl\" == \"i\""]}
{"text": "Write a function to determine if there is a subset of the given set with sum equal to the given sum.", "task_id": 481, "code": "import Batteries\n\nopen Std\n\ndef isSubsetSum (set : List Nat) (n : Nat) (sum : Nat) : Bool :=\n  match n with\n  | 0 => sum == 0\n  | n+1 =>\n    if sum == 0 then true\n    else\n      let v := set.getD n 0\n      if v > sum then\n        isSubsetSum set n sum\n      else\n        isSubsetSum set n sum || isSubsetSum set n (sum - v)\n\n#guard isSubsetSum [3, 34, 4, 12, 5, 2] 6 9 == true\n#guard isSubsetSum [3, 34, 4, 12, 5, 2] 6 30 == false\n#guard isSubsetSum [3, 34, 4, 12, 5, 2] 6 15 == true\n", "test_list": ["#guard isSubsetSum [3, 34, 4, 12, 5, 2] 6 9 == true", "#guard isSubsetSum [3, 34, 4, 12, 5, 2] 6 30 == false", "#guard isSubsetSum [3, 34, 4, 12, 5, 2] 6 15 == true"]}
{"text": "Write a function to find sequences of one upper case letter followed by lower case letters in the given string by using regex.", "task_id": 482, "code": "import Batteries\nopen Std\n\ndef isLower (c : Char) : Bool := 'a' ≤ c && c ≤ 'z'\ndef isUpper (c : Char) : Bool := 'A' ≤ c && c ≤ 'Z'\n\ndef allLower (s : String) : Bool :=\n  s.data.all isLower\n\ndef getCharAt (s : String) (i : Nat) : Option Char :=\n  let rec go (l : List Char) (i : Nat) : Option Char :=\n    match l, i with\n    | [], _ => none\n    | c :: _, 0 => some c\n    | _ :: t, i+1 => go t i\n  go s.data i\n\ndef matchRe (text : String) : String := Id.run do\n  let n := text.length\n  \n  \n  for j in [1 : n] do\n    let suffix := text.drop j\n    match getCharAt text (j - 1) with\n    | some c =>\n      if isUpper c && allLower suffix then\n        return \"Yes\"\n    | none => pure ()\n  return \"No\"\n\n#guard matchRe \"Geeks\" == \"Yes\"\n#guard matchRe \"geeksforGeeks\" == \"Yes\"\n#guard matchRe \"geeks\" == \"No\"\n", "test_list": ["#guard matchRe \"Geeks\" == \"Yes\"", "#guard matchRe \"geeksforGeeks\" == \"Yes\"", "#guard matchRe \"geeks\" == \"No\""]}
{"text": "Write a python function to find the first natural number whose factorial is divisible by x.", "task_id": 483, "code": "import Batteries\n\nopen Std\n\ndef firstFactorialDivisibleNumber (x : Nat) : Nat := Id.run do\n  let mut i := 1\n  let mut fact := 1\n  for j in [1 : x] do\n    fact := fact * j\n    i := j\n    if fact % x == 0 then\n      return i\n  return i\n\n#guard firstFactorialDivisibleNumber 10 = 5\n#guard firstFactorialDivisibleNumber 15 = 5\n#guard firstFactorialDivisibleNumber 5 = 4\n", "test_list": ["#guard firstFactorialDivisibleNumber 10 = 5", "#guard firstFactorialDivisibleNumber 15 = 5", "#guard firstFactorialDivisibleNumber 5 = 4"]}
{"text": "Write a function to remove the matching tuples from the given two tuples.", "task_id": 484, "code": "import Batteries\n\nopen Std\n\ndef removeMatchingTuple (test_list1 test_list2 : List (String × String)) : List (String × String) :=\n  test_list1.filter (fun sub => !(test_list2.contains sub))\n\n#guard removeMatchingTuple [(\"Hello\", \"dude\"), (\"How\", \"are\"), (\"you\", \"?\")] [(\"Hello\", \"dude\"), (\"How\", \"are\")] = [(\"you\", \"?\")]\n#guard removeMatchingTuple [(\"Part\", \"of\"), (\"the\", \"journey\"), (\"is \", \"end\")] [(\"Journey\", \"the\"), (\"is\", \"end\")] = [(\"Part\", \"of\"), (\"the\", \"journey\"), (\"is \", \"end\")]\n#guard removeMatchingTuple [(\"Its\", \"been\"), (\"a\", \"long\"), (\"day\", \"without\")] [(\"a\", \"long\"), (\"my\", \"friend\")] = [(\"Its\", \"been\"), (\"day\", \"without\")]\n", "test_list": ["#guard removeMatchingTuple [(\"Hello\", \"dude\"), (\"How\", \"are\"), (\"you\", \"?\")] [(\"Hello\", \"dude\"), (\"How\", \"are\")] = [(\"you\", \"?\")]", "#guard removeMatchingTuple [(\"Part\", \"of\"), (\"the\", \"journey\"), (\"is \", \"end\")] [(\"Journey\", \"the\"), (\"is\", \"end\")] = [(\"Part\", \"of\"), (\"the\", \"journey\"), (\"is \", \"end\")]", "#guard removeMatchingTuple [(\"Its\", \"been\"), (\"a\", \"long\"), (\"day\", \"without\")] [(\"a\", \"long\"), (\"my\", \"friend\")] = [(\"Its\", \"been\"), (\"day\", \"without\")]"]}
{"text": "Write a function to find the largest palindromic number in the given array.", "task_id": 485, "code": "import Batteries\n\nopen Std\n\ndef removeFirst (xs : List Int) (x : Int) : List Int :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeFirst ys x\n\ndef findMin (xs : List Int) : Int :=\n  match xs with\n  | [] => 0\n  | y :: ys => ys.foldl (fun m z => if z < m then z else m) y\n\ndef selectionSortAsc (xs : List Int) : List Int := Id.run do\n  let mut rest := xs\n  let mut res : List Int := []\n  while !rest.isEmpty do\n    let m := findMin rest\n    let rest' := removeFirst rest m\n    res := res ++ [m]\n    rest := rest'\n  return res\n\ndef is_palindrome (n : Int) : Bool := Id.run do\n  if n < 0 then return false\n  let nNat : Nat := Int.toNat n\n  let mut divisor : Nat := 1\n  while nNat / divisor >= 10 do\n    divisor := divisor * 10\n  let mut m := nNat\n  let mut d := divisor\n  while m != 0 do\n    let leading := m / d\n    let trailing := m % 10\n    if !(leading == trailing) then return false\n    m := (m % d) / 10\n    d := d / 100\n  return true\n\ndef largest_palindrome (A : List Int) (n : Nat) : Int := Id.run do\n  let sorted := selectionSortAsc A\n  let mut i := n\n  while i > 0 do\n    let idx := i - 1\n    let x := sorted.getD idx 0\n    if is_palindrome x then return x\n    i := i - 1\n  return -1\n\n#guard largest_palindrome [1, 232, 54545, 999991] 4 == 54545\n#guard largest_palindrome [1, 2, 3, 4, 5, 50] 6 == 5\n#guard largest_palindrome [1, 3, 7, 9, 45] 5 == 9\n", "test_list": ["#guard largest_palindrome [1, 232, 54545, 999991] 4 == 54545", "#guard largest_palindrome [1, 2, 3, 4, 5, 50] 6 == 5", "#guard largest_palindrome [1, 3, 7, 9, 45] 5 == 9"]}
{"text": "Write a function to compute binomial probability for the given number.", "task_id": 486, "code": "import Batteries\nopen Std\n\ndef powFloat (x : Float) (k : Nat) : Float := Id.run do\n  let mut res := 1.0\n  for _ in [:k] do\n    res := res * x\n  return res\n\ndef nCr (n r : Nat) : Float := Id.run do\n  let mut r2 := r\n  if Float.ofNat r > Float.ofNat n / 2.0 then\n    r2 := n - r\n  let mut answer : Float := 1.0\n  for i in [1 : r2 + 1] do\n    let num := Float.ofNat (n - r2 + i)\n    let den := Float.ofNat i\n    answer := answer * num\n    answer := answer / den\n  return answer\n\ndef binomialProbability (n k : Nat) (p : Float) : Float :=\n  nCr n k * powFloat p k * powFloat (1.0 - p) (n - k)\n\nmacro \"#guard \" t:term : command =>\n  `( #eval (if $t then () else (panic! \"guard failed\" : Unit)) )\n\n#guard (binomialProbability 10 5 (1.0/3.0) == 0.13656454808718185)\n#guard (binomialProbability 11 6 (2.0/4.0) == 0.2255859375)\n#guard (binomialProbability 12 7 (3.0/5.0) == 0.227030335488)\n", "test_list": ["#guard (binomialProbability 10 5 (1.0/3.0) == 0.13656454808718185)", "#guard (binomialProbability 11 6 (2.0/4.0) == 0.2255859375)", "#guard (binomialProbability 12 7 (3.0/5.0) == 0.227030335488)"]}
{"text": "Write a function to sort a list of tuples in increasing order by the last element in each tuple.", "task_id": 487, "code": "import Batteries\nopen Std\n\nprivate def onePass (xs : List (Nat × Nat)) : List (Nat × Nat) × Bool :=\n  match xs with\n  | [] => ([], False)\n  | a :: rest =>\n    let rec aux (acc : List (Nat × Nat)) (cur : Nat × Nat) (rest : List (Nat × Nat)) (changed : Bool) :\n        List (Nat × Nat) × Bool :=\n      match rest with\n      | [] => ((acc.reverse) ++ [cur], changed)\n      | b :: rs =>\n        if cur.snd > b.snd then\n          aux (b :: acc) cur rs True\n        else\n          aux (cur :: acc) b rs changed\n    aux [] a rest False\n\ndef sortTuple (tup : List (Nat × Nat)) : List (Nat × Nat) :=\n  let rec iter (n : Nat) (xs : List (Nat × Nat)) : List (Nat × Nat) :=\n    match n with\n    | 0 => xs\n    | n' + 1 =>\n      let (ys, changed) := onePass xs\n      if changed then\n        iter n' ys\n      else\n        ys\n  iter tup.length tup\n\n#guard sortTuple [(1, 3), (3, 2), (2, 1)] == [(2, 1), (3, 2), (1, 3)]\n#guard sortTuple [(2, 4), (3, 3), (1, 1)] == [(1, 1), (3, 3), (2, 4)]\n#guard sortTuple [(3, 9), (6, 7), (4, 3)] == [(4, 3), (6, 7), (3, 9)]\n", "test_list": ["#guard sortTuple [(1, 3), (3, 2), (2, 1)] == [(2, 1), (3, 2), (1, 3)]", "#guard sortTuple [(2, 4), (3, 3), (1, 1)] == [(1, 1), (3, 3), (2, 4)]", "#guard sortTuple [(3, 9), (6, 7), (4, 3)] == [(4, 3), (6, 7), (3, 9)]"]}
{"text": "Write a function to find the area of a pentagon.", "task_id": 488, "code": "import Batteries\n\nopen Std\n\ndef areaPentagon (a : Nat) : Float :=\n  let af := Float.ofNat a\n  let inner := 5.0 + 2.0 * Float.sqrt 5.0\n  let v := Float.sqrt (5.0 * inner)\n  (v * (af * af)) / 4.0\n\n#guard areaPentagon 5 == 43.01193501472417\n#guard areaPentagon 10 == 172.0477400588967\n#guard areaPentagon 15 == 387.10741513251753\n", "test_list": ["#guard areaPentagon 5 == 43.01193501472417", "#guard areaPentagon 10 == 172.0477400588967", "#guard areaPentagon 15 == 387.10741513251753"]}
{"text": "Write a python function to find the frequency of the largest value in a given array.", "task_id": 489, "code": "import Batteries\n\nopen Std\n\ndef frequency_Of_Largest (n : Nat) (arr : List Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let mut mn := a[0]!\n  let mut freq := 1\n  for i in [1 : n] do\n    let v := a[i]!\n    if v > mn then\n      mn := v\n      freq := 1\n    else if v == mn then\n      freq := freq + 1\n    else\n      ()\n  return freq\n\n#guard frequency_Of_Largest 5 [1,2,3,4,4] = 2\n#guard frequency_Of_Largest 3 [5,6,5] = 1\n#guard frequency_Of_Largest 4 [2,7,7,7] = 3\n", "test_list": ["#guard frequency_Of_Largest 5 [1,2,3,4,4] = 2", "#guard frequency_Of_Largest 3 [5,6,5] = 1", "#guard frequency_Of_Largest 4 [2,7,7,7] = 3"]}
{"text": "Write a function to extract all the pairs which are symmetric in the given tuple list.", "task_id": 490, "code": "import Batteries\n\nopen Std\n\ndef ltBool (a b : Nat) : Bool :=\n  Nat.ble (a + 1) b\n\ndef extractSymmetric (test_list : List (Nat × Nat)) : HashSet (Nat × Nat) := Id.run do\n  let s1 : HashSet (Nat × Nat) := HashSet.ofList test_list\n  let swappedList := test_list.map (fun p => (p.snd, p.fst))\n  let s2 : HashSet (Nat × Nat) := HashSet.ofList swappedList\n  let temp := s1.filter (fun x => x ∈ s2)\n  let res := temp.filter (fun p => ltBool p.fst p.snd)\n  return res\n\n#guard extractSymmetric [(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] == HashSet.ofList [(8, 9), (6, 7)]\n#guard extractSymmetric [(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] == HashSet.ofList [(9, 10), (7, 8)]\n#guard extractSymmetric [(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] == HashSet.ofList [(8, 9), (10, 11)]\n", "test_list": ["#guard extractSymmetric [(6, 7), (2, 3), (7, 6), (9, 8), (10, 2), (8, 9)] == HashSet.ofList [(8, 9), (6, 7)]", "#guard extractSymmetric [(7, 8), (3, 4), (8, 7), (10, 9), (11, 3), (9, 10)] == HashSet.ofList [(9, 10), (7, 8)]", "#guard extractSymmetric [(8, 9), (4, 5), (9, 8), (11, 10), (12, 4), (10, 11)] == HashSet.ofList [(8, 9), (10, 11)]"]}
{"text": "Write a function to find the sum of geometric progression series.", "task_id": 491, "code": "import Batteries\n\nopen Std\n\ndef sumGp (a n r : Nat) : Nat := Id.run do\n  let mut total := 0\n  let mut term := a\n  for _ in [: n] do\n    total := total + term\n    term := term * r\n  return total\n\n#guard sumGp 1 5 2 = 31\n#guard sumGp 1 5 4 = 341\n#guard sumGp 2 6 3 = 728\n", "test_list": ["#guard sumGp 1 5 2 = 31", "#guard sumGp 1 5 4 = 341", "#guard sumGp 2 6 3 = 728"]}
{"text": "Write a function to search an element in the given array by using binary search.", "task_id": 492, "code": "import Batteries\n\nopen Std\n\ndef binarySearch (itemList : List Nat) (item : Nat) : Bool :=\n  let len := itemList.length\n  let last : Int := Int.ofNat len - 1\n  let rec loop (first : Int) (last : Int) (found : Bool) (fuel : Nat) : Bool :=\n    if fuel = 0 then found else\n    if first <= last && !found then\n      let mid : Int := (first + last) / 2\n      let midNat : Nat := Int.toNat mid\n      let midVal : Nat := itemList.getD midNat 0\n      if midVal = item then\n        true\n      else if item < midVal then\n        loop first (mid - 1) false (fuel - 1)\n      else\n        loop (mid + 1) last false (fuel - 1)\n    else found\n  loop 0 last false (len + 1)\n\n#guard binarySearch [1,2,3,5,8] 6 == false\n#guard binarySearch [7,8,9,10,13] 10 == true\n#guard binarySearch [11,13,14,19,22,36] 23 == false\n", "test_list": ["#guard binarySearch [1,2,3,5,8] 6 == false", "#guard binarySearch [7,8,9,10,13] 10 == true", "#guard binarySearch [11,13,14,19,22,36] 23 == false"]}
{"text": "Write a function to convert the given binary tuple to integer.", "task_id": 494, "code": "import Batteries\n\nopen Std\n\ndef binaryToInteger (test_tup : List Nat) : String :=\n  let n := test_tup.foldl (fun acc ele => acc * 2 + ele) 0\n  toString n\n\n#guard binaryToInteger [1, 1, 0, 1, 0, 0, 1] = \"105\"\n#guard binaryToInteger [0, 1, 1, 0, 0, 1, 0, 1] = \"101\"\n#guard binaryToInteger [1, 1, 0, 1, 0, 1] = \"53\"\n", "test_list": ["#guard binaryToInteger [1, 1, 0, 1, 0, 0, 1] = \"105\"", "#guard binaryToInteger [0, 1, 1, 0, 0, 1, 0, 1] = \"101\"", "#guard binaryToInteger [1, 1, 0, 1, 0, 1] = \"53\""]}
{"text": "Write a function to remove lowercase substrings from a given string by using regex.", "task_id": 495, "code": "import Batteries\n\nopen Std\n\ndef removeLowercase (str1 : String) : String :=\n  let remove_lower := fun (text : String) =>\n    let filtered := text.data.filter (fun c =>\n      let n := c.toNat\n      not (n >= 'a'.toNat && n <= 'z'.toNat))\n    String.mk filtered\n  let result := remove_lower str1\n  result\n\n#guard removeLowercase \"KDeoALOklOOHserfLoAJSIskdsf\" = \"KDALOOOHLAJSI\"\n#guard removeLowercase \"ProducTnamEstreAmIngMediAplAYer\" = \"PTEAIMAAY\"\n#guard removeLowercase \"maNufacTuredbYSheZenTechNolOGIes\" = \"NTYSZTNOGI\"\n", "test_list": ["#guard removeLowercase \"KDeoALOklOOHserfLoAJSIskdsf\" = \"KDALOOOHLAJSI\"", "#guard removeLowercase \"ProducTnamEstreAmIngMediAplAYer\" = \"PTEAIMAAY\"", "#guard removeLowercase \"maNufacTuredbYSheZenTechNolOGIes\" = \"NTYSZTNOGI\""]}
{"text": "Write a function to find the smallest integers from a given list of numbers using heap queue algorithm.", "task_id": 496, "code": "import Batteries\n\nopen Std\n\ndef findMin? (xs : List Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | x :: xs => some (xs.foldl (fun acc y => if y < acc then y else acc) x)\n\ndef heapQueueSmallest (nums : List Nat) (n : Nat) : List Nat :=\n  let rec extract (arr : List Nat) (k : Nat) (acc : List Nat) : List Nat :=\n    if k = 0 then acc.reverse\n    else\n      match findMin? arr with\n      | none => acc.reverse\n      | some m =>\n        let arr' := arr.erase m\n        extract arr' (k - 1) (m :: acc)\n  extract nums n []\n\n#guard heapQueueSmallest [25, 35, 22, 85, 14, 65, 75, 25, 58] 3 == [14, 22, 25]\n#guard heapQueueSmallest [25, 35, 22, 85, 14, 65, 75, 25, 58] 2 == [14, 22]\n#guard heapQueueSmallest [25, 35, 22, 85, 14, 65, 75, 22, 58] 5 == [14, 22, 22, 25, 35]\n", "test_list": ["#guard heapQueueSmallest [25, 35, 22, 85, 14, 65, 75, 25, 58] 3 == [14, 22, 25]", "#guard heapQueueSmallest [25, 35, 22, 85, 14, 65, 75, 25, 58] 2 == [14, 22]", "#guard heapQueueSmallest [25, 35, 22, 85, 14, 65, 75, 22, 58] 5 == [14, 22, 22, 25, 35]"]}
{"text": "Write a function to find the surface area of a cone.", "task_id": 497, "code": "import Batteries\nopen Std\n\ndef surfacearea_cone (r h : Nat) : Float :=\n  let rf := (Float.ofNat r)\n  let hf := (Float.ofNat h)\n  let l := Float.sqrt (rf * rf + hf * hf)\n  3.141592653589793 * rf * (rf + l)\n\n#guard surfacearea_cone 5 12 == 282.7433388230814\n#guard surfacearea_cone 10 15 == 880.5179353159282\n#guard surfacearea_cone 19 17 == 2655.923961165254\n", "test_list": ["#guard surfacearea_cone 5 12 == 282.7433388230814", "#guard surfacearea_cone 10 15 == 880.5179353159282", "#guard surfacearea_cone 19 17 == 2655.923961165254"]}
{"text": "Write a python function to find gcd of two positive integers.", "task_id": 498, "code": "import Batteries\n\nopen Std\n\ndef gcd (x y : Nat) : Nat := Id.run do\n  let mut g := 1\n  if x % y == 0 then\n    return y\n  let half := y / 2\n  for i in [1 : half + 1] do\n    let k := half - (i - 1)\n    if x % k == 0 && y % k == 0 then\n      g := k\n      return g\n  return g\n\n#guard gcd 12 17 = 1\n#guard gcd 4 6 = 2\n#guard gcd 2 9 = 1\n", "test_list": ["#guard gcd 12 17 = 1", "#guard gcd 4 6 = 2", "#guard gcd 2 9 = 1"]}
{"text": "Write a function to find the diameter of a circle.", "task_id": 499, "code": "import Batteries\n\nopen Std\n\ndef diameterCircle (r : Nat) : Nat :=\n  let diameter := 2 * r\n  diameter\n\n#guard diameterCircle 10 = 20\n#guard diameterCircle 40 = 80\n#guard diameterCircle 15 = 30\n", "test_list": ["#guard diameterCircle 10 = 20", "#guard diameterCircle 40 = 80", "#guard diameterCircle 15 = 30"]}
{"text": "Write a function to concatenate all elements of the given list into a string.", "task_id": 500, "code": "import Batteries\n\nopen Std\n\ndef concatenate_elements (list : List String) : String :=\n  list.foldl (fun ans i => ans ++ \" \" ++ i) \" \"\n\n#guard concatenate_elements [\"hello\",\"there\",\"have\",\"a\",\"rocky\",\"day\"] == \"  hello there have a rocky day\"\n#guard concatenate_elements [\"Hi\",\"there\",\"How\",\"are\",\"you\"] == \"  Hi there How are you\"\n#guard concatenate_elements [\"Part\",\"of\",\"the\",\"journey\",\"is\",\"end\"] == \"  Part of the journey is end\"\n", "test_list": ["#guard concatenate_elements [\"hello\",\"there\",\"have\",\"a\",\"rocky\",\"day\"] == \"  hello there have a rocky day\"", "#guard concatenate_elements [\"Hi\",\"there\",\"How\",\"are\",\"you\"] == \"  Hi there How are you\"", "#guard concatenate_elements [\"Part\",\"of\",\"the\",\"journey\",\"is\",\"end\"] == \"  Part of the journey is end\""]}
{"text": "Write a python function to find common divisor between two numbers in a given pair.", "task_id": 501, "code": "import Batteries\n\nopen Std\n\ndef ngcd (x y : Nat) : Nat := Id.run do\n  let m := Nat.min x y\n  let mut g := 1\n  for i in [1 : m + 1] do\n    if x % i == 0 && y % i == 0 then\n      g := i\n  return g\n\ndef num_comm_div (x y : Nat) : Nat := Id.run do\n  let n := ngcd x y\n  let z := Nat.sqrt n\n  let mut result := 0\n  for i in [1 : z + 1] do\n    if n % i == 0 then\n      result := result + 2\n      if i == n / i then\n        result := result - 1\n  return result\n\n#guard num_comm_div 2 4 = 2\n#guard num_comm_div 2 8 = 2\n#guard num_comm_div 12 24 = 6\n", "test_list": ["#guard num_comm_div 2 4 = 2", "#guard num_comm_div 2 8 = 2", "#guard num_comm_div 12 24 = 6"]}
{"text": "Write a python function to find remainder of two numbers.", "task_id": 502, "code": "import Batteries\n\nopen Std\n\ndef find (n m : Nat) : Nat :=\n  let r := n % m\n  r\n\n#guard find 3 3 = 0\n#guard find 10 3 = 1\n#guard find 16 5 = 1\n", "test_list": ["#guard find 3 3 = 0", "#guard find 10 3 = 1", "#guard find 16 5 = 1"]}
{"text": "Write a function to add consecutive numbers of a given list.", "task_id": 503, "code": "import Batteries\n\nopen Std\n\ndef addConsecutiveNums (nums : List Nat) : List Nat :=\n  match nums with\n  | [] => []\n  | [_] => []\n  | a :: b :: t => (a + b) :: addConsecutiveNums (b :: t)\n\n#guard addConsecutiveNums [1, 1, 3, 4, 4, 5, 6, 7] = [2, 4, 7, 8, 9, 11, 13]\n#guard addConsecutiveNums [4, 5, 8, 9, 6, 10] = [9, 13, 17, 15, 16]\n#guard addConsecutiveNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = [3, 5, 7, 9, 11, 13, 15, 17, 19]\n", "test_list": ["#guard addConsecutiveNums [1, 1, 3, 4, 4, 5, 6, 7] = [2, 4, 7, 8, 9, 11, 13]", "#guard addConsecutiveNums [4, 5, 8, 9, 6, 10] = [9, 13, 17, 15, 16]", "#guard addConsecutiveNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = [3, 5, 7, 9, 11, 13, 15, 17, 19]"]}
{"text": "Write a python function to find the cube sum of first n natural numbers.", "task_id": 504, "code": "import Batteries\n\nopen Std\n\ndef sum_Of_Series (n : Nat) : Nat := Id.run do\n  let mut s := 0\n  for i in [1 : n + 1] do\n    s := s + i * i * i\n  return s\n\n#guard sum_Of_Series 5 = 225\n#guard sum_Of_Series 2 = 9\n#guard sum_Of_Series 3 = 36\n", "test_list": ["#guard sum_Of_Series 5 = 225", "#guard sum_Of_Series 2 = 9", "#guard sum_Of_Series 3 = 36"]}
{"text": "Write a function to move all zeroes to the end of the given array.", "task_id": 505, "code": "import Batteries\n\nopen Std\n\ndef re_order (A : List Nat) : List Nat := Id.run do\n  let mut arr := A.toArray\n  let mut k : Nat := 0\n  \n  for x in A do\n    if x != 0 then\n      arr := arr.set! k x\n      k := k + 1\n  \n  for i in [k : arr.size] do\n    arr := arr.set! i 0\n  return arr.toList\n\n#guard re_order [6, 0, 8, 2, 3, 0, 4, 0, 1] = [6, 8, 2, 3, 4, 1, 0, 0, 0]\n#guard re_order [4, 0, 2, 7, 0, 9, 0, 12, 0] = [4, 2, 7, 9, 12, 0, 0, 0, 0]\n#guard re_order [3, 11, 0, 74, 14, 0, 1, 0, 2] = [3, 11, 74, 14, 1, 2, 0, 0, 0]\n", "test_list": ["#guard re_order [6, 0, 8, 2, 3, 0, 4, 0, 1] = [6, 8, 2, 3, 4, 1, 0, 0, 0]", "#guard re_order [4, 0, 2, 7, 0, 9, 0, 12, 0] = [4, 2, 7, 9, 12, 0, 0, 0, 0]", "#guard re_order [3, 11, 0, 74, 14, 0, 1, 0, 2] = [3, 11, 74, 14, 1, 2, 0, 0, 0]"]}
{"text": "Write a function to calculate the permutation coefficient of given p(n, k).", "task_id": 506, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef permutationCoefficient (n k : Nat) : Nat := Id.run do\n  let mut P : Array (Array Nat) := Array.replicate (n+1) (Array.replicate (k+1) 0)\n  for i in [0 : n+1] do\n    let m := Nat.min i k\n    for j in [0 : m+1] do\n      if j == 0 then\n        P := P.set2d? i j 1\n      else\n        let v := P.get2d (i-1) j 0 + j * P.get2d (i-1) (j-1) 0\n        P := P.set2d? i j v\n      if j < k then\n        P := P.set2d? i (j+1) 0\n  return P.get2d n k 0\n\n#guard permutationCoefficient 10 2 = 90\n#guard permutationCoefficient 10 3 = 720\n#guard permutationCoefficient 10 1 = 10\n", "test_list": ["#guard permutationCoefficient 10 2 = 90", "#guard permutationCoefficient 10 3 = 720", "#guard permutationCoefficient 10 1 = 10"]}
{"text": "Write a function to remove specific words from a given list.", "task_id": 507, "code": "import Batteries\n\nopen Std\n\ndef removeWords (list1 : List String) (removewords : List String) : List String := Id.run do\n  \n  let copy := list1\n  let mut res := list1\n  for word in copy do\n    if removewords.contains word then\n      res := res.erase word\n  return res\n\n#guard removeWords [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] [\"white\", \"orange\"] == [\"red\", \"green\", \"blue\", \"black\"]\n#guard removeWords [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] [\"black\", \"orange\"] == [\"red\", \"green\", \"blue\", \"white\"]\n#guard removeWords [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] [\"blue\", \"white\"] == [\"red\", \"green\", \"black\", \"orange\"]\n", "test_list": ["#guard removeWords [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] [\"white\", \"orange\"] == [\"red\", \"green\", \"blue\", \"black\"]", "#guard removeWords [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] [\"black\", \"orange\"] == [\"red\", \"green\", \"blue\", \"white\"]", "#guard removeWords [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"] [\"blue\", \"white\"] == [\"red\", \"green\", \"black\", \"orange\"]"]}
{"text": "Write a function to check if the common elements between two given lists are in the same order or not.", "task_id": 508, "code": "import Batteries\n\nopen Std\n\ndef sameOrder (l1 l2 : List String) : Bool :=\n  let s1 := HashSet.ofList l1\n  let s2 := HashSet.ofList l2\n  let common := s1.filter (fun x => x ∈ s2)\n  let l1f := l1.filter (fun e => e ∈ common)\n  let l2f := l2.filter (fun e => e ∈ common)\n  l1f == l2f\n\n#guard sameOrder [\"red\",\"green\",\"black\",\"orange\"] [\"red\",\"pink\",\"green\",\"white\",\"black\"] == true\n#guard sameOrder [\"red\",\"pink\",\"green\",\"white\",\"black\"] [\"white\",\"orange\",\"pink\",\"black\"] == false\n#guard sameOrder [\"red\",\"green\",\"black\",\"orange\"] [\"red\",\"pink\",\"green\",\"white\",\"black\"] == true\n", "test_list": ["#guard sameOrder [\"red\",\"green\",\"black\",\"orange\"] [\"red\",\"pink\",\"green\",\"white\",\"black\"] == true", "#guard sameOrder [\"red\",\"pink\",\"green\",\"white\",\"black\"] [\"white\",\"orange\",\"pink\",\"black\"] == false", "#guard sameOrder [\"red\",\"green\",\"black\",\"orange\"] [\"red\",\"pink\",\"green\",\"white\",\"black\"] == true"]}
{"text": "Write a python function to find the average of odd numbers till a given odd number.", "task_id": 509, "code": "import Batteries\n\nopen Std\n\ndef averageOdd (n : Nat) : Sum String Nat :=\n  if n % 2 == 0 then\n    .inl \"Invalid Input\"\n  else\n    let rec accumOdd : Nat -> Nat × Nat\n      | 0 => (0, 0)\n      | 1 => (1, 1)\n      | Nat.succ (Nat.succ k) =>\n        let (sm, cnt) := accumOdd k\n        (sm + (k + 2), cnt + 1)\n    let (sm, cnt) := accumOdd n\n    .inr (sm / cnt)\n\n#guard averageOdd 9 = .inr 5\n#guard averageOdd 5 = .inr 3\n#guard averageOdd 11 = .inr 6\n", "test_list": ["#guard averageOdd 9 = .inr 5", "#guard averageOdd 5 = .inr 3", "#guard averageOdd 11 = .inr 6"]}
{"text": "Write a function to find the number of subsequences having product smaller than k for the given non negative array.", "task_id": 510, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef noOfSubsequences (arr : List Nat) (k : Nat) : Nat := Id.run do\n  let n := arr.length\n  let mut dp : Array (Array Nat) := Array.replicate (k+1) (Array.replicate (n+1) 0)\n  for i in [1 : k + 1] do\n    for j in [1 : n + 1] do\n      let base := dp.get2d i (j-1) 0\n      let a := arr.getD (j-1) 0\n      let val :=\n        if h : a ≤ i ∧ a > 0 then\n          base + (dp.get2d (i / a) (j-1) 0 + 1)\n        else\n          base\n      dp := dp.set2d? i j val\n  return dp.get2d k n 0\n\n#guard noOfSubsequences [1,2,3,4] 10 = 11\n#guard noOfSubsequences [4,8,7,2] 50 = 9\n#guard noOfSubsequences [5,6,7,8] 15 = 4\n", "test_list": ["#guard noOfSubsequences [1,2,3,4] 10 = 11", "#guard noOfSubsequences [4,8,7,2] 50 = 9", "#guard noOfSubsequences [5,6,7,8] 15 = 4"]}
{"text": "Write a python function to find minimum sum of factors of a given number.", "task_id": 511, "code": "import Batteries\n\nopen Std\n\ndef findMinSum (num : Nat) : Nat := Id.run do\n  let mut s : Nat := 0\n  let mut i : Nat := 2\n  let mut n : Nat := num\n  while i * i <= n do\n    while n % i == 0 do\n      s := s + i\n      n := n / i\n    i := i + 1\n  s := s + n\n  return s\n\n#guard findMinSum 12 = 7\n#guard findMinSum 105 = 15\n#guard findMinSum 2 = 2\n", "test_list": ["#guard findMinSum 12 = 7", "#guard findMinSum 105 = 15", "#guard findMinSum 2 = 2"]}
{"text": "Write a function to count the element frequency in the mixed nested tuple.", "task_id": 512, "code": "import Batteries\nopen Std\n\ninductive NestedTuple where\n| int : Nat → NestedTuple\n| tuple : List NestedTuple → NestedTuple\nderiving Repr\n\ndef flatten (t : NestedTuple) : List Nat :=\n  match t with\n  | .int n => [n]\n  | .tuple xs => xs.flatMap flatten\n\ndef count_element_freq (test_tuple : NestedTuple) : Std.HashMap Nat Nat := Id.run do\n  let mut res : Std.HashMap Nat Nat := {}\n  for ele in flatten test_tuple do\n    let c := (res.get? ele).getD 0\n    res := res.insert ele (c + 1)\n  return res\n\ndef mapOfList (xs : List (Nat × Nat)) : Std.HashMap Nat Nat := Id.run do\n  let mut m : Std.HashMap Nat Nat := {}\n  for (k, v) in xs do\n    m := m.insert k v\n  return m\n\ndef mapsEqual (m1 m2 : Std.HashMap Nat Nat) : Bool := Id.run do\n  if m1.size == m2.size then\n    let mut ok := true\n    for (k, v) in m1.toList do\n      if ((m2.get? k).getD 0) == v then\n        pure ()\n      else\n        ok := false\n    return ok\n  else\n    return false\n\ndef t1 : Task512.NestedTuple :=\n  .tuple [\n    .int 5, .int 6, .tuple [.int 5, .int 6], .int 7, .tuple [.int 8, .int 9], .int 9\n  ]\n#guard mapsEqual (count_element_freq t1) (mapOfList [(5,2), (6,2), (7,1), (8,1), (9,2)])\n\ndef t2 : Task512.NestedTuple :=\n  .tuple [\n    .int 6, .int 7, .tuple [.int 6, .int 7], .int 8, .tuple [.int 9, .int 10], .int 10\n  ]\n#guard mapsEqual (count_element_freq t2) (mapOfList [(6,2), (7,2), (8,1), (9,1), (10,2)])\n\ndef t3 : Task512.NestedTuple :=\n  .tuple [\n    .int 7, .int 8, .tuple [.int 7, .int 8], .int 9, .tuple [.int 10, .int 11], .int 11\n  ]\n#guard mapsEqual (count_element_freq t3) (mapOfList [(7,2), (8,2), (9,1), (10,1), (11,2)])\n", "test_list": ["#guard mapsEqual (count_element_freq t1) (mapOfList [(5,2), (6,2), (7,1), (8,1), (9,2)])", "#guard mapsEqual (count_element_freq t2) (mapOfList [(6,2), (7,2), (8,1), (9,1), (10,2)])", "#guard mapsEqual (count_element_freq t3) (mapOfList [(7,2), (8,2), (9,1), (10,1), (11,2)])"]}
{"text": "Write a function to convert tuple into list by adding the given string after every element.", "task_id": 513, "code": "import Batteries\nopen Std\n\ndef addStr (test_tup : List Nat) (K : String) : List (Sum Nat String) :=\n  List.foldr (fun sub acc => Sum.inl sub :: Sum.inr K :: acc) [] test_tup\n\n#guard addStr [5, 6, 7, 4, 9] \"FDF\" = [Sum.inl 5, Sum.inr \"FDF\", Sum.inl 6, Sum.inr \"FDF\", Sum.inl 7, Sum.inr \"FDF\", Sum.inl 4, Sum.inr \"FDF\", Sum.inl 9, Sum.inr \"FDF\"]\n#guard addStr [7, 8, 9, 10] \"PF\" = [Sum.inl 7, Sum.inr \"PF\", Sum.inl 8, Sum.inr \"PF\", Sum.inl 9, Sum.inr \"PF\", Sum.inl 10, Sum.inr \"PF\"]\n#guard addStr [11, 14, 12, 1, 4] \"JH\" = [Sum.inl 11, Sum.inr \"JH\", Sum.inl 14, Sum.inr \"JH\", Sum.inl 12, Sum.inr \"JH\", Sum.inl 1, Sum.inr \"JH\", Sum.inl 4, Sum.inr \"JH\"]\n", "test_list": ["#guard addStr [5, 6, 7, 4, 9] \"FDF\" = [Sum.inl 5, Sum.inr \"FDF\", Sum.inl 6, Sum.inr \"FDF\", Sum.inl 7, Sum.inr \"FDF\", Sum.inl 4, Sum.inr \"FDF\", Sum.inl 9, Sum.inr \"FDF\"]", "#guard addStr [7, 8, 9, 10] \"PF\" = [Sum.inl 7, Sum.inr \"PF\", Sum.inl 8, Sum.inr \"PF\", Sum.inl 9, Sum.inr \"PF\", Sum.inl 10, Sum.inr \"PF\"]", "#guard addStr [11, 14, 12, 1, 4] \"JH\" = [Sum.inl 11, Sum.inr \"JH\", Sum.inl 14, Sum.inr \"JH\", Sum.inl 12, Sum.inr \"JH\", Sum.inl 1, Sum.inr \"JH\", Sum.inl 4, Sum.inr \"JH\"]"]}
{"text": "Write a function to find the summation of tuple elements in the given tuple list.", "task_id": 514, "code": "import Batteries\n\nopen Std\n\ndef sumElements (test_tup : List Nat) : Nat :=\n  let res := test_tup.foldl (fun acc x => acc + x) 0\n  res\n\n#guard sumElements [7, 8, 9, 1, 10, 7] = 42\n#guard sumElements [1, 2, 3, 4, 5, 6] = 21\n#guard sumElements [11, 12, 13, 45, 14] = 95\n", "test_list": ["#guard sumElements [7, 8, 9, 1, 10, 7] = 42", "#guard sumElements [1, 2, 3, 4, 5, 6] = 21", "#guard sumElements [11, 12, 13, 45, 14] = 95"]}
{"text": "Write a function to check if there is a subset with sum divisible by m.", "task_id": 515, "code": "import Batteries\nopen Std\n\ndef modular_sum (arr : List Nat) (n m : Nat) : Bool :=\n  if n > m then\n    true\n  else\n    if m = 0 then\n      false\n    else\n      let arrN := arr.take n\n      let rec go (xs : List Nat) (dp : Std.HashSet Nat) : Bool :=\n        match xs with\n        | [] => dp.contains 0\n        | a :: xs' =>\n          if dp.contains 0 then\n            true\n          else\n            let temp : Std.HashSet Nat :=\n              dp.fold (init := ({} : Std.HashSet Nat)) (fun acc j => acc.insert ((j + a) % m))\n            let dp2 :=\n              temp.fold (init := dp) (fun acc j => acc.insert j)\n            let dp3 := dp2.insert (a % m)\n            go xs' dp3\n      go arrN ({} : Std.HashSet Nat)\n\n#guard modular_sum [3, 1, 7, 5] 4 6 == true\n#guard modular_sum [1, 7] 2 5 == false\n#guard modular_sum [1, 6] 2 5 == false\n", "test_list": ["#guard modular_sum [3, 1, 7, 5] 4 6 == true", "#guard modular_sum [1, 7] 2 5 == false", "#guard modular_sum [1, 6] 2 5 == false"]}
{"text": "Write a function to sort a list of elements using radix sort.", "task_id": 516, "code": "import Batteries\nopen Std\n\ndef numPasses (m : Nat) : Nat :=\n  if m == 0 then 0\n  else\n    Id.run do\n      let mut t := m - 1\n      let mut acc := 0\n      while t != 0 do\n        t := t / 10\n        acc := acc + 1\n      return acc\n\ndef radixSort (nums : List Nat) : List Nat := Id.run do\n  match nums with\n  | [] => return []\n  | _ =>\n    let maxDigit := nums.foldl (fun m x => if x > m then x else m) 0\n    let passes := numPasses maxDigit\n    let mut placement := 1\n    let mut arr := nums.toArray\n    for _ in [: passes] do\n      let mut buckets : Array (Array Nat) := Array.replicate 10 #[]\n      for i in arr do\n        let tmp := (i / placement) % 10\n        buckets := buckets.modify tmp (fun bucket => bucket.push i)\n      let mut a := 0\n      for b in [0:10] do\n        let buck := buckets[b]!\n        for x in buck do\n          arr := arr.set! a x\n          a := a + 1\n      placement := placement * 10\n    return arr.toList\n\n#guard radixSort [15, 79, 25, 68, 37] = [15, 25, 37, 68, 79]\n#guard radixSort [9, 11, 8, 7, 3, 2] = [2, 3, 7, 8, 9, 11]\n#guard radixSort [36, 12, 24, 26, 29] = [12, 24, 26, 29, 36]\n", "test_list": ["#guard radixSort [15, 79, 25, 68, 37] = [15, 25, 37, 68, 79]", "#guard radixSort [9, 11, 8, 7, 3, 2] = [2, 3, 7, 8, 9, 11]", "#guard radixSort [36, 12, 24, 26, 29] = [12, 24, 26, 29, 36]"]}
{"text": "Write a python function to find the largest postive number from the given list.", "task_id": 517, "code": "import Batteries\n\nopen Std\n\ndef largestPos (list1 : List Int) : Int :=\n  match list1 with\n  | [] => 0\n  | h :: _ =>\n    Id.run do\n      let mut m := h\n      for x in list1 do\n        if x > m then\n          m := x\n      return m\n\n#guard largestPos [1, 2, 3, 4, -1] = 4\n#guard largestPos [0, 1, 2, -5, -1, 6] = 6\n#guard largestPos [0, 0, 1, 0] = 1\n", "test_list": ["#guard largestPos [1, 2, 3, 4, -1] = 4", "#guard largestPos [0, 1, 2, -5, -1, 6] = 6", "#guard largestPos [0, 0, 1, 0] = 1"]}
{"text": "Write a function to find the square root of a perfect number.", "task_id": 518, "code": "import Batteries\n\nopen Std\n\ndef sqrtRoot (num : Nat) : Nat :=\n  \n  Nat.sqrt num\n\n#guard sqrtRoot 4 = 2\n#guard sqrtRoot 16 = 4\n#guard sqrtRoot 400 = 20\n", "test_list": ["#guard sqrtRoot 4 = 2", "#guard sqrtRoot 16 = 4", "#guard sqrtRoot 400 = 20"]}
{"text": "Write a function to calculate volume of a tetrahedron.", "task_id": 519, "code": "import Batteries\n\nopen Std\n\ndef volumeTetrahedron (num : Nat) : Float :=\n  let n := num.toFloat\n  let n3 := n * n * n\n  let denom := 6.0 * Float.sqrt 2.0\n  let volume := n3 / denom\n  (Float.round (volume * 100.0)) / 100.0\n\n#guard volumeTetrahedron 10 == 117.85\n#guard volumeTetrahedron 15 == 397.75\n#guard volumeTetrahedron 20 == 942.81\n", "test_list": ["#guard volumeTetrahedron 10 == 117.85", "#guard volumeTetrahedron 15 == 397.75", "#guard volumeTetrahedron 20 == 942.81"]}
{"text": "Write a function to find the lcm of the given array elements.", "task_id": 520, "code": "import Batteries\nopen Std\n\ndef findLcm (num1 num2 : Nat) : Nat := Id.run do\n  let mut num := if num1 > num2 then num1 else num2\n  let mut den := if num1 > num2 then num2 else num1\n  \n  let mut rem := num % den\n  while rem != 0 do\n    num := den\n    den := rem\n    rem := num % den\n  let g := den\n  let lcm := (num1 * num2) / g\n  return lcm\n\ndef getLcm (l : List Nat) : Nat := Id.run do\n  match l with\n  | num1 :: num2 :: rest =>\n    let mut lcm := findLcm num1 num2\n    for v in rest do\n      lcm := findLcm lcm v\n    return lcm\n  | _ => return 0\n\n#guard getLcm [2, 7, 3, 9, 4] = 252\n#guard getLcm [1, 2, 8, 3] = 24\n#guard getLcm [3, 8, 4, 10, 5] = 120\n", "test_list": ["#guard getLcm [2, 7, 3, 9, 4] = 252", "#guard getLcm [1, 2, 8, 3] = 24", "#guard getLcm [3, 8, 4, 10, 5] = 120"]}
{"text": "Write a function to print check if the triangle is scalene or not.", "task_id": 521, "code": "import Batteries\n\nopen Std\n\ndef check_isosceles (x y z : Nat) : Bool :=\n  if (! (x == y)) && (! (y == z)) && (! (z == x)) then\n    true\n  else\n    false\n\n#guard check_isosceles 6 8 12 == true\n#guard check_isosceles 6 6 12 == false\n#guard check_isosceles 6 15 20 == true\n", "test_list": ["#guard check_isosceles 6 8 12 == true", "#guard check_isosceles 6 6 12 == false", "#guard check_isosceles 6 15 20 == true"]}
{"text": "Write a function to find the longest bitonic subsequence for the given array.", "task_id": 522, "code": "import Batteries\n\nopen Std\n\ndef lbs (arr : List Nat) : Nat := Id.run do\n  let n := arr.length\n  let arrA := arr.toArray\n  let mut lis := Array.replicate (n+1) 1\n  for i in [1 : n] do\n    for j in [0 : i] do\n      if arrA[i]! > arrA[j]! && lis[i]! < lis[j]! + 1 then\n        lis := lis.set! i (lis[j]! + 1)\n  let mut lds := Array.replicate (n+1) 1\n  if n >= 2 then\n    for k in [0 : n-1] do\n      let i := (n-2) - k\n      for j in [i+1 : n] do\n        if arrA[i]! > arrA[j]! && lds[i]! < lds[j]! + 1 then\n          lds := lds.set! i (lds[j]! + 1)\n  let mut maximum := lis[0]! + lds[0]! - 1\n  for i in [1 : n] do\n    let cand := lis[i]! + lds[i]! - 1\n    maximum := if cand > maximum then cand else maximum\n  return maximum\n\n#guard lbs [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] = 7\n#guard lbs [1, 11, 2, 10, 4, 5, 2, 1] = 6\n#guard lbs [80, 60, 30, 40, 20, 10] = 5\n", "test_list": ["#guard lbs [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15] = 7", "#guard lbs [1, 11, 2, 10, 4, 5, 2, 1] = 6", "#guard lbs [80, 60, 30, 40, 20, 10] = 5"]}
{"text": "Write a function to check whether a given string has a capital letter, a lower case letter, a number and specified length using lambda function.", "task_id": 523, "code": "import Batteries\n\nopen Std\n\ninductive BoolOrString\n| bool (b : Bool)\n| str (s : String)\n\nderiving Repr, BEq\n\ndef isUpperAscii (c : Char) : Bool := 'A' ≤ c && c ≤ 'Z'\ndef isLowerAscii (c : Char) : Bool := 'a' ≤ c && c ≤ 'z'\ndef isDigitAscii (c : Char) : Bool := '0' ≤ c && c ≤ '9'\n\ndef checkString (str1 : String) : List String :=\n  let messg : List (String → BoolOrString) := [\n    (fun s => if s.toList.any isUpperAscii then BoolOrString.bool true else BoolOrString.str \"String must have 1 upper case character.\"),\n    (fun s => if s.toList.any isLowerAscii then BoolOrString.bool true else BoolOrString.str \"String must have 1 lower case character.\"),\n    (fun s => if s.toList.any isDigitAscii then BoolOrString.bool true else BoolOrString.str \"String must have 1 number.\"),\n    (fun s => if s.length ≥ 7 then BoolOrString.bool true else BoolOrString.str \"String length should be atleast 8.\")\n  ]\n  let rs := messg.map (fun f => f str1)\n  let result := rs.foldl (fun acc r =>\n    match r with\n    | BoolOrString.bool _ => acc\n    | BoolOrString.str s => acc ++ [s]\n  ) []\n  if result.isEmpty then [\"Valid string.\"] else result\n\n#guard checkString \"python\" = [\"String must have 1 upper case character.\", \"String must have 1 number.\", \"String length should be atleast 8.\"]\n#guard checkString \"123python\" = [\"String must have 1 upper case character.\"]\n#guard checkString \"123Python\" = [\"Valid string.\"]\n", "test_list": ["#guard checkString \"python\" = [\"String must have 1 upper case character.\", \"String must have 1 number.\", \"String length should be atleast 8.\"]", "#guard checkString \"123python\" = [\"String must have 1 upper case character.\"]", "#guard checkString \"123Python\" = [\"Valid string.\"]"]}
{"text": "Write a function to find the sum of maximum increasing subsequence of the given array.", "task_id": 524, "code": "import Batteries\n\nopen Std\n\ndef maxSumIncreasingSubsequence (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let mut msis := Array.replicate n 0\n  for i in [: n] do\n    msis := msis.set! i (a.getD i 0)\n  for i in [1 : n] do\n    for j in [: i] do\n      let ai := a.getD i 0\n      let aj := a.getD j 0\n      if ai > aj && msis[i]! < msis[j]! + ai then\n        msis := msis.set! i (msis[j]! + ai)\n  let mut m := 0\n  for i in [: n] do\n    if m < msis[i]! then\n      m := msis[i]!\n  return m\n\n#guard maxSumIncreasingSubsequence [1, 101, 2, 3, 100, 4, 5] 7 = 106\n#guard maxSumIncreasingSubsequence [3, 4, 5, 10] 4 = 22\n#guard maxSumIncreasingSubsequence [10, 5, 4, 3] 4 = 10\n", "test_list": ["#guard maxSumIncreasingSubsequence [1, 101, 2, 3, 100, 4, 5] 7 = 106", "#guard maxSumIncreasingSubsequence [3, 4, 5, 10] 4 = 22", "#guard maxSumIncreasingSubsequence [10, 5, 4, 3] 4 = 10"]}
{"text": "Write a python function to check whether two given lines are parallel or not.", "task_id": 525, "code": "import Batteries\n\nopen Std\n\ndef parallel_lines (line1 : List Int) (line2 : List Int) : Bool :=\n  match line1, line2 with\n  | a1 :: b1 :: _, a2 :: b2 :: _ => a1 * b2 == a2 * b1\n  | _, _ => false\n\n#guard parallel_lines [2,3,4] [2,3,8] == true\n#guard parallel_lines [2,3,4] [4,-3,8] == false\n#guard parallel_lines [3,3] [5,5] == true\n", "test_list": ["#guard parallel_lines [2,3,4] [2,3,8] == true", "#guard parallel_lines [2,3,4] [4,-3,8] == false", "#guard parallel_lines [3,3] [5,5] == true"]}
{"text": "Write a python function to capitalize first and last letters of each word of a given string.", "task_id": 526, "code": "import Batteries\nopen Std\n\ndef wordTitle (w : String) : String :=\n  if w.length = 0 then \"\"\n  else\n    let first := w.take 1\n    let rest := w.drop 1\n    first.toUpper ++ rest.toLower\n\ndef capitalizeFirstLastLetters (str1 : String) : String := Id.run do\n  let words0 := str1.splitOn \" \"\n  let words := words0.filter (fun w => w != \"\")\n  let titleWords := words.map wordTitle\n  let mut result := \"\"\n  for word in titleWords do\n    let len := word.length\n    if len = 0 then\n      result := result ++ \" \"\n    else\n      result := result ++ (word.take (len - 1)) ++ ((word.drop (len - 1)).toUpper) ++ \" \"\n  if result.length = 0 then\n    return \"\"\n  else\n    return result.take (result.length - 1)\n\n#guard capitalizeFirstLastLetters \"python\" == \"PythoN\"\n#guard capitalizeFirstLastLetters \"bigdata\" == \"BigdatA\"\n#guard capitalizeFirstLastLetters \"Hadoop\" == \"HadooP\"\n", "test_list": ["#guard capitalizeFirstLastLetters \"python\" == \"PythoN\"", "#guard capitalizeFirstLastLetters \"bigdata\" == \"BigdatA\"", "#guard capitalizeFirstLastLetters \"Hadoop\" == \"HadooP\""]}
{"text": "Write a function to find all pairs in an integer array whose sum is equal to a given number.", "task_id": 527, "code": "import Batteries\nopen Std\n\nprivate def listGet? {α} (xs : List α) (i : Nat) : Option α :=\n  match xs, i with\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs', Nat.succ j => listGet? xs' j\n\ndef getPairsCount (arr : List Int) (n : Nat) (sum : Int) : Nat := Id.run do\n  \n  let mut count : Nat := 0\n  for i in [0 : n] do\n    for j in [i + 1 : n] do\n      let ai := (listGet? arr i).getD 0\n      let aj := (listGet? arr j).getD 0\n      if ai + aj == sum then\n        count := count + 1\n  return count\n\n#guard getPairsCount [1, 5, 7, -1, 5] 5 6 = 3\n#guard getPairsCount [1, 5, 7, -1] 4 6 = 2\n#guard getPairsCount [1, 1, 1, 1] 4 2 = 6\n", "test_list": ["#guard getPairsCount [1, 5, 7, -1, 5] 5 6 = 3", "#guard getPairsCount [1, 5, 7, -1] 4 6 = 2", "#guard getPairsCount [1, 1, 1, 1] 4 2 = 6"]}
{"text": "Write a function to find the list of lists with minimum length.", "task_id": 528, "code": "import Batteries\n\nopen Std\n\ndef cmpNat (a b : Nat) : Ordering :=\n  if a == b then Ordering.eq\n  else if Nat.blt a b then Ordering.lt else Ordering.gt\n\ndef compareLexNatList (xs ys : List Nat) : Ordering :=\n  match xs, ys with\n  | [], [] => Ordering.eq\n  | [], _  => Ordering.lt\n  | _, []  => Ordering.gt\n  | x::xs', y::ys' =>\n    match cmpNat x y with\n    | Ordering.lt => Ordering.lt\n    | Ordering.gt => Ordering.gt\n    | Ordering.eq => compareLexNatList xs' ys'\n\ndef minLength (list1 : List (List Nat)) : Nat × List Nat :=\n  match list1 with\n  | [] => (0, [])\n  | x::xs =>\n    xs.foldl\n      (fun (acc : Nat × List Nat) (cur : List Nat) =>\n        let accLen := acc.fst\n        let accList := acc.snd\n        let accLen' := Nat.min accLen cur.length\n        let accList' :=\n          match compareLexNatList cur accList with\n          | Ordering.lt => cur\n          | _ => accList\n        (accLen', accList')\n      )\n      (x.length, x)\n\n#guard minLength [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] = (1, [0])\n#guard minLength [[1], [5, 7], [10, 12, 14, 15]] = (1, [1])\n#guard minLength [[5], [15, 20, 25]] = (1, [5])\n", "test_list": ["#guard minLength [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] = (1, [0])", "#guard minLength [[1], [5, 7], [10, 12, 14, 15]] = (1, [1])", "#guard minLength [[5], [15, 20, 25]] = (1, [5])"]}
{"text": "Write a function to find the nth jacobsthal-lucas number.", "task_id": 529, "code": "import Batteries\n\nopen Std\n\ndef jacobsthalLucas (n : Nat) : Nat := Id.run do\n  \n  let mut dp := Array.replicate (n+1) 0\n  dp := dp.modify 0 (fun _ => 2)\n  dp := dp.modify 1 (fun _ => 1)\n  for i in [2 : n+1] do\n    dp := dp.set! i <| dp[i-1]! + 2 * dp[i-2]!\n  return dp[n]!\n\n#guard jacobsthalLucas 5 == 31\n#guard jacobsthalLucas 2 == 5\n#guard jacobsthalLucas 4 == 17\n", "test_list": ["#guard jacobsthalLucas 5 == 31", "#guard jacobsthalLucas 2 == 5", "#guard jacobsthalLucas 4 == 17"]}
{"text": "Write a function to find the ration of negative numbers in an array of integers.", "task_id": 530, "code": "import Batteries\nopen Std\n\ndef negativeCount (nums : List Int) : Float := Id.run do\n  \n  let n := nums.length\n  let mut n1 : Nat := 0\n  for x in nums do\n    if x < 0 then\n      n1 := n1 + 1\n  let ratio := (Float.ofNat n1) / (Float.ofNat n)\n  let scaled := ratio * 100.0\n  let k := Float.floor (scaled + 0.5)\n  return k / 100.0\n\n#guard negativeCount [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8] == 0.31\n#guard negativeCount [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] == 0.31\n#guard negativeCount [2, 4, -6, -9, 11, -12, 14, -5, 17] == 0.44\n", "test_list": ["#guard negativeCount [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8] == 0.31", "#guard negativeCount [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] == 0.31", "#guard negativeCount [2, 4, -6, -9, 11, -12, 14, -5, 17] == 0.44"]}
{"text": "Write a function to find minimum number of coins that make a given value.", "task_id": 531, "code": "import Batteries\nopen Std\n\ndef listGet? {α} (xs : List α) (i : Nat) : Option α :=\n  let rec go (xs : List α) (i : Nat) : Option α :=\n    match xs with\n    | [] => none\n    | x :: xs' =>\n      match i with\n      | 0 => some x\n      | i+1 => go xs' i\n  go xs i\n\ndef minCoins (coins : List Nat) (m : Nat) (V : Nat) : Nat :=\n  let inf : Nat := 1000000000\n  let coins' := coins.take m\n  let dp :=\n    Id.run do\n      let mut dp : List Nat := [0]\n      for v in [1:V+1] do\n        let mut res := inf\n        for ci in coins' do\n          if ci ≠ 0 ∧ ci ≤ v then\n            let sub := (listGet? dp (v - ci)).getD inf\n            if sub ≠ inf ∧ sub + 1 < res then\n              res := sub + 1\n        dp := dp ++ [res]\n      return dp\n  (listGet? dp V).getD inf\n\n#guard minCoins [9, 6, 5, 1] 4 11 = 2\n#guard minCoins [4, 5, 6, 7, 8, 9] 6 9 = 1\n#guard minCoins [1, 2, 3] 3 4 = 2\n", "test_list": ["#guard minCoins [9, 6, 5, 1] 4 11 = 2", "#guard minCoins [4, 5, 6, 7, 8, 9] 6 9 = 1", "#guard minCoins [1, 2, 3] 3 4 = 2"]}
{"text": "Write a function to check if the two given strings are permutations of each other.", "task_id": 532, "code": "import Batteries\n\nopen Std\n\ndef insertBy {α} (le : α → α → Bool) (x : α) : List α → List α\n| [] => [x]\n| y :: ys => if le x y then x :: y :: ys else y :: insertBy le x ys\n\ndef isort {α} (le : α → α → Bool) : List α → List α\n| [] => []\n| y :: ys => insertBy le y (isort le ys)\n\ndef charLE (a b : Char) : Bool := Nat.ble a.toNat b.toNat\n\ndef joinWith (sep : String) (cs : List Char) : String :=\n  match cs with\n  | [] => \"\"\n  | c :: cs =>\n    cs.foldl (fun acc ch => acc ++ sep ++ String.singleton ch) (String.singleton c)\n\ndef checkPermutation (str1 str2 : String) : Bool :=\n  let n1 := str1.length\n  let n2 := str2.length\n  if n1 != n2 then\n    false\n  else\n    let a := isort charLE str1.data\n    let b := isort charLE str2.data\n    let s1 := joinWith \" \" a\n    let s2 := joinWith \" \" b\n    s1.take n1 == s2.take n2\n\n#guard checkPermutation \"abc\" \"cba\" == true\n#guard checkPermutation \"test\" \"ttew\" == false\n#guard checkPermutation \"xxyz\" \"yxzx\" == true\n", "test_list": ["#guard checkPermutation \"abc\" \"cba\" == true", "#guard checkPermutation \"test\" \"ttew\" == false", "#guard checkPermutation \"xxyz\" \"yxzx\" == true"]}
{"text": "Write a function to remove particular data type elements from the given tuple.", "task_id": 533, "code": "import Batteries\nopen Std\n\ninductive DataType where\n  | int\n  | str\n  | float\n  deriving BEq, DecidableEq, Repr\n\ninductive DataVal where\n  | intVal (i : Int)\n  | strVal (s : String)\n  | floatVal (f : Float)\n  deriving BEq, Repr\n\ndef isInstanceOf (v : DataVal) (t : DataType) : Bool :=\n  match v, t with\n  | .intVal _, .int => true\n  | .strVal _, .str => true\n  | .floatVal _, .float => true\n  | _, _ => false\n\ndef removeDatatype (testTuple : List DataVal) (dataType : DataType) : List DataVal := Id.run do\n  let mut res : Array DataVal := #[]\n  for ele in testTuple do\n    if !(isInstanceOf ele dataType) then\n      res := res.push ele\n  return res.toList\n\n#guard removeDatatype [DataVal.intVal 4, DataVal.intVal 5, DataVal.intVal 4, DataVal.floatVal 7.7, DataVal.floatVal 1.2] DataType.int == [DataVal.floatVal 7.7, DataVal.floatVal 1.2]\n#guard removeDatatype [DataVal.intVal 7, DataVal.intVal 8, DataVal.intVal 9, DataVal.strVal \"SR\"] DataType.str == [DataVal.intVal 7, DataVal.intVal 8, DataVal.intVal 9]\n#guard removeDatatype [DataVal.intVal 7, DataVal.floatVal 1.1, DataVal.intVal 2, DataVal.floatVal 2.2] DataType.float == [DataVal.intVal 7, DataVal.intVal 2]\n", "test_list": ["#guard removeDatatype [DataVal.intVal 4, DataVal.intVal 5, DataVal.intVal 4, DataVal.floatVal 7.7, DataVal.floatVal 1.2] DataType.int == [DataVal.floatVal 7.7, DataVal.floatVal 1.2]", "#guard removeDatatype [DataVal.intVal 7, DataVal.intVal 8, DataVal.intVal 9, DataVal.strVal \"SR\"] DataType.str == [DataVal.intVal 7, DataVal.intVal 8, DataVal.intVal 9]", "#guard removeDatatype [DataVal.intVal 7, DataVal.floatVal 1.1, DataVal.intVal 2, DataVal.floatVal 2.2] DataType.float == [DataVal.intVal 7, DataVal.intVal 2]"]}
{"text": "Write a function to search a literals string in a string and also find the location within the original string where the pattern occurs.", "task_id": 534, "code": "import Batteries\n\nopen Std\n\ndef searchLiteral (pattern : String) (text : String) : Nat × Nat := Id.run do\n  let n := text.length\n  let m := pattern.length\n  for i in [0 : (n + 1) - m] do\n    if (text.drop i).take m == pattern then\n      return (i, i + m)\n  return (0, 0)\n\n#guard searchLiteral \"python\" \"python programming language\" = (0, 6)\n#guard searchLiteral \"programming\" \"python programming language\" = (7, 18)\n#guard searchLiteral \"language\" \"python programming language\" = (19, 27)\n", "test_list": ["#guard searchLiteral \"python\" \"python programming language\" = (0, 6)", "#guard searchLiteral \"programming\" \"python programming language\" = (7, 18)", "#guard searchLiteral \"language\" \"python programming language\" = (19, 27)"]}
{"text": "Write a function to find the top or bottom surface area of a cylinder.", "task_id": 535, "code": "import Batteries\n\nopen Std\n\ndef topbottom_surfacearea (r : Float) : Float :=\n  let toporbottomarea := (3.1415 : Float) * r * r\n  toporbottomarea\n\n#guard topbottom_surfacearea 10.0 == 314.15000000000003\n#guard topbottom_surfacearea 5.0 == 78.53750000000001\n#guard topbottom_surfacearea 4.0 == 50.264\n", "test_list": ["#guard topbottom_surfacearea 10.0 == 314.15000000000003", "#guard topbottom_surfacearea 5.0 == 78.53750000000001", "#guard topbottom_surfacearea 4.0 == 50.264"]}
{"text": "Write a function to select the nth items of a list.", "task_id": 536, "code": "import Batteries\n\nopen Std\n\ndef nthItems (list : List Nat) (n : Nat) : List Nat :=\n  if n = 0 then []\n  else\n    let rec go (xs : List Nat) (i : Nat) : List Nat :=\n      match xs with\n      | [] => []\n      | x :: xs' =>\n        if i % n == 0 then\n          x :: go xs' (i + 1)\n        else\n          go xs' (i + 1)\n    go list 0\n\n#guard nthItems [1, 2, 3, 4, 5, 6, 7, 8, 9] 2 == [1, 3, 5, 7, 9]\n#guard nthItems [10, 15, 19, 17, 16, 18] 3 == [10, 17]\n#guard nthItems [14, 16, 19, 15, 17] 4 == [14, 17]\n", "test_list": ["#guard nthItems [1, 2, 3, 4, 5, 6, 7, 8, 9] 2 == [1, 3, 5, 7, 9]", "#guard nthItems [10, 15, 19, 17, 16, 18] 3 == [10, 17]", "#guard nthItems [14, 16, 19, 15, 17] 4 == [14, 17]"]}
{"text": "Write a python function to find the first repeated word in a given string.", "task_id": 537, "code": "import Batteries\n\nopen Std\n\ndef firstRepeatedWord (str1 : String) : String := Id.run do\n  let words := str1.splitOn \" \"\n  let mut temp : HashSet String := ({} : HashSet String)\n  for word in words do\n    if word ∈ temp then\n      return word\n    else\n      temp := temp.insert word\n  return \"None\"\n\n#guard firstRepeatedWord \"ab ca bc ab\" == \"ab\"\n#guard firstRepeatedWord \"ab ca bc\" == \"None\"\n#guard firstRepeatedWord \"ab ca bc ca ab bc\" == \"ca\"\n", "test_list": ["#guard firstRepeatedWord \"ab ca bc ab\" == \"ab\"", "#guard firstRepeatedWord \"ab ca bc\" == \"None\"", "#guard firstRepeatedWord \"ab ca bc ca ab bc\" == \"ca\""]}
{"text": "Write a python function to convert a given string list to a tuple.", "task_id": 538, "code": "import Batteries\n\nopen Std\n\ndef string_list_to_tuple (str1 : String) : List Char :=\n  str1.data.filter (fun c => !c.isWhitespace)\n\n#guard string_list_to_tuple (\"python 3.0\") == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']\n#guard string_list_to_tuple (\"bigdata\") == ['b', 'i', 'g', 'd', 'a', 't', 'a']\n#guard string_list_to_tuple (\"language\") == ['l', 'a', 'n', 'g', 'u', 'a', 'g', 'e']\n", "test_list": ["#guard string_list_to_tuple (\"python 3.0\") == ['p', 'y', 't', 'h', 'o', 'n', '3', '.', '0']", "#guard string_list_to_tuple (\"bigdata\") == ['b', 'i', 'g', 'd', 'a', 't', 'a']", "#guard string_list_to_tuple (\"language\") == ['l', 'a', 'n', 'g', 'u', 'a', 'g', 'e']"]}
{"text": "Write a function to create a list containing the power of said number in bases raised to the corresponding number in the index using map function.", "task_id": 539, "code": "import Batteries\n\nopen Std\n\ndef basesnum_coresspondingnum (bases_num : List Nat) (index : List Nat) : List Nat :=\n  let rec go (bs is : List Nat) : List Nat :=\n    match bs, is with\n    | b :: bs', i :: is' => (b ^ i) :: go bs' is'\n    | _, _ => []\n  go bases_num index\n\n#guard basesnum_coresspondingnum [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [10, 400, 27000, 2560000, 312500000, 46656000000, 8235430000000, 1677721600000000, 387420489000000000, 100000000000000000000]\n#guard basesnum_coresspondingnum [1, 2, 3, 4, 5, 6, 7] [10, 20, 30, 40, 50, 60, 70] == [1, 1048576, 205891132094649, 1208925819614629174706176, 88817841970012523233890533447265625, 48873677980689257489322752273774603865660850176, 143503601609868434285603076356671071740077383739246066639249]\n#guard basesnum_coresspondingnum [4, 8, 12, 16, 20, 24, 28] [3, 6, 9, 12, 15, 18, 21] == [64, 262144, 5159780352, 281474976710656, 32768000000000000000, 6979147079584381377970176, 2456510688823056210273111113728]\n", "test_list": ["#guard basesnum_coresspondingnum [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == [10, 400, 27000, 2560000, 312500000, 46656000000, 8235430000000, 1677721600000000, 387420489000000000, 100000000000000000000]", "#guard basesnum_coresspondingnum [1, 2, 3, 4, 5, 6, 7] [10, 20, 30, 40, 50, 60, 70] == [1, 1048576, 205891132094649, 1208925819614629174706176, 88817841970012523233890533447265625, 48873677980689257489322752273774603865660850176, 143503601609868434285603076356671071740077383739246066639249]", "#guard basesnum_coresspondingnum [4, 8, 12, 16, 20, 24, 28] [3, 6, 9, 12, 15, 18, 21] == [64, 262144, 5159780352, 281474976710656, 32768000000000000000, 6979147079584381377970176, 2456510688823056210273111113728]"]}
{"text": "Write a python function to find the difference between highest and least frequencies in a given array.", "task_id": 540, "code": "import Batteries\nopen Std\n\ndef findMinAux (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => xs.foldl (fun acc y => if y < acc then y else acc) x\n\ndef deleteOne (l : List Nat) (x : Nat) : List Nat :=\n  match l with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: deleteOne ys x\n\ndef selectionSortAsc (l : List Nat) : List Nat :=\n  let rec loop (fuel : Nat) (rest : List Nat) (res : List Nat) : List Nat :=\n    match fuel with\n    | 0 => res.reverse ++ rest\n    | Nat.succ fuel' =>\n      match rest with\n      | [] => res.reverse\n      | _ =>\n        let m := findMinAux rest\n        let rest' := deleteOne rest m\n        loop fuel' rest' (m :: res)\n  loop l.length l []\n\ndef listGet? {α} (l : List α) (i : Nat) : Option α :=\n  let rec go (l' : List α) (i' : Nat) : Option α :=\n    match l', i' with\n    | [], _ => none\n    | x :: _, 0 => some x\n    | _ :: xs, Nat.succ j => go xs j\n  go l i\n\ndef findDiff (arr : List Nat) (n : Nat) : Int := Id.run do\n  let arrSorted := selectionSortAsc arr\n  let mut count : Nat := 0\n  let mut maxCount : Nat := 0\n  let mut minCount : Nat := n\n  for i in [0 : n - 1] do\n    match listGet? arrSorted i, listGet? arrSorted (i + 1) with\n    | some xi, some xj =>\n      if xi == xj then\n        count := count + 1\n        continue\n      else\n        maxCount := Nat.max maxCount count\n        minCount := Nat.min minCount count\n        count := 0\n    | _, _ => pure ()\n  return Int.ofNat maxCount - Int.ofNat minCount\n\n#guard findDiff [1,1,2,2,7,8,4,5,1,4] 10 == 2\n#guard findDiff [1,7,9,2,3,3,1,3,3] 9 == 3\n#guard findDiff [1,2,1,2] 4 == 0\n", "test_list": ["#guard findDiff [1,1,2,2,7,8,4,5,1,4] 10 == 2", "#guard findDiff [1,7,9,2,3,3,1,3,3] 9 == 3", "#guard findDiff [1,2,1,2] 4 == 0"]}
{"text": "Write a function to find if the given number is abundant or not.", "task_id": 541, "code": "import Batteries\n\nopen Std\n\ndef getSum (n : Nat) : Nat := Id.run do\n  let bound := Nat.sqrt n\n  let mut s : Nat := 0\n  for i in [1 : bound + 1] do\n    if n % i == 0 then\n      let q := n / i\n      if q == i then\n        s := s + i\n      else\n        s := s + i\n        s := s + q\n  s := s - n\n  return s\n\ndef checkAbundant (n : Nat) : Bool :=\n  if getSum n > n then true else false\n\n#guard checkAbundant 12 == true\n#guard checkAbundant 15 == false\n#guard checkAbundant 18 == true\n", "test_list": ["#guard checkAbundant 12 == true", "#guard checkAbundant 15 == false", "#guard checkAbundant 18 == true"]}
{"text": "Write a function to replace all occurrences of spaces, commas, or dots with a colon in the given string by using regex.", "task_id": 542, "code": "import Batteries\n\nopen Std\n\ndef fillSpaces (text : String) : String :=\n  String.mk <|\n    text.data.map (fun c => if c == ' ' || c == ',' || c == '.' then ':' else c)\n\n#guard fillSpaces \"Boult Curve Wireless Neckband\" == \"Boult:Curve:Wireless:Neckband\"\n#guard fillSpaces \"Stereo Sound Sweatproof\" == \"Stereo:Sound:Sweatproof\"\n#guard fillSpaces \"Probass Curve Audio\" == \"Probass:Curve:Audio\"\n", "test_list": ["#guard fillSpaces \"Boult Curve Wireless Neckband\" == \"Boult:Curve:Wireless:Neckband\"", "#guard fillSpaces \"Stereo Sound Sweatproof\" == \"Stereo:Sound:Sweatproof\"", "#guard fillSpaces \"Probass Curve Audio\" == \"Probass:Curve:Audio\""]}
{"text": "Write a function to add two numbers and print number of digits of sum.", "task_id": 543, "code": "import Batteries\n\nopen Std\n\ndef countDigits (num1 num2 : Nat) : Nat := Id.run do\n  let mut number := num1 + num2\n  let mut count := 0\n  while number != 0 do\n    number := number / 10\n    count := count + 1\n  return count\n\n#guard countDigits 9875 10 = 4\n#guard countDigits 98759853034 100 = 11\n#guard countDigits 1234567 500 = 7\n", "test_list": ["#guard countDigits 9875 10 = 4", "#guard countDigits 98759853034 100 = 11", "#guard countDigits 1234567 500 = 7"]}
{"text": "Write a function to flatten the tuple list to a string.", "task_id": 544, "code": "import Batteries\nopen Std\n\ndef flattenTuple (test_list : List (List String)) : String :=\n  let flat : List String := test_list.foldr (fun sub acc => sub ++ acc) []\n  match flat with\n  | [] => \"\"\n  | x :: xs => xs.foldl (fun acc s => acc ++ \" \" ++ s) x\n\n#guard flattenTuple [[\"1\", \"4\", \"6\"], [\"5\", \"8\"], [\"2\", \"9\"], [\"1\", \"10\"]] = \"1 4 6 5 8 2 9 1 10\"\n#guard flattenTuple [[\"2\", \"3\", \"4\"], [\"6\", \"9\"], [\"3\", \"2\"], [\"2\", \"11\"]] = \"2 3 4 6 9 3 2 2 11\"\n#guard flattenTuple [[\"14\", \"21\", \"9\"], [\"24\", \"19\"], [\"12\", \"29\"], [\"23\", \"17\"]] = \"14 21 9 24 19 12 29 23 17\"\n", "test_list": ["#guard flattenTuple [[\"1\", \"4\", \"6\"], [\"5\", \"8\"], [\"2\", \"9\"], [\"1\", \"10\"]] = \"1 4 6 5 8 2 9 1 10\"", "#guard flattenTuple [[\"2\", \"3\", \"4\"], [\"6\", \"9\"], [\"3\", \"2\"], [\"2\", \"11\"]] = \"2 3 4 6 9 3 2 2 11\"", "#guard flattenTuple [[\"14\", \"21\", \"9\"], [\"24\", \"19\"], [\"12\", \"29\"], [\"23\", \"17\"]] = \"14 21 9 24 19 12 29 23 17\""]}
{"text": "Write a python function to toggle only first and last bits of a given number.", "task_id": 545, "code": "import Batteries\n\nopen Std\n\ndef take_L_and_F_set_bits (n : Nat) : Nat := Id.run do\n  let mut m := n\n  m := m ||| Nat.shiftRight m 1\n  m := m ||| Nat.shiftRight m 2\n  m := m ||| Nat.shiftRight m 4\n  m := m ||| Nat.shiftRight m 8\n  m := m ||| Nat.shiftRight m 16\n  return (Nat.shiftRight (m + 1) 1) + 1\n\ndef toggle_F_and_L_bits (n : Nat) : Nat :=\n  if n == 1 then 0 else n ^^^ take_L_and_F_set_bits n\n\n#guard toggle_F_and_L_bits 10 == 3\n#guard toggle_F_and_L_bits 15 == 6\n#guard toggle_F_and_L_bits 20 == 5\n", "test_list": ["#guard toggle_F_and_L_bits 10 == 3", "#guard toggle_F_and_L_bits 15 == 6", "#guard toggle_F_and_L_bits 20 == 5"]}
{"text": "Write a function to find the last occurrence of a character in a string.", "task_id": 546, "code": "import Batteries\n\nopen Std\n\ndef lastOccurenceChar (string : String) (char : Char) : Option Nat := Id.run do\n  let mut flag : Option Nat := none\n  let n := string.length\n  let target := String.singleton char\n  for i in [0 : n] do\n    if (string.drop i).take 1 == target then\n      flag := some i\n  match flag with\n  | none => return none\n  | some i => return some (i + 1)\n\n#guard lastOccurenceChar \"hello world\" 'l' == some 10\n#guard lastOccurenceChar \"language\" 'g' == some 7\n#guard lastOccurenceChar \"little\" 'y' == none\n", "test_list": ["#guard lastOccurenceChar \"hello world\" 'l' == some 10", "#guard lastOccurenceChar \"language\" 'g' == some 7", "#guard lastOccurenceChar \"little\" 'y' == none"]}
{"text": "Write a python function to find the sum of hamming distances of all consecutive numbers from o to n.", "task_id": 547, "code": "import Batteries\n\nopen Std\n\ndef totalHammingDistance (n : Nat) : Nat := Id.run do\n  let mut i := 1\n  let mut s := 0\n  while n / i > 0 do\n    s := s + n / i\n    i := i * 2\n  return s\n\n#guard totalHammingDistance 4 == 7\n#guard totalHammingDistance 2 == 3\n#guard totalHammingDistance 5 == 8\n", "test_list": ["#guard totalHammingDistance 4 == 7", "#guard totalHammingDistance 2 == 3", "#guard totalHammingDistance 5 == 8"]}
{"text": "Write a function to find the length of the longest increasing subsequence of the given sequence.", "task_id": 548, "code": "import Batteries\n\nopen Std\n\ndef longestIncreasingSubsequence (arr : List Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let n := a.size\n  let mut L := Array.replicate n 1\n  for i in [1 : n] do\n    for j in [0 : i] do\n      if a[i]! > a[j]! && L[i]! < L[j]! + 1 then\n        L := L.set! i (L[j]! + 1)\n  let mut maximum := 0\n  for i in [0 : n] do\n    maximum := Nat.max maximum (L[i]!)\n  return maximum\n\n#guard longestIncreasingSubsequence [10, 22, 9, 33, 21, 50, 41, 60] = 5\n#guard longestIncreasingSubsequence [3, 10, 2, 1, 20] = 3\n#guard longestIncreasingSubsequence [50, 3, 10, 7, 40, 80] = 4\n", "test_list": ["#guard longestIncreasingSubsequence [10, 22, 9, 33, 21, 50, 41, 60] = 5", "#guard longestIncreasingSubsequence [3, 10, 2, 1, 20] = 3", "#guard longestIncreasingSubsequence [50, 3, 10, 7, 40, 80] = 4"]}
{"text": "Write a python function to find the sum of fifth power of first n odd natural numbers.", "task_id": 549, "code": "import Batteries\n\nopen Std\n\ndef odd_Num_Sum (n : Nat) : Nat := Id.run do\n  let mut sm := 0\n  for i in [1 : n+1] do\n    let j := (2*i) - 1\n    sm := sm + j * j * j * j * j\n  return sm\n\n#guard odd_Num_Sum 1 = 1\n#guard odd_Num_Sum 2 = 244\n#guard odd_Num_Sum 3 = 3369\n", "test_list": ["#guard odd_Num_Sum 1 = 1", "#guard odd_Num_Sum 2 = 244", "#guard odd_Num_Sum 3 = 3369"]}
{"text": "Write a python function to find the maximum element in a sorted and rotated array.", "task_id": 550, "code": "import Batteries\n\nopen Std\n\npartial def find_Max (arr : List Nat) (low high : Nat) : Nat :=\n  let a := arr.toArray\n  if high < low then\n    a[0]!\n  else if high == low then\n    a[low]!\n  else\n    let mid := low + (high - low) / 2\n    if mid < high && a[mid + 1]! < a[mid]! then\n      a[mid]!\n    else if mid > low && a[mid]! < a[mid - 1]! then\n      a[mid - 1]!\n    else if a[low]! > a[mid]! then\n      find_Max arr low (mid - 1)\n    else\n      find_Max arr (mid + 1) high\n\n#guard find_Max [2,3,5,6,9] 0 4 = 9\n#guard find_Max [3,4,5,2,1] 0 4 = 5\n#guard find_Max [1,2,3] 0 2 = 3\n", "test_list": ["#guard find_Max [2,3,5,6,9] 0 4 = 9", "#guard find_Max [3,4,5,2,1] 0 4 = 5", "#guard find_Max [1,2,3] 0 2 = 3"]}
{"text": "Write a function to extract a specified column from a given nested list.", "task_id": 551, "code": "import Batteries\nopen Std\n\ndef extractColumn (list1 : List (List Int)) (n : Nat) : List Int :=\n  list1.map (fun row =>\n    match row.drop n with\n    | [] => (0 : Int)\n    | x :: _ => x)\n\n#guard extractColumn [[1, 2, 3], [2, 4, 5], [1, 1, 1]] 0 = [1, 2, 1]\n#guard extractColumn [[1, 2, 3], [-2, 4, -5], [1, -1, 1]] 2 = [3, -5, 1]\n#guard extractColumn [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] 0 = [1, 5, 1, 13, 5, 9]\n", "test_list": ["#guard extractColumn [[1, 2, 3], [2, 4, 5], [1, 1, 1]] 0 = [1, 2, 1]", "#guard extractColumn [[1, 2, 3], [-2, 4, -5], [1, -1, 1]] 2 = [3, -5, 1]", "#guard extractColumn [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] 0 = [1, 5, 1, 13, 5, 9]"]}
{"text": "Write a python function to check whether a given sequence is linear or not.", "task_id": 552, "code": "import Batteries\n\nopen Std\n\ndef diffs (xs : List Int) : List Int :=\n  match xs with\n  | [] => []\n  | [_] => []\n  | x :: y :: ys => (y - x) :: diffs (y :: ys)\n\ndef Seq_Linear (seq_nums : List Int) : String :=\n  match diffs seq_nums with\n  | [] => \"Non Linear Sequence\"\n  | d :: ds => if ds.all (fun x => x == d) then \"Linear Sequence\" else \"Non Linear Sequence\"\n\n#guard Seq_Linear [0,2,4,6,8,10] = \"Linear Sequence\"\n#guard Seq_Linear [1,2,3] = \"Linear Sequence\"\n#guard Seq_Linear [1,5,2] = \"Non Linear Sequence\"\n", "test_list": ["#guard Seq_Linear [0,2,4,6,8,10] = \"Linear Sequence\"", "#guard Seq_Linear [1,2,3] = \"Linear Sequence\"", "#guard Seq_Linear [1,5,2] = \"Non Linear Sequence\""]}
{"text": "Write a python function to find odd numbers from a mixed list.", "task_id": 554, "code": "import Batteries\n\nopen Std\n\ndef Split (list : List Nat) : List Nat :=\n  list.filter (fun i => i % 2 != 0)\n\n#guard Split [1,2,3,4,5,6] == [1,3,5]\n#guard Split [10,11,12,13] == [11,13]\n#guard Split [7,8,9,1] == [7,9,1]\n", "test_list": ["#guard Split [1,2,3,4,5,6] == [1,3,5]", "#guard Split [10,11,12,13] == [11,13]", "#guard Split [7,8,9,1] == [7,9,1]"]}
{"text": "Write a python function to find the difference between sum of cubes of first n natural numbers and the sum of first n natural numbers.", "task_id": 555, "code": "import Batteries\n\nopen Std\n\ndef difference (n : Nat) : Nat :=\n  let S := (n * (n + 1)) / 2\n  let res := S * (S - 1)\n  res\n\n#guard difference 3 = 30\n#guard difference 5 = 210\n#guard difference 2 = 6\n", "test_list": ["#guard difference 3 = 30", "#guard difference 5 = 210", "#guard difference 2 = 6"]}
{"text": "Write a python function to count the pairs with xor as an odd number.", "task_id": 556, "code": "import Batteries\n\nopen Std\n\ndef find_Odd_Pair (A : List Nat) (N : Nat) : Nat := Id.run do\n  let mut oddPair := 0\n  for i in [0:N] do\n    for j in [i+1:N] do\n      let ai := A.getD i 0\n      let aj := A.getD j 0\n      if ((ai ^^^ aj) % 2) != 0 then\n        oddPair := oddPair + 1\n  return oddPair\n\n#guard find_Odd_Pair [5,4,7,2,1] 5 = 6\n#guard find_Odd_Pair [7,2,8,1,0,5,11] 7 = 12\n#guard find_Odd_Pair [1,2,3] 3 = 2\n", "test_list": ["#guard find_Odd_Pair [5,4,7,2,1] 5 = 6", "#guard find_Odd_Pair [7,2,8,1,0,5,11] 7 = 12", "#guard find_Odd_Pair [1,2,3] 3 = 2"]}
{"text": "Write a function to toggle characters case in a string.", "task_id": 557, "code": "import Batteries\n\nopen Std\n\ndef toggleString (string : String) : String :=\n  let mapped := string.data.map (fun c =>\n    if 'a' ≤ c && c ≤ 'z' then\n      Char.ofNat (c.toNat - 'a'.toNat + 'A'.toNat)\n    else if 'A' ≤ c && c ≤ 'Z' then\n      Char.ofNat (c.toNat - 'A'.toNat + 'a'.toNat)\n    else c\n  )\n  String.mk mapped\n\n#guard toggleString \"Python\" == \"pYTHON\"\n#guard toggleString \"Pangram\" == \"pANGRAM\"\n#guard toggleString \"LIttLE\" == \"liTTle\"\n", "test_list": ["#guard toggleString \"Python\" == \"pYTHON\"", "#guard toggleString \"Pangram\" == \"pANGRAM\"", "#guard toggleString \"LIttLE\" == \"liTTle\""]}
{"text": "Write a python function to find the digit distance between two integers.", "task_id": 558, "code": "import Batteries\n\nopen Std\n\ndef digitDistanceNums (n1 n2 : Int) : Nat :=\n  let d : Nat := Int.natAbs (n1 - n2)\n  let s := toString d\n  s.data.foldl (fun acc c => acc + (c.toNat - ('0').toNat)) 0\n\n#guard digitDistanceNums 1 2 == 1\n#guard digitDistanceNums 23 56 == 6\n#guard digitDistanceNums 123 256 == 7\n", "test_list": ["#guard digitDistanceNums 1 2 == 1", "#guard digitDistanceNums 23 56 == 6", "#guard digitDistanceNums 123 256 == 7"]}
{"text": "Write a function to find the largest sum of contiguous subarray in the given array.", "task_id": 559, "code": "import Batteries\n\nopen Std\n\ndef max_sub_array_sum (a : List Int) (size : Nat) : Int := Id.run do\n  \n  let arr := a.toArray\n  let mut max_so_far : Int := 0\n  let mut max_ending_here : Int := 0\n  for i in [0 : size] do\n    let x := arr[i]!\n    max_ending_here := max_ending_here + x\n    if max_ending_here < 0 then\n      max_ending_here := 0\n    else if max_so_far < max_ending_here then\n      max_so_far := max_ending_here\n  return max_so_far\n\n#guard max_sub_array_sum [-2, -3, 4, -1, -2, 1, 5, -3] 8 = 7\n#guard max_sub_array_sum [-3, -4, 5, -2, -3, 2, 6, -4] 8 = 8\n#guard max_sub_array_sum [-4, -5, 6, -3, -4, 3, 7, -5] 8 = 10\n", "test_list": ["#guard max_sub_array_sum [-2, -3, 4, -1, -2, 1, 5, -3] 8 = 7", "#guard max_sub_array_sum [-3, -4, 5, -2, -3, 2, 6, -4] 8 = 8", "#guard max_sub_array_sum [-4, -5, 6, -3, -4, 3, 7, -5] 8 = 10"]}
{"text": "Write a function to find the union of elements of the given tuples.", "task_id": 560, "code": "import Batteries\n\nopen Std\n\ndef unionElements (t1 t2 : List Nat) : HashSet Nat :=\n  HashSet.ofList (t1 ++ t2)\n\n#guard unionElements [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [3, 4, 5, 6, 7, 10]\n#guard unionElements [1, 2, 3, 4] [3, 4, 5, 6] == HashSet.ofList [1, 2, 3, 4, 5, 6]\n#guard unionElements [11, 12, 13, 14] [13, 15, 16, 17] == HashSet.ofList [11, 12, 13, 14, 15, 16, 17]\n", "test_list": ["#guard unionElements [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [3, 4, 5, 6, 7, 10]", "#guard unionElements [1, 2, 3, 4] [3, 4, 5, 6] == HashSet.ofList [1, 2, 3, 4, 5, 6]", "#guard unionElements [11, 12, 13, 14] [13, 15, 16, 17] == HashSet.ofList [11, 12, 13, 14, 15, 16, 17]"]}
{"text": "Write a python function to find the maximum length of sublist.", "task_id": 562, "code": "import Batteries\n\nopen Std\n\ndef Find_Max_Length (lst : List (List Nat)) : Nat :=\n  lst.foldl (fun acc x => Nat.max acc x.length) 0\n\n#guard Find_Max_Length [[1], [1,4], [5,6,7,8]] = 4\n#guard Find_Max_Length [[0,1], [2,2], [3,2,1]] = 3\n#guard Find_Max_Length [[7], [22,23], [13,14,15], [10,20,30,40,50]] = 5\n", "test_list": ["#guard Find_Max_Length [[1], [1,4], [5,6,7,8]] = 4", "#guard Find_Max_Length [[0,1], [2,2], [3,2,1]] = 3", "#guard Find_Max_Length [[7], [22,23], [13,14,15], [10,20,30,40,50]] = 5"]}
{"text": "Write a function to extract values between quotation marks of a string.", "task_id": 563, "code": "import Batteries\n\nopen Std\n\ndef extractValues (text : String) : List String :=\n  let parts := text.splitOn \"\\\"\"\n  let rec go (ps : List String) (i : Nat) (acc : List String) : List String :=\n    match ps with\n    | [] => acc.reverse\n    | p :: ps' =>\n      let acc' := if i % 2 = 1 then p :: acc else acc\n      go ps' (i+1) acc'\n  go parts 0 []\n\n#guard extractValues \"\\\"Python\\\", \\\"PHP\\\", \\\"Java\\\"\" = [\"Python\", \"PHP\", \"Java\"]\n#guard extractValues \"\\\"python\\\",\\\"program\\\",\\\"language\\\"\" = [\"python\",\"program\",\"language\"]\n#guard extractValues \"\\\"red\\\",\\\"blue\\\",\\\"green\\\",\\\"yellow\\\"\" = [\"red\",\"blue\",\"green\",\"yellow\"]\n", "test_list": ["#guard extractValues \"\\\"Python\\\", \\\"PHP\\\", \\\"Java\\\"\" = [\"Python\", \"PHP\", \"Java\"]", "#guard extractValues \"\\\"python\\\",\\\"program\\\",\\\"language\\\"\" = [\"python\",\"program\",\"language\"]", "#guard extractValues \"\\\"red\\\",\\\"blue\\\",\\\"green\\\",\\\"yellow\\\"\" = [\"red\",\"blue\",\"green\",\"yellow\"]"]}
{"text": "Write a python function to count unequal element pairs from the given array.", "task_id": 564, "code": "import Batteries\nopen Std\n\ndef listGet? {α : Type u} : List α → Nat → Option α\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs, Nat.succ i => listGet? xs i\n\ndef countPairs (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let mut cnt := 0\n  for i in [0 : n] do\n    for j in [i+1 : n] do\n      let ai := (listGet? arr i).getD 0\n      let aj := (listGet? arr j).getD 0\n      if ai == aj then\n        pure ()\n      else\n        cnt := cnt + 1\n  return cnt\n\n#guard countPairs [1,2,1] 3 = 2\n#guard countPairs [1,1,1,1] 4 = 0\n#guard countPairs [1,2,3,4,5] 5 = 10\n", "test_list": ["#guard countPairs [1,2,1] 3 = 2", "#guard countPairs [1,1,1,1] 4 = 0", "#guard countPairs [1,2,3,4,5] 5 = 10"]}
{"text": "Write a python function to split a string into characters.", "task_id": 565, "code": "import Batteries\nopen Std\n\ndef split (word : String) : List String :=\n  word.data.map (fun c => String.mk [c])\n\n#guard split \"python\" == [\"p\",\"y\",\"t\",\"h\",\"o\",\"n\"]\n#guard split \"Name\" == [\"N\",\"a\",\"m\",\"e\"]\n#guard split \"program\" == [\"p\",\"r\",\"o\",\"g\",\"r\",\"a\",\"m\"]\n", "test_list": ["#guard split \"python\" == [\"p\",\"y\",\"t\",\"h\",\"o\",\"n\"]", "#guard split \"Name\" == [\"N\",\"a\",\"m\",\"e\"]", "#guard split \"program\" == [\"p\",\"r\",\"o\",\"g\",\"r\",\"a\",\"m\"]"]}
{"text": "Write a function to get the sum of a non-negative integer.", "task_id": 566, "code": "import Batteries\n\nopen Std\n\ndef sumDigits (n : Nat) : Nat := Id.run do\n  let mut m := n\n  let mut s := 0\n  while m != 0 do\n    s := s + m % 10\n    m := m / 10\n  return s\n\n#guard sumDigits 345 = 12\n#guard sumDigits 12 = 3\n#guard sumDigits 97 = 16\n", "test_list": ["#guard sumDigits 345 = 12", "#guard sumDigits 12 = 3", "#guard sumDigits 97 = 16"]}
{"text": "Write a function to check whether a specified list is sorted or not.", "task_id": 567, "code": "import Batteries\n\nopen Std\n\ndef issortList (list1 : List Nat) : Bool :=\n  let rec go (l : List Nat) : Bool :=\n    match l with\n    | [] => true\n    | _ :: [] => true\n    | x :: y :: rest => if Nat.ble x y then go (y :: rest) else false\n  go list1\n\n#guard issortList [1,2,4,6,8,10,12,14,16,17] == true\n#guard issortList [1, 2, 4, 6, 8, 10, 12, 14, 20, 17] == false\n#guard issortList [1, 2, 4, 6, 8, 10, 15, 14, 20] == false\n", "test_list": ["#guard issortList [1,2,4,6,8,10,12,14,16,17] == true", "#guard issortList [1, 2, 4, 6, 8, 10, 12, 14, 20, 17] == false", "#guard issortList [1, 2, 4, 6, 8, 10, 15, 14, 20] == false"]}
{"text": "Write a function to create a list of empty dictionaries.", "task_id": 568, "code": "import Batteries\nopen Std\n\ndef emptyList (length : Nat) : List (Std.HashMap Nat Nat) :=\n  List.replicate length (Std.HashMap.emptyWithCapacity (capacity := 0))\n\nmacro_rules\n  | `(Std.HashMap.empty) => `(Std.HashMap.emptyWithCapacity (capacity := 0))\n\ninstance [BEq α] [Hashable α] [BEq β] : BEq (Std.HashMap α β) where\n  beq m₁ m₂ :=\n    let findInList (k : α) (xs : List (α × β)) : Option β :=\n      match xs.find? (fun kv => kv.fst == k) with\n      | some kv => some kv.snd\n      | none => none\n    let ok :=\n      (m₁.toList).foldl (fun acc (kv : α × β) =>\n        if acc then\n          let k := kv.fst\n          let v1 := kv.snd\n          match findInList k (m₂.toList) with\n          | some v2 => v1 == v2\n          | none => false\n        else\n          false\n      ) true\n    ok && (m₁.size == m₂.size)\n\n#guard emptyList 5 == List.replicate 5 (Std.HashMap.empty : Std.HashMap Nat Nat)\n#guard emptyList 6 == List.replicate 6 (Std.HashMap.empty : Std.HashMap Nat Nat)\n#guard emptyList 7 == List.replicate 7 (Std.HashMap.empty : Std.HashMap Nat Nat)\n", "test_list": ["#guard emptyList 5 == List.replicate 5 (Std.HashMap.empty : Std.HashMap Nat Nat)", "#guard emptyList 6 == List.replicate 6 (Std.HashMap.empty : Std.HashMap Nat Nat)", "#guard emptyList 7 == List.replicate 7 (Std.HashMap.empty : Std.HashMap Nat Nat)"]}
{"text": "Write a function to sort each sublist of strings in a given list of lists.", "task_id": 569, "code": "import Batteries\n\nopen Std\n\ndef insertBy {α} (le : α → α → Bool) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys => if le x y then x :: y :: ys else y :: insertBy le x ys\n\ndef isort {α} (le : α → α → Bool) (xs : List α) : List α :=\n  xs.foldr (fun x acc => insertBy le x acc) []\n\ndef strLe (a b : String) : Bool :=\n  match compare a b with\n  | Ordering.lt => true\n  | Ordering.eq => true\n  | Ordering.gt => false\n\ndef sortSublists (list1 : List (List String)) : List (List String) :=\n  list1.map (fun xs => isort strLe xs)\n\n#guard sortSublists [[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]] == [[\"green\", \"orange\"], [\"black\", \"white\"], [\"black\", \"orange\", \"white\"]]\n#guard sortSublists [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]] == [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]]\n#guard sortSublists [[\"a\",\"b\"],[\"d\",\"c\"],[\"g\",\"h\"], [\"f\",\"e\"]] == [[\"a\", \"b\"], [\"c\", \"d\"], [\"g\", \"h\"], [\"e\", \"f\"]]\n", "test_list": ["#guard sortSublists [[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]] == [[\"green\", \"orange\"], [\"black\", \"white\"], [\"black\", \"orange\", \"white\"]]", "#guard sortSublists [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]] == [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]]", "#guard sortSublists [[\"a\",\"b\"],[\"d\",\"c\"],[\"g\",\"h\"], [\"f\",\"e\"]] == [[\"a\", \"b\"], [\"c\", \"d\"], [\"g\", \"h\"], [\"e\", \"f\"]]"]}
{"text": "Write a function to remove words from a given list of strings containing a character or string.", "task_id": 570, "code": "import Batteries\n\nopen Std\n\ndef joinWithSpace (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: xs => xs.foldl (fun acc y => acc ++ \" \" ++ y) x\n\ndef containsSubstring (s sub : String) : Bool := Id.run do\n  if sub == \"\" then return true\n  let n := s.length\n  let m := sub.length\n  if h : m > n then\n    return false\n  else\n    let upper := n - m + 1\n    for i in [0 : upper] do\n      if (s.drop i).take m == sub then\n        return true\n    return false\n\ndef removeWords (list1 : List String) (charlist : List String) : List String :=\n  list1.map (fun line =>\n    let words := line.splitOn \" \"\n    let filtered := words.filter (fun word => not (charlist.any (fun phrase => containsSubstring word phrase)))\n    joinWithSpace filtered\n  )\n\n#guard removeWords [\"Red color\", \"Orange#\", \"Green\", \"Orange @\", \"White\"] [\"#\", \"color\", \"@\"] == [\"Red\", \"\", \"Green\", \"Orange\", \"White\"]\n#guard removeWords [\"Red &\", \"Orange+\", \"Green\", \"Orange @\", \"White\"] [\"&\", \"+\", \"@\"] == [\"Red\", \"\", \"Green\", \"Orange\", \"White\"]\n#guard removeWords [\"Red &\", \"Orange+\", \"Green\", \"Orange @\", \"White\"] [\"@\"] == [\"Red &\", \"Orange+\", \"Green\", \"Orange\", \"White\"]\n", "test_list": ["#guard removeWords [\"Red color\", \"Orange#\", \"Green\", \"Orange @\", \"White\"] [\"#\", \"color\", \"@\"] == [\"Red\", \"\", \"Green\", \"Orange\", \"White\"]", "#guard removeWords [\"Red &\", \"Orange+\", \"Green\", \"Orange @\", \"White\"] [\"&\", \"+\", \"@\"] == [\"Red\", \"\", \"Green\", \"Orange\", \"White\"]", "#guard removeWords [\"Red &\", \"Orange+\", \"Green\", \"Orange @\", \"White\"] [\"@\"] == [\"Red &\", \"Orange+\", \"Green\", \"Orange\", \"White\"]"]}
{"text": "Write a function to find maximum possible sum of disjoint pairs for the given array of integers and a number k.", "task_id": 571, "code": "import Batteries\n\nopen Std\n\ndef insertSorted {α} (le : α → α → Bool) (x : α) (l : List α) : List α :=\n  match l with\n  | [] => [x]\n  | y :: ys => if le x y then x :: l else y :: insertSorted le x ys\n\ndef isort {α} (le : α → α → Bool) (l : List α) : List α :=\n  l.foldr (fun a acc => insertSorted le a acc) []\n\ndef maxSumPairDiffLessthanK (arr : List Nat) (N K : Nat) : Nat := Id.run do\n  let arrSorted := isort Nat.ble arr\n  let arrA := arrSorted.toArray\n  let mut dp := Array.replicate N 0\n  \n  for i in [1 : N] do\n    dp := dp.set! i (dp[i-1]!)\n    let ai := arrA[i]!\n    let aim1 := arrA[i-1]!\n    if Nat.blt (ai - aim1) K then\n      let candidate := if Nat.ble 2 i then dp[i-2]! + ai + aim1 else ai + aim1\n      let prev := dp[i]!\n      let m := Nat.max prev candidate\n      dp := dp.set! i m\n  return dp[N-1]!\n\n#guard maxSumPairDiffLessthanK [3, 5, 10, 15, 17, 12, 9] 7 4 = 62\n#guard maxSumPairDiffLessthanK [5, 15, 10, 300] 4 12 = 25\n#guard maxSumPairDiffLessthanK [1, 2, 3, 4, 5, 6] 6 6 = 21\n", "test_list": ["#guard maxSumPairDiffLessthanK [3, 5, 10, 15, 17, 12, 9] 7 4 = 62", "#guard maxSumPairDiffLessthanK [5, 15, 10, 300] 4 12 = 25", "#guard maxSumPairDiffLessthanK [1, 2, 3, 4, 5, 6] 6 6 = 21"]}
{"text": "Write a python function to remove two duplicate numbers from a given number of lists.", "task_id": 572, "code": "import Batteries\n\nopen Std\n\ndef listCount (xs : List Nat) (x : Nat) : Nat :=\n  xs.foldl (fun acc y => acc + (if y == x then 1 else 0)) 0\n\ndef twoUniqueNums (nums : List Nat) : List Nat :=\n  nums.filter (fun i => listCount nums i == 1)\n\n#guard twoUniqueNums [1,2,3,2,3,4,5] == [1, 4, 5]\n#guard twoUniqueNums [1,2,3,2,4,5] == [1, 3, 4, 5]\n#guard twoUniqueNums [1,2,3,4,5] == [1, 2, 3, 4, 5]\n", "test_list": ["#guard twoUniqueNums [1,2,3,2,3,4,5] == [1, 4, 5]", "#guard twoUniqueNums [1,2,3,2,4,5] == [1, 3, 4, 5]", "#guard twoUniqueNums [1,2,3,4,5] == [1, 2, 3, 4, 5]"]}
{"text": "Write a python function to calculate the product of the unique numbers of a given list.", "task_id": 573, "code": "import Batteries\n\nopen Std\n\ndef unique_product (list_data : List Nat) : Nat := Id.run do\n  let mut seen : HashSet Nat := {}\n  let mut p := 1\n  for i in list_data do\n    if !seen.contains i then\n      p := p * i\n      seen := seen.insert i\n  return p\n\n#guard unique_product [10, 20, 30, 40, 20, 50, 60, 40] = 720000000\n#guard unique_product [1, 2, 3, 1] = 6\n#guard unique_product [7, 8, 9, 0, 1, 1] = 0\n", "test_list": ["#guard unique_product [10, 20, 30, 40, 20, 50, 60, 40] = 720000000", "#guard unique_product [1, 2, 3, 1] = 6", "#guard unique_product [7, 8, 9, 0, 1, 1] = 0"]}
{"text": "Write a function to find the surface area of a cylinder.", "task_id": 574, "code": "import Batteries\n\nopen Std\n\ndef surfacearea_cylinder (r h : Nat) : Float :=\n  let rf := Float.ofNat r\n  let hf := Float.ofNat h\n  let surfacearea := ((2.0 * 3.1415 * rf * rf) + (2.0 * 3.1415 * rf * hf))\n  surfacearea\n\n#guard surfacearea_cylinder 10 5 == (942.45 : Float)\n#guard surfacearea_cylinder 4 5 == (226.18800000000002 : Float)\n#guard surfacearea_cylinder 4 10 == (351.848 : Float)\n", "test_list": ["#guard surfacearea_cylinder 10 5 == (942.45 : Float)", "#guard surfacearea_cylinder 4 5 == (226.18800000000002 : Float)", "#guard surfacearea_cylinder 4 10 == (351.848 : Float)"]}
{"text": "Write a python function to find nth number in a sequence which is not a multiple of a given number.", "task_id": 575, "code": "import Batteries\n\nopen Std\n\ndef countNo (A N L R : Nat) : Nat := Id.run do\n  let mut count := 0\n  let mut res := L\n  for i in [L : R+1] do\n    if i % A != 0 then\n      count := count + 1\n    res := i\n    if count == N then\n      break\n  return res\n\n#guard countNo 2 3 1 10 = 5\n#guard countNo 3 6 4 20 = 11\n#guard countNo 5 10 4 20 = 16\n", "test_list": ["#guard countNo 2 3 1 10 = 5", "#guard countNo 3 6 4 20 = 11", "#guard countNo 5 10 4 20 = 16"]}
{"text": "Write a python function to check whether an array is subarray of another or not.", "task_id": 576, "code": "import Batteries\nopen Std\n\ndef is_Sub_Array (A B : List Nat) (n m : Nat) : Bool :=\n  let arr := A.toArray\n  let brr := B.toArray\n  let fuel0 := (n + 1) * (m + 1) + 1\n  let rec loop (i j : Nat) : Nat → Bool\n    | 0 => false\n    | fuel + 1 =>\n      if i < n && j < m then\n        if arr[i]! == brr[j]! then\n          let i' := i + 1\n          let j' := j + 1\n          if j' == m then true else loop i' j' fuel\n        else\n          let i' := (i - j) + 1\n          let j' := 0\n          loop i' j' fuel\n      else\n        false\n  loop 0 0 fuel0\n\n#guard is_Sub_Array [1,4,3,5] [1,2] 4 2 == false\n#guard is_Sub_Array [1,2,1] [1,2,1] 3 3 == true\n#guard is_Sub_Array [1,0,2,2] [2,2,0] 4 3 == false\n", "test_list": ["#guard is_Sub_Array [1,4,3,5] [1,2] 4 2 == false", "#guard is_Sub_Array [1,2,1] [1,2,1] 3 3 == true", "#guard is_Sub_Array [1,0,2,2] [2,2,0] 4 3 == false"]}
{"text": "Write a python function to find the last digit in factorial of a given number.", "task_id": 577, "code": "import Batteries\n\nopen Std\n\ndef lastDigitFactorial (n : Nat) : Nat :=\n  if n == 0 then 1\n  else if n ≤ 2 then n\n  else if n == 3 then 6\n  else if n == 4 then 4\n  else 0\n\n#guard lastDigitFactorial 4 = 4\n#guard lastDigitFactorial 21 = 0\n#guard lastDigitFactorial 30 = 0\n", "test_list": ["#guard lastDigitFactorial 4 = 4", "#guard lastDigitFactorial 21 = 0", "#guard lastDigitFactorial 30 = 0"]}
{"text": "Write a function to interleave lists of the same length.", "task_id": 578, "code": "import Batteries\n\nopen Std\n\ndef interleaveLists (list1 list2 list3 : List Nat) : List Nat :=\n  match list1, list2, list3 with\n  | x1 :: t1, x2 :: t2, x3 :: t3 => x1 :: x2 :: x3 :: interleaveLists t1 t2 t3\n  | _, _, _ => []\n\n#guard interleaveLists [1,2,3,4,5,6,7] [10,20,30,40,50,60,70] [100,200,300,400,500,600,700] == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n#guard interleaveLists [10,20] [15,2] [5,10] == [10,15,5,20,2,10]\n#guard interleaveLists [11,44] [10,15] [20,5] == [11,10,20,44,15,5]\n", "test_list": ["#guard interleaveLists [1,2,3,4,5,6,7] [10,20,30,40,50,60,70] [100,200,300,400,500,600,700] == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]", "#guard interleaveLists [10,20] [15,2] [5,10] == [10,15,5,20,2,10]", "#guard interleaveLists [11,44] [10,15] [20,5] == [11,10,20,44,15,5]"]}
{"text": "Write a function to find the dissimilar elements in the given two tuples.", "task_id": 579, "code": "import Batteries\n\nopen Std\n\ndef findDissimilar (l1 l2 : List Nat) : HashSet Nat := Id.run do\n  let s1 := HashSet.ofList l1\n  let s2 := HashSet.ofList l2\n  let part1 := s1.filter (fun x => !(x ∈ s2))\n  let part2 := s2.filter (fun x => !(x ∈ s1))\n  let mut res := part1\n  for x in part2.toList do\n    res := res.insert x\n  return res\n\n#guard findDissimilar [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [3, 6, 7, 10]\n#guard findDissimilar [1, 2, 3, 4] [7, 2, 3, 9] == HashSet.ofList [1, 4, 7, 9]\n#guard findDissimilar [21, 11, 25, 26] [26, 34, 21, 36] == HashSet.ofList [34, 36, 11, 25]\n", "test_list": ["#guard findDissimilar [3, 4, 5, 6] [5, 7, 4, 10] == HashSet.ofList [3, 6, 7, 10]", "#guard findDissimilar [1, 2, 3, 4] [7, 2, 3, 9] == HashSet.ofList [1, 4, 7, 9]", "#guard findDissimilar [21, 11, 25, 26] [26, 34, 21, 36] == HashSet.ofList [34, 36, 11, 25]"]}
{"text": "Write a function to extract the even elements in the nested mixed tuple.", "task_id": 580, "code": "import Batteries\nopen Std\n\ninductive PyVal\n| int (n : Nat)\n| tup (xs : List PyVal)\n  deriving Repr, Inhabited\n\nmutual\n  def decEqPyVal (a b : PyVal) : Decidable (a = b) :=\n    match a, b with\n    | PyVal.int n, PyVal.int m =>\n        if h : n = m then\n          isTrue (by cases h; rfl)\n        else\n          isFalse (by\n            intro h'\n            cases h'\n            exact h rfl)\n    | PyVal.tup xs, PyVal.tup ys =>\n        match decEqListPyVal xs ys with\n        | isTrue h => isTrue (by cases h; rfl)\n        | isFalse h => isFalse (by\n            intro h'\n            cases h'\n            exact h rfl)\n    | PyVal.int _, PyVal.tup _ => isFalse (by intro h; cases h)\n    | PyVal.tup _, PyVal.int _ => isFalse (by intro h; cases h)\n  def decEqListPyVal (xs ys : List PyVal) : Decidable (xs = ys) :=\n    match xs, ys with\n    | [], [] => isTrue rfl\n    | [], _::_ => isFalse (by intro h; cases h)\n    | _::_, [] => isFalse (by intro h; cases h)\n    | x::xs', y::ys' =>\n        match decEqPyVal x y with\n        | isTrue hx =>\n            match decEqListPyVal xs' ys' with\n            | isTrue hxs => isTrue (by cases hx; cases hxs; rfl)\n            | isFalse hxs =>\n                isFalse (by\n                  intro h\n                  cases h\n                  exact hxs rfl)\n        | isFalse hx =>\n            isFalse (by\n              intro h\n              cases h\n              exact hx rfl)\nend\n\ninstance : DecidableEq PyVal := fun a b => decEqPyVal a b\n\nmutual\n  def evenEle (t : PyVal) (evenFnc : Nat → Bool) : PyVal :=\n    match t with\n    | PyVal.int _ => PyVal.tup []\n    | PyVal.tup xs => PyVal.tup (processList xs evenFnc)\n\n  def processList (ys : List PyVal) (evenFnc : Nat → Bool) : List PyVal :=\n    match ys with\n    | [] => []\n    | y :: ys' =>\n        let rest := processList ys' evenFnc\n        match y with\n        | PyVal.int n => if evenFnc n then PyVal.int n :: rest else rest\n        | PyVal.tup zs => evenEle (PyVal.tup zs) evenFnc :: rest\nend\n\ndef extractEven (testTuple : PyVal) : PyVal :=\n  let res := evenEle testTuple (fun x => x % 2 == 0)\n  res\n\n#guard extractEven (PyVal.tup [PyVal.int 4, PyVal.int 5, PyVal.tup [PyVal.int 7, PyVal.int 6, PyVal.tup [PyVal.int 2, PyVal.int 4]], PyVal.int 6, PyVal.int 8]) =\n  PyVal.tup [PyVal.int 4, PyVal.tup [PyVal.int 6, PyVal.tup [PyVal.int 2, PyVal.int 4]], PyVal.int 6, PyVal.int 8]\n\n#guard extractEven (PyVal.tup [PyVal.int 5, PyVal.int 6, PyVal.tup [PyVal.int 8, PyVal.int 7, PyVal.tup [PyVal.int 4, PyVal.int 8]], PyVal.int 7, PyVal.int 9]) =\n  PyVal.tup [PyVal.int 6, PyVal.tup [PyVal.int 8, PyVal.tup [PyVal.int 4, PyVal.int 8]]]\n\n#guard extractEven (PyVal.tup [PyVal.int 5, PyVal.int 6, PyVal.tup [PyVal.int 9, PyVal.int 8, PyVal.tup [PyVal.int 4, PyVal.int 6]], PyVal.int 8, PyVal.int 10]) =\n  PyVal.tup [PyVal.int 6, PyVal.tup [PyVal.int 8, PyVal.tup [PyVal.int 4, PyVal.int 6]], PyVal.int 8, PyVal.int 10]\n", "test_list": ["#guard extractEven (PyVal.tup [PyVal.int 4, PyVal.int 5, PyVal.tup [PyVal.int 7, PyVal.int 6, PyVal.tup [PyVal.int 2, PyVal.int 4]], PyVal.int 6, PyVal.int 8]) =", "#guard extractEven (PyVal.tup [PyVal.int 5, PyVal.int 6, PyVal.tup [PyVal.int 8, PyVal.int 7, PyVal.tup [PyVal.int 4, PyVal.int 8]], PyVal.int 7, PyVal.int 9]) =", "#guard extractEven (PyVal.tup [PyVal.int 5, PyVal.int 6, PyVal.tup [PyVal.int 9, PyVal.int 8, PyVal.tup [PyVal.int 4, PyVal.int 6]], PyVal.int 8, PyVal.int 10]) ="]}
{"text": "Write a python function to find the surface area of the square pyramid.", "task_id": 581, "code": "import Batteries\n\nopen Std\n\ndef surfaceArea (b s : Nat) : Nat :=\n  2 * b * s + b ^ 2\n\n#guard surfaceArea 3 4 = 33\n#guard surfaceArea 4 5 = 56\n#guard surfaceArea 1 2 = 5\n", "test_list": ["#guard surfaceArea 3 4 = 33", "#guard surfaceArea 4 5 = 56", "#guard surfaceArea 1 2 = 5"]}
{"text": "Write a function to check if a dictionary is empty or not.", "task_id": 582, "code": "import Batteries\n\nopen Std\n\ndef my_dict (dict1 : HashSet Nat) : Bool :=\n  if (! dict1.isEmpty) then false else true\n\n#guard my_dict (HashSet.ofList [10]) == false\n#guard my_dict (HashSet.ofList [11]) == false\n#guard my_dict (HashSet.empty) == true\n", "test_list": ["#guard my_dict (HashSet.ofList [10]) == false", "#guard my_dict (HashSet.ofList [11]) == false", "#guard my_dict (HashSet.empty) == true"]}
{"text": "Write a function for nth catalan number.", "task_id": 583, "code": "import Batteries\n\nopen Std\n\npartial def catalanNumber (num : Nat) : Nat := Id.run do\n  if num <= 1 then\n    return 1\n  let mut res := 0\n  for i in [:num] do\n    res := res + catalanNumber i * catalanNumber (num - i - 1)\n  return res\n\n#guard catalanNumber 10 == 16796\n#guard catalanNumber 9 == 4862\n#guard catalanNumber 7 == 429\n", "test_list": ["#guard catalanNumber 10 == 16796", "#guard catalanNumber 9 == 4862", "#guard catalanNumber 7 == 429"]}
{"text": "Write a function to find all adverbs and their positions in a given sentence by using regex.", "task_id": 584, "code": "import Batteries\nopen Std\n\ndef isWordChar (c : Char) : Bool :=\n  let n := c.toNat\n  let isLower := ('a'.toNat ≤ n) && (n ≤ 'z'.toNat)\n  let isUpper := ('A'.toNat ≤ n) && (n ≤ 'Z'.toNat)\n  let isDigit := ('0'.toNat ≤ n) && (n ≤ '9'.toNat)\n  isLower || isUpper || isDigit || (n == '_'.toNat)\n\ndef listNth? {α} (xs : List α) (i : Nat) : Option α :=\n  match xs, i with\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs', i+1 => listNth? xs' i\n\ndef charAt? (s : String) (i : Nat) : Option Char :=\n  listNth? s.data i\n\ndef advanceWord (s : String) (j : Nat) (_n : Nat) : Nat :=\n  let tail := s.drop j\n  let rec count (cs : List Char) (acc : Nat) : Nat :=\n    match cs with\n    | [] => acc\n    | c :: cs' =>\n      if isWordChar c then count cs' (acc + 1) else acc\n  j + count tail.data 0\n\ndef findAdverbs (text : String) : String := Id.run do\n  let n := text.length\n  let mut res : Option String := none\n  let mut stop : Bool := false\n  for i in [0 : n] do\n    if !stop then\n      match charAt? text i with\n      | some c =>\n        if isWordChar c then\n          let prevWord :=\n            if i == 0 then false\n            else\n              match charAt? text (i - 1) with\n              | some pc => isWordChar pc\n              | none => false\n          if !prevWord then\n            let j := advanceWord text i n\n            let tokLen := j - i\n            if tokLen >= 3 then\n              let token := (text.drop i).take tokLen\n              if token.length >= 2 && token.drop (token.length - 2) == \"ly\" then\n                let r := toString i ++ \"-\" ++ toString j ++ \": \" ++ token\n                res := some r\n                stop := true\n            else\n              pure ()\n          else\n            pure ()\n        else\n          pure ()\n      | none => pure ()\n    else\n      pure ()\n  return res.getD \"\"\n\n#guard findAdverbs \"Clearly, he has no excuse for such behavior.\" == \"0-7: Clearly\"\n#guard findAdverbs \"Please handle the situation carefuly\" == \"28-36: carefuly\"\n#guard findAdverbs \"Complete the task quickly\" == \"18-25: quickly\"\n", "test_list": ["#guard findAdverbs \"Clearly, he has no excuse for such behavior.\" == \"0-7: Clearly\"", "#guard findAdverbs \"Please handle the situation carefuly\" == \"28-36: carefuly\"", "#guard findAdverbs \"Complete the task quickly\" == \"18-25: quickly\""]}
{"text": "Write a function to find the n - expensive price items from a given dataset using heap queue algorithm.", "task_id": 585, "code": "import Batteries\n\nopen Std\n\nstructure Item where\n  name : String\n  price : Float\n  deriving BEq, Repr\n\ndef expensiveItems (items : List Item) (n : Nat) : List Item := Id.run do\n  let rec findMax (ys : List Item) (i : Nat) (best? : Option (Item × Nat)) : Option (Item × Nat) :=\n    match ys with\n    | [] => best?\n    | y :: ys' =>\n      let best? :=\n        match best? with\n        | none => some (y, i)\n        | some (b, j) => if y.price > b.price then some (y, i) else some (b, j)\n      findMax ys' (i+1) best?\n  let rec removeIdx (ys : List Item) (i : Nat) : List Item :=\n    match ys with\n    | [] => []\n    | y :: ys' =>\n      match i with\n      | 0 => ys'\n      | Nat.succ j => y :: removeIdx ys' j\n  let mut xs := items\n  let mut res : List Item := []\n  for _ in [: n] do\n    match findMax xs 0 none with\n    | none => break\n    | some (m, idx) =>\n      res := res ++ [m]\n      xs := removeIdx xs idx\n  return res\n\n#guard expensiveItems [{ name := \"Item-1\", price := (101.1 : Float) }, { name := \"Item-2\", price := (555.22 : Float) }] 1 == [{ name := \"Item-2\", price := (555.22 : Float) }]\n#guard expensiveItems [{ name := \"Item-1\", price := (101.1 : Float) }, { name := \"Item-2\", price := (555.22 : Float) }, { name := \"Item-3\", price := (45.09 : Float) }] 2 == [{ name := \"Item-2\", price := (555.22 : Float) }, { name := \"Item-1\", price := (101.1 : Float) }]\n#guard expensiveItems [{ name := \"Item-1\", price := (101.1 : Float) }, { name := \"Item-2\", price := (555.22 : Float) }, { name := \"Item-3\", price := (45.09 : Float) }, { name := \"Item-4\", price := (22.75 : Float) }] 1 == [{ name := \"Item-2\", price := (555.22 : Float) }]\n", "test_list": ["#guard expensiveItems [{ name := \"Item-1\", price := (101.1 : Float) }, { name := \"Item-2\", price := (555.22 : Float) }] 1 == [{ name := \"Item-2\", price := (555.22 : Float) }]", "#guard expensiveItems [{ name := \"Item-1\", price := (101.1 : Float) }, { name := \"Item-2\", price := (555.22 : Float) }, { name := \"Item-3\", price := (45.09 : Float) }] 2 == [{ name := \"Item-2\", price := (555.22 : Float) }, { name := \"Item-1\", price := (101.1 : Float) }]", "#guard expensiveItems [{ name := \"Item-1\", price := (101.1 : Float) }, { name := \"Item-2\", price := (555.22 : Float) }, { name := \"Item-3\", price := (45.09 : Float) }, { name := \"Item-4\", price := (22.75 : Float) }] 1 == [{ name := \"Item-2\", price := (555.22 : Float) }]"]}
{"text": "Write a python function to split the array and add the first part to the end.", "task_id": 586, "code": "import Batteries\n\nopen Std\n\ndef split_Arr (a : List Nat) (n k : Nat) : List Nat :=\n  let b := a.take k\n  (a.drop k) ++ b\n\n#guard split_Arr [12,10,5,6,52,36] 6 2 = [5,6,52,36,12,10]\n#guard split_Arr [1,2,3,4] 4 1 = [2,3,4,1]\n#guard split_Arr [0,1,2,3,4,5,6,7] 8 3 = [3,4,5,6,7,0,1,2]\n", "test_list": ["#guard split_Arr [12,10,5,6,52,36] 6 2 = [5,6,52,36,12,10]", "#guard split_Arr [1,2,3,4] 4 1 = [2,3,4,1]", "#guard split_Arr [0,1,2,3,4,5,6,7] 8 3 = [3,4,5,6,7,0,1,2]"]}
{"text": "Write a function to convert a list to a tuple.", "task_id": 587, "code": "import Batteries\n\nopen Std\n\ndef listTuple (listx : List Nat) : List Nat :=\n  listx\n\n#guard listTuple [5, 10, 7, 4, 15, 3] == [5, 10, 7, 4, 15, 3]\n#guard listTuple [2, 4, 5, 6, 2, 3, 4, 4, 7] == [2, 4, 5, 6, 2, 3, 4, 4, 7]\n#guard listTuple [58, 44, 56] == [58, 44, 56]\n", "test_list": ["#guard listTuple [5, 10, 7, 4, 15, 3] == [5, 10, 7, 4, 15, 3]", "#guard listTuple [2, 4, 5, 6, 2, 3, 4, 4, 7] == [2, 4, 5, 6, 2, 3, 4, 4, 7]", "#guard listTuple [58, 44, 56] == [58, 44, 56]"]}
{"text": "Write a python function to find the difference between largest and smallest value in a given array.", "task_id": 588, "code": "import Batteries\n\nopen Std\n\ndef bigDiff (nums : List Nat) : Nat :=\n  match nums with\n  | [] => 0\n  | x :: xs =>\n    let (mn, mx) := xs.foldl (fun (acc : Nat × Nat) y =>\n      let a := acc.fst\n      let b := acc.snd\n      let a' := if y < a then y else a\n      let b' := if y > b then y else b\n      (a', b')\n    ) (x, x)\n    mx - mn\n\n#guard bigDiff [1,2,3,4] == 3\n#guard bigDiff [4,5,12] == 8\n#guard bigDiff [9,2,3] == 7\n", "test_list": ["#guard bigDiff [1,2,3,4] == 3", "#guard bigDiff [4,5,12] == 8", "#guard bigDiff [9,2,3] == 7"]}
{"text": "Write a function to find perfect squares between two given numbers.", "task_id": 589, "code": "import Batteries\n\nopen Std\n\ndef perfectSquares (a b : Nat) : List Nat := Id.run do\n  let mut lists : List Nat := []\n  for i in [a : b+1] do\n    for j in [1 : i+1] do\n      if j * j == i then\n        lists := lists ++ [i]\n  return lists\n\n#guard perfectSquares 1 30 == [1, 4, 9, 16, 25]\n#guard perfectSquares 50 100 == [64, 81, 100]\n#guard perfectSquares 100 200 == [100, 121, 144, 169, 196]\n", "test_list": ["#guard perfectSquares 1 30 == [1, 4, 9, 16, 25]", "#guard perfectSquares 50 100 == [64, 81, 100]", "#guard perfectSquares 100 200 == [100, 121, 144, 169, 196]"]}
{"text": "Write a function to convert polar coordinates to rectangular coordinates.", "task_id": 590, "code": "import Batteries\nopen Std\n\ndef polar_rect (x y : Nat) : ((Float × Float) × (Float × Float)) :=\n  let fx := Float.ofInt (Int.ofNat x)\n  let fy := Float.ofInt (Int.ofNat y)\n  let r  := Float.sqrt (fx*fx + fy*fy)\n  \n  let phi := Float.atan2 fy fx\n  let cn  := (r, phi)\n  \n  let re  : Float := -2.0\n  let im  : Float := 0.0\n  let cn1 := (re, im)\n  (cn, cn1)\n\ndef fAbs (x : Float) : Float := if x >= 0.0 then x else -x\n\ndef almostEq (a b eps : Float) : Bool :=\n  if fAbs (a - b) <= eps then true else false\n\ndef pairAlmostEq (p q : Float × Float) (eps : Float) : Bool :=\n  almostEq p.fst q.fst eps && almostEq p.snd q.snd eps\n\ndef eps : Float := 1.0e-12\n\ndef r1 := polar_rect 3 4\n#guard pairAlmostEq r1.fst (5.0, 0.9272952180016122) eps &&\n       pairAlmostEq r1.snd (-2.0, 2.4492935982947064e-16) eps\n\ndef r2 := polar_rect 4 7\n#guard pairAlmostEq r2.fst (8.06225774829855, 1.0516502125483738) eps &&\n       pairAlmostEq r2.snd (-2.0, 2.4492935982947064e-16) eps\n\ndef r3 := polar_rect 15 17\n#guard pairAlmostEq r3.fst (22.67156809750927, 0.8478169733934057) eps &&\n       pairAlmostEq r3.snd (-2.0, 2.4492935982947064e-16) eps\n", "test_list": ["#guard pairAlmostEq r1.fst (5.0, 0.9272952180016122) eps &&", "#guard pairAlmostEq r2.fst (8.06225774829855, 1.0516502125483738) eps &&", "#guard pairAlmostEq r3.fst (22.67156809750927, 0.8478169733934057) eps &&"]}
{"text": "Write a python function to interchange the first and last elements in a list.", "task_id": 591, "code": "import Batteries\n\nopen Std\n\ndef splitLast {α} : List α → Option (List α × α)\n| [] => none\n| [x] => some ([], x)\n| x :: xs =>\n  match splitLast xs with\n  | none => none\n  | some (init, last) => some (x :: init, last)\n\ndef swap_List (newList : List Nat) : List Nat :=\n  match newList with\n  | [] => []\n  | [x] => [x]\n  | x :: xs =>\n    match splitLast xs with\n    | none => x :: xs\n    | some (mid, last) => last :: mid ++ [x]\n\n#guard swap_List [12, 35, 9, 56, 24] == [24, 35, 9, 56, 12]\n#guard swap_List [1, 2, 3] == [3, 2, 1]\n#guard swap_List [4, 5, 6] == [6, 5, 4]\n", "test_list": ["#guard swap_List [12, 35, 9, 56, 24] == [24, 35, 9, 56, 12]", "#guard swap_List [1, 2, 3] == [3, 2, 1]", "#guard swap_List [4, 5, 6] == [6, 5, 4]"]}
{"text": "Write a python function to find sum of product of binomial co-efficients.", "task_id": 592, "code": "import Batteries\n\nopen Std\n\ndef binomialCoeff (n k : Nat) : Nat := Id.run do\n  let mut C : Array Nat := Array.replicate (k+1) 0\n  C := C.set! 0 1\n  for i in [1 : n+1] do\n    let upper := Nat.min i k\n    let mut j := upper\n    while h : j > 0 do\n      let vj := C[j]!\n      let vjm1 := C[j-1]!\n      C := C.set! j (vj + vjm1)\n      j := j - 1\n  return C[k]!\n\ndef sumOfProduct (n : Nat) : Nat :=\n  binomialCoeff (2 * n) (n - 1)\n\n#guard sumOfProduct 3 == 15\n#guard sumOfProduct 4 == 56\n#guard sumOfProduct 1 == 1\n", "test_list": ["#guard sumOfProduct 3 == 15", "#guard sumOfProduct 4 == 56", "#guard sumOfProduct 1 == 1"]}
{"text": "Write a function to remove leading zeroes from an ip address.", "task_id": 593, "code": "import Batteries\n\nopen Std\n\ndef dropLeadingZeros (s : String) : String :=\n  String.mk (s.data.dropWhile (fun c => c == '0'))\n\ndef removezero_ip (ip : String) : String :=\n  let parts := ip.splitOn \".\"\n  let parts2 := parts.map dropLeadingZeros\n  match parts2 with\n  | [] => \"\"\n  | p::ps => ps.foldl (fun acc s => acc ++ \".\" ++ s) p\n\n#guard removezero_ip \"216.08.094.196\" = \"216.8.94.196\"\n#guard removezero_ip \"12.01.024\" = \"12.1.24\"\n#guard removezero_ip \"216.08.094.0196\" = \"216.8.94.196\"\n", "test_list": ["#guard removezero_ip \"216.08.094.196\" = \"216.8.94.196\"", "#guard removezero_ip \"12.01.024\" = \"12.1.24\"", "#guard removezero_ip \"216.08.094.0196\" = \"216.8.94.196\""]}
{"text": "Write a function to find the difference of first even and odd number of a given list.", "task_id": 594, "code": "import Batteries\n\nopen Std\n\ndef diffEvenOdd (list1 : List Int) : Int :=\n  let firstEven :=\n    match list1.find? (fun el => el % 2 == 0) with\n    | some el => el\n    | none => -1\n  let firstOdd :=\n    match list1.find? (fun el => el % 2 != 0) with\n    | some el => el\n    | none => -1\n  firstEven - firstOdd\n\n#guard diffEvenOdd [1,3,5,7,4,1,6,8] = 3\n#guard diffEvenOdd [1,2,3,4,5,6,7,8,9,10] = 1\n#guard diffEvenOdd [1,5,7,9,10] = 9\n", "test_list": ["#guard diffEvenOdd [1,3,5,7,4,1,6,8] = 3", "#guard diffEvenOdd [1,2,3,4,5,6,7,8,9,10] = 1", "#guard diffEvenOdd [1,5,7,9,10] = 9"]}
{"text": "Write a python function to count minimum number of swaps required to convert one binary string to another.", "task_id": 595, "code": "import Batteries\n\nopen Std\n\ndef mismatchCount (s1 s2 : String) : Nat :=\n  let rec go (l1 l2 : List Char) (acc : Nat) :=\n    match l1, l2 with\n    | c1::t1, c2::t2 =>\n        let acc' := if c1 == c2 then acc else acc + 1\n        go t1 t2 acc'\n    | _, _ => acc\n  go s1.data s2.data 0\n\ndef min_Swaps (str1 str2 : String) : Sum Nat String :=\n  let count := mismatchCount str1 str2\n  if count % 2 == 0 then\n    Sum.inl (count / 2)\n  else\n    Sum.inr \"Not Possible\"\n\n#guard min_Swaps \"1101\" \"1110\" = Sum.inl 1\n#guard min_Swaps \"111\" \"000\" = Sum.inr \"Not Possible\"\n#guard min_Swaps \"111\" \"110\" = Sum.inr \"Not Possible\"\n", "test_list": ["#guard min_Swaps \"1101\" \"1110\" = Sum.inl 1", "#guard min_Swaps \"111\" \"000\" = Sum.inr \"Not Possible\"", "#guard min_Swaps \"111\" \"110\" = Sum.inr \"Not Possible\""]}
{"text": "Write a function to find the size of the given tuple.", "task_id": 596, "code": "import Batteries\n\nopen Std\n\ninductive PyVal where\n  | N : Nat → PyVal\n  | S : String → PyVal\n  | T : List PyVal → PyVal\n\nderiving instance Inhabited for PyVal\n\ndef tupleSize (tuple_list : PyVal) : Nat :=\n  match tuple_list with\n  | PyVal.T xs => xs.length\n  | _ => 0\n\ndef pyGetSizeOf (x : PyVal) : Nat :=\n  tupleSize x\n\n#guard tupleSize (PyVal.T [PyVal.S \"A\", PyVal.N 1, PyVal.S \"B\", PyVal.N 2, PyVal.S \"C\", PyVal.N 3])\n       = pyGetSizeOf (PyVal.T [PyVal.S \"A\", PyVal.N 1, PyVal.S \"B\", PyVal.N 2, PyVal.S \"C\", PyVal.N 3])\n#guard tupleSize (PyVal.T [PyVal.N 1, PyVal.S \"Raju\", PyVal.N 2, PyVal.S \"Nikhil\", PyVal.N 3, PyVal.S \"Deepanshu\"])\n       = pyGetSizeOf (PyVal.T [PyVal.N 1, PyVal.S \"Raju\", PyVal.N 2, PyVal.S \"Nikhil\", PyVal.N 3, PyVal.S \"Deepanshu\"])\n#guard tupleSize (PyVal.T [\n         PyVal.T [PyVal.N 1, PyVal.S \"Lion\"],\n         PyVal.T [PyVal.N 2, PyVal.S \"Tiger\"],\n         PyVal.T [PyVal.N 3, PyVal.S \"Fox\"],\n         PyVal.T [PyVal.N 4, PyVal.S \"Wolf\"]\n       ])\n       = pyGetSizeOf (PyVal.T [\n         PyVal.T [PyVal.N 1, PyVal.S \"Lion\"],\n         PyVal.T [PyVal.N 2, PyVal.S \"Tiger\"],\n         PyVal.T [PyVal.N 3, PyVal.S \"Fox\"],\n         PyVal.T [PyVal.N 4, PyVal.S \"Wolf\"]\n       ])\n", "test_list": ["#guard tupleSize (PyVal.T [PyVal.S \"A\", PyVal.N 1, PyVal.S \"B\", PyVal.N 2, PyVal.S \"C\", PyVal.N 3])", "#guard tupleSize (PyVal.T [PyVal.N 1, PyVal.S \"Raju\", PyVal.N 2, PyVal.S \"Nikhil\", PyVal.N 3, PyVal.S \"Deepanshu\"])", "#guard tupleSize (PyVal.T ["]}
{"text": "Write a function to find kth element from the given two sorted arrays.", "task_id": 597, "code": "import Batteries\n\nopen Std\n\ndef findKth (arr1 arr2 : List Nat) (m n k : Nat) : Nat := Id.run do\n  \n  \n  let a1 := arr1.toArray\n  let a2 := arr2.toArray\n  let mut sorted1 := Array.replicate (m + n) 0\n  let mut i := 0\n  let mut j := 0\n  let mut d := 0\n  while i < m && j < n do\n    if a1[i]! < a2[j]! then\n      sorted1 := sorted1.set! d (a1[i]!)\n      i := i + 1\n    else\n      sorted1 := sorted1.set! d (a2[j]!)\n      j := j + 1\n    d := d + 1\n  while i < m do\n    sorted1 := sorted1.set! d (a1[i]!)\n    d := d + 1\n    i := i + 1\n  while j < n do\n    sorted1 := sorted1.set! d (a2[j]!)\n    d := d + 1\n    j := j + 1\n  return sorted1[k - 1]!\n\n#guard findKth [2, 3, 6, 7, 9] [1, 4, 8, 10] 5 4 5 = 6\n#guard findKth [100, 112, 256, 349, 770] [72, 86, 113, 119, 265, 445, 892] 5 7 7 = 256\n#guard findKth [3, 4, 7, 8, 10] [2, 5, 9, 11] 5 4 6 = 8\n", "test_list": ["#guard findKth [2, 3, 6, 7, 9] [1, 4, 8, 10] 5 4 5 = 6", "#guard findKth [100, 112, 256, 349, 770] [72, 86, 113, 119, 265, 445, 892] 5 7 7 = 256", "#guard findKth [3, 4, 7, 8, 10] [2, 5, 9, 11] 5 4 6 = 8"]}
{"text": "Write a function to check whether the given number is armstrong or not.", "task_id": 598, "code": "import Batteries\n\nopen Std\n\ndef armstrong_number (number : Nat) : Bool :=\n  let rec countDigits (t : Nat) (acc : Nat) : Nat :=\n    if t > 0 then countDigits (t / 10) (acc + 1) else acc\n  let times := countDigits number 0\n  let rec sumPows (t : Nat) (acc : Nat) : Nat :=\n    if t > 0 then\n      let reminder := t % 10\n      sumPows (t / 10) (acc + reminder ^ times)\n    else\n      acc\n  let s := sumPows number 0\n  number == s\n\n#guard armstrong_number 153 == true\n#guard armstrong_number 259 == false\n#guard armstrong_number 4458 == false\n", "test_list": ["#guard armstrong_number 153 == true", "#guard armstrong_number 259 == false", "#guard armstrong_number 4458 == false"]}
{"text": "Write a function to find sum and average of first n natural numbers.", "task_id": 599, "code": "import Batteries\n\nopen Std\n\ndef sumAverage (number : Nat) : Nat × Float := Id.run do\n  let mut total : Nat := 0\n  for value in [1 : number + 1] do\n    total := total + value\n  let average : Float := (Float.ofNat total) / (Float.ofNat number)\n  return (total, average)\n\n#guard sumAverage 10 == (55, 5.5)\n#guard sumAverage 15 == (120, 8.0)\n#guard sumAverage 20 == (210, 10.5)\n", "test_list": ["#guard sumAverage 10 == (55, 5.5)", "#guard sumAverage 15 == (120, 8.0)", "#guard sumAverage 20 == (210, 10.5)"]}
{"text": "Write a python function to check whether the given number is even or not using bitwise operator.", "task_id": 600, "code": "import Batteries\n\nopen Std\n\ndef isEven (n : Nat) : Bool :=\n  if (n ^^^ 1) == (n + 1) then true else false\n\n#guard isEven 1 == false\n#guard isEven 2 == true\n#guard isEven 3 == false\n", "test_list": ["#guard isEven 1 == false", "#guard isEven 2 == true", "#guard isEven 3 == false"]}
{"text": "Write a function to find the longest chain which can be formed from the given set of pairs.", "task_id": 601, "code": "import Batteries\nopen Std\n\nstructure Pair where\n  a : Nat\n  b : Nat\nderiving Inhabited\n\ndef maxChainLength (arr : List Pair) (n : Nat) : Nat := Id.run do\n  \n  let arrA := arr.toArray\n  let mut mcl : Array Nat := Array.replicate n 1\n  for i in [1 : n] do\n    for j in [0 : i] do\n      if arrA[i]!.a > arrA[j]!.b && mcl[i]! < mcl[j]! + 1 then\n        mcl := mcl.set! i (mcl[j]! + 1)\n  let mut mx := 0\n  for i in [0 : n] do\n    if mx < mcl[i]! then\n      mx := mcl[i]!\n  return mx\n\n#guard maxChainLength [Pair.mk 5 24, Pair.mk 15 25, Pair.mk 27 40, Pair.mk 50 60] 4 = 3\n#guard maxChainLength [Pair.mk 1 2, Pair.mk 3 4, Pair.mk 5 6, Pair.mk 7 8] 4 = 4\n#guard maxChainLength [Pair.mk 19 10, Pair.mk 11 12, Pair.mk 13 14, Pair.mk 15 16, Pair.mk 31 54] 5 = 5\n", "test_list": ["#guard maxChainLength [Pair.mk 5 24, Pair.mk 15 25, Pair.mk 27 40, Pair.mk 50 60] 4 = 3", "#guard maxChainLength [Pair.mk 1 2, Pair.mk 3 4, Pair.mk 5 6, Pair.mk 7 8] 4 = 4", "#guard maxChainLength [Pair.mk 19 10, Pair.mk 11 12, Pair.mk 13 14, Pair.mk 15 16, Pair.mk 31 54] 5 = 5"]}
{"text": "Write a function to get a lucid number smaller than or equal to n.", "task_id": 603, "code": "import Batteries\nopen Std\n\ndef getAt? {α} (xs : List α) (i : Nat) : Option α :=\n  match xs, i with\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs, i+1 => getAt? xs i\n\ndef getLudic (n : Nat) : List Nat :=\n  let ludics0 := (List.range n).map (fun i => i + 1)\n  let rec inner (fuel2 : Nat) (first : Nat) (removeIdx : Nat) (lst : List Nat) : List Nat :=\n    match fuel2 with\n    | 0 => lst\n    | fuel2 + 1 =>\n      if removeIdx < lst.length then\n        match getAt? lst removeIdx with\n        | none => lst\n        | some v =>\n          let lst2 := lst.erase v\n          let next := removeIdx + first - 1\n          inner fuel2 first next lst2\n      else\n        lst\n  let rec outer (fuel : Nat) (index : Nat) (lst : List Nat) : List Nat :=\n    match fuel with\n    | 0 => lst\n    | fuel + 1 =>\n      if index != lst.length then\n        match getAt? lst index with\n        | none => lst\n        | some first =>\n          let lst1 := inner (n + 1) first (index + first) lst\n          outer fuel (index + 1) lst1\n      else\n        lst\n  outer (n + 1) 1 ludics0\n\n#guard getLudic 10 = [1, 2, 3, 5, 7]\n#guard getLudic 25 = [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]\n#guard getLudic 45 = [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]\n", "test_list": ["#guard getLudic 10 = [1, 2, 3, 5, 7]", "#guard getLudic 25 = [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]", "#guard getLudic 45 = [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43]"]}
{"text": "Write a function to reverse words in a given string.", "task_id": 604, "code": "import Batteries\n\nopen Std\n\ndef reverseWords (s : String) : String :=\n  let words := (s.splitOn \" \").filter (fun w => w != \"\")\n  String.intercalate \" \" words.reverse\n\n#guard reverseWords \"python program\" = \"program python\"\n#guard reverseWords \"java language\" = \"language java\"\n#guard reverseWords \"indian man\" = \"man indian\"\n", "test_list": ["#guard reverseWords \"python program\" = \"program python\"", "#guard reverseWords \"java language\" = \"language java\"", "#guard reverseWords \"indian man\" = \"man indian\""]}
{"text": "Write a function to check if the given integer is a prime number.", "task_id": 605, "code": "import Batteries\n\nopen Std\n\ndef primeNum (num : Int) : Bool := Id.run do\n  if num >= 1 then\n    let halfNat : Nat := Int.toNat (num / 2)\n    for i in [2 : halfNat] do\n      if num % (Int.ofNat i) == 0 then\n        return false\n      else\n        return true\n    return false\n  else\n    return false\n\n#guard primeNum 13 == true\n#guard primeNum 7 == true\n#guard primeNum (-1010) == false\n", "test_list": ["#guard primeNum 13 == true", "#guard primeNum 7 == true", "#guard primeNum (-1010) == false"]}
{"text": "Write a function to convert degrees to radians.", "task_id": 606, "code": "import Batteries\n\nopen Std\n\ndef radianDegree (degree : Nat) : Float :=\n  let piConst : Float := 3.141592653589793\n  let radian := (Float.ofNat degree) * (piConst / 180.0)\n  radian\n\n#guard radianDegree 90 == 1.5707963267948966\n#guard radianDegree 60 == 1.0471975511965976\n#guard radianDegree 120 == 2.0943951023931953\n", "test_list": ["#guard radianDegree 90 == 1.5707963267948966", "#guard radianDegree 60 == 1.0471975511965976", "#guard radianDegree 120 == 2.0943951023931953"]}
{"text": "Write a function to search a literals string in a string and also find the location within the original string where the pattern occurs by using regex.", "task_id": 607, "code": "import Batteries\n\nopen Std\n\ndef findLiterals (text : String) (pattern : String) : (String × Nat × Nat) := Id.run do\n  let n := text.length\n  let m := pattern.length\n  if m == 0 then\n    return (pattern, 0, 0)\n  if m > n then\n    return (pattern, n, n)\n  for i in [: (n - m + 1)] do\n    if (text.drop i).take m == pattern then\n      return (pattern, i, i + m)\n  \n  return (pattern, n, n)\n\n#guard findLiterals \"The quick brown fox jumps over the lazy dog.\" \"fox\" = (\"fox\", 16, 19)\n#guard findLiterals \"Its been a very crazy procedure right\" \"crazy\" = (\"crazy\", 16, 21)\n#guard findLiterals \"Hardest choices required strongest will\" \"will\" = (\"will\", 35, 39)\n", "test_list": ["#guard findLiterals \"The quick brown fox jumps over the lazy dog.\" \"fox\" = (\"fox\", 16, 19)", "#guard findLiterals \"Its been a very crazy procedure right\" \"crazy\" = (\"crazy\", 16, 21)", "#guard findLiterals \"Hardest choices required strongest will\" \"will\" = (\"will\", 35, 39)"]}
{"text": "Write a python function to find nth bell number.", "task_id": 608, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef bellNumber (n : Nat) : Nat := Id.run do\n  let mut bell : Array (Array Nat) := Array.replicate (n+1) (Array.replicate (n+1) 0)\n  bell := bell.set2d? 0 0 1\n  for i in [1 : n+1] do\n    bell := bell.set2d? i 0 (bell.get2d (i-1) (i-1) 0)\n    for j in [1 : i+1] do\n      bell := bell.set2d? i j (bell.get2d (i-1) (j-1) 0 + bell.get2d i (j-1) 0)\n  return bell.get2d n 0 0\n\n#guard bellNumber 2 = 2\n#guard bellNumber 3 = 5\n#guard bellNumber 4 = 15\n", "test_list": ["#guard bellNumber 2 = 2", "#guard bellNumber 3 = 5", "#guard bellNumber 4 = 15"]}
{"text": "Write a python function to find minimum possible value for the given periodic function.", "task_id": 609, "code": "import Batteries\n\nopen Std\n\ndef floorMin (A B N : Nat) : Nat :=\n  let x := max (B - 1) N\n  (A * x) / B\n\n#guard floorMin 10 20 30 = 15\n#guard floorMin 1 2 1 = 0\n#guard floorMin 11 10 9 = 9\n", "test_list": ["#guard floorMin 10 20 30 = 15", "#guard floorMin 1 2 1 = 0", "#guard floorMin 11 10 9 = 9"]}
{"text": "Write a python function to remove the k'th element from a given list.", "task_id": 610, "code": "import Batteries\n\nopen Std\n\ndef remove_kth_element (list1 : List Nat) (L : Nat) : List Nat :=\n  list1.take (L - 1) ++ list1.drop L\n\n#guard remove_kth_element [1,1,2,3,4,4,5,1] 3 = [1, 1, 3, 4, 4, 5, 1]\n#guard remove_kth_element [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4] 4 = [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]\n#guard remove_kth_element [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10] 5 = [10,10,15,19, 18, 17, 26, 26, 17, 18, 10]\n", "test_list": ["#guard remove_kth_element [1,1,2,3,4,4,5,1] 3 = [1, 1, 3, 4, 4, 5, 1]", "#guard remove_kth_element [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4] 4 = [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]", "#guard remove_kth_element [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10] 5 = [10,10,15,19, 18, 17, 26, 26, 17, 18, 10]"]}
{"text": "Write a function to find the maximum of nth column from the given tuple list.", "task_id": 611, "code": "import Batteries\n\nopen Std\n\ndef maxOfNth (testList : List (List Nat)) (N : Nat) : Nat :=\n  let vals := testList.map (fun sub => sub.getD N 0)\n  vals.foldl (fun acc x => if x > acc then x else acc) 0\n\n#guard maxOfNth [[5, 6, 7], [1, 3, 5], [8, 9, 19]] 2 = 19\n#guard maxOfNth [[6, 7, 8], [2, 4, 6], [9, 10, 20]] 1 = 10\n#guard maxOfNth [[7, 8, 9], [3, 5, 7], [10, 11, 21]] 1 = 11\n", "test_list": ["#guard maxOfNth [[5, 6, 7], [1, 3, 5], [8, 9, 19]] 2 = 19", "#guard maxOfNth [[6, 7, 8], [2, 4, 6], [9, 10, 20]] 1 = 10", "#guard maxOfNth [[7, 8, 9], [3, 5, 7], [10, 11, 21]] 1 = 11"]}
{"text": "Write a python function to merge the first and last elements separately in a list of lists.", "task_id": 612, "code": "import Batteries\n\nopen Std\n\ndef collectHeadsTails {α : Type} : List (List α) → Option (List α × List (List α))\n| [] => some ([], [])\n| (l :: rest) =>\n  match l with\n  | [] => none\n  | h :: t =>\n    match collectHeadsTails rest with\n    | some (hs, ts) => some (h :: hs, t :: ts)\n    | none => none\n\npartial def transposeTrunc {α : Type} (xss : List (List α)) : List (List α) :=\n  match collectHeadsTails xss with\n  | some (hs, ts) => hs :: transposeTrunc ts\n  | none => []\n\ndef merge {α : Type} (lst : List (List α)) : List (List α) :=\n  transposeTrunc lst\n\n#guard merge [[\"x\", \"y\"], [\"a\", \"b\"], [\"m\", \"n\"]] == [[\"x\", \"a\", \"m\"], [\"y\", \"b\", \"n\"]]\n#guard merge [[1, 2], [3, 4], [5, 6], [7, 8]] == [[1, 3, 5, 7], [2, 4, 6, 8]]\n#guard merge [[\"x\", \"y\", \"z\"], [\"a\", \"b\", \"c\"], [\"m\", \"n\", \"o\"]] == [[\"x\", \"a\", \"m\"], [\"y\", \"b\", \"n\"], [\"z\", \"c\", \"o\"]]\n", "test_list": ["#guard merge [[\"x\", \"y\"], [\"a\", \"b\"], [\"m\", \"n\"]] == [[\"x\", \"a\", \"m\"], [\"y\", \"b\", \"n\"]]", "#guard merge [[1, 2], [3, 4], [5, 6], [7, 8]] == [[1, 3, 5, 7], [2, 4, 6, 8]]", "#guard merge [[\"x\", \"y\", \"z\"], [\"a\", \"b\", \"c\"], [\"m\", \"n\", \"o\"]] == [[\"x\", \"a\", \"m\"], [\"y\", \"b\", \"n\"], [\"z\", \"c\", \"o\"]]"]}
{"text": "Write a function to find the maximum value in record list as tuple attribute in the given tuple list.", "task_id": 613, "code": "import Batteries\n\nopen Std\n\ndef maximumValue (testList : List (String × List Nat)) : List (String × Nat) :=\n  testList.map (fun (key, lst) =>\n    let m :=\n      match lst with\n      | [] => 0  \n      | h :: t => t.foldl (fun acc x => if acc < x then x else acc) h\n    (key, m)\n  )\n\n#guard maximumValue [(\"key1\", [3, 4, 5]), (\"key2\", [1, 4, 2]), (\"key3\", [9, 3])] == [(\"key1\", 5), (\"key2\", 4), (\"key3\", 9)]\n#guard maximumValue [(\"key1\", [4, 5, 6]), (\"key2\", [2, 5, 3]), (\"key3\", [10, 4])] == [(\"key1\", 6), (\"key2\", 5), (\"key3\", 10)]\n#guard maximumValue [(\"key1\", [5, 6, 7]), (\"key2\", [3, 6, 4]), (\"key3\", [11, 5])] == [(\"key1\", 7), (\"key2\", 6), (\"key3\", 11)]\n", "test_list": ["#guard maximumValue [(\"key1\", [3, 4, 5]), (\"key2\", [1, 4, 2]), (\"key3\", [9, 3])] == [(\"key1\", 5), (\"key2\", 4), (\"key3\", 9)]", "#guard maximumValue [(\"key1\", [4, 5, 6]), (\"key2\", [2, 5, 3]), (\"key3\", [10, 4])] == [(\"key1\", 6), (\"key2\", 5), (\"key3\", 10)]", "#guard maximumValue [(\"key1\", [5, 6, 7]), (\"key2\", [3, 6, 4]), (\"key3\", [11, 5])] == [(\"key1\", 7), (\"key2\", 6), (\"key3\", 11)]"]}
{"text": "Write a function to find the cumulative sum of all the values that are present in the given tuple list.", "task_id": 614, "code": "import Batteries\n\nopen Std\n\ndef sumList (xs : List Nat) : Nat :=\n  xs.foldl (· + ·) 0\n\ndef cummulative_sum (test_list : List (List Nat)) : Nat :=\n  (test_list.map sumList).foldl (· + ·) 0\n\n#guard cummulative_sum [[1, 3], [5, 6, 7], [2, 6]] = 30\n#guard cummulative_sum [[2, 4], [6, 7, 8], [3, 7]] = 37\n#guard cummulative_sum [[3, 5], [7, 8, 9], [4, 8]] = 44\n", "test_list": ["#guard cummulative_sum [[1, 3], [5, 6, 7], [2, 6]] = 30", "#guard cummulative_sum [[2, 4], [6, 7, 8], [3, 7]] = 37", "#guard cummulative_sum [[3, 5], [7, 8, 9], [4, 8]] = 44"]}
{"text": "Write a function to find average value of the numbers in a given tuple of tuples.", "task_id": 615, "code": "import Batteries\n\nopen Std\n\ndef averageTuple (nums : List (List Int)) : List Float := Id.run do\n  if nums.isEmpty then\n    return []\n  let cols := nums.head!.length\n  let rows := nums.length\n  let mut res : Array Float := #[]\n  for j in [0:cols] do\n    let mut s : Float := 0.0\n    for row in nums do\n      s := s + Float.ofInt (row.getD j 0)\n    res := res.push (s / Float.ofNat rows)\n  return res.toList\n\n#guard averageTuple [[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]] == [30.5, 34.25, 27.0, 23.25]\n#guard averageTuple [[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]] == [25.5, -18.0, 3.75]\n#guard averageTuple [[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]] == [305.0, 342.5, 270.0, 232.5]\n", "test_list": ["#guard averageTuple [[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]] == [30.5, 34.25, 27.0, 23.25]", "#guard averageTuple [[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]] == [25.5, -18.0, 3.75]", "#guard averageTuple [[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]] == [305.0, 342.5, 270.0, 232.5]"]}
{"text": "Write a function to perfom the modulo of tuple elements in the given two tuples.", "task_id": 616, "code": "import Batteries\n\nopen Std\n\ndef tupleModulo (test_tup1 test_tup2 : List Nat) : List Nat :=\n  (List.zip test_tup1 test_tup2).map (fun (a, b) => a % b)\n\n#guard tupleModulo [10, 4, 5, 6] [5, 6, 7, 5] = [0, 4, 5, 1]\n#guard tupleModulo [11, 5, 6, 7] [6, 7, 8, 6] = [5, 5, 6, 1]\n#guard tupleModulo [12, 6, 7, 8] [7, 8, 9, 7] = [5, 6, 7, 1]\n", "test_list": ["#guard tupleModulo [10, 4, 5, 6] [5, 6, 7, 5] = [0, 4, 5, 1]", "#guard tupleModulo [11, 5, 6, 7] [6, 7, 8, 6] = [5, 5, 6, 1]", "#guard tupleModulo [12, 6, 7, 8] [7, 8, 9, 7] = [5, 6, 7, 1]"]}
{"text": "Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.", "task_id": 617, "code": "import Batteries\n\nopen Std\n\ndef min_Jumps (a b d : Nat) : Float :=\n  let temp := a\n  let a' := Nat.min a b\n  let b' := Nat.max temp b\n  if d >= b' then\n    (Float.ofNat (d + b' - 1)) / (Float.ofNat b')\n  else if d == 0 then\n    0.0\n  else if d == a' then\n    1.0\n  else\n    2.0\n\n#guard min_Jumps 3 4 11 == 3.5\n#guard min_Jumps 3 4 0 == 0.0\n#guard min_Jumps 11 14 11 == 1.0\n", "test_list": ["#guard min_Jumps 3 4 11 == 3.5", "#guard min_Jumps 3 4 0 == 0.0", "#guard min_Jumps 11 14 11 == 1.0"]}
{"text": "Write a function to divide two lists using map and lambda function.", "task_id": 618, "code": "import Batteries\n\nopen Std\n\ndef divList (nums1 : List Nat) (nums2 : List Nat) : List Float :=\n  (List.zip nums1 nums2).map (fun p => (Float.ofNat p.fst) / (Float.ofNat p.snd))\n\n#guard divList [4, 5, 6] [1, 2, 3] == [4.0, 2.5, 2.0]\n#guard divList [3, 2] [1, 4] == [3.0, 0.5]\n#guard divList [90, 120] [50, 70] == [1.8, 1.7142857142857142]\n", "test_list": ["#guard divList [4, 5, 6] [1, 2, 3] == [4.0, 2.5, 2.0]", "#guard divList [3, 2] [1, 4] == [3.0, 0.5]", "#guard divList [90, 120] [50, 70] == [1.8, 1.7142857142857142]"]}
{"text": "Write a function to move all the numbers in it to the given string.", "task_id": 619, "code": "import Batteries\n\nopen Std\n\ndef moveNum (test_str : String) : String :=\n  let (res, dig) := (test_str.toList).foldl\n    (fun (acc : String × String) (c : Char) =>\n      let res := acc.fst\n      let dig := acc.snd\n      if c.isDigit then (res, dig.push c) else (res.push c, dig)\n    ) (\"\", \"\")\n  res ++ dig\n\n#guard moveNum \"I1love143you55three3000thousand\" == \"Iloveyouthreethousand1143553000\"\n#guard moveNum \"Avengers124Assemble\" == \"AvengersAssemble124\"\n#guard moveNum \"Its11our12path13to14see15things16do17things\" == \"Itsourpathtoseethingsdothings11121314151617\"\n", "test_list": ["#guard moveNum \"I1love143you55three3000thousand\" == \"Iloveyouthreethousand1143553000\"", "#guard moveNum \"Avengers124Assemble\" == \"AvengersAssemble124\"", "#guard moveNum \"Its11our12path13to14see15things16do17things\" == \"Itsourpathtoseethingsdothings11121314151617\""]}
{"text": "Write a function to find the largest subset where each pair is divisible.", "task_id": 620, "code": "import Batteries\nopen Std\n\ndef largestSubset (a : List Nat) (n : Nat) : Nat := Id.run do\n  let aArr := a.toArray\n  let mut dp := Array.replicate n 0\n  if n == 0 then\n    return 0\n  dp := dp.set! (n - 1) 1\n  let mut i := n - 1\n  while i > 0 do\n    let idx := i - 1\n    let mut mxm := 0\n    let ai := aArr[idx]!\n    let mut j := i\n    while j < n do\n      let aj := aArr[j]!\n      if aj % ai == 0 || ai % aj == 0 then\n        let v := dp[j]!\n        mxm := if mxm < v then v else mxm\n      j := j + 1\n    dp := dp.set! idx (1 + mxm)\n    i := i - 1\n  let mut res := 0\n  for k in [: n] do\n    let v := dp[k]!\n    res := if res < v then v else res\n  return res\n\n#guard largestSubset [1, 3, 6, 13, 17, 18] 6 = 4\n#guard largestSubset [10, 5, 3, 15, 20] 5 = 3\n#guard largestSubset [18, 1, 3, 6, 13, 17] 6 = 4\n", "test_list": ["#guard largestSubset [1, 3, 6, 13, 17, 18] 6 = 4", "#guard largestSubset [10, 5, 3, 15, 20] 5 = 3", "#guard largestSubset [18, 1, 3, 6, 13, 17] 6 = 4"]}
{"text": "Write a function to increment the numeric values in the given strings by k.", "task_id": 621, "code": "import Batteries\n\nopen Std\n\nprivate def parseNatDigits (s : String) : Option Nat :=\n  if s.length == 0 then none else\n  let rec loop (cs : List Char) (acc : Nat) : Option Nat :=\n    match cs with\n    | [] => some acc\n    | c :: cs' =>\n      if '0' ≤ c && c ≤ '9' then\n        let digit := c.toNat - '0'.toNat\n        loop cs' (acc * 10 + digit)\n      else\n        none\n  loop s.data 0\n\ndef increment_numerics (test_list : List String) (K : Nat) : List String :=\n  test_list.map (fun ele =>\n    match parseNatDigits ele with\n    | some n => toString (n + K)\n    | none => ele)\n\n#guard increment_numerics [\"MSM\", \"234\", \"is\", \"98\", \"123\", \"best\", \"4\"] 6 == [\"MSM\", \"240\", \"is\", \"104\", \"129\", \"best\", \"10\"]\n#guard increment_numerics [\"Dart\", \"356\", \"is\", \"88\", \"169\", \"Super\", \"6\"] 12 == [\"Dart\", \"368\", \"is\", \"100\", \"181\", \"Super\", \"18\"]\n#guard increment_numerics [\"Flutter\", \"451\", \"is\", \"44\", \"96\", \"Magnificent\", \"12\"] 33 == [\"Flutter\", \"484\", \"is\", \"77\", \"129\", \"Magnificent\", \"45\"]\n", "test_list": ["#guard increment_numerics [\"MSM\", \"234\", \"is\", \"98\", \"123\", \"best\", \"4\"] 6 == [\"MSM\", \"240\", \"is\", \"104\", \"129\", \"best\", \"10\"]", "#guard increment_numerics [\"Dart\", \"356\", \"is\", \"88\", \"169\", \"Super\", \"6\"] 12 == [\"Dart\", \"368\", \"is\", \"100\", \"181\", \"Super\", \"18\"]", "#guard increment_numerics [\"Flutter\", \"451\", \"is\", \"44\", \"96\", \"Magnificent\", \"12\"] 33 == [\"Flutter\", \"484\", \"is\", \"77\", \"129\", \"Magnificent\", \"45\"]"]}
{"text": "Write a function to find the median of two sorted arrays of same size.", "task_id": 622, "code": "import Batteries\n\nopen Std\n\ndef getMedian (arr1 arr2 : List Nat) (n : Nat) : Float := Id.run do\n  let mut i := 0\n  let mut j := 0\n  let mut m1 : Int := -1\n  let mut m2 : Int := -1\n  for _ in [: n + 1] do\n    if i == n then\n      m1 := m2\n      m2 := Int.ofNat (arr2.getD 0 0)\n      break\n    else if j == n then\n      m1 := m2\n      m2 := Int.ofNat (arr1.getD 0 0)\n      break\n    else\n      let ai := arr1.getD i 0\n      let aj := arr2.getD j 0\n      if ai ≤ aj then\n        m1 := m2\n        m2 := Int.ofNat ai\n        i := i + 1\n      else\n        m1 := m2\n        m2 := Int.ofNat aj\n        j := j + 1\n  return Float.ofInt (m1 + m2) / 2.0\n\n#guard getMedian [1, 12, 15, 26, 38] [2, 13, 17, 30, 45] 5 == 16.0\n#guard getMedian [2, 4, 8, 9] [7, 13, 19, 28] 4 == 8.5\n#guard getMedian [3, 6, 14, 23, 36, 42] [2, 18, 27, 39, 49, 55] 6 == 25.0\n", "test_list": ["#guard getMedian [1, 12, 15, 26, 38] [2, 13, 17, 30, 45] 5 == 16.0", "#guard getMedian [2, 4, 8, 9] [7, 13, 19, 28] 4 == 8.5", "#guard getMedian [3, 6, 14, 23, 36, 42] [2, 18, 27, 39, 49, 55] 6 == 25.0"]}
{"text": "Write a function to find the n-th power of individual elements in a list using lambda function.", "task_id": 623, "code": "import Batteries\n\nopen Std\n\ndef nthNums (nums : List Nat) (n : Nat) : List Nat :=\n  nums.map (fun x => x ^ n)\n\n#guard nthNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2 == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n#guard nthNums [10, 20, 30] 3 == [1000, 8000, 27000]\n#guard nthNums [12, 15] 5 == [248832, 759375]\n", "test_list": ["#guard nthNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2 == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "#guard nthNums [10, 20, 30] 3 == [1000, 8000, 27000]", "#guard nthNums [12, 15] 5 == [248832, 759375]"]}
{"text": "Write a python function to convert the given string to upper case.", "task_id": 624, "code": "import Batteries\n\nopen Std\n\ndef isUpper (string : String) : String :=\n  string.map Char.toUpper\n\n#guard isUpper \"person\" == \"PERSON\"\n#guard isUpper \"final\" == \"FINAL\"\n#guard isUpper \"Valid\" == \"VALID\"\n", "test_list": ["#guard isUpper \"person\" == \"PERSON\"", "#guard isUpper \"final\" == \"FINAL\"", "#guard isUpper \"Valid\" == \"VALID\""]}
{"text": "Write a python function to interchange first and last elements in a given list.", "task_id": 625, "code": "import Batteries\n\nopen Std\n\ndef swapList (newList : List Nat) : List Nat := Id.run do\n  \n  let size := newList.length\n  let mut arr := newList.toArray\n  let temp := arr[0]!\n  arr := arr.set! 0 arr[size - 1]!\n  arr := arr.set! (size - 1) temp\n  return arr.toList\n\n#guard swapList [1, 2, 3] = [3, 2, 1]\n#guard swapList [1, 2, 3, 4, 4] = [4, 2, 3, 4, 1]\n#guard swapList [4, 5, 6] = [6, 5, 4]\n", "test_list": ["#guard swapList [1, 2, 3] = [3, 2, 1]", "#guard swapList [1, 2, 3, 4, 4] = [4, 2, 3, 4, 1]", "#guard swapList [4, 5, 6] = [6, 5, 4]"]}
{"text": "Write a python function to find the largest triangle that can be inscribed in the semicircle.", "task_id": 626, "code": "import Batteries\n\nopen Std\n\ndef triangleArea (r : Int) : Int :=\n  if r < 0 then\n    -1\n  else\n    r * r\n\n#guard triangleArea 0 = 0\n#guard triangleArea (-1) = -1\n#guard triangleArea 2 = 4\n", "test_list": ["#guard triangleArea 0 = 0", "#guard triangleArea (-1) = -1", "#guard triangleArea 2 = 4"]}
{"text": "Write a python function to find the smallest missing number from the given array.", "task_id": 627, "code": "import Batteries\n\nopen Std\n\ndef findFirstMissing (array : List Nat) (start end_ : Nat) : Nat := Id.run do\n  \n  let mut s := start\n  let mut e := end_\n  while s ≤ e do\n    if s != array.getD s 0 then\n      return s\n    let mid := (s + e) / 2\n    if array.getD mid 0 == mid then\n      s := mid + 1\n    else\n      e := mid\n  return e + 1\n\n#guard findFirstMissing [0,1,2,3] 0 3 = 4\n#guard findFirstMissing [0,1,2,6,9] 0 4 = 3\n#guard findFirstMissing [2,3,5,8,9] 0 4 = 0\n", "test_list": ["#guard findFirstMissing [0,1,2,3] 0 3 = 4", "#guard findFirstMissing [0,1,2,6,9] 0 4 = 3", "#guard findFirstMissing [2,3,5,8,9] 0 4 = 0"]}
{"text": "Write a function to replace all spaces in the given string with character * list item * list item * list item * list item '%20'.", "task_id": 628, "code": "import Batteries\nopen Std\n\ndef MAX : Nat := 1000\n\nprivate def dropFrontSpaces (cs : List Char) : List Char :=\n  match cs with\n  | [] => []\n  | c :: t => if c == ' ' then dropFrontSpaces t else cs\n\nprivate def rstripSpaces (cs : List Char) : List Char :=\n  let rec trimRev (rev : List Char) : List Char :=\n    match rev with\n    | [] => []\n    | c :: t => if c == ' ' then trimRev t else rev\n  (trimRev cs.reverse).reverse\n\nprivate def trimSpaces (s : String) : String :=\n  let cs := s.data\n  let cs1 := dropFrontSpaces cs\n  let cs2 := rstripSpaces cs1\n  String.mk cs2\n\ndef replaceSpaces (string : String) : String :=\n  let s := trimSpaces string\n  let i := s.data.length\n  let spaceCount := s.data.foldl (fun acc c => if c == ' ' then acc + 1 else acc) 0\n  let newLen := i + spaceCount * 2\n  if newLen > MAX then\n    \"-1\"\n  else\n    let resRev := s.data.foldl (fun acc c => if c == ' ' then '0' :: '2' :: '%' :: acc else c :: acc) []\n    String.mk resRev.reverse\n\n#guard replaceSpaces \"My Name is Dawood\" = \"My%20Name%20is%20Dawood\"\n#guard replaceSpaces \"I am a Programmer\" = \"I%20am%20a%20Programmer\"\n#guard replaceSpaces \"I love Coding\" = \"I%20love%20Coding\"\n", "test_list": ["#guard replaceSpaces \"My Name is Dawood\" = \"My%20Name%20is%20Dawood\"", "#guard replaceSpaces \"I am a Programmer\" = \"I%20am%20a%20Programmer\"", "#guard replaceSpaces \"I love Coding\" = \"I%20love%20Coding\""]}
{"text": "Write a python function to find even numbers from a mixed list.", "task_id": 629, "code": "import Batteries\n\nopen Std\n\ndef Split (list : List Nat) : List Nat := Id.run do\n  let mut ev_li : List Nat := []\n  for i in list do\n    if i % 2 == 0 then\n      ev_li := ev_li ++ [i]\n  return ev_li\n\n#guard Split [1,2,3,4,5] = [2,4]\n#guard Split [4,5,6,7,8,0,1] = [4,6,8,0]\n#guard Split [8,12,15,19] = [8,12]\n", "test_list": ["#guard Split [1,2,3,4,5] = [2,4]", "#guard Split [4,5,6,7,8,0,1] = [4,6,8,0]", "#guard Split [8,12,15,19] = [8,12]"]}
{"text": "Write a function to extract all the adjacent coordinates of the given coordinate tuple.", "task_id": 630, "code": "import Batteries\nopen Std\n\ndef adjac (ele : List Nat) (sub : List Nat := []) : List (List Nat) :=\n  match ele with\n  | [] => [sub]\n  | x :: xs =>\n    let candidates := [x - 1, x, x + 1]\n    candidates.foldl (fun acc j => acc ++ adjac xs (sub ++ [j])) []\n\ndef get_coordinates (test_tup : List Nat) : List (List Nat) :=\n  let res := adjac test_tup\n  res\n\n#guard get_coordinates [3, 4] == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n#guard get_coordinates [4, 5] == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]\n#guard get_coordinates [5, 6] == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]\n", "test_list": ["#guard get_coordinates [3, 4] == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]", "#guard get_coordinates [4, 5] == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]]", "#guard get_coordinates [5, 6] == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]]"]}
{"text": "Write a function to replace whitespaces with an underscore and vice versa in a given string by using regex.", "task_id": 631, "code": "import Batteries\n\nopen Std\n\ndef replaceSpaces (text : String) : String :=\n  let chars := text.data.map (fun c => if c == ' ' then '_' else c)\n  String.mk chars\n\n#guard replaceSpaces \"Jumanji The Jungle\" = \"Jumanji_The_Jungle\"\n#guard replaceSpaces \"The Avengers\" = \"The_Avengers\"\n#guard replaceSpaces \"Fast and Furious\" = \"Fast_and_Furious\"\n", "test_list": ["#guard replaceSpaces \"Jumanji The Jungle\" = \"Jumanji_The_Jungle\"", "#guard replaceSpaces \"The Avengers\" = \"The_Avengers\"", "#guard replaceSpaces \"Fast and Furious\" = \"Fast_and_Furious\""]}
{"text": "Write a python function to move all zeroes to the end of the given list.", "task_id": 632, "code": "import Batteries\n\nopen Std\n\ndef moveZero (numList : List Nat) : List Nat :=\n  let zeroCount := numList.foldl (fun acc i => if i == 0 then acc + 1 else acc) 0\n  let a := List.replicate zeroCount 0\n  let x := numList.filter (fun i => i != 0)\n  x ++ a\n\n#guard moveZero [1,0,2,0,3,4] = [1,2,3,4,0,0]\n#guard moveZero [2,3,2,0,0,4,0,5,0] = [2,3,2,4,5,0,0,0,0]\n#guard moveZero [0,1,0,1,1] = [1,1,1,0,0]\n", "test_list": ["#guard moveZero [1,0,2,0,3,4] = [1,2,3,4,0,0]", "#guard moveZero [2,3,2,0,0,4,0,5,0] = [2,3,2,4,5,0,0,0,0]", "#guard moveZero [0,1,0,1,1] = [1,1,1,0,0]"]}
{"text": "Write a python function to find the sum of xor of all pairs of numbers in the given array.", "task_id": 633, "code": "import Batteries\n\nopen Std\n\ndef pair_OR_Sum (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let mut ans := 0\n  for i in [0:n] do\n    for j in [i+1:n] do\n      ans := ans + (a[i]! ^^^ a[j]!)\n  return ans\n\n#guard pair_OR_Sum [5,9,7,6] 4 = 47\n#guard pair_OR_Sum [7,3,5] 3 = 12\n#guard pair_OR_Sum [7,3] 2 = 4\n", "test_list": ["#guard pair_OR_Sum [5,9,7,6] 4 = 47", "#guard pair_OR_Sum [7,3,5] 3 = 12", "#guard pair_OR_Sum [7,3] 2 = 4"]}
{"text": "Write a python function to find the sum of fourth power of first n even natural numbers.", "task_id": 634, "code": "import Batteries\n\nopen Std\n\ndef evenPowerSum (n : Nat) : Nat := Id.run do\n  let mut s := 0\n  for i in [1 : n+1] do\n    let j := 2 * i\n    s := s + j * j * j * j\n  return s\n\n#guard evenPowerSum 2 = 272\n#guard evenPowerSum 3 = 1568\n#guard evenPowerSum 4 = 5664\n", "test_list": ["#guard evenPowerSum 2 = 272", "#guard evenPowerSum 3 = 1568", "#guard evenPowerSum 4 = 5664"]}
{"text": "Write a function to push all values into a heap and then pop off the smallest values one at a time.", "task_id": 635, "code": "import Batteries\n\nopen Std\n\ndef findMin? (xs : List Nat) : Option Nat :=\n  match xs with\n  | [] => none\n  | x :: xs' => some <| xs'.foldl (fun acc y => if y < acc then y else acc) x\n\ndef removeOne (x : Nat) (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne x ys\n\ndef heapSort (iterable : List Nat) : List Nat := Id.run do\n  let mut h := iterable\n  let n := h.length\n  let mut res : Array Nat := #[]\n  for _ in [: n] do\n    match findMin? h with\n    | none => break\n    | some m =>\n      res := res.push m\n      h := removeOne m h\n  return res.toList\n\n#guard heapSort [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n#guard heapSort [25, 35, 22, 85, 14, 65, 75, 25, 58] = [14, 22, 25, 25, 35, 58, 65, 75, 85]\n#guard heapSort [7, 1, 9, 5] = [1, 5, 7, 9]\n", "test_list": ["#guard heapSort [1, 3, 5, 7, 9, 2, 4, 6, 8, 0] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]", "#guard heapSort [25, 35, 22, 85, 14, 65, 75, 25, 58] = [14, 22, 25, 25, 35, 58, 65, 75, 85]", "#guard heapSort [7, 1, 9, 5] = [1, 5, 7, 9]"]}
{"text": "Write a python function to check if roots of a quadratic equation are reciprocal of each other or not.", "task_id": 636, "code": "import Batteries\n\nopen Std\n\ndef Check_Solution (a b c : Int) : String :=\n  if a == c then \"Yes\" else \"No\"\n\n#guard Check_Solution 2 0 2 == \"Yes\"\n#guard Check_Solution 2 (-5) 2 == \"Yes\"\n#guard Check_Solution 1 2 3 == \"No\"\n", "test_list": ["#guard Check_Solution 2 0 2 == \"Yes\"", "#guard Check_Solution 2 (-5) 2 == \"Yes\"", "#guard Check_Solution 1 2 3 == \"No\""]}
{"text": "Write a function to check whether the given amount has no profit and no loss", "task_id": 637, "code": "import Batteries\n\nopen Std\n\ndef noprofit_noloss (actual_cost sale_amount : Nat) : Bool :=\n  if sale_amount == actual_cost then true else false\n\n#guard noprofit_noloss 1500 1200 == false\n#guard noprofit_noloss 100 100 == true\n#guard noprofit_noloss 2000 5000 == false\n", "test_list": ["#guard noprofit_noloss 1500 1200 == false", "#guard noprofit_noloss 100 100 == true", "#guard noprofit_noloss 2000 5000 == false"]}
{"text": "Write a function to calculate wind chill index.", "task_id": 638, "code": "import Batteries\nopen Std\n\ndef wind_chill (v t : Int) : Int :=\n  let vF := Float.ofInt v\n  let tF := Float.ofInt t\n  let p := Float.pow vF 0.16\n  let wc := 13.12 + 0.6215 * tF - 11.37 * p + 0.3965 * tF * p\n  let r := Float.round wc\n  Int64.toInt (Float.toInt64 r)\n\n#guard wind_chill 120 35 = 40\n#guard wind_chill 40 70 = 86\n#guard wind_chill 10 100 = 116\n", "test_list": ["#guard wind_chill 120 35 = 40", "#guard wind_chill 40 70 = 86", "#guard wind_chill 10 100 = 116"]}
{"text": "Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.", "task_id": 639, "code": "import Batteries\n\nopen Std\n\ndef isLowerPython (cs : List Char) : Bool :=\n  let rec go (cs : List Char) (seen : Bool) : Bool :=\n    match cs with\n    | [] => seen\n    | c :: t =>\n      if c.isAlpha then\n        if c.isLower then go t true else false\n      else\n        go t seen\n  go cs false\n\ndef firstUpper (s : String) : Bool :=\n  match s.data with\n  | [] => false\n  | c :: _ => c.isUpper\n\ndef restLower (s : String) : Bool :=\n  match s.data with\n  | [] => false\n  | _ :: t => isLowerPython t\n\ndef sampleNam (sampleNames : List String) : Nat :=\n  let filtered := sampleNames.filter (fun el => firstUpper el && restLower el)\n  let joined := filtered.foldl (fun acc s => acc ++ s) \"\"\n  joined.length\n\n#guard sampleNam [\"sally\", \"Dylan\", \"rebecca\", \"Diana\", \"Joanne\", \"keith\"] = 16\n#guard sampleNam [\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"] = 10\n#guard sampleNam [\"abcd\", \"Python\", \"abba\", \"aba\"] = 6\n", "test_list": ["#guard sampleNam [\"sally\", \"Dylan\", \"rebecca\", \"Diana\", \"Joanne\", \"keith\"] = 16", "#guard sampleNam [\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"] = 10", "#guard sampleNam [\"abcd\", \"Python\", \"abba\", \"aba\"] = 6"]}
{"text": "Write a function to remove the parenthesis area in a string.", "task_id": 640, "code": "import Batteries\n\nopen Std\n\npartial def consumeAfterOpen (rest : List Char) : Option (List Char) :=\n  match rest with\n  | [] => none\n  | ')' :: _ => none\n  | _ =>\n    let rec find (cs : List Char) : Option (List Char) :=\n      match cs with\n      | [] => none\n      | ')' :: after => some after\n      | _ :: t => find t\n    find rest\n\npartial def removeParenAreaAux (acc : List Char) (cs : List Char) : List Char :=\n  match cs with\n  | [] => acc.reverse\n  | '(' :: rest =>\n      match consumeAfterOpen rest with\n      | some after =>\n          let acc' := match acc with\n            | ' ' :: accTail => accTail\n            | _ => acc\n          removeParenAreaAux acc' after\n      | none =>\n          removeParenAreaAux ('(' :: acc) rest\n  | c :: rest => removeParenAreaAux (c :: acc) rest\n\ndef removeParenArea (s : String) : String :=\n  String.mk (removeParenAreaAux [] s.toList)\n\ndef removeParenthesis (items : List String) : String :=\n  \n  match items with\n  | item :: _ => removeParenArea item\n  | [] => \"\"\n\n#guard removeParenthesis [\"python (chrome)\"] = \"python\"\n#guard removeParenthesis [\"string(.abc)\"] = \"string\"\n#guard removeParenthesis [\"alpha(num)\"] = \"alpha\"\n", "test_list": ["#guard removeParenthesis [\"python (chrome)\"] = \"python\"", "#guard removeParenthesis [\"string(.abc)\"] = \"string\"", "#guard removeParenthesis [\"alpha(num)\"] = \"alpha\""]}
{"text": "Write a function to find the nth nonagonal number.", "task_id": 641, "code": "import Batteries\n\nopen Std\n\ndef isNonagonal (n : Nat) : Nat :=\n  (n * (7 * n - 5)) / 2\n\n#guard isNonagonal 10 = 325\n#guard isNonagonal 15 = 750\n#guard isNonagonal 18 = 1089\n", "test_list": ["#guard isNonagonal 10 = 325", "#guard isNonagonal 15 = 750", "#guard isNonagonal 18 = 1089"]}
{"text": "Write a function to remove similar rows from the given tuple matrix.", "task_id": 642, "code": "import Batteries\n\nopen Std\n\nabbrev Pair := Nat × Nat\n\ndef lePair (p q : Pair) : Bool :=\n  if Nat.blt p.fst q.fst then true\n  else if Nat.blt q.fst p.fst then false\n  else Nat.ble p.snd q.snd\n\ndef minByPair (xs : List Pair) : Option Pair :=\n  match xs with\n  | [] => none\n  | h :: t => some <| t.foldl (fun acc x => if lePair x acc then x else acc) h\n\ndef removeOnePair (xs : List Pair) (x : Pair) : List Pair :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOnePair ys x\n\ndef sortPairsDet (xs : List Pair) : List Pair := Id.run do\n  let mut ys := xs\n  let mut res : List Pair := []\n  let n := ys.length\n  for _ in [: n] do\n    match minByPair ys with\n    | none => ()\n    | some m =>\n      res := res ++ [m]\n      ys := removeOnePair ys m\n  return res\n\ndef removeSimilarRow (testList : List (List Pair)) : HashSet (List Pair) :=\n  let processed := testList.map (fun sub =>\n    let dedup := (HashSet.ofList sub).toList\n    sortPairsDet dedup\n  )\n  HashSet.ofList processed\n\n#guard removeSimilarRow [[(4, 5), (3, 2)], [(2, 2), (4, 6)], [(3, 2), (4, 5)]] ==\n  HashSet.ofList [[(2, 2), (4, 6)], [(3, 2), (4, 5)]]\n#guard removeSimilarRow [[(5, 6), (4, 3)], [(3, 3), (5, 7)], [(4, 3), (5, 6)]] ==\n  HashSet.ofList [[(4, 3), (5, 6)], [(3, 3), (5, 7)]]\n#guard removeSimilarRow [[(6, 7), (5, 4)], [(4, 4), (6, 8)], [(5, 4), (6, 7)]] ==\n  HashSet.ofList [[(4, 4), (6, 8)], [(5, 4), (6, 7)]]\n", "test_list": ["#guard removeSimilarRow [[(4, 5), (3, 2)], [(2, 2), (4, 6)], [(3, 2), (4, 5)]] ==", "#guard removeSimilarRow [[(5, 6), (4, 3)], [(3, 3), (5, 7)], [(4, 3), (5, 6)]] ==", "#guard removeSimilarRow [[(6, 7), (5, 4)], [(4, 4), (6, 8)], [(5, 4), (6, 7)]] =="]}
{"text": "Write a function that matches a word containing 'z', not at the start or end of the word.", "task_id": 643, "code": "import Batteries\n\nopen Std\n\ndef isAsciiLower (c : Char) : Bool :=\n  if 'a' ≤ c then\n    if c ≤ 'z' then true else false\n  else\n    false\n\ndef isAsciiUpper (c : Char) : Bool :=\n  if 'A' ≤ c then\n    if c ≤ 'Z' then true else false\n  else\n    false\n\ndef isDigit (c : Char) : Bool :=\n  if '0' ≤ c then\n    if c ≤ '9' then true else false\n  else\n    false\n\ndef isWordChar (c : Char) : Bool :=\n  isAsciiLower c || isAsciiUpper c || isDigit c || c == '_'\n\ndef hasZMiddleAux : List Char → Bool\n  | a :: b :: c :: t =>\n      if (b == 'z') && isWordChar a && isWordChar c then\n        true\n      else\n        hasZMiddleAux (b :: c :: t)\n  | _ => false\n\ndef text_match_wordz_middle (text : String) : String :=\n  if hasZMiddleAux text.data then \"Found a match!\" else \"Not matched!\"\n\n#guard text_match_wordz_middle \"pythonzabc.\" == \"Found a match!\"\n#guard text_match_wordz_middle \"xyzabc.\" == \"Found a match!\"\n#guard text_match_wordz_middle \"  lang  .\" == \"Not matched!\"\n", "test_list": ["#guard text_match_wordz_middle \"pythonzabc.\" == \"Found a match!\"", "#guard text_match_wordz_middle \"xyzabc.\" == \"Found a match!\"", "#guard text_match_wordz_middle \"  lang  .\" == \"Not matched!\""]}
{"text": "Write a python function to reverse an array upto a given position.", "task_id": 644, "code": "import Batteries\n\nopen Std\n\ndef reverse_Array_Upto_K (input : List Nat) (k : Nat) : List Nat :=\n  let first := input.take k\n  let rest := input.drop k\n  first.reverse ++ rest\n\n#guard reverse_Array_Upto_K [1, 2, 3, 4, 5, 6] 4 = [4, 3, 2, 1, 5, 6]\n#guard reverse_Array_Upto_K [4, 5, 6, 7] 2 = [5, 4, 6, 7]\n#guard reverse_Array_Upto_K [9, 8, 7, 6, 5] 3 = [7, 8, 9, 6, 5]\n", "test_list": ["#guard reverse_Array_Upto_K [1, 2, 3, 4, 5, 6] 4 = [4, 3, 2, 1, 5, 6]", "#guard reverse_Array_Upto_K [4, 5, 6, 7] 2 = [5, 4, 6, 7]", "#guard reverse_Array_Upto_K [9, 8, 7, 6, 5] 3 = [7, 8, 9, 6, 5]"]}
{"text": "Write a function to find the product of it’s kth index in the given tuples.", "task_id": 645, "code": "import Batteries\nopen Std\n\ndef getProduct (val : List Nat) : Nat :=\n  val.foldl (fun acc ele => acc * ele) 1\n\ndef indexOrDefault (xs : List Nat) (n : Nat) (defVal : Nat) : Nat :=\n  match xs, n with\n  | [], _ => defVal\n  | x :: _, 0 => x\n  | _ :: xs', n' + 1 => indexOrDefault xs' n' defVal\n\ndef findKProduct (testList : List (List Nat)) (K : Nat) : Nat :=\n  let vals := testList.map (fun sub => indexOrDefault sub K 0)\n  getProduct vals\n\n#guard findKProduct [[5, 6, 7], [1, 3, 5], [8, 9, 19]] 2 = 665\n#guard findKProduct [[6, 7, 8], [2, 4, 6], [9, 10, 20]] 1 = 280\n#guard findKProduct [[7, 8, 9], [3, 5, 7], [10, 11, 21]] 0 = 210\n", "test_list": ["#guard findKProduct [[5, 6, 7], [1, 3, 5], [8, 9, 19]] 2 = 665", "#guard findKProduct [[6, 7, 8], [2, 4, 6], [9, 10, 20]] 1 = 280", "#guard findKProduct [[7, 8, 9], [3, 5, 7], [10, 11, 21]] 0 = 210"]}
{"text": "Write a python function to count number of cubes of size k in a cube of size n.", "task_id": 646, "code": "import Batteries\n\nopen Std\n\ndef No_of_cubes (N K : Nat) : Nat := Id.run do\n  let mut No := 0\n  No := (N - K + 1)\n  No := No ^ 3\n  return No\n\n#guard No_of_cubes 2 1 = 8\n#guard No_of_cubes 5 2 = 64\n#guard No_of_cubes 1 1 = 1\n", "test_list": ["#guard No_of_cubes 2 1 = 8", "#guard No_of_cubes 5 2 = 64", "#guard No_of_cubes 1 1 = 1"]}
{"text": "Write a function to split a string at uppercase letters.", "task_id": 647, "code": "import Batteries\nopen Std\n\ndef isUpperAscii (c : Char) : Bool :=\n  let cn := c.toNat\n  (Nat.ble (Char.toNat 'A') cn) && (Nat.ble cn (Char.toNat 'Z'))\n\ndef takeNonUpper (ds : List Char) (bufRev : List Char) : (List Char × List Char) :=\n  match ds with\n  | [] => (bufRev.reverse, [])\n  | d :: ds' =>\n    if isUpperAscii d then\n      (bufRev.reverse, d :: ds')\n    else\n      takeNonUpper ds' (d :: bufRev)\n\ndef loopSplitAux (cs : List Char) (accRev : List String) (fuel : Nat) : List String :=\n  match fuel with\n  | 0 => accRev.reverse\n  | Nat.succ fuel' =>\n    match cs with\n    | [] => accRev.reverse\n    | c :: cs' =>\n      if isUpperAscii c then\n        let (nonUpper, rest) := takeNonUpper cs' []\n        let pieceChars := c :: nonUpper\n        let piece := String.mk pieceChars\n        loopSplitAux rest (piece :: accRev) fuel'\n      else\n        loopSplitAux cs' accRev fuel'\n\ndef splitUpperstring (text : String) : List String :=\n  loopSplitAux text.data [] text.length\n\n#guard splitUpperstring \"PythonProgramLanguage\" == [\"Python\", \"Program\", \"Language\"]\n#guard splitUpperstring \"PythonProgram\" == [\"Python\", \"Program\"]\n#guard splitUpperstring \"ProgrammingLanguage\" == [\"Programming\", \"Language\"]\n", "test_list": ["#guard splitUpperstring \"PythonProgramLanguage\" == [\"Python\", \"Program\", \"Language\"]", "#guard splitUpperstring \"PythonProgram\" == [\"Python\", \"Program\"]", "#guard splitUpperstring \"ProgrammingLanguage\" == [\"Programming\", \"Language\"]"]}
{"text": "Write a function to exchange the position of every n-th value with (n+1)th value and (n+1)th value with n-th value in a given list.", "task_id": 648, "code": "import Batteries\n\nopen Std\n\ndef exchangeElements (lst : List Nat) : List Nat :=\n  let rec go (l accRev : List Nat) : List Nat :=\n    match l with\n    | a :: b :: t => go t (a :: b :: accRev)\n    | a :: [] => a :: accRev\n    | [] => accRev\n  (go lst []).reverse\n\n#guard exchangeElements [0,1,2,3,4,5] = [1,0,3,2,5,4]\n#guard exchangeElements [5,6,7,8,9,10] = [6,5,8,7,10,9]\n#guard exchangeElements [25,35,45,55,75,95] = [35,25,55,45,95,75]\n", "test_list": ["#guard exchangeElements [0,1,2,3,4,5] = [1,0,3,2,5,4]", "#guard exchangeElements [5,6,7,8,9,10] = [6,5,8,7,10,9]", "#guard exchangeElements [25,35,45,55,75,95] = [35,25,55,45,95,75]"]}
{"text": "Write a python function to calculate the sum of the numbers in a list between the indices of a specified range.", "task_id": 649, "code": "import Batteries\n\nopen Std\n\ndef sumRangeList (nums : List Nat) (m n : Nat) : Nat := Id.run do\n  let mut sum_range := 0\n  for i in [m : n+1] do\n    sum_range := sum_range + nums.getD i 0\n  return sum_range\n\n#guard sumRangeList [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12] 8 10 = 29\n#guard sumRangeList [1,2,3,4,5] 1 2 = 5\n#guard sumRangeList [1,0,1,2,5,6] 4 5 = 11\n", "test_list": ["#guard sumRangeList [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12] 8 10 = 29", "#guard sumRangeList [1,2,3,4,5] 1 2 = 5", "#guard sumRangeList [1,0,1,2,5,6] 4 5 = 11"]}
{"text": "Write a python function to check whether the given two arrays are equal or not.", "task_id": 650, "code": "import Batteries\n\nopen Std\n\ndef findMin (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | h :: t => t.foldl (fun acc x => if x < acc then x else acc) h\n\ndef removeOne (l : List Nat) (x : Nat) : List Nat :=\n  match l with\n  | [] => []\n  | h :: t => if h == x then t else h :: removeOne t x\n\ndef selectionSort (l : List Nat) : List Nat :=\n  let rec loop (lst : List Nat) (k : Nat) (res : List Nat) : List Nat :=\n    match k with\n    | 0 => res\n    | k'+1 =>\n      match lst with\n      | [] => res\n      | _ =>\n        let m := findMin lst\n        let lst' := removeOne lst m\n        loop lst' k' (res ++ [m])\n  loop l l.length []\n\ndef are_Equal (arr1 arr2 : List Nat) (n m : Nat) : Bool := Id.run do\n  if n == m then\n    let s1 := selectionSort arr1\n    let s2 := selectionSort arr2\n    for i in [0 : n - 1] do\n      if (s1.getD i 0) == (s2.getD i 0) then\n        pure ()\n      else\n        return false\n    return true\n  else\n    return false\n\n#guard are_Equal [1,2,3] [3,2,1] 3 3 == true\n#guard are_Equal [1,1,1] [2,2,2] 3 3 == false\n#guard are_Equal [8,9] [4,5,6] 2 3 == false\n", "test_list": ["#guard are_Equal [1,2,3] [3,2,1] 3 3 == true", "#guard are_Equal [1,1,1] [2,2,2] 3 3 == false", "#guard are_Equal [8,9] [4,5,6] 2 3 == false"]}
{"text": "Write a function to check if one tuple is a subset of another tuple.", "task_id": 651, "code": "import Batteries\n\nopen Std\n\ndef checkSubset (test_tup1 test_tup2 : List Nat) : Bool :=\n  let s1 : HashSet Nat := HashSet.ofList test_tup1\n  test_tup2.all (fun x => s1.contains x)\n\n#guard checkSubset [10, 4, 5, 6] [5, 10] == true\n#guard checkSubset [1, 2, 3, 4] [5, 6] == false\n#guard checkSubset [7, 8, 9, 10] [10, 8] == true\n", "test_list": ["#guard checkSubset [10, 4, 5, 6] [5, 10] == true", "#guard checkSubset [1, 2, 3, 4] [5, 6] == false", "#guard checkSubset [7, 8, 9, 10] [10, 8] == true"]}
{"text": "Write a function to flatten the given tuple matrix into the tuple list with each tuple representing each column.", "task_id": 652, "code": "import Batteries\nopen Std\n\ndef joinWith (sep : String) (arr : List String) : String :=\n  match arr with\n  | [] => \"\"\n  | x :: xs => xs.foldl (fun acc s => acc ++ sep ++ s) x\n\ndef tupleStr (l : List Nat) : String :=\n  \"(\" ++ joinWith \", \" (l.map (fun n => toString n)) ++ \")\"\n\ndef flattenPairs (xss : List (List (Nat × Nat))) : List (Nat × Nat) :=\n  xss.foldr (fun row acc => row ++ acc) []\n\ndef matrixToList (test_list : List (List (Nat × Nat))) : String :=\n  let temp := flattenPairs test_list\n  let (xs, ys) := temp.foldr (fun (a, b) (as, bs) => (a :: as, b :: bs)) ([], [])\n  \"[\" ++ tupleStr xs ++ \", \" ++ tupleStr ys ++ \"]\"\n\n#guard matrixToList [[(4,5),(7,8)], [(10,13),(18,17)], [(0,4),(10,1)]] = \"[(4, 7, 10, 18, 0, 10), (5, 8, 13, 17, 4, 1)]\"\n#guard matrixToList [[(5,6),(8,9)], [(11,14),(19,18)], [(1,5),(11,2)]] = \"[(5, 8, 11, 19, 1, 11), (6, 9, 14, 18, 5, 2)]\"\n#guard matrixToList [[(6,7),(9,10)], [(12,15),(20,21)], [(23,7),(15,8)]] = \"[(6, 9, 12, 20, 23, 15), (7, 10, 15, 21, 7, 8)]\"\n", "test_list": ["#guard matrixToList [[(4,5),(7,8)], [(10,13),(18,17)], [(0,4),(10,1)]] = \"[(4, 7, 10, 18, 0, 10), (5, 8, 13, 17, 4, 1)]\"", "#guard matrixToList [[(5,6),(8,9)], [(11,14),(19,18)], [(1,5),(11,2)]] = \"[(5, 8, 11, 19, 1, 11), (6, 9, 14, 18, 5, 2)]\"", "#guard matrixToList [[(6,7),(9,10)], [(12,15),(20,21)], [(23,7),(15,8)]] = \"[(6, 9, 12, 20, 23, 15), (7, 10, 15, 21, 7, 8)]\""]}
{"text": "Write a function to group a sequence of key-value pairs into a dictionary of lists using collections module.", "task_id": 653, "code": "import Batteries\nopen Std\n\ndef lookupByKey {β} (xs : List (String × β)) (k : String) : Option β :=\n  match xs with\n  | [] => none\n  | (k', v) :: xs' => if k = k' then some v else lookupByKey xs' k\n\ndef grouping_dictionary (l : List (String × Nat)) : Std.HashMap String (List Nat) :=\n  l.foldl (fun d (kv : String × Nat) =>\n    let k := kv.fst\n    let v := kv.snd\n    let vs := (lookupByKey (d.toList) k).getD []\n    d.insert k (vs ++ [v])\n  ) ({} : Std.HashMap String (List Nat))\n\ninstance instBEqHashMapStringListNat : BEq (Std.HashMap String (List Nat)) where\n  beq m₁ m₂ :=\n    if m₁.size == m₂.size then\n      let ok := (m₁.toList.foldl (fun acc (kv : String × (List Nat)) =>\n        let k := kv.fst\n        let v := kv.snd\n        let present :=\n          match Task653.lookupByKey (m₂.toList) k with\n          | some v2 => v == v2\n          | none => false\n        acc && present\n      ) true)\n      ok\n    else\n      false\n\n#guard grouping_dictionary [(\"yellow\", 1), (\"blue\", 2), (\"yellow\", 3), (\"blue\", 4), (\"red\", 1)] == Std.HashMap.ofList [(\"yellow\", [1, 3]), (\"blue\", [2, 4]), (\"red\", [1])]\n#guard grouping_dictionary [(\"yellow\", 10), (\"blue\", 20), (\"yellow\", 30), (\"blue\", 40), (\"red\", 10)] == Std.HashMap.ofList [(\"yellow\", [10, 30]), (\"blue\", [20, 40]), (\"red\", [10])]\n#guard grouping_dictionary [(\"yellow\", 15), (\"blue\", 25), (\"yellow\", 35), (\"blue\", 45), (\"red\", 15)] == Std.HashMap.ofList [(\"yellow\", [15, 35]), (\"blue\", [25, 45]), (\"red\", [15])]\n", "test_list": ["#guard grouping_dictionary [(\"yellow\", 1), (\"blue\", 2), (\"yellow\", 3), (\"blue\", 4), (\"red\", 1)] == Std.HashMap.ofList [(\"yellow\", [1, 3]), (\"blue\", [2, 4]), (\"red\", [1])]", "#guard grouping_dictionary [(\"yellow\", 10), (\"blue\", 20), (\"yellow\", 30), (\"blue\", 40), (\"red\", 10)] == Std.HashMap.ofList [(\"yellow\", [10, 30]), (\"blue\", [20, 40]), (\"red\", [10])]", "#guard grouping_dictionary [(\"yellow\", 15), (\"blue\", 25), (\"yellow\", 35), (\"blue\", 45), (\"red\", 15)] == Std.HashMap.ofList [(\"yellow\", [15, 35]), (\"blue\", [25, 45]), (\"red\", [15])]"]}
{"text": "Write a function to find the perimeter of a rectangle.", "task_id": 654, "code": "import Batteries\n\nopen Std\n\ndef rectanglePerimeter (l b : Nat) : Nat :=\n  let perimeter := 2 * (l + b)\n  perimeter\n\n#guard rectanglePerimeter 10 20 = 60\n#guard rectanglePerimeter 10 5 = 30\n#guard rectanglePerimeter 4 2 = 12\n", "test_list": ["#guard rectanglePerimeter 10 20 = 60", "#guard rectanglePerimeter 10 5 = 30", "#guard rectanglePerimeter 4 2 = 12"]}
{"text": "Write a python function to find the sum of fifth power of n natural numbers.", "task_id": 655, "code": "import Batteries\n\nopen Std\n\ndef fifth_Power_Sum (n : Nat) : Nat := Id.run do\n  let mut sm := 0\n  for i in [1 : n+1] do\n    sm := sm + i*i*i*i*i\n  return sm\n\n#guard fifth_Power_Sum 2 = 33\n#guard fifth_Power_Sum 4 = 1300\n#guard fifth_Power_Sum 3 = 276\n", "test_list": ["#guard fifth_Power_Sum 2 = 33", "#guard fifth_Power_Sum 4 = 1300", "#guard fifth_Power_Sum 3 = 276"]}
{"text": "Write a python function to find the minimum sum of absolute differences of two arrays.", "task_id": 656, "code": "import Batteries\n\nopen Std\n\ndef insertSorted (x : Nat) : List Nat → List Nat\n| [] => [x]\n| y :: ys => if x ≤ y then x :: y :: ys else y :: insertSorted x ys\n\ndef isort (xs : List Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | y :: ys => insertSorted y (isort ys)\n\ndef findMinSum (a b : List Nat) (n : Nat) : Nat :=\n  let sa := isort a\n  let sb := isort b\n  let pairs := (sa.take n).zip (sb.take n)\n  pairs.foldl (init := 0) (fun s p =>\n    let x := p.fst\n    let y := p.snd\n    s + (if x ≥ y then x - y else y - x))\n\n#guard findMinSum [3,2,1] [2,1,3] 3 = 0\n#guard findMinSum [1,2,3] [4,5,6] 3 = 9\n#guard findMinSum [4,1,8,7] [2,3,6,5] 4 = 6\n", "test_list": ["#guard findMinSum [3,2,1] [2,1,3] 3 = 0", "#guard findMinSum [1,2,3] [4,5,6] 3 = 9", "#guard findMinSum [4,1,8,7] [2,3,6,5] 4 = 6"]}
{"text": "Write a python function to find the first digit in factorial of a given number.", "task_id": 657, "code": "import Batteries\n\nopen Std\n\ndef firstDigit (n : Nat) : Nat := Id.run do\n  let mut fact := 1\n  for i in [2 : n+1] do\n    fact := fact * i\n    while fact % 10 == 0 do\n      fact := fact / 10\n  while !((fact / 10) == 0) do\n    fact := fact / 10\n  return fact\n\n#guard firstDigit 5 = 1\n#guard firstDigit 10 = 3\n#guard firstDigit 7 = 5\n", "test_list": ["#guard firstDigit 5 = 1", "#guard firstDigit 10 = 3", "#guard firstDigit 7 = 5"]}
{"text": "Write a function to find the item with maximum occurrences in a given list.", "task_id": 658, "code": "import Batteries\n\nopen Std\n\ndef countOcc (xs : List Nat) (x : Nat) : Nat :=\n  xs.foldl (fun acc y => if y == x then acc + 1 else acc) 0\n\ndef maxOccurrences (list1 : List Nat) : Nat := Id.run do\n  let result0 := match list1 with\n    | [] => 0\n    | x :: _ => x\n  let mut maxVal := 0\n  let mut result := result0\n  for i in list1 do\n    let occu := countOcc list1 i\n    if occu > maxVal then\n      maxVal := occu\n      result := i\n  return result\n\n#guard maxOccurrences [2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,4,6,9,1,2] = 2\n#guard maxOccurrences [1, 3,5, 7,1, 3,13, 15, 17,5, 7,9,1, 11] = 1\n#guard maxOccurrences [1, 2, 3,2, 4, 5,1, 1, 1] = 1\n", "test_list": ["#guard maxOccurrences [2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,4,6,9,1,2] = 2", "#guard maxOccurrences [1, 3,5, 7,1, 3,13, 15, 17,5, 7,9,1, 11] = 1", "#guard maxOccurrences [1, 2, 3,2, 4, 5,1, 1, 1] = 1"]}
{"text": "Write a python function to print duplicants from a list of integers.", "task_id": 659, "code": "import Batteries\nopen Std\n\nprivate def getAt? {α} (xs : List α) (i : Nat) : Option α :=\n  match xs.drop i with\n  | [] => none\n  | y :: _ => some y\n\ndef Repeat (x : List Int) : List Int := Id.run do\n  let xs := x\n  let size := xs.length\n  let mut repeated : List Int := []\n  for i in [0:size] do\n    match getAt? xs i with\n    | some xi =>\n      let k := i + 1\n      for j in [k:size] do\n        match getAt? xs j with\n        | some xj =>\n          if xi == xj && !(repeated.contains xi) then\n            repeated := repeated ++ [xi]\n          else\n            pure ()\n        | none => pure ()\n    | none => pure ()\n  return repeated\n\n#guard Repeat [10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20] == [20, 30, -20, 60]\n#guard Repeat [-1, 1, -1, 8] == [-1]\n#guard Repeat [1, 2, 3, 1, 2] == [1, 2]\n", "test_list": ["#guard Repeat [10, 20, 30, 20, 20, 30, 40, 50, -20, 60, 60, -20, -20] == [20, 30, -20, 60]", "#guard Repeat [-1, 1, -1, 8] == [-1]", "#guard Repeat [1, 2, 3, 1, 2] == [1, 2]"]}
{"text": "Write a python function to choose points from two ranges such that no point lies in both the ranges.", "task_id": 660, "code": "import Batteries\n\nopen Std\n\ndef find_Points (l1 r1 l2 r2 : Int) : Int × Int :=\n  let x := if l1 != l2 then (if l1 ≤ l2 then l1 else l2) else (-1)\n  let y := if r1 != r2 then (if r1 ≥ r2 then r1 else r2) else (-1)\n  (x, y)\n\n#guard find_Points 5 10 1 5 = (1, 10)\n#guard find_Points 3 5 7 9 = (3, 9)\n#guard find_Points 1 5 2 8 = (1, 8)\n", "test_list": ["#guard find_Points 5 10 1 5 = (1, 10)", "#guard find_Points 3 5 7 9 = (3, 9)", "#guard find_Points 1 5 2 8 = (1, 8)"]}
{"text": "Write a function to find the maximum sum that can be formed which has no three consecutive elements present.", "task_id": 661, "code": "import Batteries\nopen Std\n\ndef maxSumOfThreeConsecutive (arr : List Nat) (n : Nat) : Nat :=\n  match n with\n  | 0 => 0\n  | _ =>\n    match arr with\n    | [] => 0\n    | a0 :: t =>\n      let dp0 := a0\n      if n = 1 then\n        dp0\n      else\n        match t with\n        | [] => dp0\n        | a1 :: u =>\n          let dp1 := a0 + a1\n          if n = 2 then\n            dp1\n          else\n            match u with\n            | [] => dp1\n            | a2 :: v =>\n              let dp2 := Nat.max dp1 (Nat.max (a1 + a2) (a0 + a2))\n              if n = 3 then\n                dp2\n              else\n                let rec go (i : Nat) (prev3dp prev2dp prev1dp prev1a : Nat) (rest : List Nat) : Nat :=\n                  match rest with\n                  | [] => prev1dp\n                  | ai :: rest' =>\n                    if i < n then\n                      let dpi := Nat.max (Nat.max prev1dp (prev2dp + ai)) (ai + prev1a + prev3dp)\n                      go (i + 1) prev2dp prev1dp dpi ai rest'\n                    else\n                      prev1dp\n                go 3 dp0 dp1 dp2 a2 v\n\n#guard maxSumOfThreeConsecutive [100, 1000, 100, 1000, 1] 5 = 2101\n#guard maxSumOfThreeConsecutive [3000, 2000, 1000, 3, 10] 5 = 5013\n#guard maxSumOfThreeConsecutive [1, 2, 3, 4, 5, 6, 7, 8] 8 = 27\n", "test_list": ["#guard maxSumOfThreeConsecutive [100, 1000, 100, 1000, 1] 5 = 2101", "#guard maxSumOfThreeConsecutive [3000, 2000, 1000, 3, 10] 5 = 5013", "#guard maxSumOfThreeConsecutive [1, 2, 3, 4, 5, 6, 7, 8] 8 = 27"]}
{"text": "Write a function to sort a list in a dictionary.", "task_id": 662, "code": "import Batteries\nopen Std\n\ndef insertSortedNat (x : Nat) : List Nat → List Nat\n| [] => [x]\n| y :: ys => if x ≤ y then x :: (y :: ys) else y :: insertSortedNat x ys\n\ndef sortNat : List Nat → List Nat\n| [] => []\n| x :: xs => insertSortedNat x (sortNat xs)\n\ndef mkMap (l : List (String × List Nat)) : HashMap String (List Nat) := Id.run do\n  let mut m : HashMap String (List Nat) := HashMap.emptyWithCapacity 0\n  for (k,v) in l do\n    m := m.insert k v\n  return m\n\ndef sortedDict (dict1 : HashMap String (List Nat)) : HashMap String (List Nat) := Id.run do\n  let mut m : HashMap String (List Nat) := HashMap.emptyWithCapacity 0\n  for (k, v) in dict1.toList do\n    m := m.insert k (sortNat v)\n  return m\n\ndef find? [BEq α] [Hashable α] (m : HashMap α β) (a : α) : Option β :=\n  let rec go : List (α × β) → Option β\n  | [] => none\n  | (k, v) :: t => if k == a then some v else go t\n  go m.toList\n\n#guard (\n  let input := Task662.mkMap [(\"n1\", [2, 3, 1]), (\"n2\", [5, 1, 2]), (\"n3\", [3, 2, 4])]\n  let res := Task662.sortedDict input\n  ((res.find? \"n1\").getD [] == [1, 2, 3]) &&\n  ((res.find? \"n2\").getD [] == [1, 2, 5]) &&\n  ((res.find? \"n3\").getD [] == [2, 3, 4]) &&\n  (res.size == 3)\n)\n\n#guard (\n  let input := Task662.mkMap [(\"n1\", [25, 37, 41]), (\"n2\", [41, 54, 63]), (\"n3\", [29, 38, 93])]\n  let res := Task662.sortedDict input\n  ((res.find? \"n1\").getD [] == [25, 37, 41]) &&\n  ((res.find? \"n2\").getD [] == [41, 54, 63]) &&\n  ((res.find? \"n3\").getD [] == [29, 38, 93]) &&\n  (res.size == 3)\n)\n\n#guard (\n  let input := Task662.mkMap [(\"n1\", [58, 44, 56]), (\"n2\", [91, 34, 58]), (\"n3\", [100, 200, 300])]\n  let res := Task662.sortedDict input\n  ((res.find? \"n1\").getD [] == [44, 56, 58]) &&\n  ((res.find? \"n2\").getD [] == [34, 58, 91]) &&\n  ((res.find? \"n3\").getD [] == [100, 200, 300]) &&\n  (res.size == 3)\n)\n", "test_list": ["#guard (", "#guard (", "#guard ("]}
{"text": "Write a function to find the largest possible value of k such that k modulo x is y.", "task_id": 663, "code": "import Batteries\n\nopen Std\n\ndef findMaxVal (n x y : Nat) : Int := Id.run do\n  let mut ans : Int := -1  \n  for k in [0 : n+1] do\n    if k % x == y then\n      let kk : Int := Int.ofNat k\n      if kk > ans then\n        ans := kk\n  if ans >= 0 && ans ≤ Int.ofNat n then\n    return ans\n  else\n    return -1\n\n#guard findMaxVal 15 10 5 == (15 : Int)\n#guard findMaxVal 187 10 5 == (185 : Int)\n#guard findMaxVal 16 11 1 == (12 : Int)\n", "test_list": ["#guard findMaxVal 15 10 5 == (15 : Int)", "#guard findMaxVal 187 10 5 == (185 : Int)", "#guard findMaxVal 16 11 1 == (12 : Int)"]}
{"text": "Write a python function to find the average of even numbers till a given even number.", "task_id": 664, "code": "import Batteries\n\nopen Std\n\ndef averageEven (n : Nat) : Nat := Id.run do\n  \n  let mut m := n\n  let mut sm := 0\n  let mut count := 0\n  while m >= 2 do\n    count := count + 1\n    sm := sm + m\n    m := m - 2\n  return sm / count\n\n#guard averageEven 2 = 2\n#guard averageEven 4 = 3\n#guard averageEven 100 = 51\n", "test_list": ["#guard averageEven 2 = 2", "#guard averageEven 4 = 3", "#guard averageEven 100 = 51"]}
{"text": "Write a python function to shift first element to the end of given list.", "task_id": 665, "code": "import Batteries\n\nopen Std\n\ndef moveLast (num_list : List Nat) : List Nat :=\n  match num_list with\n  | [] => []\n  | h :: t =>\n    let cnt := (h :: t).foldl (fun acc x => if x == h then acc + 1 else acc) 0\n    let a := List.replicate cnt h\n    let x := (h :: t).filter (fun i => i != h)\n    x ++ a\n\n#guard moveLast [1,2,3,4] == [2,3,4,1]\n#guard moveLast [2,3,4,1,5,0] == [3,4,1,5,0,2]\n#guard moveLast [5,4,3,2,1] == [4,3,2,1,5]\n", "test_list": ["#guard moveLast [1,2,3,4] == [2,3,4,1]", "#guard moveLast [2,3,4,1,5,0] == [3,4,1,5,0,2]", "#guard moveLast [5,4,3,2,1] == [4,3,2,1,5]"]}
{"text": "Write a function to count occurrence of a character in a string.", "task_id": 666, "code": "import Batteries\n\nopen Std\n\ndef countChar (string : String) (char : Char) : Nat := Id.run do\n  let mut count := 0\n  for c in string.toList do\n    if c == char then\n      count := count + 1\n  return count\n\n#guard countChar \"Python\" 'o' = 1\n#guard countChar \"little\" 't' = 2\n#guard countChar \"assert\" 's' = 2\n", "test_list": ["#guard countChar \"Python\" 'o' = 1", "#guard countChar \"little\" 't' = 2", "#guard countChar \"assert\" 's' = 2"]}
{"text": "Write a python function to count number of vowels in the string.", "task_id": 667, "code": "import Batteries\n\nopen Std\n\ndef Check_Vow (string : String) (vowels : String) : Nat :=\n  (string.data.filter (fun c => vowels.data.any (fun v => v == c))).length\n\n#guard Check_Vow \"corner\" \"AaEeIiOoUu\" = 2\n#guard Check_Vow \"valid\" \"AaEeIiOoUu\" = 2\n#guard Check_Vow \"true\" \"AaEeIiOoUu\" = 2\n", "test_list": ["#guard Check_Vow \"corner\" \"AaEeIiOoUu\" = 2", "#guard Check_Vow \"valid\" \"AaEeIiOoUu\" = 2", "#guard Check_Vow \"true\" \"AaEeIiOoUu\" = 2"]}
{"text": "Write a python function to replace multiple occurence of character by single.", "task_id": 668, "code": "import Batteries\n\nopen Std\n\ndef replace (string : String) (char : String) : String :=\n  let n := char.length\n  if n == 0 then\n    string\n  else\n    let rec go (s : String) (acc : String) (fuel : Nat) : String :=\n      match fuel with\n      | 0 => acc\n      | Nat.succ fuel' =>\n        if s.length == 0 then acc\n        else\n          if s.take n == char then\n            let rec cnt (t : String) (k : Nat) (fuel2 : Nat) : (String × Nat) :=\n              match fuel2 with\n              | 0 => (t, k)\n              | Nat.succ fuel2' =>\n                if t.take n == char then\n                  cnt (t.drop n) (k+1) fuel2'\n                else\n                  (t, k)\n            let pr := cnt s 0 (s.length + 1)\n            let rest := pr.fst\n            go rest (acc ++ char) fuel'\n          else\n            go (s.drop 1) (acc ++ s.take 1) fuel'\n    go string \"\" (string.length + 1)\n\n#guard replace \"peep\" \"e\" == \"pep\"\n#guard replace \"Greek\" \"e\" == \"Grek\"\n#guard replace \"Moon\" \"o\" == \"Mon\"\n", "test_list": ["#guard replace \"peep\" \"e\" == \"pep\"", "#guard replace \"Greek\" \"e\" == \"Grek\"", "#guard replace \"Moon\" \"o\" == \"Mon\""]}
{"text": "Write a function to check whether the given ip address is valid or not using regex.", "task_id": 669, "code": "import Batteries\n\nopen Std\n\ndef check_IP (Ip : String) : String :=\n  let parts := Ip.splitOn \".\"\n  if parts.length != 4 then\n    \"Invalid IP address\"\n  else\n    if parts.all (fun p =>\n      match p.toNat? with\n      | some n => n ≤ 255\n      | none => false) then\n      \"Valid IP address\"\n    else\n      \"Invalid IP address\"\n\n#guard check_IP \"192.168.0.1\" == \"Valid IP address\"\n#guard check_IP \"110.234.52.124\" == \"Valid IP address\"\n#guard check_IP \"366.1.2.2\" == \"Invalid IP address\"\n", "test_list": ["#guard check_IP \"192.168.0.1\" == \"Valid IP address\"", "#guard check_IP \"110.234.52.124\" == \"Valid IP address\"", "#guard check_IP \"366.1.2.2\" == \"Invalid IP address\""]}
{"text": "Write a python function to check whether a sequence of numbers has a decreasing trend or not.", "task_id": 670, "code": "import Batteries\n\nopen Std\n\ndef decreasingTrend (nums : List Int) : Bool :=\n  let rec aux : List Int → Bool\n    | [] => true\n    | [_] => true\n    | a :: b :: t =>\n      if h : a <= b then\n        aux (b :: t)\n      else\n        false\n  aux nums\n\n#guard decreasingTrend [-4, -3, -2, -1] == true\n#guard decreasingTrend [1, 2, 3] == true\n#guard decreasingTrend [3, 2, 1] == false\n", "test_list": ["#guard decreasingTrend [-4, -3, -2, -1] == true", "#guard decreasingTrend [1, 2, 3] == true", "#guard decreasingTrend [3, 2, 1] == false"]}
{"text": "Write a python function to set the right most unset bit.", "task_id": 671, "code": "import Batteries\n\nopen Std\n\ndef getPosOfRightMostSetBit (n : Nat) : Nat := Id.run do\n  if n == 0 then return 0\n  let mut pos := 1\n  let mut m := n\n  while m % 2 == 0 do\n    pos := pos + 1\n    m := m / 2\n  return pos\n\ndef setRightMostUnsetBit (n : Nat) : Nat :=\n  if n == 0 then\n    1\n  else if (n &&& (n + 1)) == 0 then\n    n\n  else\n    let pos := getPosOfRightMostSetBit (n + 1)\n    ((2 ^ (pos - 1)) ||| n)\n\n#guard setRightMostUnsetBit 21 = 23\n#guard setRightMostUnsetBit 11 = 15\n#guard setRightMostUnsetBit 15 = 15\n", "test_list": ["#guard setRightMostUnsetBit 21 = 23", "#guard setRightMostUnsetBit 11 = 15", "#guard setRightMostUnsetBit 15 = 15"]}
{"text": "Write a function to find maximum of three numbers.", "task_id": 672, "code": "import Batteries\n\nopen Std\n\ndef maxOfThree (num1 num2 num3 : Nat) : Nat :=\n  if num1 >= num2 && num1 >= num3 then\n    num1\n  else if num2 >= num1 && num2 >= num3 then\n    num2\n  else\n    num3\n\n#guard maxOfThree 10 20 30 = 30\n#guard maxOfThree 55 47 39 = 55\n#guard maxOfThree 10 49 30 = 49\n", "test_list": ["#guard maxOfThree 10 20 30 = 30", "#guard maxOfThree 55 47 39 = 55", "#guard maxOfThree 10 49 30 = 49"]}
{"text": "Write a python function to convert a list of multiple integers into a single integer.", "task_id": 673, "code": "import Batteries\n\nopen Std\n\ndef convert (list : List Nat) : Nat :=\n  let s := list.map (fun i => toString i)\n  let resStr := s.foldl (fun acc x => acc ++ x) \"\"\n  match resStr.toNat? with\n  | some n => n\n  | none => 0\n\n#guard convert [1, 2, 3] = 123\n#guard convert [4, 5, 6] = 456\n#guard convert [7, 8, 9] = 789\n", "test_list": ["#guard convert [1, 2, 3] = 123", "#guard convert [4, 5, 6] = 456", "#guard convert [7, 8, 9] = 789"]}
{"text": "Write a function to remove duplicate words from a given string using collections module.", "task_id": 674, "code": "import Batteries\n\nopen Std\n\ndef joinWith (sep : String) (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: xs => xs.foldl (fun acc y => acc ++ sep ++ y) x\n\ndef remove_duplicate (string : String) : String := Id.run do\n  let words := (string.splitOn \" \").filter (fun w => w != \"\")\n  let mut seen : HashSet String := {}\n  let mut res : List String := []\n  for w in words do\n    if !seen.contains w then\n      seen := seen.insert w\n      res := res ++ [w]\n  return joinWith \" \" res\n\n#guard remove_duplicate \"Python Exercises Practice Solution Exercises\" = \"Python Exercises Practice Solution\"\n#guard remove_duplicate \"Python Exercises Practice Solution Python\" = \"Python Exercises Practice Solution\"\n#guard remove_duplicate \"Python Exercises Practice Solution Practice\" = \"Python Exercises Practice Solution\"\n", "test_list": ["#guard remove_duplicate \"Python Exercises Practice Solution Exercises\" = \"Python Exercises Practice Solution\"", "#guard remove_duplicate \"Python Exercises Practice Solution Python\" = \"Python Exercises Practice Solution\"", "#guard remove_duplicate \"Python Exercises Practice Solution Practice\" = \"Python Exercises Practice Solution\""]}
{"text": "Write a function to add two integers. however, if the sum is between the given range it will return 20.", "task_id": 675, "code": "import Batteries\n\nopen Std\n\ndef sumNums (x y m n : Nat) : Nat :=\n  let s := x + y\n  if m ≤ s ∧ s < n then 20 else s\n\n#guard sumNums 2 10 11 20 = 20\n#guard sumNums 15 17 1 10 = 32\n#guard sumNums 10 15 5 30 = 20\n", "test_list": ["#guard sumNums 2 10 11 20 = 20", "#guard sumNums 15 17 1 10 = 32", "#guard sumNums 10 15 5 30 = 20"]}
{"text": "Write a function to remove everything except alphanumeric characters from the given string by using regex.", "task_id": 676, "code": "import Batteries\n\nopen Std\n\ndef isAsciiAlphaNum (c : Char) : Bool :=\n  let n := c.toNat\n  (n >= '0'.toNat && n <= '9'.toNat) ||\n  (n >= 'A'.toNat && n <= 'Z'.toNat) ||\n  (n >= 'a'.toNat && n <= 'z'.toNat)\n\ndef remove_extra_char (text1 : String) : String :=\n  String.mk (text1.data.filter isAsciiAlphaNum)\n\n#guard remove_extra_char \"**//Google Android// - 12. \" = \"GoogleAndroid12\"\n#guard remove_extra_char \"****//Google Flutter//*** - 36. \" = \"GoogleFlutter36\"\n#guard remove_extra_char \"**//Google Firebase// - 478. \" = \"GoogleFirebase478\"\n", "test_list": ["#guard remove_extra_char \"**//Google Android// - 12. \" = \"GoogleAndroid12\"", "#guard remove_extra_char \"****//Google Flutter//*** - 36. \" = \"GoogleFlutter36\"", "#guard remove_extra_char \"**//Google Firebase// - 478. \" = \"GoogleFirebase478\""]}
{"text": "Write a function to check if the triangle is valid or not.", "task_id": 677, "code": "import Batteries\n\nopen Std\n\ndef validityTriangle (a b c : Nat) : Bool :=\n  let total := a + b + c\n  if total == 180 then true else false\n\n#guard validityTriangle 60 50 90 == false\n#guard validityTriangle 45 75 60 == true\n#guard validityTriangle 30 50 100 == true\n", "test_list": ["#guard validityTriangle 60 50 90 == false", "#guard validityTriangle 45 75 60 == true", "#guard validityTriangle 30 50 100 == true"]}
{"text": "Write a python function to remove spaces from a given string.", "task_id": 678, "code": "import Batteries\n\nopen Std\n\ndef removeSpaces (str1 : String) : String :=\n  String.mk (List.filter (fun c => c != ' ') str1.data)\n\n#guard removeSpaces \"a b c\" = \"abc\"\n#guard removeSpaces \"1 2 3\" = \"123\"\n#guard removeSpaces \" b c\" = \"bc\"\n", "test_list": ["#guard removeSpaces \"a b c\" = \"abc\"", "#guard removeSpaces \"1 2 3\" = \"123\"", "#guard removeSpaces \" b c\" = \"bc\""]}
{"text": "Write a function to access dictionary key’s element by index.", "task_id": 679, "code": "import Batteries\nopen Std\n\nprivate def getAt? {α : Type u} (xs : List α) (i : Nat) : Option α :=\n  match xs, i with\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs', Nat.succ j => getAt? xs' j\n\ndef accessKey (ditionary : List (String × Nat)) (key : Nat) : String :=\n  match getAt? ditionary key with\n  | some (s, _) => s\n  | none => \"\"\n\n#guard accessKey [(\"physics\",80),(\"math\",90),(\"chemistry\",86)] 0 = \"physics\"\n#guard accessKey [(\"python\",10),(\"java\",20),(\"C++\",30)] 2 = \"C++\"\n#guard accessKey [(\"program\",15),(\"computer\",45)] 1 = \"computer\"\n", "test_list": ["#guard accessKey [(\"physics\",80),(\"math\",90),(\"chemistry\",86)] 0 = \"physics\"", "#guard accessKey [(\"python\",10),(\"java\",20),(\"C++\",30)] 2 = \"C++\"", "#guard accessKey [(\"program\",15),(\"computer\",45)] 1 = \"computer\""]}
{"text": "Write a python function to check whether a sequence of numbers has an increasing trend or not.", "task_id": 680, "code": "import Batteries\n\nopen Std\n\ndef increasingTrend (nums : List Nat) : Bool :=\n  match nums with\n  | [] => true\n  | x :: xs =>\n    let rec go (prev : Nat) (ys : List Nat) : Bool :=\n      match ys with\n      | [] => true\n      | y :: ys' => if prev ≤ y then go y ys' else false\n    go x xs\n\n#guard increasingTrend [1, 2, 3, 4] = true\n#guard increasingTrend [4, 3, 2, 1] = false\n#guard increasingTrend [0, 1, 4, 9] = true\n", "test_list": ["#guard increasingTrend [1, 2, 3, 4] = true", "#guard increasingTrend [4, 3, 2, 1] = false", "#guard increasingTrend [0, 1, 4, 9] = true"]}
{"text": "Write a python function to find the smallest prime divisor of a number.", "task_id": 681, "code": "import Batteries\n\nopen Std\n\ndef smallestDivisor (n : Nat) : Nat := Id.run do\n  if n % 2 == 0 then\n    return 2\n  let limit := Nat.sqrt n\n  for i in [3 : limit + 1] do\n    if (i % 2 == 1) && (n % i == 0) then return i\n  return n\n\n#guard smallestDivisor 10 = 2\n#guard smallestDivisor 25 = 5\n#guard smallestDivisor 31 = 31\n", "test_list": ["#guard smallestDivisor 10 = 2", "#guard smallestDivisor 25 = 5", "#guard smallestDivisor 31 = 31"]}
{"text": "Write a function to multiply two lists using map and lambda function.", "task_id": 682, "code": "import Batteries\n\nopen Std\n\ndef mulList (nums1 nums2 : List Nat) : List Nat :=\n  match nums1, nums2 with\n  | x :: xs, y :: ys => (x * y) :: mulList xs ys\n  | _, _ => []\n\n#guard mulList [1, 2, 3] [4, 5, 6] = [4, 10, 18]\n#guard mulList [1, 2] [3, 4] = [3, 8]\n#guard mulList [90, 120] [50, 70] = [4500, 8400]\n", "test_list": ["#guard mulList [1, 2, 3] [4, 5, 6] = [4, 10, 18]", "#guard mulList [1, 2] [3, 4] = [3, 8]", "#guard mulList [90, 120] [50, 70] = [4500, 8400]"]}
{"text": "Write a python function to check whether the given number can be represented by sum of two squares or not.", "task_id": 683, "code": "import Batteries\n\nopen Std\n\ndef sumSquare (n : Nat) : Bool := Id.run do\n  for i in [1 : Nat.sqrt n + 1] do\n    for j in [1 : Nat.sqrt n + 1] do\n      if i*i + j*j == n then\n        return true\n  return false\n\n#guard sumSquare 25 == true\n#guard sumSquare 24 == false\n#guard sumSquare 17 == true\n", "test_list": ["#guard sumSquare 25 == true", "#guard sumSquare 24 == false", "#guard sumSquare 17 == true"]}
{"text": "Write a python function to count occurences of a character in a repeated string.", "task_id": 684, "code": "import Batteries\nopen Std\n\ndef countChar (s : String) (x : Char) : Nat :=\n  let n := 10\n  let totalInS := s.data.foldl (fun acc c => if c == x then acc + 1 else acc) 0\n  let len := s.length\n  let repetitions := n / len\n  let base := totalInS * repetitions\n  let l := n % len\n  let pref := s.take l\n  let extra := pref.data.foldl (fun acc c => if c == x then acc + 1 else acc) 0\n  base + extra\n\n#guard countChar \"abcac\" 'a' == 4\n#guard countChar \"abca\" 'c' == 2\n#guard countChar \"aba\" 'a' == 7\n", "test_list": ["#guard countChar \"abcac\" 'a' == 4", "#guard countChar \"abca\" 'c' == 2", "#guard countChar \"aba\" 'a' == 7"]}
{"text": "Write a python function to find sum of prime numbers between 1 to n.", "task_id": 685, "code": "import Batteries\n\nopen Std\n\ndef sumOfPrimes (n : Nat) : Nat := Id.run do\n  let mut prime : Array Bool := Array.replicate (n + 1) true\n  let mut p := 2\n  while p * p <= n do\n    if prime[p]! then\n      let mut i := p * 2\n      while i <= n do\n        prime := prime.set! i false\n        i := i + p\n    p := p + 1\n  let mut s := 0\n  let mut i := 2\n  while i <= n do\n    if prime[i]! then\n      s := s + i\n    i := i + 1\n  return s\n\n#guard sumOfPrimes 10 = 17\n#guard sumOfPrimes 20 = 77\n#guard sumOfPrimes 5 = 10\n", "test_list": ["#guard sumOfPrimes 10 = 17", "#guard sumOfPrimes 20 = 77", "#guard sumOfPrimes 5 = 10"]}
{"text": "Write a function to find the frequency of each element in the given list.", "task_id": 686, "code": "import Batteries\nopen Std\n\ndef assocInc (xs : List (Nat × Nat)) (k : Nat) : (List (Nat × Nat)) × Bool :=\n  let rec go (ys : List (Nat × Nat)) : (List (Nat × Nat)) × Bool :=\n    match ys with\n    | [] => ([(k, 1)], true)\n    | (a, b) :: t =>\n        if a = k then ((k, b + 1) :: t, false)\n        else\n          let (t', isNew) := go t\n          ((a, b) :: t', isNew)\n  go xs\n\ndef assocFind (xs : List (Nat × Nat)) (k : Nat) : Nat :=\n  let rec f (ys : List (Nat × Nat)) :=\n    match ys with\n    | [] => 0\n    | (a, b) :: t => if a = k then b else f t\n  f xs\n\ndef intercalateStrings (sep : String) (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: t => t.foldl (fun acc s => acc ++ sep ++ s) x\n\ndef freqElement (test_tup : List Nat) : String :=\n  let rec build (l : List Nat) (counts : List (Nat × Nat)) (order : List Nat) :\n      List (Nat × Nat) × List Nat :=\n    match l with\n    | [] => (counts, order)\n    | e :: t =>\n      let (counts', isNew) := assocInc counts e\n      let order' := if isNew then order ++ [e] else order\n      build t counts' order'\n  let (counts, order) := build test_tup [] []\n  let parts := order.map (fun k => toString k ++ \": \" ++ toString (assocFind counts k))\n  \"{\" ++ intercalateStrings \", \" parts ++ \"}\"\n\n#guard freqElement [4, 5, 4, 5, 6, 6, 5, 5, 4] = \"{4: 3, 5: 4, 6: 2}\"\n#guard freqElement [7, 8, 8, 9, 4, 7, 6, 5, 4] = \"{7: 2, 8: 2, 9: 1, 4: 2, 6: 1, 5: 1}\"\n#guard freqElement [1, 4, 3, 1, 4, 5, 2, 6, 2, 7] = \"{1: 2, 4: 2, 3: 1, 5: 1, 2: 2, 6: 1, 7: 1}\"\n", "test_list": ["#guard freqElement [4, 5, 4, 5, 6, 6, 5, 5, 4] = \"{4: 3, 5: 4, 6: 2}\"", "#guard freqElement [7, 8, 8, 9, 4, 7, 6, 5, 4] = \"{7: 2, 8: 2, 9: 1, 4: 2, 6: 1, 5: 1}\"", "#guard freqElement [1, 4, 3, 1, 4, 5, 2, 6, 2, 7] = \"{1: 2, 4: 2, 3: 1, 5: 1, 2: 2, 6: 1, 7: 1}\""]}
{"text": "Write a function to find the greatest common divisor (gcd) of two integers by using recursion.", "task_id": 687, "code": "import Batteries\n\nopen Std\n\npartial def recurGcd (a b : Nat) : Nat :=\n  let low := Nat.min a b\n  let high := Nat.max a b\n  if low == 0 then\n    high\n  else if low == 1 then\n    1\n  else\n    recurGcd low (high % low)\n\n#guard recurGcd 12 14 == 2\n#guard recurGcd 13 17 == 1\n#guard recurGcd 9 3 == 3\n", "test_list": ["#guard recurGcd 12 14 == 2", "#guard recurGcd 13 17 == 1", "#guard recurGcd 9 3 == 3"]}
{"text": "Write a function to get the length of a complex number.", "task_id": 688, "code": "import Batteries\n\nopen Std\n\ndef lenComplex (a b : Int) : Float :=\n  let af := Float.ofInt a\n  let bf := Float.ofInt b\n  Float.sqrt (af * af + bf * bf)\n\n#guard lenComplex 3 4 == 5.0\n#guard lenComplex 9 10 == 13.45362404707371\n#guard lenComplex 7 9 == 11.40175425099138\n", "test_list": ["#guard lenComplex 3 4 == 5.0", "#guard lenComplex 9 10 == 13.45362404707371", "#guard lenComplex 7 9 == 11.40175425099138"]}
{"text": "## write a function to find the minimum number of jumps to reach the end of the array for the given array of integers where each element represents the max number of steps that can be made forward from that element. > indented block > indented block", "task_id": 689, "code": "import Batteries\nopen Std\n\ndef minJumps (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let INF := n + 1\n  if n == 0 then\n    return INF\n  let arrA := arr.toArray\n  if arrA.getD 0 0 == 0 then\n    return INF\n  let mut jumps := Array.replicate n 0\n  for i in [1 : n] do\n    jumps := jumps.set! i INF\n    let mut found := false\n    for j in [0 : i] do\n      if !found then\n        let aj := arrA.getD j 0\n        let cond1 := i ≤ j + aj\n        let cond2 := jumps.getD j 0 != INF\n        if cond1 && cond2 then\n          let newv := Nat.min (jumps.getD i INF) ((jumps.getD j 0) + 1)\n          jumps := jumps.set! i newv\n          found := true\n      else\n        pure ()\n  return jumps.getD (n - 1) INF\n\n#guard minJumps [1, 3, 6, 1, 0, 9] 6 = 3\n#guard minJumps [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] 11 = 3\n#guard minJumps [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 11 = 10\n", "test_list": ["#guard minJumps [1, 3, 6, 1, 0, 9] 6 = 3", "#guard minJumps [1, 3, 5, 8, 9, 2, 6, 7, 6, 8, 9] 11 = 3", "#guard minJumps [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] 11 = 10"]}
{"text": "Write a function to multiply consecutive numbers of a given list.", "task_id": 690, "code": "import Batteries\n\nopen Std\n\ndef mulConsecutiveNums (nums : List Nat) : List Nat :=\n  match nums with\n  | [] => []\n  | [_] => []\n  | a :: b :: rest => (a * b) :: mulConsecutiveNums (b :: rest)\n\n#guard mulConsecutiveNums [1, 1, 3, 4, 4, 5, 6, 7] = [1, 3, 12, 16, 20, 30, 42]\n#guard mulConsecutiveNums [4, 5, 8, 9, 6, 10] = [20, 40, 72, 54, 60]\n#guard mulConsecutiveNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = [2, 6, 12, 20, 30, 42, 56, 72, 90]\n", "test_list": ["#guard mulConsecutiveNums [1, 1, 3, 4, 4, 5, 6, 7] = [1, 3, 12, 16, 20, 30, 42]", "#guard mulConsecutiveNums [4, 5, 8, 9, 6, 10] = [20, 40, 72, 54, 60]", "#guard mulConsecutiveNums [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] = [2, 6, 12, 20, 30, 42, 56, 72, 90]"]}
{"text": "Write a function to group the 1st elements on the basis of 2nd elements in the given tuple list.", "task_id": 691, "code": "import Batteries\nopen Std\n\ndef insertBy {α} (lt : α → α → Bool) (x : α) : List α → List α\n| [] => [x]\n| y :: ys => if lt y x then y :: insertBy lt x ys else x :: y :: ys\n\ndef isort {α} (lt : α → α → Bool) : List α → List α\n| [] => []\n| x :: xs => insertBy lt x (isort lt xs)\n\ndef findVal? [BEq α] [Hashable α] (m : Std.HashMap α β) (k : α) : Option β :=\n  let rec go : List (α × β) → Option β\n  | [] => none\n  | (k', v) :: xs => if k' == k then some v else go xs\n  go m.toList\n\ndef groupElement (test_list : List (Nat × Nat)) : Std.HashMap Nat (List Nat) :=\n  let sorted := isort (fun a b => Nat.blt a.snd b.snd) test_list\n  let rec go (l : List (Nat × Nat)) (res : Std.HashMap Nat (List Nat)) : Std.HashMap Nat (List Nat) :=\n    match l with\n    | [] => res\n    | (a, b) :: xs =>\n      let old := (findVal? res b).getD []\n      let res' := res.insert b (old ++ [a])\n      go xs res'\n  go sorted {}\n\ndef mapEqList (m : Std.HashMap Nat (List Nat)) (l : List (Nat × List Nat)) : Bool :=\n  let okVals := l.all (fun kv =>\n    let k := kv.fst\n    let v := kv.snd\n    match findVal? m k with\n    | some v' => v' == v\n    | none => false)\n  okVals && (m.size == l.length)\n\n#guard mapEqList (groupElement [(6, 5), (2, 7), (2, 5), (8, 7), (9, 8), (3, 7)]) [(5, [6, 2]), (7, [2, 8, 3]), (8, [9])] = true\n#guard mapEqList (groupElement [(7, 6), (3, 8), (3, 6), (9, 8), (10, 9), (4, 8)]) [(6, [7, 3]), (8, [3, 9, 4]), (9, [10])] = true\n#guard mapEqList (groupElement [(8, 7), (4, 9), (4, 7), (10, 9), (11, 10), (5, 9)]) [(7, [8, 4]), (9, [4, 10, 5]), (10, [11])] = true\n", "test_list": ["#guard mapEqList (groupElement [(6, 5), (2, 7), (2, 5), (8, 7), (9, 8), (3, 7)]) [(5, [6, 2]), (7, [2, 8, 3]), (8, [9])] = true", "#guard mapEqList (groupElement [(7, 6), (3, 8), (3, 6), (9, 8), (10, 9), (4, 8)]) [(6, [7, 3]), (8, [3, 9, 4]), (9, [10])] = true", "#guard mapEqList (groupElement [(8, 7), (4, 9), (4, 7), (10, 9), (11, 10), (5, 9)]) [(7, [8, 4]), (9, [4, 10, 5]), (10, [11])] = true"]}
{"text": "Write a python function to find the last two digits in factorial of a given number.", "task_id": 692, "code": "import Batteries\n\nopen Std\n\ndef lastTwoDigits (N : Nat) : Option Nat :=\n  if N >= 10 then\n    none\n  else\n    let fac := Id.run do\n      let mut fac := 1\n      for i in [1 : N + 1] do\n        fac := (fac * i) % 100\n      return fac\n    some fac\n\n#guard lastTwoDigits 7 = some 40\n#guard lastTwoDigits 5 = some 20\n#guard lastTwoDigits 2 = some 2\n", "test_list": ["#guard lastTwoDigits 7 = some 40", "#guard lastTwoDigits 5 = some 20", "#guard lastTwoDigits 2 = some 2"]}
{"text": "Write a function to remove multiple spaces in a string by using regex.", "task_id": 693, "code": "import Batteries\n\nopen Std\n\ndef remove_multiple_spaces (text1 : String) : String :=\n  let rec go (cs : List Char) (prevSpace : Bool) (acc : List Char) : List Char :=\n    match cs with\n    | [] => acc.reverse\n    | c :: rest =>\n      if c == ' ' then\n        if prevSpace then\n          go rest true acc\n        else\n          go rest true (' ' :: acc)\n      else\n        go rest false (c :: acc)\n  String.mk (go text1.data false [])\n\n#guard remove_multiple_spaces \"Google      Assistant\" = \"Google Assistant\"\n#guard remove_multiple_spaces \"Quad      Core\" = \"Quad Core\"\n#guard remove_multiple_spaces \"ChromeCast      Built-in\" = \"ChromeCast Built-in\"\n", "test_list": ["#guard remove_multiple_spaces \"Google      Assistant\" = \"Google Assistant\"", "#guard remove_multiple_spaces \"Quad      Core\" = \"Quad Core\"", "#guard remove_multiple_spaces \"ChromeCast      Built-in\" = \"ChromeCast Built-in\""]}
{"text": "Write a function to extract unique values from the given dictionary values.", "task_id": 694, "code": "import Batteries\n\nopen Std\n\ndef extractUnique (testDict : List (String × List Nat)) : List Nat := Id.run do\n  \n  let mut s : HashSet Nat := {}\n  let mut maxV : Nat := 0\n  for (_, vals) in testDict do\n    for v in vals do\n      s := s.insert v\n      if v > maxV then maxV := v\n  \n  let mut res : Array Nat := #[]\n  for k in [0 : maxV + 1] do\n    if s.contains k then\n      res := res.push k\n  return res.toList\n\n#guard extractUnique [(\"msm\", [5, 6, 7, 8]), (\"is\", [10, 11, 7, 5]), (\"best\", [6, 12, 10, 8]), (\"for\", [1, 2, 5])] == [1, 2, 5, 6, 7, 8, 10, 11, 12]\n#guard extractUnique [(\"Built\", [7, 1, 9, 4]), (\"for\", [11, 21, 36, 14, 9]), (\"ISP\", [4, 1, 21, 39, 47]), (\"TV\", [1, 32, 38])] == [1, 4, 7, 9, 11, 14, 21, 32, 36, 38, 39, 47]\n#guard extractUnique [(\"F\", [11, 13, 14, 17]), (\"A\", [12, 11, 15, 18]), (\"N\", [19, 21, 15, 36]), (\"G\", [37, 36, 35])] == [11, 12, 13, 14, 15, 17, 18, 19, 21, 35, 36, 37]\n", "test_list": ["#guard extractUnique [(\"msm\", [5, 6, 7, 8]), (\"is\", [10, 11, 7, 5]), (\"best\", [6, 12, 10, 8]), (\"for\", [1, 2, 5])] == [1, 2, 5, 6, 7, 8, 10, 11, 12]", "#guard extractUnique [(\"Built\", [7, 1, 9, 4]), (\"for\", [11, 21, 36, 14, 9]), (\"ISP\", [4, 1, 21, 39, 47]), (\"TV\", [1, 32, 38])] == [1, 4, 7, 9, 11, 14, 21, 32, 36, 38, 39, 47]", "#guard extractUnique [(\"F\", [11, 13, 14, 17]), (\"A\", [12, 11, 15, 18]), (\"N\", [19, 21, 15, 36]), (\"G\", [37, 36, 35])] == [11, 12, 13, 14, 15, 17, 18, 19, 21, 35, 36, 37]"]}
{"text": "Write a function to check if each element of the second tuple is greater than its corresponding index in the first tuple.", "task_id": 695, "code": "import Batteries\n\nopen Std\n\ndef checkGreater (testTup1 testTup2 : List Nat) : Bool :=\n  (List.zip testTup1 testTup2).all (fun p => p.fst < p.snd)\n\n#guard checkGreater [10, 4, 5] [13, 5, 18] = true\n#guard checkGreater [1, 2, 3] [2, 1, 4] = false\n#guard checkGreater [4, 5, 6] [5, 6, 7] = true\n", "test_list": ["#guard checkGreater [10, 4, 5] [13, 5, 18] = true", "#guard checkGreater [1, 2, 3] [2, 1, 4] = false", "#guard checkGreater [4, 5, 6] [5, 6, 7] = true"]}
{"text": "Write a function to zip two given lists of lists.", "task_id": 696, "code": "import Batteries\n\nopen Std\n\ndef zipList {α : Type} (list1 list2 : List (List α)) : List (List α) :=\n  List.zipWith (fun a b => a ++ b) list1 list2\n\n#guard zipList [[1, 3], [5, 7], [9, 11]] [[2, 4], [6, 8], [10, 12, 14]] == [[1, 3, 2, 4], [5, 7, 6, 8], [9, 11, 10, 12, 14]]\n#guard zipList [[1, 2], [3, 4], [5, 6]] [[7, 8], [9, 10], [11, 12]] == [[1, 2, 7, 8], [3, 4, 9, 10], [5, 6, 11, 12]]\n#guard zipList [[\"a\", \"b\"], [\"c\", \"d\"]] [[\"e\", \"f\"], [\"g\", \"h\"]] == [[\"a\", \"b\", \"e\", \"f\"], [\"c\", \"d\", \"g\", \"h\"]]\n", "test_list": ["#guard zipList [[1, 3], [5, 7], [9, 11]] [[2, 4], [6, 8], [10, 12, 14]] == [[1, 3, 2, 4], [5, 7, 6, 8], [9, 11, 10, 12, 14]]", "#guard zipList [[1, 2], [3, 4], [5, 6]] [[7, 8], [9, 10], [11, 12]] == [[1, 2, 7, 8], [3, 4, 9, 10], [5, 6, 11, 12]]", "#guard zipList [[\"a\", \"b\"], [\"c\", \"d\"]] [[\"e\", \"f\"], [\"g\", \"h\"]] == [[\"a\", \"b\", \"e\", \"f\"], [\"c\", \"d\", \"g\", \"h\"]]"]}
{"text": "Write a function to find number of even elements in the given list using lambda function.", "task_id": 697, "code": "import Batteries\n\nopen Std\n\ndef count_even (array_nums : List Int) : Nat :=\n  (array_nums.filter (fun x => x % 2 == 0)).length\n\n#guard count_even [1, 2, 3, 5, 7, 8, 9, 10] == 3\n#guard count_even [10,15,14,13,-18,12,-20] == 5\n#guard count_even [1, 2, 4, 8, 9] == 3\n", "test_list": ["#guard count_even [1, 2, 3, 5, 7, 8, 9, 10] == 3", "#guard count_even [10,15,14,13,-18,12,-20] == 5", "#guard count_even [1, 2, 4, 8, 9] == 3"]}
{"text": "Write a function to sort dictionary items by tuple product of keys for the given dictionary with tuple keys.", "task_id": 698, "code": "import Batteries\n\nopen Std\n\ndef insertBy {α : Type} (lt : α → α → Bool) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys => if lt x y then x :: y :: ys else y :: insertBy lt x ys\n\ndef isortBy {α : Type} (lt : α → α → Bool) (xs : List α) : List α :=\n  xs.foldl (fun acc x => insertBy lt x acc) []\n\ndef sortDictItem (testDict : List ((Nat × Nat) × Nat)) : List ((Nat × Nat) × Nat) :=\n  let keyProd (p : (Nat × Nat) × Nat) : Nat :=\n    let k := p.fst\n    k.fst * k.snd\n  isortBy (fun a b => keyProd a < keyProd b) testDict\n\n#guard sortDictItem [((5, 6), 3), ((2, 3), 9), ((8, 4), 10), ((6, 4), 12)] == [((2, 3), 9), ((6, 4), 12), ((5, 6), 3), ((8, 4), 10)]\n#guard sortDictItem [((6, 7), 4), ((3, 4), 10), ((9, 5), 11), ((7, 5), 13)] == [((3, 4), 10), ((7, 5), 13), ((6, 7), 4), ((9, 5), 11)]\n#guard sortDictItem [((7, 8), 5), ((4, 5), 11), ((10, 6), 12), ((8, 6), 14)] == [((4, 5), 11), ((8, 6), 14), ((7, 8), 5), ((10, 6), 12)]\n", "test_list": ["#guard sortDictItem [((5, 6), 3), ((2, 3), 9), ((8, 4), 10), ((6, 4), 12)] == [((2, 3), 9), ((6, 4), 12), ((5, 6), 3), ((8, 4), 10)]", "#guard sortDictItem [((6, 7), 4), ((3, 4), 10), ((9, 5), 11), ((7, 5), 13)] == [((3, 4), 10), ((7, 5), 13), ((6, 7), 4), ((9, 5), 11)]", "#guard sortDictItem [((7, 8), 5), ((4, 5), 11), ((10, 6), 12), ((8, 6), 14)] == [((4, 5), 11), ((8, 6), 14), ((7, 8), 5), ((10, 6), 12)]"]}
{"text": "Write a python function to find the minimum number of swaps required to convert one binary string to another.", "task_id": 699, "code": "import Batteries\n\nopen Std\n\ndef min_Swaps (str1 str2 : String) : Sum Nat String :=\n  \n  let l1 := str1.data\n  let l2 := str2.data\n  let count := (List.zip l1 l2).foldl (init := 0) (fun acc p =>\n    match p with\n    | (a, b) => if a == b then acc else acc + 1)\n  if count % 2 == 0 then\n    Sum.inl (count / 2)\n  else\n    Sum.inr \"Not Possible\"\n\n#guard min_Swaps \"1101\" \"1110\" == Sum.inl 1\n#guard min_Swaps \"1111\" \"0100\" == Sum.inr \"Not Possible\"\n#guard min_Swaps \"1110000\" \"0001101\" == Sum.inl 3\n", "test_list": ["#guard min_Swaps \"1101\" \"1110\" == Sum.inl 1", "#guard min_Swaps \"1111\" \"0100\" == Sum.inr \"Not Possible\"", "#guard min_Swaps \"1110000\" \"0001101\" == Sum.inl 3"]}
{"text": "Write a function to count the number of elements in a list which are within a specific range.", "task_id": 700, "code": "import Batteries\n\nopen Std\n\ndef leq {α} [Ord α] (a b : α) : Bool :=\n  match compare a b with\n  | Ordering.lt => true\n  | Ordering.eq => true\n  | Ordering.gt => false\n\ndef countRangeInList {α} [Ord α] (li : List α) (min : α) (max : α) : Nat :=\n  li.foldl (init := 0) (fun ctr x =>\n    if leq min x && leq x max then ctr + 1 else ctr)\n\n#guard countRangeInList [10,20,30,40,40,40,70,80,99] 40 100 = 6\n#guard countRangeInList ['a','b','c','d','e','f'] 'a' 'e' = 5\n#guard countRangeInList [7,8,9,15,17,19,45] 15 20 = 3\n", "test_list": ["#guard countRangeInList [10,20,30,40,40,40,70,80,99] 40 100 = 6", "#guard countRangeInList ['a','b','c','d','e','f'] 'a' 'e' = 5", "#guard countRangeInList [7,8,9,15,17,19,45] 15 20 = 3"]}
{"text": "Write a function to find the equilibrium index of the given array.", "task_id": 701, "code": "import Batteries\n\nopen Std\n\ndef equilibriumIndex (arr : List Int) : Int := Id.run do\n  let mut totalSum := arr.foldl (fun acc x => acc + x) (0 : Int)\n  let mut leftSum : Int := 0\n  let mut i : Int := 0\n  for num in arr do\n    totalSum := totalSum - num\n    if leftSum == totalSum then\n      return i\n    leftSum := leftSum + num\n    i := i + 1\n  return (-1)\n\n#guard equilibriumIndex [1, 2, 3, 4, 1, 2, 3] = 3\n#guard equilibriumIndex [-7, 1, 5, 2, -4, 3, 0] = 3\n#guard equilibriumIndex [1, 2, 3] = -1\n", "test_list": ["#guard equilibriumIndex [1, 2, 3, 4, 1, 2, 3] = 3", "#guard equilibriumIndex [-7, 1, 5, 2, -4, 3, 0] = 3", "#guard equilibriumIndex [1, 2, 3] = -1"]}
{"text": "Write a function to find the minimum number of elements that should be removed such that amax-amin<=k.", "task_id": 702, "code": "import Batteries\nopen Std\n\ndef listMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | x :: xs => xs.foldl (fun m y => if y < m then y else m) x\n\ndef removeOne (xs : List Nat) (x : Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne ys x\n\ndef getAtD {α} (xs : List α) (i : Nat) (dflt : α) : α :=\n  match xs.drop i with\n  | [] => dflt\n  | y :: _ => y\n\ndef selectionSortNat (xs : List Nat) : List Nat :=\n  let rec go (ys : List Nat) (acc : List Nat) (fuel : Nat) : List Nat :=\n    match fuel with\n    | 0 => acc ++ ys\n    | fuel' + 1 =>\n      match ys with\n      | [] => acc\n      | _ =>\n        let m := listMin ys\n        let ys' := removeOne ys m\n        go ys' (acc ++ [m]) fuel'\n  go xs [] xs.length\n\ndef findInd (key i n k : Nat) (arr : List Nat) : Int :=\n  let start0 := i + 1\n  let end0 := n - 1\n  let rec loop (start_ end_ : Nat) (ind : Int) (fuel : Nat) : Int :=\n    match fuel with\n    | 0 => ind\n    | fuel' + 1 =>\n      if start_ < end_ then\n        let mid := start_ + (end_ - start_) / 2\n        let midVal := getAtD arr mid 0\n        if midVal ≤ key + k then\n          loop (mid + 1) end_ (Int.ofNat mid) fuel'\n        else\n          loop start_ mid ind fuel'\n      else\n        ind\n  loop start0 end0 (-1) (n + 1)\n\ndef removals (arr : List Nat) (n k : Nat) : Nat := Id.run do\n  let arrS := selectionSortNat arr\n  let mut ans := n - 1\n  for i in [0 : n] do\n    let key := getAtD arrS i 0\n    let j := findInd key i n k arrS\n    if j != (-1) then\n      let jNat := Int.toNat j\n      let segLen := (jNat - i) + 1\n      let cand := n - segLen\n      ans := Nat.min ans cand\n  return ans\n\n#guard removals [1, 3, 4, 9, 10, 11, 12, 17, 20] 9 4 == 5\n#guard removals [1, 5, 6, 2, 8] 5 2 == 3\n#guard removals [1, 2, 3, 4, 5, 6] 6 3 == 2\n", "test_list": ["#guard removals [1, 3, 4, 9, 10, 11, 12, 17, 20] 9 4 == 5", "#guard removals [1, 5, 6, 2, 8] 5 2 == 3", "#guard removals [1, 2, 3, 4, 5, 6] 6 3 == 2"]}
{"text": "Write a function to check whether the given key is present in the dictionary or not.", "task_id": 703, "code": "import Batteries\nopen Std\n\ndef isKeyPresent (d : Std.HashMap Nat Nat) (x : Nat) : Bool :=\n  d.contains x\n\ndef mkMap (xs : List (Nat × Nat)) : Std.HashMap Nat Nat :=\n  xs.foldl (fun (m : Std.HashMap Nat Nat) (k, v) => m.insert k v) (Std.HashMap.emptyWithCapacity (α := Nat) (β := Nat) xs.length)\n\n#guard isKeyPresent (mkMap [(1,10), (2,20), (3,30), (4,40), (5,50), (6,60)]) 5 == true\n#guard isKeyPresent (mkMap [(1,10), (2,20), (3,30), (4,40), (5,50), (6,60)]) 6 == true\n#guard isKeyPresent (mkMap [(1,10), (2,20), (3,30), (4,40), (5,50), (6,60)]) 10 == false\n", "test_list": ["#guard isKeyPresent (mkMap [(1,10), (2,20), (3,30), (4,40), (5,50), (6,60)]) 5 == true", "#guard isKeyPresent (mkMap [(1,10), (2,20), (3,30), (4,40), (5,50), (6,60)]) 6 == true", "#guard isKeyPresent (mkMap [(1,10), (2,20), (3,30), (4,40), (5,50), (6,60)]) 10 == false"]}
{"text": "Write a function to calculate the harmonic sum of n-1.", "task_id": 704, "code": "import Batteries\n\nopen Std\n\ndef harmonicSum : Nat -> Float\n| 0 => 1.0\n| 1 => 1.0\n| n+2 => (1.0 / Float.ofNat (n+2)) + harmonicSum (n+1)\n\n#guard harmonicSum 10 == (2.9289682539682538 : Float)\n#guard harmonicSum 4 == (2.083333333333333 : Float)\n#guard harmonicSum 7 == (2.5928571428571425 : Float)\n", "test_list": ["#guard harmonicSum 10 == (2.9289682539682538 : Float)", "#guard harmonicSum 4 == (2.083333333333333 : Float)", "#guard harmonicSum 7 == (2.5928571428571425 : Float)"]}
{"text": "Write a function to sort a list of lists by length and value.", "task_id": 705, "code": "import Batteries\n\nopen Std\n\ndef removeFirst {α} [BEq α] (xs : List α) (y : α) : List α :=\n  match xs with\n  | [] => []\n  | x :: xs' => if x == y then xs' else x :: removeFirst xs' y\n\ndef compareList {α} [Ord α] : List α → List α → Ordering\n| [], [] => .eq\n| [], _  => .lt\n| _,  [] => .gt\n| x :: xs, y :: ys =>\n  match compare x y with\n  | .lt => .lt\n  | .gt => .gt\n  | .eq => compareList xs ys\n\ndef selectionSortStableBy {α} [BEq α] (le : α → α → Bool) (xs : List α) : List α := Id.run do\n  let lt (a b : α) := le a b && !(le b a)\n  let n := xs.length\n  let mut src := xs\n  let mut res : List α := []\n  for _ in [: n] do\n    match src with\n    | [] => ()\n    | x :: xs' =>\n      let minVal := (x :: xs').foldl (fun m a => if lt a m then a else m) x\n      let rest := removeFirst (x :: xs') minVal\n      res := res ++ [minVal]\n      src := rest\n  return res\n\ndef sortSublists {α} [Ord α] [BEq α] (list1 : List (List α)) : List (List α) :=\n  let leLex (a b : List α) : Bool :=\n    match compareList a b with\n    | .gt => false\n    | _   => true\n  let byLex := selectionSortStableBy leLex list1\n  let leLen (a b : List α) : Bool := Nat.ble a.length b.length\n  selectionSortStableBy leLen byLex\n\n#guard sortSublists [[2], [0], [1, 3], [0, 7], [9, 11], [13, 15, 17]] = [[0], [2], [0, 7], [1, 3], [9, 11], [13, 15, 17]]\n#guard sortSublists [[1], [2, 3], [4, 5, 6], [7], [10, 11]] = [[1], [7], [2, 3], [10, 11], [4, 5, 6]]\n#guard sortSublists [[\"python\"], [\"java\", \"C\", \"C++\"], [\"DBMS\"], [\"SQL\", \"HTML\"]] = [[\"DBMS\"], [\"python\"], [\"SQL\", \"HTML\"], [\"java\", \"C\", \"C++\"]]\n", "test_list": ["#guard sortSublists [[2], [0], [1, 3], [0, 7], [9, 11], [13, 15, 17]] = [[0], [2], [0, 7], [1, 3], [9, 11], [13, 15, 17]]", "#guard sortSublists [[1], [2, 3], [4, 5, 6], [7], [10, 11]] = [[1], [7], [2, 3], [10, 11], [4, 5, 6]]", "#guard sortSublists [[\"python\"], [\"java\", \"C\", \"C++\"], [\"DBMS\"], [\"SQL\", \"HTML\"]] = [[\"DBMS\"], [\"python\"], [\"SQL\", \"HTML\"], [\"java\", \"C\", \"C++\"]]"]}
{"text": "Write a function to find whether an array is subset of another array.", "task_id": 706, "code": "import Batteries\n\nopen Std\n\ndef isSubset (arr1 : List Nat) (m : Nat) (arr2 : List Nat) (n : Nat) : Bool := Id.run do\n  let s : HashSet Nat := HashSet.ofList (arr1.take m)\n  for x in arr2.take n do\n    if x ∈ s then\n      pure ()\n    else\n      return false\n  return true\n\n#guard isSubset [11, 1, 13, 21, 3, 7] 6 [11, 3, 7, 1] 4 == true\n#guard isSubset [1, 2, 3, 4, 5, 6] 6 [1, 2, 4] 3 == true\n#guard isSubset [10, 5, 2, 23, 19] 5 [19, 5, 3] 3 == false\n", "test_list": ["#guard isSubset [11, 1, 13, 21, 3, 7] 6 [11, 3, 7, 1] 4 == true", "#guard isSubset [1, 2, 3, 4, 5, 6] 6 [1, 2, 4] 3 == true", "#guard isSubset [10, 5, 2, 23, 19] 5 [19, 5, 3] 3 == false"]}
{"text": "Write a python function to count the total set bits from 1 to n.", "task_id": 707, "code": "import Batteries\n\nopen Std\n\ndef countSetBits (n : Nat) : Nat := Id.run do\n  let n1 := n + 1\n  let mut powerOf2 := 2\n  let mut cnt := n1 / 2\n  while powerOf2 <= n1 do\n    let totalPairs := n1 / powerOf2\n    cnt := cnt + (totalPairs / 2) * powerOf2\n    if totalPairs % 2 == 1 then\n      cnt := cnt + (n1 % powerOf2)\n    else\n      cnt := cnt + 0\n    powerOf2 := powerOf2 * 2\n  return cnt\n\n#guard countSetBits 16 = 33\n#guard countSetBits 2 = 2\n#guard countSetBits 14 = 28\n", "test_list": ["#guard countSetBits 16 = 33", "#guard countSetBits 2 = 2", "#guard countSetBits 14 = 28"]}
{"text": "Write a python function to convert a string to a list.", "task_id": 708, "code": "import Batteries\n\nopen Std\n\ndef Convert (string : String) : List String :=\n  string.splitOn \" \"\n\n#guard Convert \"python program\" == [\"python\", \"program\"]\n#guard Convert \"Data Analysis\" == [\"Data\", \"Analysis\"]\n#guard Convert \"Hadoop Training\" == [\"Hadoop\", \"Training\"]\n", "test_list": ["#guard Convert \"python program\" == [\"python\", \"program\"]", "#guard Convert \"Data Analysis\" == [\"Data\", \"Analysis\"]", "#guard Convert \"Hadoop Training\" == [\"Hadoop\", \"Training\"]"]}
{"text": "Write a function to count unique keys for each value present in the tuple.", "task_id": 709, "code": "import Batteries\n\nopen Std\n\ndef containsNat (xs : List Nat) (x : Nat) : Bool :=\n  xs.any (fun y => y == x)\n\ndef eraseDupsNat (xs : List Nat) : List Nat :=\n  let rec go (ys : List Nat) (acc : List Nat) : List Nat :=\n    match ys with\n    | [] => acc.reverse\n    | y :: ys' =>\n      if containsNat acc y then go ys' acc else go ys' (y :: acc)\n  go xs []\n\ndef insertKV (m : List (Nat × List Nat)) (k v : Nat) : List (Nat × List Nat) :=\n  match m with\n  | [] => [(k, [v])]\n  | (k', vs) :: rest =>\n    if k' == k then (k', vs ++ [v]) :: rest else (k', vs) :: insertKV rest k v\n\ndef dictToStringNatNat (pairs : List (Nat × Nat)) : String :=\n  let (body, _) := pairs.foldl (fun (st : String × Bool) (kv : Nat × Nat) =>\n    let (acc, first) := st\n    let sep := if first then \"\" else \", \"\n    let piece := sep ++ toString kv.fst ++ \": \" ++ toString kv.snd\n    (acc ++ piece, false)\n  ) (\"\", true)\n  \"{\" ++ body ++ \"}\"\n\ndef getUnique (testList : List (Nat × Nat)) : String := Id.run do\n  \n  let mut res : List (Nat × List Nat) := []\n  for sub in testList do\n    let v := sub.fst\n    let k := sub.snd\n    res := insertKV res k v\n  \n  let counts : List (Nat × Nat) := res.map (fun (k, vs) => (k, (eraseDupsNat vs).length))\n  return dictToStringNatNat counts\n\n#guard getUnique [(3, 4), (1, 2), (2, 4), (8, 2), (7, 2), (8, 1), (9, 1), (8, 4), (10, 4)] == \"{4: 4, 2: 3, 1: 2}\"\n#guard getUnique [(4, 5), (2, 3), (3, 5), (9, 3), (8, 3), (9, 2), (10, 2), (9, 5), (11, 5)] == \"{5: 4, 3: 3, 2: 2}\"\n#guard getUnique [(6, 5), (3, 4), (2, 6), (11, 1), (8, 22), (8, 11), (4, 3), (14, 3), (11, 6)] == \"{5: 1, 4: 1, 6: 2, 1: 1, 22: 1, 11: 1, 3: 2}\"\n", "test_list": ["#guard getUnique [(3, 4), (1, 2), (2, 4), (8, 2), (7, 2), (8, 1), (9, 1), (8, 4), (10, 4)] == \"{4: 4, 2: 3, 1: 2}\"", "#guard getUnique [(4, 5), (2, 3), (3, 5), (9, 3), (8, 3), (9, 2), (10, 2), (9, 5), (11, 5)] == \"{5: 4, 3: 3, 2: 2}\"", "#guard getUnique [(6, 5), (3, 4), (2, 6), (11, 1), (8, 22), (8, 11), (4, 3), (14, 3), (11, 6)] == \"{5: 1, 4: 1, 6: 2, 1: 1, 22: 1, 11: 1, 3: 2}\""]}
{"text": "Write a function to access the initial and last data of the given tuple record.", "task_id": 710, "code": "import Batteries\nopen Std\n\ndef front_and_rear (test_tup : List Nat) : Nat × Nat :=\n  \n  let first :=\n    match test_tup with\n    | [] => 0\n    | x :: _ => x\n  let last := test_tup.foldl (fun _ x => x) 0\n  (first, last)\n\n#guard front_and_rear [10, 4, 5, 6, 7] = (10, 7)\n#guard front_and_rear [1, 2, 3, 4, 5] = (1, 5)\n#guard front_and_rear [6, 7, 8, 9, 10] = (6, 10)\n", "test_list": ["#guard front_and_rear [10, 4, 5, 6, 7] = (10, 7)", "#guard front_and_rear [1, 2, 3, 4, 5] = (1, 5)", "#guard front_and_rear [6, 7, 8, 9, 10] = (6, 10)"]}
{"text": "Write a python function to check whether the product of digits of a number at even and odd places is equal or not.", "task_id": 711, "code": "import Batteries\n\nopen Std\n\ndef productEqual (n : Nat) : Bool := Id.run do\n  if n < 10 then return false\n  let mut m := n\n  let mut prodOdd := 1\n  let mut prodEven := 1\n  while m > 0 do\n    let digit := m % 10\n    prodOdd := prodOdd * digit\n    m := m / 10\n    if m == 0 then break\n    let digit2 := m % 10\n    prodEven := prodEven * digit2\n    m := m / 10\n  return prodOdd == prodEven\n\n#guard productEqual 2841 == true\n#guard productEqual 1234 == false\n#guard productEqual 1212 == false\n", "test_list": ["#guard productEqual 2841 == true", "#guard productEqual 1234 == false", "#guard productEqual 1212 == false"]}
{"text": "Write a function to remove duplicates from a list of lists.", "task_id": 712, "code": "import Batteries\n\nopen Std\n\nclass Cmp (α : Type) where\n  lt : α → α → Bool\n\ndef natLt (a b : Nat) : Bool :=\n  Nat.ble (a + 1) b\n\ndef charLt (a b : Char) : Bool :=\n  natLt a.toNat b.toNat\n\ninstance : Cmp Nat where\n  lt := fun a b => natLt a b\n\ninstance : Cmp String where\n  lt := fun a b =>\n    let rec go (xs ys : List Char) : Bool :=\n      match xs, ys with\n      | [], [] => false\n      | [], _ => true\n      | _, [] => false\n      | x::xs, y::ys => if x == y then go xs ys else charLt x y\n    go a.data b.data\n\ninstance : Cmp (List Nat) where\n  lt := fun xs ys =>\n    let rec go (xs ys : List Nat) : Bool :=\n      match xs, ys with\n      | [], [] => false\n      | [], _ => true\n      | _, [] => false\n      | x::xs, y::ys => if Nat.beq x y then go xs ys else natLt x y\n    go xs ys\n\ndef insertBy {α} (lt : α → α → Bool) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys => if lt x y then x :: y :: ys else y :: insertBy lt x ys\n\ndef isort {α} (lt : α → α → Bool) (xs : List α) : List α :=\n  xs.foldl (fun acc x => insertBy lt x acc) []\n\ndef dedupAdj {α} [BEq α] (xs : List α) : List α :=\n  let rec go (prev? : Option α) (acc : List α) (ys : List α) : List α :=\n    match ys with\n    | [] => acc.reverse\n    | y :: ys' =>\n      match prev? with\n      | some p =>\n        if y == p then go prev? acc ys' else go (some y) (y :: acc) ys'\n      | none => go (some y) (y :: acc) ys'\n  go none [] xs\n\ndef remove_duplicate {α} [Cmp α] [BEq α] (list1 : List α) : List α :=\n  let sorted := isort (Cmp.lt) list1\n  dedupAdj sorted\n\n#guard remove_duplicate [[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]] = [[10, 20], [30, 56, 25], [33], [40]]\n#guard remove_duplicate [\"a\", \"b\", \"a\", \"c\", \"c\"] = [\"a\", \"b\", \"c\"]\n#guard remove_duplicate [1, 3, 5, 6, 3, 5, 6, 1] = [1, 3, 5, 6]\n", "test_list": ["#guard remove_duplicate [[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]] = [[10, 20], [30, 56, 25], [33], [40]]", "#guard remove_duplicate [\"a\", \"b\", \"a\", \"c\", \"c\"] = [\"a\", \"b\", \"c\"]", "#guard remove_duplicate [1, 3, 5, 6, 3, 5, 6, 1] = [1, 3, 5, 6]"]}
{"text": "Write a function to check if the given tuple contains all valid values or not.", "task_id": 713, "code": "import Batteries\n\nopen Std\n\ndef checkValid (testTup : List Bool) : Bool :=\n  let res := !(testTup.any (fun ele => !ele))\n  res\n\n#guard checkValid [true, true, true, true] == true\n#guard checkValid [true, false, true, true] == false\n#guard checkValid [true, true, true, true] == true\n", "test_list": ["#guard checkValid [true, true, true, true] == true", "#guard checkValid [true, false, true, true] == false", "#guard checkValid [true, true, true, true] == true"]}
{"text": "Write a python function to count the number of distinct power of prime factor of given number.", "task_id": 714, "code": "import Batteries\n\nopen Std\n\ndef countFac (n : Nat) : Nat := Id.run do\n  \n  let m := n\n  let mut count := 0\n  let mut i := 2\n  let mut n0 := n\n  while h : i * i ≤ m do\n    let mut total := 0\n    while n0 % i == 0 do\n      n0 := n0 / i\n      total := total + 1\n    let mut temp := 0\n    let mut j := 1\n    while h2 : temp + j ≤ total do\n      temp := temp + j\n      count := count + 1\n      j := j + 1\n    i := i + 1\n  if n0 != 1 then\n    count := count + 1\n  return count\n\n#guard countFac 24 == 3\n#guard countFac 12 == 2\n#guard countFac 4 == 1\n", "test_list": ["#guard countFac 24 == 3", "#guard countFac 12 == 2", "#guard countFac 4 == 1"]}
{"text": "Write a function to convert the given string of integers into a tuple.", "task_id": 715, "code": "import Batteries\n\nopen Std\n\ndef strToTuple (test_str : String) : List Int :=\n  test_str.splitOn \", \" |>.map (fun s => (s.toInt?).getD 0)\n\n#guard strToTuple \"1, -5, 4, 6, 7\" == [1, -5, 4, 6, 7]\n#guard strToTuple \"1, 2, 3, 4, 5\" == [1, 2, 3, 4, 5]\n#guard strToTuple \"4, 6, 9, 11, 13, 14\" == [4, 6, 9, 11, 13, 14]\n", "test_list": ["#guard strToTuple \"1, -5, 4, 6, 7\" == [1, -5, 4, 6, 7]", "#guard strToTuple \"1, 2, 3, 4, 5\" == [1, 2, 3, 4, 5]", "#guard strToTuple \"4, 6, 9, 11, 13, 14\" == [4, 6, 9, 11, 13, 14]"]}
{"text": "Write a function to find the perimeter of a rombus.", "task_id": 716, "code": "import Batteries\n\nopen Std\n\ndef rombusPerimeter (a : Nat) : Nat :=\n  let perimeter := 4 * a\n  perimeter\n\n#guard rombusPerimeter 10 == 40\n#guard rombusPerimeter 5 == 20\n#guard rombusPerimeter 4 == 16\n", "test_list": ["#guard rombusPerimeter 10 == 40", "#guard rombusPerimeter 5 == 20", "#guard rombusPerimeter 4 == 16"]}
{"text": "Write a function to calculate the standard deviation.", "task_id": 717, "code": "import Batteries\n\nopen Std\n\ndef avg_calc (ls : List Float) : Float :=\n  \n  \n  let n := ls.length\n  if n <= 1 then\n    ls.headD 0.0\n  else\n    let sum := ls.foldl (fun acc el => acc + el) 0.0\n    sum / Float.ofNat n\n\ndef sd_calc (data : List Float) : Float :=\n  let n := data.length\n  if n <= 1 then\n    0.0\n  else\n    let mean := avg_calc data\n    let ssum := data.foldl (fun acc el => acc + (el - mean) * (el - mean)) 0.0\n    Float.sqrt (ssum / Float.ofNat (n - 1))\n\n#guard sd_calc [4.0, 2.0, 5.0, 8.0, 6.0] == 2.23606797749979\n#guard sd_calc [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0] == 2.160246899469287\n#guard sd_calc [5.0, 9.0, 10.0, 15.0, 6.0, 4.0] == 4.070217029430577\n", "test_list": ["#guard sd_calc [4.0, 2.0, 5.0, 8.0, 6.0] == 2.23606797749979", "#guard sd_calc [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0] == 2.160246899469287", "#guard sd_calc [5.0, 9.0, 10.0, 15.0, 6.0, 4.0] == 4.070217029430577"]}
{"text": "Write a function to create a list taking alternate elements from another given list.", "task_id": 718, "code": "import Batteries\n\nopen Std\n\ndef alternateElements {α} (list1 : List α) : List α :=\n  let rec go (take : Bool) (l : List α) : List α :=\n    match l with\n    | [] => []\n    | x :: xs =>\n      if take then x :: go false xs else go true xs\n  go true list1\n\n#guard alternateElements [\"red\", \"black\", \"white\", \"green\", \"orange\"] == [\"red\", \"white\", \"orange\"]\n#guard alternateElements ([2, 0, 3, 4, 0, 2, 8, 3, 4, 2] : List Nat) == [2, 3, 0, 8, 4]\n#guard alternateElements ([1,2,3,4,5,6,7,8,9,10] : List Nat) == [1,3,5,7,9]\n", "test_list": ["#guard alternateElements [\"red\", \"black\", \"white\", \"green\", \"orange\"] == [\"red\", \"white\", \"orange\"]", "#guard alternateElements ([2, 0, 3, 4, 0, 2, 8, 3, 4, 2] : List Nat) == [2, 3, 0, 8, 4]", "#guard alternateElements ([1,2,3,4,5,6,7,8,9,10] : List Nat) == [1,3,5,7,9]"]}
{"text": "Write a function that matches a string that has an a followed by zero or more b's.", "task_id": 719, "code": "import Batteries\n\nopen Std\n\ndef textMatch (text : String) : String :=\n  let _patterns := \"ab*?\" \n  if text.data.any (fun c => c = 'a') then\n    \"Found a match!\"\n  else\n    \"Not matched!\"\n\n#guard textMatch \"ac\" == \"Found a match!\"\n#guard textMatch \"dc\" == \"Not matched!\"\n#guard textMatch \"abba\" == \"Found a match!\"\n", "test_list": ["#guard textMatch \"ac\" == \"Found a match!\"", "#guard textMatch \"dc\" == \"Not matched!\"", "#guard textMatch \"abba\" == \"Found a match!\""]}
{"text": "Write a function to add a dictionary to the tuple.", "task_id": 720, "code": "import Batteries\n\nopen Std\n\ninductive NatOrDict where\n  | nat (n : Nat)\n  | dict (d : List (String × Nat))\n  deriving Repr, DecidableEq\n\ndef addDictToTuple (test_tup : List Nat) (test_dict : List (String × Nat)) : List NatOrDict :=\n  let test_tup := test_tup.map NatOrDict.nat\n  let test_tup := test_tup.concat (NatOrDict.dict test_dict)\n  test_tup\n\n#guard addDictToTuple [4, 5, 6] [(\"MSAM\", 1), (\"is\", 2), (\"best\", 3)] = [NatOrDict.nat 4, NatOrDict.nat 5, NatOrDict.nat 6, NatOrDict.dict [(\"MSAM\", 1), (\"is\", 2), (\"best\", 3)]]\n#guard addDictToTuple [1, 2, 3] [(\"UTS\", 2), (\"is\", 3), (\"Worst\", 4)] = [NatOrDict.nat 1, NatOrDict.nat 2, NatOrDict.nat 3, NatOrDict.dict [(\"UTS\", 2), (\"is\", 3), (\"Worst\", 4)]]\n#guard addDictToTuple [8, 9, 10] [(\"POS\", 3), (\"is\", 4), (\"Okay\", 5)] = [NatOrDict.nat 8, NatOrDict.nat 9, NatOrDict.nat 10, NatOrDict.dict [(\"POS\", 3), (\"is\", 4), (\"Okay\", 5)]]\n", "test_list": ["#guard addDictToTuple [4, 5, 6] [(\"MSAM\", 1), (\"is\", 2), (\"best\", 3)] = [NatOrDict.nat 4, NatOrDict.nat 5, NatOrDict.nat 6, NatOrDict.dict [(\"MSAM\", 1), (\"is\", 2), (\"best\", 3)]]", "#guard addDictToTuple [1, 2, 3] [(\"UTS\", 2), (\"is\", 3), (\"Worst\", 4)] = [NatOrDict.nat 1, NatOrDict.nat 2, NatOrDict.nat 3, NatOrDict.dict [(\"UTS\", 2), (\"is\", 3), (\"Worst\", 4)]]", "#guard addDictToTuple [8, 9, 10] [(\"POS\", 3), (\"is\", 4), (\"Okay\", 5)] = [NatOrDict.nat 8, NatOrDict.nat 9, NatOrDict.nat 10, NatOrDict.dict [(\"POS\", 3), (\"is\", 4), (\"Okay\", 5)]]"]}
{"text": "Write a function to find a path with the maximum average over all existing paths for the given square matrix of size n*n.", "task_id": 721, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef List.get2d {α : Type} (l : List (List α)) (y x : Nat) (fallback : α) :=\n  (l.getD y []).getD x fallback\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef maxAverageOfPath (cost : List (List Nat)) (N : Nat) : Float := Id.run do\n  let mut dp : Array (Array Nat) := Array.replicate (N+1) (Array.replicate (N+1) 0)\n  dp := dp.set2d? 0 0 (cost.get2d 0 0 0)\n  for i in [1 : N] do\n    dp := dp.set2d? i 0 <| dp.get2d (i-1) 0 0 + cost.get2d i 0 0\n  for j in [1 : N] do\n    dp := dp.set2d? 0 j <| dp.get2d 0 (j-1) 0 + cost.get2d 0 j 0\n  for i in [1 : N] do\n    for j in [1 : N] do\n      let best := max (dp.get2d (i-1) j 0) (dp.get2d i (j-1) 0)\n      dp := dp.set2d? i j <| best + cost.get2d i j 0\n  let total := dp.get2d (N-1) (N-1) 0\n  let numerator := Float.ofNat total\n  let denomNat := 2 * N - 1\n  let denom := Float.ofNat denomNat\n  return numerator / denom\n\n#guard maxAverageOfPath [[1, 2, 3], [6, 5, 4], [7, 3, 9]] 3 == (5.2 : Float)\n#guard maxAverageOfPath [[2, 3, 4], [7, 6, 5], [8, 4, 10]] 3 == (6.2 : Float)\n#guard maxAverageOfPath [[3, 4, 5], [8, 7, 6], [9, 5, 11]] 3 == (7.2 : Float)\n", "test_list": ["#guard maxAverageOfPath [[1, 2, 3], [6, 5, 4], [7, 3, 9]] 3 == (5.2 : Float)", "#guard maxAverageOfPath [[2, 3, 4], [7, 6, 5], [8, 4, 10]] 3 == (6.2 : Float)", "#guard maxAverageOfPath [[3, 4, 5], [8, 7, 6], [9, 5, 11]] 3 == (7.2 : Float)"]}
{"text": "Write a function to count the same pair in two given lists using map function.", "task_id": 723, "code": "import Batteries\n\nopen Std\n\ndef countSamePair (nums1 nums2 : List Int) : Nat :=\n  let eqs : List Bool := (List.zip nums1 nums2).map (fun (a, b) => a == b)\n  eqs.foldl (fun acc b => acc + (if b then 1 else 0)) 0\n\n#guard countSamePair [1, 2, 3, 4, 5, 6, 7, 8] [2, 2, 3, 1, 2, 6, 7, 9] = 4\n#guard countSamePair [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8] [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] = 11\n#guard countSamePair [2, 4, -6, -9, 11, -12, 14, -5, 17] [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] = 1\n", "test_list": ["#guard countSamePair [1, 2, 3, 4, 5, 6, 7, 8] [2, 2, 3, 1, 2, 6, 7, 9] = 4", "#guard countSamePair [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8] [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] = 11", "#guard countSamePair [2, 4, -6, -9, 11, -12, 14, -5, 17] [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8] = 1"]}
{"text": "Write a function to calculate the sum of all digits of the base to the specified power.", "task_id": 724, "code": "import Batteries\n\nopen Std\n\ndef power_base_sum (base power : Nat) : Nat :=\n  let s := toString (Nat.pow base power)\n  s.data.foldl (fun acc c => acc + (c.toNat - '0'.toNat)) 0\n\n#guard power_base_sum 2 100 = 115\n#guard power_base_sum 8 10 = 37\n#guard power_base_sum 8 15 = 62\n", "test_list": ["#guard power_base_sum 2 100 = 115", "#guard power_base_sum 8 10 = 37", "#guard power_base_sum 8 15 = 62"]}
{"text": "Write a function to extract values between quotation marks of the given string by using regex.", "task_id": 725, "code": "import Batteries\n\nopen Std\n\nstructure QuotState where\n  inQuote : Bool\n  buf : List Char\n  resRev : List String\n  deriving Inhabited\n\ndef extract_quotation (text1 : String) : List String :=\n  let step (st : QuotState) (c : Char) : QuotState :=\n    if st.inQuote then\n      if c = '\"' then\n        { inQuote := false\n        , buf := []\n        , resRev := (String.mk st.buf.reverse) :: st.resRev }\n      else\n        { st with buf := c :: st.buf }\n    else\n      if c = '\"' then\n        { inQuote := true, buf := [], resRev := st.resRev }\n      else\n        st\n  let s := text1.data.foldl step {inQuote := false, buf := [], resRev := []}\n  s.resRev.reverse\n\n#guard extract_quotation \"Cortex \\\"A53\\\" Based \\\"multi\\\" tasking \\\"Processor\\\"\" == [\"A53\", \"multi\", \"Processor\"]\n#guard extract_quotation \"Cast your \\\"favorite\\\" entertainment \\\"apps\\\"\" == [\"favorite\", \"apps\"]\n#guard extract_quotation \"Watch content \\\"4k Ultra HD\\\" resolution with \\\"HDR 10\\\" Support\" == [\"4k Ultra HD\", \"HDR 10\"]\n", "test_list": ["#guard extract_quotation \"Cortex \\\"A53\\\" Based \\\"multi\\\" tasking \\\"Processor\\\"\" == [\"A53\", \"multi\", \"Processor\"]", "#guard extract_quotation \"Cast your \\\"favorite\\\" entertainment \\\"apps\\\"\" == [\"favorite\", \"apps\"]", "#guard extract_quotation \"Watch content \\\"4k Ultra HD\\\" resolution with \\\"HDR 10\\\" Support\" == [\"4k Ultra HD\", \"HDR 10\"]"]}
{"text": "Write a function to multiply the adjacent elements of the given tuple.", "task_id": 726, "code": "import Batteries\n\nopen Std\n\ndef multiplyElements (test_tup : List Nat) : List Nat :=\n  (List.zip test_tup (test_tup.drop 1)).map (fun (p : Nat × Nat) => p.fst * p.snd)\n\n#guard multiplyElements [1, 5, 7, 8, 10] = [5, 35, 56, 80]\n#guard multiplyElements [2, 4, 5, 6, 7] = [8, 20, 30, 42]\n#guard multiplyElements [12, 13, 14, 9, 15] = [156, 182, 126, 135]\n", "test_list": ["#guard multiplyElements [1, 5, 7, 8, 10] = [5, 35, 56, 80]", "#guard multiplyElements [2, 4, 5, 6, 7] = [8, 20, 30, 42]", "#guard multiplyElements [12, 13, 14, 9, 15] = [156, 182, 126, 135]"]}
{"text": "Write a function to remove all characters except letters and numbers using regex", "task_id": 727, "code": "import Batteries\n\nopen Std\n\ndef isAsciiAlnum (c : Char) : Bool :=\n  let n := c.toNat\n  (n >= '0'.toNat && n <= '9'.toNat) ||\n  (n >= 'A'.toNat && n <= 'Z'.toNat) ||\n  (n >= 'a'.toNat && n <= 'z'.toNat)\n\ndef removeChar (S : String) : String :=\n  String.mk (S.data.filter isAsciiAlnum)\n\n#guard removeChar \"123abcjw:, .@! eiw\" == \"123abcjweiw\"\n#guard removeChar \"Hello1234:, ! Howare33u\" == \"Hello1234Howare33u\"\n#guard removeChar \"Cool543Triks@:, Make@987Trips\" == \"Cool543TriksMake987Trips\"\n", "test_list": ["#guard removeChar \"123abcjw:, .@! eiw\" == \"123abcjweiw\"", "#guard removeChar \"Hello1234:, ! Howare33u\" == \"Hello1234Howare33u\"", "#guard removeChar \"Cool543Triks@:, Make@987Trips\" == \"Cool543TriksMake987Trips\""]}
{"text": "Write a function to sum elements in two lists.", "task_id": 728, "code": "import Batteries\n\nopen Std\n\ndef sumList (lst1 lst2 : List Nat) : List Nat :=\n  List.zipWith (· + ·) lst1 lst2\n\n#guard sumList [10,20,30] [15,25,35] = [25,45,65]\n#guard sumList [1,2,3] [5,6,7] = [6,8,10]\n#guard sumList [15,20,30] [15,45,75] = [30,65,105]\n", "test_list": ["#guard sumList [10,20,30] [15,25,35] = [25,45,65]", "#guard sumList [1,2,3] [5,6,7] = [6,8,10]", "#guard sumList [15,20,30] [15,45,75] = [30,65,105]"]}
{"text": "Write a function to add two lists using map and lambda function.", "task_id": 729, "code": "import Batteries\n\nopen Std\n\ndef addList (nums1 nums2 : List Nat) : List Nat :=\n  (List.zip nums1 nums2).map (fun (p : Nat × Nat) => p.fst + p.snd)\n\n#guard addList [1, 2, 3] [4, 5, 6] = [5, 7, 9]\n#guard addList [1, 2] [3, 4] = [4, 6]\n#guard addList [10, 20] [50, 70] = [60, 90]\n", "test_list": ["#guard addList [1, 2, 3] [4, 5, 6] = [5, 7, 9]", "#guard addList [1, 2] [3, 4] = [4, 6]", "#guard addList [10, 20] [50, 70] = [60, 90]"]}
{"text": "Write a function to remove consecutive duplicates of a given list.", "task_id": 730, "code": "import Batteries\n\nopen Std\n\ndef consecutiveDuplicates [BEq α] (nums : List α) : List α :=\n  let rec go (prev? : Option α) (xs : List α) (acc : List α) :=\n    match xs with\n    | [] => acc.reverse\n    | x :: xs' =>\n      match prev? with\n      | some y =>\n        if x == y then\n          go prev? xs' acc\n        else\n          go (some x) xs' (x :: acc)\n      | none =>\n        go (some x) xs' (x :: acc)\n  go none nums []\n\n#guard consecutiveDuplicates [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n#guard consecutiveDuplicates [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10] = [10, 15, 19, 18, 17, 26, 17, 18, 10]\n#guard consecutiveDuplicates [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"] = [\"a\", \"b\", \"c\", \"d\"]\n", "test_list": ["#guard consecutiveDuplicates [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]", "#guard consecutiveDuplicates [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10] = [10, 15, 19, 18, 17, 26, 17, 18, 10]", "#guard consecutiveDuplicates [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"] = [\"a\", \"b\", \"c\", \"d\"]"]}
{"text": "Write a function to find the lateral surface area of a cone.", "task_id": 731, "code": "import Batteries\n\nopen Std\n\ndef lateralsurface_cone (r h : Nat) : Float :=\n  let rf := Float.ofNat r\n  let hf := Float.ofNat h\n  let l := Float.sqrt (rf * rf + hf * hf)\n  ((3.141592653589793 : Float) * rf * l)\n\n#guard lateralsurface_cone 5 12 == (204.20352248333654 : Float)\n#guard lateralsurface_cone 10 15 == (566.3586699569488 : Float)\n#guard lateralsurface_cone 19 17 == (1521.8090132193388 : Float)\n", "test_list": ["#guard lateralsurface_cone 5 12 == (204.20352248333654 : Float)", "#guard lateralsurface_cone 10 15 == (566.3586699569488 : Float)", "#guard lateralsurface_cone 19 17 == (1521.8090132193388 : Float)"]}
{"text": "Write a function to replace all occurrences of spaces, commas, or dots with a colon.", "task_id": 732, "code": "import Batteries\n\nopen Std\n\ndef replace_specialchar (text : String) : String :=\n  text.map (fun c => if c == ' ' || c == ',' || c == '.' then ':' else c)\n\n#guard replace_specialchar \"Python language, Programming language.\" == \"Python:language::Programming:language:\"\n#guard replace_specialchar \"a b c,d e f\" == \"a:b:c:d:e:f\"\n#guard replace_specialchar \"ram reshma,ram rahim\" == \"ram:reshma:ram:rahim\"\n", "test_list": ["#guard replace_specialchar \"Python language, Programming language.\" == \"Python:language::Programming:language:\"", "#guard replace_specialchar \"a b c,d e f\" == \"a:b:c:d:e:f\"", "#guard replace_specialchar \"ram reshma,ram rahim\" == \"ram:reshma:ram:rahim\""]}
{"text": "Write a function to find the index of the first occurrence of a given number in a sorted array.", "task_id": 733, "code": "import Batteries\nopen Std\n\ndef findFirstOccurrence (A : List Nat) (x : Nat) : Int := Id.run do\n  let mut left : Int := 0\n  let mut right : Int := (Int.ofNat A.length) - 1\n  let mut result : Int := -1\n  while left <= right do\n    let mid : Int := (left + right) / 2\n    let midNat : Nat := Int.toNat mid\n    if h : midNat < A.length then\n      let midFin : Fin A.length := ⟨midNat, h⟩\n      let midVal : Nat := A.get midFin\n      if x == midVal then\n        result := mid\n        right := mid - 1\n      else if x < midVal then\n        right := mid - 1\n      else\n        left := mid + 1\n    else\n      \n      left := right + 1\n  return result\n\n#guard findFirstOccurrence [2, 5, 5, 5, 6, 6, 8, 9, 9, 9] 5 = 1\n#guard findFirstOccurrence [2, 3, 5, 5, 6, 6, 8, 9, 9, 9] 5 = 2\n#guard findFirstOccurrence [2, 4, 1, 5, 6, 6, 8, 9, 9, 9] 6 = 4\n", "test_list": ["#guard findFirstOccurrence [2, 5, 5, 5, 6, 6, 8, 9, 9, 9] 5 = 1", "#guard findFirstOccurrence [2, 3, 5, 5, 6, 6, 8, 9, 9, 9] 5 = 2", "#guard findFirstOccurrence [2, 4, 1, 5, 6, 6, 8, 9, 9, 9] 6 = 4"]}
{"text": "Write a python function to find sum of products of all possible subarrays.", "task_id": 734, "code": "import Batteries\n\nopen Std\n\ndef sum_Of_Subarray_Prod (arr : List Nat) (n : Nat) : Nat := Id.run do\n  \n  let mut ans := 0\n  let mut res := 0\n  let mut i := n\n  while i > 0 do\n    let j := i - 1\n    let incr := arr.getD j 0 * (1 + res)\n    ans := ans + incr\n    res := incr\n    i := j\n  return ans\n\n#guard sum_Of_Subarray_Prod [1,2,3] 3 = 20\n#guard sum_Of_Subarray_Prod [1,2] 2 = 5\n#guard sum_Of_Subarray_Prod [1,2,3,4] 4 = 84\n", "test_list": ["#guard sum_Of_Subarray_Prod [1,2,3] 3 = 20", "#guard sum_Of_Subarray_Prod [1,2] 2 = 5", "#guard sum_Of_Subarray_Prod [1,2,3,4] 4 = 84"]}
{"text": "Write a python function to toggle bits of the number except the first and the last bit.", "task_id": 735, "code": "import Batteries\n\nopen Std\n\ndef setMiddleBits (n : Nat) : Nat := Id.run do\n  let mut m := n\n  m := m ||| (m >>> 1)\n  m := m ||| (m >>> 2)\n  m := m ||| (m >>> 4)\n  m := m ||| (m >>> 8)\n  m := m ||| (m >>> 16)\n  return (m >>> 1) ^^^ 1\n\ndef toggleMiddleBits (n : Nat) : Nat :=\n  if n == 1 then 1 else n ^^^ setMiddleBits n\n\n#guard toggleMiddleBits 9 = 15\n#guard toggleMiddleBits 10 = 12\n#guard toggleMiddleBits 11 = 13\n", "test_list": ["#guard toggleMiddleBits 9 = 15", "#guard toggleMiddleBits 10 = 12", "#guard toggleMiddleBits 11 = 13"]}
{"text": "Write a function to locate the left insertion point for a specified value in sorted order.", "task_id": 736, "code": "import Batteries\n\nopen Std\n\ndef left_insertion (a : List Nat) (x : Nat) : Nat :=\n  let rec aux (l : List Nat) (i : Nat) : Nat :=\n    match l with\n    | [] => i\n    | y :: ys => if x ≤ y then i else aux ys (i + 1)\n  aux a 0\n\n#guard left_insertion [1, 2, 4, 5] 6 = 4\n#guard left_insertion [1, 2, 4, 5] 3 = 2\n#guard left_insertion [1, 2, 4, 5] 7 = 4\n", "test_list": ["#guard left_insertion [1, 2, 4, 5] 6 = 4", "#guard left_insertion [1, 2, 4, 5] 3 = 2", "#guard left_insertion [1, 2, 4, 5] 7 = 4"]}
{"text": "Write a function to check whether the given string is starting with a vowel or not using regex.", "task_id": 737, "code": "import Batteries\n\nopen Std\n\ndef regex : String := \"^[aeiouAEIOU][A-Za-z0-9_]*\"\n\ndef checkStr (string : String) : String :=\n  match string.data with\n  | [] => \"Invalid\"\n  | c :: _ =>\n    let isVowel :=\n      c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n      c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\n    if isVowel then \"Valid\" else \"Invalid\"\n\n#guard checkStr \"annie\" = \"Valid\"\n#guard checkStr \"dawood\" = \"Invalid\"\n#guard checkStr \"Else\" = \"Valid\"\n", "test_list": ["#guard checkStr \"annie\" = \"Valid\"", "#guard checkStr \"dawood\" = \"Invalid\"", "#guard checkStr \"Else\" = \"Valid\""]}
{"text": "Write a function to calculate the geometric sum of n-1.", "task_id": 738, "code": "import Batteries\nopen Std\n\ndef pow2Float (k : Nat) : Float :=\n  Float.ofNat (Nat.pow 2 k)\n\nprivate def geometricSumNat : Nat -> Float\n| 0 => 1.0 / pow2Float 0\n| Nat.succ k => (1.0 / pow2Float (Nat.succ k)) + geometricSumNat k\n\ndef geometricSum (n : Int) : Float :=\n  if n < 0 then\n    0.0\n  else\n    geometricSumNat (Int.toNat n)\n\n#guard geometricSum 7 == 1.9921875\n#guard geometricSum 4 == 1.9375\n#guard geometricSum 8 == 1.99609375\n", "test_list": ["#guard geometricSum 7 == 1.9921875", "#guard geometricSum 4 == 1.9375", "#guard geometricSum 8 == 1.99609375"]}
{"text": "Write a python function to find the index of smallest triangular number with n digits.", "task_id": 739, "code": "import Batteries\nopen Std\n\ndef findIndex (n : Nat) : Nat :=\n  let t := 2 * Nat.pow 10 (n - 1)\n  let s := Nat.sqrt t\n  let s2 := s * s\n  let next2 := (s + 1) * (s + 1)\n  let d1 := t - s2\n  let d2 := next2 - t\n  if d1 < d2 then s else s + 1\n\n#guard findIndex 2 = 4\n#guard findIndex 3 = 14\n#guard findIndex 4 = 45\n", "test_list": ["#guard findIndex 2 = 4", "#guard findIndex 3 = 14", "#guard findIndex 4 = 45"]}
{"text": "Write a function to convert the given tuple to a key-value dictionary using adjacent elements.", "task_id": 740, "code": "import Batteries\nopen Std\n\ndef tupleToDict (testTup : List Nat) : HashMap Nat Nat :=\n  let rec loop (l : List Nat) (m : HashMap Nat Nat) : HashMap Nat Nat :=\n    match l with\n    | k :: v :: rest => loop rest (m.insert k v)\n    | _ => m\n  loop testTup ({} : HashMap Nat Nat)\n\ndef lookupNat (m : HashMap Nat Nat) (k : Nat) : Option Nat :=\n  let rec go (l : List (Nat × Nat)) : Option Nat :=\n    match l with\n    | [] => none\n    | (k', v) :: t => if k' == k then some v else go t\n  go m.toList\n\ndef mapEqNat (m1 m2 : HashMap Nat Nat) : Bool :=\n  if m1.size != m2.size then false\n  else\n    let b1 := m1.toList.all (fun (kv : Nat × Nat) =>\n      match lookupNat m2 kv.fst with\n      | some v2 => v2 == kv.snd\n      | none => false)\n    let b2 := m2.toList.all (fun (kv : Nat × Nat) =>\n      match lookupNat m1 kv.fst with\n      | some v1 => v1 == kv.snd\n      | none => false)\n    b1 && b2\n\n#guard mapEqNat (tupleToDict [1, 5, 7, 10, 13, 5]) (HashMap.ofList [(1, 5), (7, 10), (13, 5)]) == true\n#guard mapEqNat (tupleToDict [1, 2, 3, 4, 5, 6]) (HashMap.ofList [(1, 2), (3, 4), (5, 6)]) == true\n#guard mapEqNat (tupleToDict [7, 8, 9, 10, 11, 12]) (HashMap.ofList [(7, 8), (9, 10), (11, 12)]) == true\n", "test_list": ["#guard mapEqNat (tupleToDict [1, 5, 7, 10, 13, 5]) (HashMap.ofList [(1, 5), (7, 10), (13, 5)]) == true", "#guard mapEqNat (tupleToDict [1, 2, 3, 4, 5, 6]) (HashMap.ofList [(1, 2), (3, 4), (5, 6)]) == true", "#guard mapEqNat (tupleToDict [7, 8, 9, 10, 11, 12]) (HashMap.ofList [(7, 8), (9, 10), (11, 12)]) == true"]}
{"text": "Write a python function to check whether all the characters are same or not.", "task_id": 741, "code": "import Batteries\nopen Std\n\ndef all_Characters_Same (s : String) : Bool :=\n  let cs := s.data\n  match cs with\n  | [] => true\n  | c :: rest =>\n    let rec go (xs : List Char) : Bool :=\n      match xs with\n      | [] => true\n      | d :: ds => if d == c then go ds else false\n    go rest\n\n#guard all_Characters_Same \"python\" == false\n#guard all_Characters_Same \"aaa\" == true\n#guard all_Characters_Same \"data\" == false\n", "test_list": ["#guard all_Characters_Same \"python\" == false", "#guard all_Characters_Same \"aaa\" == true", "#guard all_Characters_Same \"data\" == false"]}
{"text": "Write a function to caluclate the area of a tetrahedron.", "task_id": 742, "code": "import Batteries\n\nopen Std\n\ndef areaTetrahedron (side : Float) : Float :=\n  Float.sqrt 3.0 * (side * side)\n\n#guard areaTetrahedron 3.0 == 15.588457268119894\n#guard areaTetrahedron 20.0 == 692.8203230275509\n#guard areaTetrahedron 10.0 == 173.20508075688772\n", "test_list": ["#guard areaTetrahedron 3.0 == 15.588457268119894", "#guard areaTetrahedron 20.0 == 692.8203230275509", "#guard areaTetrahedron 10.0 == 173.20508075688772"]}
{"text": "Write a function to rotate a given list by specified number of items to the right direction.", "task_id": 743, "code": "import Batteries\n\nopen Std\n\ndef rotateRight (list1 : List Nat) (m n : Nat) : List Nat :=\n  let len := list1.length\n  let lastM :=\n    if m == 0 then\n      list1\n    else if len ≤ m then\n      list1\n    else\n      list1.drop (len - m)\n  let firstWithoutLastN :=\n    if n == 0 then\n      []\n    else if len ≤ n then\n      []\n    else\n      list1.take (len - n)\n  lastM ++ firstWithoutLastN\n\n#guard rotateRight [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 3 4 == [8, 9, 10, 1, 2, 3, 4, 5, 6]\n#guard rotateRight [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2 2 == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n#guard rotateRight [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5 2 == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8]\n", "test_list": ["#guard rotateRight [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 3 4 == [8, 9, 10, 1, 2, 3, 4, 5, 6]", "#guard rotateRight [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 2 2 == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8]", "#guard rotateRight [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 5 2 == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8]"]}
{"text": "Write a function to check if the given tuple has any none value or not.", "task_id": 744, "code": "import Batteries\n\nopen Std\n\ndef checkNone (testTup : List (Option Nat)) : Bool :=\n  testTup.any (fun ele => match ele with | none => true | some _ => false)\n\n#guard checkNone [some 10, some 4, some 5, some 6, none] == true\n#guard checkNone [some 7, some 8, some 9, some 11, some 14] == false\n#guard checkNone [some 1, some 2, some 3, some 4, none] == true\n", "test_list": ["#guard checkNone [some 10, some 4, some 5, some 6, none] == true", "#guard checkNone [some 7, some 8, some 9, some 11, some 14] == false", "#guard checkNone [some 1, some 2, some 3, some 4, none] == true"]}
{"text": "Write a function to find numbers within a given range where every number is divisible by every digit it contains.", "task_id": 745, "code": "import Batteries\n\nopen Std\n\ndef divisibleByDigits (startnum endnum : Nat) : List Nat := Id.run do\n  let mut res : Array Nat := #[]\n  for n in [startnum : endnum + 1] do\n    let s := toString n\n    let chars := s.data\n    let ok := chars.foldl (init := true) (fun acc c =>\n      if acc then\n        let d := c.toNat - '0'.toNat\n        if d == 0 then false else n % d == 0\n      else\n        false)\n    if ok then\n      res := res.push n\n  return res.toList\n\n#guard divisibleByDigits 1 22 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n#guard divisibleByDigits 1 15 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]\n#guard divisibleByDigits 20 25 == [22, 24]\n", "test_list": ["#guard divisibleByDigits 1 22 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]", "#guard divisibleByDigits 1 15 == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15]", "#guard divisibleByDigits 20 25 == [22, 24]"]}
{"text": "Write a function to find area of a sector.", "task_id": 746, "code": "import Batteries\n\nopen Std\n\ndef sectorArea (r a : Nat) : Option Float :=\n  let pi : Float := 22.0 / 7.0\n  if a >= 360 then\n    none\n  else\n    let sectorarea := (pi * Float.ofNat (r * r)) * (Float.ofNat a / 360.0)\n    some sectorarea\n\n#guard sectorArea 4 45 == some 6.285714285714286\n#guard sectorArea 9 45 == some 31.82142857142857\n#guard sectorArea 9 360 == none\n", "test_list": ["#guard sectorArea 4 45 == some 6.285714285714286", "#guard sectorArea 9 45 == some 31.82142857142857", "#guard sectorArea 9 360 == none"]}
{"text": "Write a function to find the longest common subsequence for the given three string sequence.", "task_id": 747, "code": "import Batteries\n\nopen Std\n\ndef Array.modify3d {α : Type} (a : Array (Array (Array α))) (i j k : Nat) (f : α → α) :=\n  a.modify i (fun row2 => row2.modify j (fun row1 => row1.modify k f))\n\ndef Array.set3d? {α : Type} (a : Array (Array (Array α))) (i j k : Nat) (value : α) :=\n  a.modify3d i j k (fun _ => value)\n\ndef Array.get3d {α : Type} (a : Array (Array (Array α))) (i j k : Nat) (fallback : α) :=\n  ((a.getD i #[]).getD j #[]).getD k fallback\n\ndef lcsOfThree (X Y Z : String) (m n o : Nat) : Nat := Id.run do\n  \n  let Xa := X.data.toArray\n  let Ya := Y.data.toArray\n  let Za := Z.data.toArray\n  let mut L : Array (Array (Array Nat)) :=\n    Array.replicate (m+1) (Array.replicate (n+1) (Array.replicate (o+1) 0))\n  for i in [0 : m+1] do\n    for j in [0 : n+1] do\n      for k in [0 : o+1] do\n        if i == 0 || j == 0 || k == 0 then\n          L := L.set3d? i j k 0\n        else if Xa[i-1]! == Ya[j-1]! && Xa[i-1]! == Za[k-1]! then\n          let v := L.get3d (i-1) (j-1) (k-1) 0 + 1\n          L := L.set3d? i j k v\n        else\n          let a := L.get3d (i-1) j k 0\n          let b := L.get3d i (j-1) k 0\n          let c := L.get3d i j (k-1) 0\n          L := L.set3d? i j k (Nat.max (Nat.max a b) c)\n  return L.get3d m n o 0\n\n#guard lcsOfThree \"AGGT12\" \"12TXAYB\" \"12XBA\" 6 7 5 = 2\n#guard lcsOfThree \"Reels\" \"Reelsfor\" \"ReelsforReels\" 5 8 13 = 5\n#guard lcsOfThree \"abcd1e2\" \"bc12ea\" \"bd1ea\" 7 6 5 = 3\n", "test_list": ["#guard lcsOfThree \"AGGT12\" \"12TXAYB\" \"12XBA\" 6 7 5 = 2", "#guard lcsOfThree \"Reels\" \"Reelsfor\" \"ReelsforReels\" 5 8 13 = 5", "#guard lcsOfThree \"abcd1e2\" \"bc12ea\" \"bd1ea\" 7 6 5 = 3"]}
{"text": "Write a function to put spaces between words starting with capital letters in a given string by using regex.", "task_id": 748, "code": "import Batteries\n\nopen Std\n\ndef isBetween (c lo hi : Char) : Bool := (lo ≤ c) && (c ≤ hi)\n\ndef isWordChar (c : Char) : Bool :=\n  isBetween c 'a' 'z' || isBetween c 'A' 'Z' || isBetween c '0' '9' || (c == '_')\n\ndef isUpperAZ (c : Char) : Bool := isBetween c 'A' 'Z'\n\ndef capitalWordsSpaces (str1 : String) : String :=\n  let chars := str1.data\n  let (_, acc) := chars.foldl (init := (false, ([] : List Char))) (fun (st : Bool × List Char) (c : Char) =>\n    let prevIsWord := st.fst\n    let acc := st.snd\n    let acc' := if prevIsWord && isUpperAZ c then c :: ' ' :: acc else c :: acc\n    (isWordChar c, acc')\n  )\n  String.mk acc.reverse\n\n#guard capitalWordsSpaces \"Python\" = \"Python\"\n#guard capitalWordsSpaces \"PythonProgrammingExamples\" = \"Python Programming Examples\"\n#guard capitalWordsSpaces \"GetReadyToBeCodingFreak\" = \"Get Ready To Be Coding Freak\"\n", "test_list": ["#guard capitalWordsSpaces \"Python\" = \"Python\"", "#guard capitalWordsSpaces \"PythonProgrammingExamples\" = \"Python Programming Examples\"", "#guard capitalWordsSpaces \"GetReadyToBeCodingFreak\" = \"Get Ready To Be Coding Freak\""]}
{"text": "Write a function to sort a given list of strings of numbers numerically.", "task_id": 749, "code": "import Batteries\n\nopen Std\n\ndef insertInt (x : Int) : List Int → List Int\n| [] => [x]\n| y :: ys =>\n  match compare x y with\n  | Ordering.lt => x :: y :: ys\n  | Ordering.eq => x :: y :: ys\n  | Ordering.gt => y :: insertInt x ys\n\ndef isortInt : List Int → List Int\n| [] => []\n| x :: xs => insertInt x (isortInt xs)\n\ndef sortNumericStrings (nums_str : List String) : List Int :=\n  let result := nums_str.map (fun s => (s.trim.toInt?).getD 0)\n  isortInt result\n\n#guard sortNumericStrings [\"4\",\"12\",\"45\",\"7\",\"0\",\"100\",\"200\",\"-12\",\"-500\"] = [-500, -12, 0, 4, 7, 12, 45, 100, 200]\n#guard sortNumericStrings [\"2\",\"3\",\"8\",\"4\",\"7\",\"9\",\"8\",\"2\",\"6\",\"5\",\"1\",\"6\",\"1\",\"2\",\"3\",\"4\",\"6\",\"9\",\"1\",\"2\"] = [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]\n#guard sortNumericStrings [\"1\",\"3\",\"5\",\"7\",\"1\", \"3\",\"13\", \"15\", \"17\",\"5\", \"7 \",\"9\",\"1\", \"11\"] = [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]\n", "test_list": ["#guard sortNumericStrings [\"4\",\"12\",\"45\",\"7\",\"0\",\"100\",\"200\",\"-12\",\"-500\"] = [-500, -12, 0, 4, 7, 12, 45, 100, 200]", "#guard sortNumericStrings [\"2\",\"3\",\"8\",\"4\",\"7\",\"9\",\"8\",\"2\",\"6\",\"5\",\"1\",\"6\",\"1\",\"2\",\"3\",\"4\",\"6\",\"9\",\"1\",\"2\"] = [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9]", "#guard sortNumericStrings [\"1\",\"3\",\"5\",\"7\",\"1\", \"3\",\"13\", \"15\", \"17\",\"5\", \"7 \",\"9\",\"1\", \"11\"] = [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17]"]}
{"text": "Write a function to add the given tuple to the given list.", "task_id": 750, "code": "import Batteries\n\nopen Std\n\ndef addTuple (test_list : List Nat) (test_tup : List Nat) : List Nat :=\n  test_list ++ test_tup\n\n#guard addTuple [5, 6, 7] [9, 10] == [5, 6, 7, 9, 10]\n#guard addTuple [6, 7, 8] [10, 11] == [6, 7, 8, 10, 11]\n#guard addTuple [7, 8, 9] [11, 12] == [7, 8, 9, 11, 12]\n", "test_list": ["#guard addTuple [5, 6, 7] [9, 10] == [5, 6, 7, 9, 10]", "#guard addTuple [6, 7, 8] [10, 11] == [6, 7, 8, 10, 11]", "#guard addTuple [7, 8, 9] [11, 12] == [7, 8, 9, 11, 12]"]}
{"text": "Write a function to check if the given array represents min heap or not.", "task_id": 751, "code": "import Batteries\nopen Std\n\nprivate def checkMinHeapAux (arr : List Nat) (i fuel : Nat) : Bool :=\n  match fuel with\n  | 0 => true\n  | fuel' + 1 =>\n    let n := arr.length\n    if 2 * i + 2 > n then\n      true\n    else\n      let ai := arr.getD i 0\n      let leftIdx := 2 * i + 1\n      let rightIdx := 2 * i + 2\n      let leftChild := (Nat.ble ai (arr.getD leftIdx 0)) && checkMinHeapAux arr leftIdx fuel'\n      let rightChild := (rightIdx == n) || ((Nat.ble ai (arr.getD rightIdx 0)) && checkMinHeapAux arr rightIdx fuel')\n      leftChild && rightChild\n\ndef checkMinHeap (arr : List Nat) (i : Nat) : Bool :=\n  checkMinHeapAux arr i (arr.length - i)\n\n#guard checkMinHeap [1, 2, 3, 4, 5, 6] 0 = true\n#guard checkMinHeap [2, 3, 4, 5, 10, 15] 0 = true\n#guard checkMinHeap [2, 10, 4, 5, 3, 15] 0 = false\n", "test_list": ["#guard checkMinHeap [1, 2, 3, 4, 5, 6] 0 = true", "#guard checkMinHeap [2, 3, 4, 5, 10, 15] 0 = true", "#guard checkMinHeap [2, 10, 4, 5, 3, 15] 0 = false"]}
{"text": "Write a function to find the nth jacobsthal number.", "task_id": 752, "code": "import Batteries\n\nopen Std\n\ndef jacobsthalNum (n : Nat) : Nat := Id.run do\n  let mut dp := Array.replicate (n+1) 0\n  dp := dp.modify 0 (fun _ => 0)\n  dp := dp.modify 1 (fun _ => 1)\n  for i in [2 : n+1] do\n    dp := dp.set! i <| dp[i-1]! + 2 * dp[i-2]!\n  return dp[n]!\n\n#guard jacobsthalNum 5 = 11\n#guard jacobsthalNum 2 = 1\n#guard jacobsthalNum 4 = 5\n", "test_list": ["#guard jacobsthalNum 5 = 11", "#guard jacobsthalNum 2 = 1", "#guard jacobsthalNum 4 = 5"]}
{"text": "Write a function to find minimum k records from tuple list.", "task_id": 753, "code": "import Batteries\n\nopen Std\n\ndef findMinBySnd? (xs : List (String × Nat)) : Option (String × Nat) :=\n  match xs with\n  | [] => none\n  | h :: t =>\n    some <| t.foldl (fun acc x => if x.snd < acc.snd then x else acc) h\n\ndef selectKBySnd (xs : List (String × Nat)) (k : Nat) : List (String × Nat) :=\n  match k with\n  | 0 => []\n  | k+1 =>\n    match findMinBySnd? xs with\n    | none => []\n    | some m => m :: selectKBySnd (xs.erase m) k\n\ndef min_k (test_list : List (String × Nat)) (K : Nat) : List (String × Nat) :=\n  selectKBySnd test_list K\n\n#guard min_k [(\"Manjeet\", 10), (\"Akshat\", 4), (\"Akash\", 2), (\"Nikhil\", 8)] 2 == [(\"Akash\", 2), (\"Akshat\", 4)]\n#guard min_k [(\"Sanjeev\", 11), (\"Angat\", 5), (\"Akash\", 3), (\"Nepin\", 9)] 3 == [(\"Akash\", 3), (\"Angat\", 5), (\"Nepin\", 9)]\n#guard min_k [(\"tanmay\", 14), (\"Amer\", 11), (\"Ayesha\", 9), (\"SKD\", 16)] 1 == [(\"Ayesha\", 9)]\n", "test_list": ["#guard min_k [(\"Manjeet\", 10), (\"Akshat\", 4), (\"Akash\", 2), (\"Nikhil\", 8)] 2 == [(\"Akash\", 2), (\"Akshat\", 4)]", "#guard min_k [(\"Sanjeev\", 11), (\"Angat\", 5), (\"Akash\", 3), (\"Nepin\", 9)] 3 == [(\"Akash\", 3), (\"Angat\", 5), (\"Nepin\", 9)]", "#guard min_k [(\"tanmay\", 14), (\"Amer\", 11), (\"Ayesha\", 9), (\"SKD\", 16)] 1 == [(\"Ayesha\", 9)]"]}
{"text": "Write a function to find common index elements from three lists.", "task_id": 754, "code": "import Batteries\n\nopen Std\n\ndef extractIndexList (l1 l2 l3 : List Nat) : List Nat :=\n  let rec loop (a b c : List Nat) (acc : List Nat) :=\n    match a, b, c with\n    | m::ma, n::nb, o::oc =>\n      let acc := if m == n && n == o then acc ++ [m] else acc\n      loop ma nb oc acc\n    | _, _, _ => acc\n  loop l1 l2 l3 []\n\n#guard extractIndexList [1, 1, 3, 4, 5, 6, 7] [0, 1, 2, 3, 4, 5, 7] [0, 1, 2, 3, 4, 5, 7] == [1, 7]\n#guard extractIndexList [1, 1, 3, 4, 5, 6, 7] [0, 1, 2, 3, 4, 6, 5] [0, 1, 2, 3, 4, 6, 7] == [1, 6]\n#guard extractIndexList [1, 1, 3, 4, 6, 5, 6] [0, 1, 2, 3, 4, 5, 7] [0, 1, 2, 3, 4, 5, 7] == [1, 5]\n", "test_list": ["#guard extractIndexList [1, 1, 3, 4, 5, 6, 7] [0, 1, 2, 3, 4, 5, 7] [0, 1, 2, 3, 4, 5, 7] == [1, 7]", "#guard extractIndexList [1, 1, 3, 4, 5, 6, 7] [0, 1, 2, 3, 4, 6, 5] [0, 1, 2, 3, 4, 6, 7] == [1, 6]", "#guard extractIndexList [1, 1, 3, 4, 6, 5, 6] [0, 1, 2, 3, 4, 5, 7] [0, 1, 2, 3, 4, 5, 7] == [1, 5]"]}
{"text": "Write a function to find the second smallest number in a list.", "task_id": 755, "code": "import Batteries\n\nopen Std\n\ndef findMinFloat (l : List Float) : Option Float :=\n  match l with\n  | [] => none\n  | x::xs => some (xs.foldl (fun acc y => if y < acc then y else acc) x)\n\ndef removeOneFloat (l : List Float) (x : Float) : List Float :=\n  match l with\n  | [] => []\n  | y::ys => if y == x then ys else y :: removeOneFloat ys x\n\ndef secondSmallest (numbers : List Float) : Option Float :=\n  if numbers.length < 2 then\n    none\n  else if numbers.length == 2 && numbers.getD 0 0.0 == numbers.getD 1 0.0 then\n    none\n  else\n    let uniqRev := numbers.foldl (fun acc x => if acc.contains x then acc else x :: acc) []\n    let uniq := uniqRev.reverse\n    match findMinFloat uniq with\n    | none => none\n    | some m1 =>\n      match findMinFloat (removeOneFloat uniq m1) with\n      | none => none\n      | some m2 => some m2\n\n#guard secondSmallest [1.0, 2.0, -8.0, -2.0, 0.0, -2.0] == some (-2.0)\n#guard secondSmallest [1.0, 1.0, -0.5, 0.0, 2.0, -2.0, -2.0] == some (-0.5)\n#guard secondSmallest [2.0, 2.0] == none\n", "test_list": ["#guard secondSmallest [1.0, 2.0, -8.0, -2.0, 0.0, -2.0] == some (-2.0)", "#guard secondSmallest [1.0, 1.0, -0.5, 0.0, 2.0, -2.0, -2.0] == some (-0.5)", "#guard secondSmallest [2.0, 2.0] == none"]}
{"text": "Write a function that matches a string that has an a followed by zero or one 'b'.", "task_id": 756, "code": "import Batteries\n\nopen Std\n\ndef textMatchZeroOne (text : String) : String :=\n  let patterns := \"ab?\"\n  if text.data.any (fun c => c == 'a') then\n    \"Found a match!\"\n  else\n    \"Not matched!\"\n\n#guard textMatchZeroOne \"ac\" == \"Found a match!\"\n#guard textMatchZeroOne \"dc\" == \"Not matched!\"\n#guard textMatchZeroOne \"abbbba\" == \"Found a match!\"\n", "test_list": ["#guard textMatchZeroOne \"ac\" == \"Found a match!\"", "#guard textMatchZeroOne \"dc\" == \"Not matched!\"", "#guard textMatchZeroOne \"abbbba\" == \"Found a match!\""]}
{"text": "Write a function to count the pairs of reverse strings in the given string list.", "task_id": 757, "code": "import Batteries\nopen Std\n\ndef reverseString (s : String) : String :=\n  String.mk (s.data.reverse)\n\ndef listGetD {α} (xs : List α) (i : Nat) (d : α) : α :=\n  match xs.drop i with\n  | [] => d\n  | x :: _ => x\n\ndef countReversePairs (testList : List String) : String := Id.run do\n  let n := testList.length\n  let mut res := 0\n  for i in [0 : n] do\n    let ri := reverseString (listGetD testList i \"\")\n    for j in [i : n] do\n      if listGetD testList j \"\" == ri then\n        res := res + 1\n  return toString res\n\n#guard countReversePairs [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"] == \"2\"\n#guard countReversePairs [\"geeks\", \"best\", \"for\", \"skeeg\"] == \"1\"\n#guard countReversePairs [\"makes\", \"best\", \"sekam\", \"for\", \"rof\"] == \"2\"\n", "test_list": ["#guard countReversePairs [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"] == \"2\"", "#guard countReversePairs [\"geeks\", \"best\", \"for\", \"skeeg\"] == \"1\"", "#guard countReversePairs [\"makes\", \"best\", \"sekam\", \"for\", \"rof\"] == \"2\""]}
{"text": "Write a function to count number of unique lists within a list.", "task_id": 758, "code": "import Batteries\nopen Std\n\ndef uniqueSublists {α} [BEq α] [Hashable α] (list1 : List (List α)) : Std.HashMap (List α) Nat := Id.run do\n  \n  let mut result : Std.HashMap (List α) (List Nat) := {}\n  for l in list1 do\n    let key := l\n    let existing :=\n      let rec loop (xs : List ((List α) × (List Nat))) : List Nat :=\n        match xs with\n        | [] => []\n        | (k', v) :: t =>\n          if k' == key then v else loop t\n      loop result.toList\n    result := result.insert key (existing ++ [1])\n  \n  let mut result2 : Std.HashMap (List α) Nat := {}\n  for (k, v) in result.toList do\n    let s := v.foldl (fun acc x => acc + x) 0\n    result2 := result2.insert k s\n  return result2\n\ndef getOrDefault {κ υ} [BEq κ] [Hashable κ] (m : Std.HashMap κ υ) (k : κ) (d : υ) : υ :=\n  let rec loop (xs : List (κ × υ)) : υ :=\n    match xs with\n    | [] => d\n    | (k', v) :: t => if k == k' then v else loop t\n  loop m.toList\n\n#guard (let r := uniqueSublists [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]];\n  getOrDefault r [1, 3] 0 = 2 ∧\n  getOrDefault r [5, 7] 0 = 2 ∧\n  getOrDefault r [13, 15, 17] 0 = 1 ∧\n  getOrDefault r [9, 11] 0 = 1 ∧\n  r.size = 4)\n\n#guard (let r := uniqueSublists [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]];\n  getOrDefault r [\"green\", \"orange\"] 0 = 2 ∧\n  getOrDefault r [\"black\"] 0 = 1 ∧\n  getOrDefault r [\"white\"] 0 = 1 ∧\n  r.size = 3)\n\n#guard (let r := uniqueSublists [[10, 20, 30, 40], [60, 70, 50, 50], [90, 100, 200]];\n  getOrDefault r [10, 20, 30, 40] 0 = 1 ∧\n  getOrDefault r [60, 70, 50, 50] 0 = 1 ∧\n  getOrDefault r [90, 100, 200] 0 = 1 ∧\n  r.size = 3)\n", "test_list": ["#guard (let r := uniqueSublists [[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]];", "#guard (let r := uniqueSublists [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]];", "#guard (let r := uniqueSublists [[10, 20, 30, 40], [60, 70, 50, 50], [90, 100, 200]];"]}
{"text": "Write a function to check a decimal with a precision of 2.", "task_id": 759, "code": "import Batteries\n\nopen Std\n\ndef isAsciiDigit (c : Char) : Bool :=\n  let n := c.toNat\n  let n0 := ('0' : Char).toNat\n  let n9 := ('9' : Char).toNat\n  n0 ≤ n && n ≤ n9\n\npartial def takeDigits (xs : List Char) : Nat × List Char :=\n  match xs with\n  | [] => (0, [])\n  | c :: cs =>\n    if isAsciiDigit c then\n      let (k, rest) := takeDigits cs\n      (k + 1, rest)\n    else\n      (0, xs)\n\ndef isDecimal (num : String) : Bool :=\n  let chars := num.data\n  let (k, rest) := takeDigits chars\n  if k == 0 then false else\n    match rest with\n    | [] => true\n    | c :: rem =>\n      if c == '.' then\n        let (k2, rem2) := takeDigits rem\n        ((k2 == 1) || (k2 == 2)) && rem2.isEmpty\n      else\n        false\n\n#guard isDecimal \"123.11\" == true\n#guard isDecimal \"e666.86\" == false\n#guard isDecimal \"3.124587\" == false\n", "test_list": ["#guard isDecimal \"123.11\" == true", "#guard isDecimal \"e666.86\" == false", "#guard isDecimal \"3.124587\" == false"]}
{"text": "Write a python function to check whether an array contains only one distinct element or not.", "task_id": 760, "code": "import Batteries\n\nopen Std\n\ndef unique_Element (arr : List Nat) (n : Nat) : String :=\n  let s : HashSet Nat := HashSet.ofList arr\n  if s.size == 1 then \"YES\" else \"NO\"\n\n#guard unique_Element [1,1,1] 3 = \"YES\"\n#guard unique_Element [1,2,1,2] 4 = \"NO\"\n#guard unique_Element [1,2,3,4,5] 5 = \"NO\"\n", "test_list": ["#guard unique_Element [1,1,1] 3 = \"YES\"", "#guard unique_Element [1,2,1,2] 4 = \"NO\"", "#guard unique_Element [1,2,3,4,5] 5 = \"NO\""]}
{"text": "Write a function to caluclate arc length of an angle.", "task_id": 761, "code": "import Batteries\n\nopen Std\n\ndef arcLength (d a : Nat) : Option Float :=\n  let pi : Float := 22.0 / 7.0\n  if a >= 360 then\n    none\n  else\n    let arclength := (pi * Float.ofNat d) * (Float.ofNat a / 360.0)\n    some arclength\n\n#guard arcLength 9 45 == some 3.5357142857142856\n#guard arcLength 9 480 == none\n#guard arcLength 5 270 == some 11.785714285714285\n", "test_list": ["#guard arcLength 9 45 == some 3.5357142857142856", "#guard arcLength 9 480 == none", "#guard arcLength 5 270 == some 11.785714285714285"]}
{"text": "Write a function to check whether the given month number contains 30 days or not.", "task_id": 762, "code": "import Batteries\n\nopen Std\n\ndef check_monthnumber_number (monthnum3 : Nat) : Bool :=\n  if monthnum3 == 4 || monthnum3 == 6 || monthnum3 == 9 || monthnum3 == 11 then\n    true\n  else\n    false\n\n#guard check_monthnumber_number 6 == true\n#guard check_monthnumber_number 2 == false\n#guard check_monthnumber_number 12 == false\n", "test_list": ["#guard check_monthnumber_number 6 == true", "#guard check_monthnumber_number 2 == false", "#guard check_monthnumber_number 12 == false"]}
{"text": "Write a python function to find the minimum difference between any two elements in a given array.", "task_id": 763, "code": "import Batteries\nopen Std\n\ndef removeOne (xs : List Nat) (x : Nat) : List Nat :=\n  match xs with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne ys x\n\ndef findListMin (xs : List Nat) : Nat :=\n  match xs with\n  | [] => 0\n  | y :: ys => ys.foldl (fun m z => if z < m then z else m) y\n\ndef selectionSort (xs : List Nat) : List Nat :=\n  let rec aux (k : Nat) (xs : List Nat) (res : List Nat) : List Nat :=\n    match k with\n    | 0 => res\n    | Nat.succ k' =>\n      match xs with\n      | [] => res\n      | _  =>\n        let m := findListMin xs\n        let xs' := removeOne xs m\n        aux k' xs' (res ++ [m])\n  aux xs.length xs []\n\ndef findMinDiff (arr : List Nat) (n : Nat) : Nat :=\n  let sorted := selectionSort arr\n  let sortedN := sorted.take n\n  match sortedN with\n  | [] => 10 ^ 20\n  | [_] => 10 ^ 20\n  | x :: xs =>\n    let (_, res) := xs.foldl\n      (fun (pAcc : Nat × Nat) (y : Nat) =>\n        let p := pAcc.fst\n        let acc := pAcc.snd\n        let d := y - p\n        let acc' := if d < acc then d else acc\n        (y, acc')\n      ) (x, 10 ^ 20)\n    res\n\n#guard findMinDiff [1, 5, 3, 19, 18, 25] 6 = 1\n#guard findMinDiff [4, 3, 2, 6] 4 = 1\n#guard findMinDiff [30, 5, 20, 9] 4 = 4\n", "test_list": ["#guard findMinDiff [1, 5, 3, 19, 18, 25] 6 = 1", "#guard findMinDiff [4, 3, 2, 6] 4 = 1", "#guard findMinDiff [30, 5, 20, 9] 4 = 4"]}
{"text": "Write a python function to count numeric values in a given string.", "task_id": 764, "code": "import Batteries\n\nopen Std\n\ndef number_ctr (str : String) : Nat := Id.run do\n  let mut number_ctr := 0\n  for c in str.data do\n    if c >= '0' && c <= '9' then\n      number_ctr := number_ctr + 1\n  return number_ctr\n\n#guard number_ctr \"program2bedone\" = 1\n#guard number_ctr \"3wonders\" = 1\n#guard number_ctr \"123\" = 3\n", "test_list": ["#guard number_ctr \"program2bedone\" = 1", "#guard number_ctr \"3wonders\" = 1", "#guard number_ctr \"123\" = 3"]}
{"text": "Write a function to find nth polite number.", "task_id": 765, "code": "import Batteries\n\nopen Std\n\ndef is_polite (n : Nat) : Nat :=\n  let m := n + 1\n  let t := m + Nat.log2 m\n  m + Nat.log2 t\n\n#guard is_polite 7 = 11\n#guard is_polite 4 = 7\n#guard is_polite 9 = 13\n", "test_list": ["#guard is_polite 7 = 11", "#guard is_polite 4 = 7", "#guard is_polite 9 = 13"]}
{"text": "Write a function to iterate over all pairs of consecutive items in a given list.", "task_id": 766, "code": "import Batteries\n\nopen Std\n\ndef pairWise (l1 : List Nat) : List (Nat × Nat) := Id.run do\n  let mut temp : Array (Nat × Nat) := #[]\n  let n := l1.length\n  for i in [: n - 1] do\n    let current_element := l1.getD i 0\n    let next_element := l1.getD (i + 1) 0\n    let x := (current_element, next_element)\n    temp := temp.push x\n  return temp.toList\n\n#guard pairWise [1,1,2,3,3,4,4,5] = [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n#guard pairWise [1,5,7,9,10] = [(1, 5), (5, 7), (7, 9), (9, 10)]\n#guard pairWise [1,2,3,4,5,6,7,8,9,10] = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]\n", "test_list": ["#guard pairWise [1,1,2,3,3,4,4,5] = [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]", "#guard pairWise [1,5,7,9,10] = [(1, 5), (5, 7), (7, 9), (9, 10)]", "#guard pairWise [1,2,3,4,5,6,7,8,9,10] = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)]"]}
{"text": "Write a python function to count the number of pairs whose sum is equal to ‘sum’.", "task_id": 767, "code": "import Batteries\nopen Std\n\ndef listNth? {α} (xs : List α) (i : Nat) : Option α :=\n  match xs, i with\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs', Nat.succ i' => listNth? xs' i'\n\ndef get_Pairs_Count (arr : List Int) (n : Nat) (sum : Int) : Nat := Id.run do\n  \n  let mut count : Nat := 0\n  for i in [0 : n] do\n    for j in [i+1 : n] do\n      let ai? := listNth? arr i\n      let aj? := listNth? arr j\n      match ai?, aj? with\n      | some ai, some aj =>\n        if ai + aj = sum then\n          count := count + 1\n        else\n          ()\n      | _, _ => ()\n  return count\n\n#guard get_Pairs_Count [1,1,1,1] 4 2 = 6\n#guard get_Pairs_Count [1,5,7,-1,5] 5 6 = 3\n#guard get_Pairs_Count [1,-2,3] 3 1 = 1\n", "test_list": ["#guard get_Pairs_Count [1,1,1,1] 4 2 = 6", "#guard get_Pairs_Count [1,5,7,-1,5] 5 6 = 3", "#guard get_Pairs_Count [1,-2,3] 3 1 = 1"]}
{"text": "Write a python function to check for odd parity of a given number.", "task_id": 768, "code": "import Batteries\n\nopen Std\n\ndef check_Odd_Parity (x : Nat) : Bool := Id.run do\n  let mut x := x\n  let mut parity : Nat := 0\n  while x != 0 do\n    x := x &&& (x - 1)\n    parity := parity + 1\n  return parity % 2 == 1\n\n#guard check_Odd_Parity 13 == true\n#guard check_Odd_Parity 21 == true\n#guard check_Odd_Parity 18 == false\n", "test_list": ["#guard check_Odd_Parity 13 == true", "#guard check_Odd_Parity 21 == true", "#guard check_Odd_Parity 18 == false"]}
{"text": "Write a python function to get the difference between two lists.", "task_id": 769, "code": "import Batteries\n\nopen Std\n\ndef Diff (li1 li2 : List Nat) : HashSet Nat := Id.run do\n  let s1 := HashSet.ofList li1\n  let s2 := HashSet.ofList li2\n  let all := HashSet.ofList (li1 ++ li2)\n  return all.filter (fun x => (s1.contains x && !(s2.contains x)) || (s2.contains x && !(s1.contains x)))\n\n#guard Diff [10, 15, 20, 25, 30, 35, 40] [25, 40, 35] == HashSet.ofList [10, 20, 30, 15]\n#guard Diff [1,2,3,4,5] [6,7,1] == HashSet.ofList [2,3,4,5,6,7]\n#guard Diff [1,2,3] [6,7,1] == HashSet.ofList [2,3,6,7]\n", "test_list": ["#guard Diff [10, 15, 20, 25, 30, 35, 40] [25, 40, 35] == HashSet.ofList [10, 20, 30, 15]", "#guard Diff [1,2,3,4,5] [6,7,1] == HashSet.ofList [2,3,4,5,6,7]", "#guard Diff [1,2,3] [6,7,1] == HashSet.ofList [2,3,6,7]"]}
{"text": "Write a python function to find the sum of fourth power of first n odd natural numbers.", "task_id": 770, "code": "import Batteries\n\nopen Std\n\ndef odd_Num_Sum (n : Nat) : Nat := Id.run do\n  let mut j := 0\n  let mut sm := 0\n  for i in [1 : n + 1] do\n    j := 2 * i - 1\n    sm := sm + (j * j * j * j)\n  return sm\n\n#guard odd_Num_Sum 2 = 82\n#guard odd_Num_Sum 3 = 707\n#guard odd_Num_Sum 4 = 3108\n", "test_list": ["#guard odd_Num_Sum 2 = 82", "#guard odd_Num_Sum 3 = 707", "#guard odd_Num_Sum 4 = 3108"]}
{"text": "Write a function to check if the given expression is balanced or not.", "task_id": 771, "code": "import Batteries\n\nopen Std\n\ndef checkExpression (exp : String) : Bool := Id.run do\n  let chars := exp.data\n  let n := chars.length\n  if (n &&& 1) == 1 then\n    return false\n  let mut stack : List Char := []\n  for ch in chars do\n    if ch == '(' || ch == '{' || ch == '[' then\n      stack := ch :: stack\n    if ch == ')' || ch == '}' || ch == ']' then\n      if stack.isEmpty then\n        return false\n      let top := stack.head!\n      stack := stack.tail!\n      if (top == '(' && ch != ')') || (top == '{' && ch != '}' || (top == '[' && ch != ']')) then\n        return false\n  return stack.isEmpty\n\n#guard checkExpression \"{()}[{}]\" == true\n#guard checkExpression \"{()}[{]\" == false\n#guard checkExpression \"{()}[{}][]({})\" == true\n", "test_list": ["#guard checkExpression \"{()}[{}]\" == true", "#guard checkExpression \"{()}[{]\" == false", "#guard checkExpression \"{()}[{}][]({})\" == true"]}
{"text": "Write a function to remove all the words with k length in the given string.", "task_id": 772, "code": "import Batteries\n\nopen Std\n\ndef splitWords (s : String) : List String :=\n  let rec loop (cs : List Char) (curr : List Char) (acc : List (List Char)) : List (List Char) :=\n    match cs with\n    | [] => if curr.isEmpty then acc else (curr.reverse :: acc)\n    | c :: cs' =>\n      if c = ' ' then\n        if curr.isEmpty then loop cs' [] acc\n        else loop cs' [] (curr.reverse :: acc)\n      else\n        loop cs' (c :: curr) acc\n  let wordsRev := loop s.data [] []\n  let words := wordsRev.reverse\n  words.map (fun chars => String.mk chars)\n\ndef joinWithSpace (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: xs => xs.foldl (fun acc s => acc ++ \" \" ++ s) x\n\ndef removeLength (test_str : String) (K : Nat) : String :=\n  let temp := splitWords test_str\n  let res := temp.filter (fun ele => ele.length != K)\n  joinWithSpace res\n\n#guard removeLength \"The person is most value tet\" 3 == \"person is most value\"\n#guard removeLength \"If you told me about this ok\" 4 == \"If you me about ok\"\n#guard removeLength \"Forces of darkeness is come into the play\" 4 == \"Forces of darkeness is the\"\n", "test_list": ["#guard removeLength \"The person is most value tet\" 3 == \"person is most value\"", "#guard removeLength \"If you told me about this ok\" 4 == \"If you me about ok\"", "#guard removeLength \"Forces of darkeness is come into the play\" 4 == \"Forces of darkeness is the\""]}
{"text": "Write a function to find the occurrence and position of the substrings within a string.", "task_id": 773, "code": "import Batteries\n\nopen Std\n\ndef occuranceSubstring (text pattern : String) : (String × Nat × Nat) := Id.run do\n  let n := text.length\n  let m := pattern.length\n  let upto := if n >= m then n - m else 0\n  for i in [0 : upto + 1] do\n    if (text.drop i).take m == pattern then\n      return ((text.drop i).take m, i, i + m)\n  return (\"\", 0, 0)\n\n#guard occuranceSubstring \"python programming, python language\" \"python\" = (\"python\", 0, 6)\n#guard occuranceSubstring \"python programming,programming language\" \"programming\" = (\"programming\", 7, 18)\n#guard occuranceSubstring \"python programming,programming language\" \"language\" = (\"language\", 31, 39)\n", "test_list": ["#guard occuranceSubstring \"python programming, python language\" \"python\" = (\"python\", 0, 6)", "#guard occuranceSubstring \"python programming,programming language\" \"programming\" = (\"programming\", 7, 18)", "#guard occuranceSubstring \"python programming,programming language\" \"language\" = (\"language\", 31, 39)"]}
{"text": "Write a python function to check whether every odd index contains odd numbers of a given list.", "task_id": 775, "code": "import Batteries\n\nopen Std\n\ndef oddPosition (nums : List Nat) : Bool :=\n  let rec go (l : List Nat) (i : Nat) : Bool :=\n    match l with\n    | [] => true\n    | x :: xs => (x % 2 == i % 2) && go xs (i + 1)\n  go nums 0\n\n#guard oddPosition [2,1,4,3,6,7,6,3] == true\n#guard oddPosition [4,1,2] == true\n#guard oddPosition [1,2,3] == false\n", "test_list": ["#guard oddPosition [2,1,4,3,6,7,6,3] == true", "#guard oddPosition [4,1,2] == true", "#guard oddPosition [1,2,3] == false"]}
{"text": "Write a function to count those characters which have vowels as their neighbors in the given string.", "task_id": 776, "code": "import Batteries\nopen Std\n\ndef isVowel (c : Char) : Bool :=\n  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n\ndef listNth? {α} (xs : List α) (n : Nat) : Option α :=\n  let rec go (n : Nat) (xs : List α) : Option α :=\n    match n, xs with\n    | 0, x :: _ => some x\n    | Nat.succ n', _ :: xs' => go n' xs'\n    | _, [] => none\n  go n xs\n\ndef countVowels (testStr : String) : Nat := Id.run do\n  let chars := testStr.data\n  let len := chars.length\n  let mut res := 0\n  if len >= 2 then\n    \n    for idx in [1 : len - 1] do\n      let ci := (listNth? chars idx).getD 'a'\n      let prev := (listNth? chars (idx - 1)).getD 'a'\n      let next := (listNth? chars (idx + 1)).getD 'a'\n      if (!isVowel ci) && (isVowel prev || isVowel next) then\n        res := res + 1\n    \n    if (!isVowel ((listNth? chars 0).getD 'a')) && isVowel ((listNth? chars 1).getD 'a') then\n      res := res + 1\n    \n    if (!isVowel ((listNth? chars (len - 1)).getD 'a')) && isVowel ((listNth? chars (len - 2)).getD 'a') then\n      res := res + 1\n  return res\n\n#guard countVowels \"bestinstareels\" = 7\n#guard countVowels \"partofthejourneyistheend\" = 12\n#guard countVowels \"amazonprime\" = 5\n", "test_list": ["#guard countVowels \"bestinstareels\" = 7", "#guard countVowels \"partofthejourneyistheend\" = 12", "#guard countVowels \"amazonprime\" = 5"]}
{"text": "Write a python function to find the sum of non-repeated elements in a given array.", "task_id": 777, "code": "import Batteries\n\nopen Std\n\ndef find_Sum (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let mut seen : HashSet Nat := {}\n  let mut s : Nat := 0\n  for x in arr do\n    if !(seen.contains x) then\n      s := s + x\n      seen := seen.insert x\n  return s\n\n#guard find_Sum [1,2,3,1,1,4,5,6] 8 = 21\n#guard find_Sum [1,10,9,4,2,10,10,45,4] 9 = 71\n#guard find_Sum [12,10,9,45,2,10,10,45,10] 9 = 78\n", "test_list": ["#guard find_Sum [1,2,3,1,1,4,5,6] 8 = 21", "#guard find_Sum [1,10,9,4,2,10,10,45,4] 9 = 71", "#guard find_Sum [12,10,9,45,2,10,10,45,10] 9 = 78"]}
{"text": "Write a function to pack consecutive duplicates of a given list elements into sublists.", "task_id": 778, "code": "import Batteries\n\nopen Std\n\ndef packConsecutiveDuplicates {α : Type} [BEq α] (list1 : List α) : List (List α) :=\n  let (resAcc, curr) :=\n    list1.foldl\n      (fun (state : List (List α) × List α) (x : α) =>\n        let resAcc := state.fst\n        let curr := state.snd\n        match curr with\n        | [] => (resAcc, [x])\n        | y :: _ =>\n          if x == y then (resAcc, x :: curr) else ((curr.reverse) :: resAcc, [x]))\n      ([], [])\n  let resAcc := if curr.isEmpty then resAcc else (curr.reverse) :: resAcc\n  resAcc.reverse\n\n#guard packConsecutiveDuplicates [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4] = [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n#guard packConsecutiveDuplicates [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10] = [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]\n#guard packConsecutiveDuplicates [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"] = [[\"a\", \"a\"], [\"b\"], [\"c\"], [\"d\", \"d\"]]\n", "test_list": ["#guard packConsecutiveDuplicates [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4] = [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]", "#guard packConsecutiveDuplicates [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10] = [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]]", "#guard packConsecutiveDuplicates [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"] = [[\"a\", \"a\"], [\"b\"], [\"c\"], [\"d\", \"d\"]]"]}
{"text": "Write a function to find the combinations of sums with tuples in the given tuple list.", "task_id": 780, "code": "import Batteries\n\nopen Std\n\ndef findCombinations (test_list : List (Nat × Nat)) : List (Nat × Nat) :=\n  let rec go (l : List (Nat × Nat)) : List (Nat × Nat) :=\n    match l with\n    | [] => []\n    | x :: xs =>\n      let fromX := xs.map (fun y =>\n        match x, y with\n        | (a1, a2), (b1, b2) => (b1 + a1, b2 + a2))\n      fromX ++ go xs\n  go test_list\n\n#guard findCombinations [(2, 4), (6, 7), (5, 1), (6, 10)] = [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n#guard findCombinations [(3, 5), (7, 8), (6, 2), (7, 11)] = [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]\n#guard findCombinations [(4, 6), (8, 9), (7, 3), (8, 12)] = [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]\n", "test_list": ["#guard findCombinations [(2, 4), (6, 7), (5, 1), (6, 10)] = [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]", "#guard findCombinations [(3, 5), (7, 8), (6, 2), (7, 11)] = [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)]", "#guard findCombinations [(4, 6), (8, 9), (7, 3), (8, 12)] = [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)]"]}
{"text": "Write a python function to check whether the count of divisors is even or odd.", "task_id": 781, "code": "import Batteries\n\nopen Std\n\ndef count_Divisors (n : Nat) : String := Id.run do\n  let mut count := 0\n  for i in [1 : Nat.sqrt n + 2] do\n    if n % i == 0 then\n      if n / i == i then\n        count := count + 1\n      else\n        count := count + 2\n  if count % 2 == 0 then\n    return \"Even\"\n  else\n    return \"Odd\"\n\n#guard count_Divisors 10 == \"Even\"\n#guard count_Divisors 100 == \"Odd\"\n#guard count_Divisors 125 == \"Even\"\n", "test_list": ["#guard count_Divisors 10 == \"Even\"", "#guard count_Divisors 100 == \"Odd\"", "#guard count_Divisors 125 == \"Even\""]}
{"text": "Write a python function to find the sum of all odd length subarrays.", "task_id": 782, "code": "import Batteries\n\nopen Std\n\ndef Odd_Length_Sum (arr : List Nat) : Nat := Id.run do\n  let l := arr.length\n  let mut s := 0\n  for i in [0:l] do\n    let coeff := (((i + 1) * (l - i) + 1) / 2)\n    s := s + coeff * (arr.getD i 0)\n  return s\n\n#guard Odd_Length_Sum [1, 2, 4] = 14\n#guard Odd_Length_Sum [1, 2, 1, 2] = 15\n#guard Odd_Length_Sum [1, 7] = 8\n", "test_list": ["#guard Odd_Length_Sum [1, 2, 4] = 14", "#guard Odd_Length_Sum [1, 2, 1, 2] = 15", "#guard Odd_Length_Sum [1, 7] = 8"]}
{"text": "Write a function to find the product of first even and odd number of a given list.", "task_id": 784, "code": "import Batteries\n\nopen Std\n\ndef mulEvenOdd (list1 : List Int) : Int :=\n  let first_even := list1.find? (fun el => el % 2 == 0)\n  let first_odd := list1.find? (fun el => el % 2 != 0)\n  let fe := match first_even with | some x => x | none => -1\n  let fo := match first_odd with | some x => x | none => -1\n  fe * fo\n\n#guard mulEvenOdd [1,3,5,7,4,1,6,8] == 4\n#guard mulEvenOdd [1,2,3,4,5,6,7,8,9,10] == 2\n#guard mulEvenOdd [1,5,7,9,10] == 10\n", "test_list": ["#guard mulEvenOdd [1,3,5,7,4,1,6,8] == 4", "#guard mulEvenOdd [1,2,3,4,5,6,7,8,9,10] == 2", "#guard mulEvenOdd [1,5,7,9,10] == 10"]}
{"text": "Write a function to convert tuple string to integer tuple.", "task_id": 785, "code": "import Batteries\n\nopen Std\n\ndef removeSubstr (s sub : String) : String :=\n  (s.splitOn sub).foldl (fun acc part => acc ++ part) \"\"\n\ndef tupleStrInt (testStr : String) : List Int :=\n  let s1 := removeSubstr testStr \"(\"\n  let s2 := removeSubstr s1 \")\"\n  let s3 := removeSubstr s2 \"...\"\n  let parts := s3.splitOn \", \"\n  parts.map (fun num => (num.toInt?).getD 0)\n\n#guard tupleStrInt \"(7, 8, 9)\" == [7, 8, 9]\n#guard tupleStrInt \"(1, 2, 3)\" == [1, 2, 3]\n#guard tupleStrInt \"(4, 5, 6)\" == [4, 5, 6]\n", "test_list": ["#guard tupleStrInt \"(7, 8, 9)\" == [7, 8, 9]", "#guard tupleStrInt \"(1, 2, 3)\" == [1, 2, 3]", "#guard tupleStrInt \"(4, 5, 6)\" == [4, 5, 6]"]}
{"text": "Write a function to locate the right insertion point for a specified value in sorted order.", "task_id": 786, "code": "import Batteries\n\nopen Std\n\ndef rightInsertion (a : List Nat) (x : Nat) : Nat :=\n  a.foldl (fun acc y => if y ≤ x then acc + 1 else acc) 0\n\n#guard rightInsertion [1,2,4,5] 6 == 4\n#guard rightInsertion [1,2,4,5] 3 == 2\n#guard rightInsertion [1,2,4,5] 7 == 4\n", "test_list": ["#guard rightInsertion [1,2,4,5] 6 == 4", "#guard rightInsertion [1,2,4,5] 3 == 2", "#guard rightInsertion [1,2,4,5] 7 == 4"]}
{"text": "Write a function that matches a string that has an a followed by three 'b'.", "task_id": 787, "code": "import Batteries\n\nopen Std\n\ndef textMatchThree (text : String) : String := Id.run do\n  let pattern := \"abbb\"\n  let m := pattern.length\n  let n := text.length\n  let mut found := false\n  for i in [0 : n - m + 1] do\n    if (text.drop i).take m = pattern then\n      found := true\n  return if found then \"Found a match!\" else \"Not matched!\"\n\n#guard textMatchThree \"ac\" == \"Not matched!\"\n#guard textMatchThree \"dc\" == \"Not matched!\"\n#guard textMatchThree \"abbbba\" == \"Found a match!\"\n", "test_list": ["#guard textMatchThree \"ac\" == \"Not matched!\"", "#guard textMatchThree \"dc\" == \"Not matched!\"", "#guard textMatchThree \"abbbba\" == \"Found a match!\""]}
{"text": "Write a function to create a new tuple from the given string and list.", "task_id": 788, "code": "import Batteries\n\nopen Std\n\ndef newTuple (test_list : List String) (test_str : String) : List String :=\n  let res := test_list ++ [test_str]\n  res\n\n#guard newTuple [\"WEB\", \"is\"] \"best\" == [\"WEB\", \"is\", \"best\"]\n#guard newTuple [\"We\", \"are\"] \"Developers\" == [\"We\", \"are\", \"Developers\"]\n#guard newTuple [\"Part\", \"is\"] \"Wrong\" == [\"Part\", \"is\", \"Wrong\"]\n", "test_list": ["#guard newTuple [\"WEB\", \"is\"] \"best\" == [\"WEB\", \"is\", \"best\"]", "#guard newTuple [\"We\", \"are\"] \"Developers\" == [\"We\", \"are\", \"Developers\"]", "#guard newTuple [\"Part\", \"is\"] \"Wrong\" == [\"Part\", \"is\", \"Wrong\"]"]}
{"text": "Write a function to calculate the perimeter of a regular polygon.", "task_id": 789, "code": "import Batteries\n\nopen Std\n\ndef perimeterPolygon (s l : Nat) : Nat :=\n  let perimeter := s * l\n  perimeter\n\n#guard perimeterPolygon 4 20 = 80\n#guard perimeterPolygon 10 15 = 150\n#guard perimeterPolygon 9 7 = 63\n", "test_list": ["#guard perimeterPolygon 4 20 = 80", "#guard perimeterPolygon 10 15 = 150", "#guard perimeterPolygon 9 7 = 63"]}
{"text": "Write a python function to check whether every even index contains even numbers of a given list.", "task_id": 790, "code": "import Batteries\n\nopen Std\n\ndef evenPosition (nums : List Nat) : Bool := Id.run do\n  for i in [0 : nums.length] do\n    let xi := nums.getD i 0\n    if xi % 2 == i % 2 then\n      ()\n    else\n      return false\n  return true\n\n#guard evenPosition [3, 2, 1] == false\n#guard evenPosition [1, 2, 3] == false\n#guard evenPosition [2, 1, 4] == true\n", "test_list": ["#guard evenPosition [3, 2, 1] == false", "#guard evenPosition [1, 2, 3] == false", "#guard evenPosition [2, 1, 4] == true"]}
{"text": "Write a function to remove the nested record from the given tuple.", "task_id": 791, "code": "import Batteries\n\nopen Std\n\ndef remove_nested (test_tup : List (Sum Nat (List Nat))) : List Nat :=\n  test_tup.foldl (init := []) (fun acc ele =>\n    match ele with\n    | Sum.inl n => acc ++ [n]\n    | Sum.inr _ => acc\n  )\n\n#guard remove_nested [Sum.inl 1, Sum.inl 5, Sum.inl 7, Sum.inr [4, 6], Sum.inl 10] = [1, 5, 7, 10]\n#guard remove_nested [Sum.inl 2, Sum.inl 6, Sum.inl 8, Sum.inr [5, 7], Sum.inl 11] = [2, 6, 8, 11]\n#guard remove_nested [Sum.inl 3, Sum.inl 7, Sum.inl 9, Sum.inr [6, 8], Sum.inl 12] = [3, 7, 9, 12]\n", "test_list": ["#guard remove_nested [Sum.inl 1, Sum.inl 5, Sum.inl 7, Sum.inr [4, 6], Sum.inl 10] = [1, 5, 7, 10]", "#guard remove_nested [Sum.inl 2, Sum.inl 6, Sum.inl 8, Sum.inr [5, 7], Sum.inl 11] = [2, 6, 8, 11]", "#guard remove_nested [Sum.inl 3, Sum.inl 7, Sum.inl 9, Sum.inr [6, 8], Sum.inl 12] = [3, 7, 9, 12]"]}
{"text": "Write a python function to count the number of lists in a given number of lists.", "task_id": 792, "code": "import Batteries\n\nopen Std\n\ndef countList {α : Type} (inputList : List α) : Nat :=\n  inputList.length\n\n#guard countList [[1, 3], [5, 7], [9, 11], [13, 15, 17]] = 4\n#guard countList [[1,2],[2,3],[4,5]] = 3\n#guard countList [[1,0],[2,0]] = 2\n", "test_list": ["#guard countList [[1, 3], [5, 7], [9, 11], [13, 15, 17]] = 4", "#guard countList [[1,2],[2,3],[4,5]] = 3", "#guard countList [[1,0],[2,0]] = 2"]}
{"text": "Write a python function to find the last position of an element in a sorted array.", "task_id": 793, "code": "import Batteries\nopen Std\n\ndef last (arr : List Int) (x : Int) (n : Nat) : Int :=\n  let rec loop (low high res : Int) (fuel : Nat) : Int :=\n    match fuel with\n    | 0 => res\n    | Nat.succ fuel' =>\n      if low ≤ high then\n        let mid : Int := (low + high) / 2\n        let v : Int := arr.getD (Int.toNat mid) 0\n        if v > x then\n          loop low (mid - 1) res fuel'\n        else if v < x then\n          loop (mid + 1) high res fuel'\n        else\n          loop (mid + 1) high mid fuel'\n      else\n        res\n  loop 0 (Int.ofNat n - 1) (-1) n\n\n#guard last [1,2,3] 1 3 = 0\n#guard last [1,1,1,2,3,4] 1 6 = 2\n#guard last [2,3,2,3,6,8,9] 3 8 = 3\n", "test_list": ["#guard last [1,2,3] 1 3 = 0", "#guard last [1,1,1,2,3,4] 1 6 = 2", "#guard last [2,3,2,3,6,8,9] 3 8 = 3"]}
{"text": "Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.", "task_id": 794, "code": "import Batteries\nopen Std\n\ndef text_starta_endb (text : String) : String :=\n  let _ := \"a.*?b$\"\n  let n := text.length\n  let endsWithB := text.drop (n - 1) == \"b\"\n  let pref := text.take (n - 1)\n  if endsWithB then\n    if pref.data.any (fun c => c == 'a') then\n      \"Found a match!\"\n    else\n      \"Not matched!\"\n  else\n    \"Not matched!\"\n\n#guard text_starta_endb \"aabbbb\" == \"Found a match!\"\n#guard text_starta_endb \"aabAbbbc\" == \"Not matched!\"\n#guard text_starta_endb \"accddbbjjj\" == \"Not matched!\"\n", "test_list": ["#guard text_starta_endb \"aabbbb\" == \"Found a match!\"", "#guard text_starta_endb \"aabAbbbc\" == \"Not matched!\"", "#guard text_starta_endb \"accddbbjjj\" == \"Not matched!\""]}
{"text": "Write a function to find the n - cheap price items from a given dataset using heap queue algorithm.", "task_id": 795, "code": "import Batteries\n\nopen Std\n\nstructure Item where\n  name : String\n  price : Float\nderiving Repr, BEq\n\nprivate def findMinByPrice (l : List Item) : Option Item :=\n  match l with\n  | [] => none\n  | h :: t =>\n    some <| t.foldl (fun m x => if x.price < m.price then x else m) h\n\nprivate def removeFirst (l : List Item) (x : Item) : List Item :=\n  match l with\n  | [] => []\n  | h :: t => if h == x then t else h :: removeFirst t x\n\ndef cheapItems (items : List Item) (n : Nat) : List Item := Id.run do\n  let mut rest := items\n  let mut res : List Item := []\n  for _ in [: n] do\n    match findMinByPrice rest with\n    | none => break\n    | some m =>\n      res := res ++ [m]\n      rest := removeFirst rest m\n  return res\n\n#guard cheapItems [{ name := \"Item-1\", price := 101.1 }, { name := \"Item-2\", price := 555.22 }] 1 == [{ name := \"Item-1\", price := 101.1 }]\n#guard cheapItems [{ name := \"Item-1\", price := 101.1 }, { name := \"Item-2\", price := 555.22 }] 2 == [{ name := \"Item-1\", price := 101.1 }, { name := \"Item-2\", price := 555.22 }]\n#guard cheapItems [\n  { name := \"Item-1\", price := 101.1 },\n  { name := \"Item-2\", price := 555.22 },\n  { name := \"Item-3\", price := 45.09 },\n  { name := \"Item-4\", price := 22.75 }\n] 1 == [{ name := \"Item-4\", price := 22.75 }]\n", "test_list": ["#guard cheapItems [{ name := \"Item-1\", price := 101.1 }, { name := \"Item-2\", price := 555.22 }] 1 == [{ name := \"Item-1\", price := 101.1 }]", "#guard cheapItems [{ name := \"Item-1\", price := 101.1 }, { name := \"Item-2\", price := 555.22 }] 2 == [{ name := \"Item-1\", price := 101.1 }, { name := \"Item-2\", price := 555.22 }]", "#guard cheapItems ["]}
{"text": "Write function to find the sum of all items in the given dictionary.", "task_id": 796, "code": "import Batteries\n\nopen Std\n\ndef returnSum (dict : HashMap String Nat) : Nat := Id.run do\n  let mut s := 0\n  for (_, v) in dict.toList do\n    s := s + v\n  return s\n\ndef buildDict (xs : List (String × Nat)) : HashMap String Nat := Id.run do\n  let mut m : HashMap String Nat := {}\n  for (k, v) in xs do\n    m := m.insert k v\n  return m\n\n#guard returnSum (buildDict [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) = 600\n#guard returnSum (buildDict [(\"a\", 25), (\"b\", 18), (\"c\", 45)]) = 88\n#guard returnSum (buildDict [(\"a\", 36), (\"b\", 39), (\"c\", 49)]) = 124\n", "test_list": ["#guard returnSum (buildDict [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) = 600", "#guard returnSum (buildDict [(\"a\", 25), (\"b\", 18), (\"c\", 45)]) = 88", "#guard returnSum (buildDict [(\"a\", 36), (\"b\", 39), (\"c\", 49)]) = 124"]}
{"text": "Write a python function to find the sum of all odd natural numbers within the range l and r.", "task_id": 797, "code": "import Batteries\n\nopen Std\n\ndef sum_Odd (n : Nat) : Nat :=\n  let terms := (n + 1) / 2\n  let sum1 := terms * terms\n  sum1\n\ndef sum_in_Range (l r : Nat) : Nat :=\n  sum_Odd r - sum_Odd (l - 1)\n\n#guard sum_in_Range 2 5 = 8\n#guard sum_in_Range 5 7 = 12\n#guard sum_in_Range 7 13 = 40\n", "test_list": ["#guard sum_in_Range 2 5 = 8", "#guard sum_in_Range 5 7 = 12", "#guard sum_in_Range 7 13 = 40"]}
{"text": "Write a python function to find the sum of an array.", "task_id": 798, "code": "import Batteries\n\nopen Std\n\ndef _sum (arr : List Nat) : Nat :=\n  arr.foldl (fun s i => s + i) 0\n\n#guard _sum [1, 2, 3] = 6\n#guard _sum [15, 12, 13, 10] = 50\n#guard _sum [0, 1, 2] = 3\n", "test_list": ["#guard _sum [1, 2, 3] = 6", "#guard _sum [15, 12, 13, 10] = 50", "#guard _sum [0, 1, 2] = 3"]}
{"text": "Write a python function to left rotate the bits of a given number.", "task_id": 799, "code": "import Batteries\n\nopen Std\n\ndef INT_BITS : Nat := 32\n\ndef left_Rotate (n d : Nat) : Nat :=\n  Nat.lor (Nat.shiftLeft n d) (Nat.shiftRight n (INT_BITS - d))\n\n#guard left_Rotate 16 2 = 64\n#guard left_Rotate 10 2 = 40\n#guard left_Rotate 99 3 = 792\n", "test_list": ["#guard left_Rotate 16 2 = 64", "#guard left_Rotate 10 2 = 40", "#guard left_Rotate 99 3 = 792"]}
{"text": "Write a function to remove all whitespaces from a string.", "task_id": 800, "code": "import Batteries\n\nopen Std\n\ndef removeAllSpaces (text : String) : String :=\n  String.mk (text.data.filter (fun c => !c.isWhitespace))\n\n#guard removeAllSpaces \"python  program\" == \"pythonprogram\"\n#guard removeAllSpaces \"python   programming    language\" == \"pythonprogramminglanguage\"\n#guard removeAllSpaces \"python                     program\" == \"pythonprogram\"\n", "test_list": ["#guard removeAllSpaces \"python  program\" == \"pythonprogram\"", "#guard removeAllSpaces \"python   programming    language\" == \"pythonprogramminglanguage\"", "#guard removeAllSpaces \"python                     program\" == \"pythonprogram\""]}
{"text": "Write a python function to count the number of equal numbers from three given integers.", "task_id": 801, "code": "import Batteries\n\nopen Std\n\ndef testThreeEqual (x y z : Int) : Nat :=\n  let s := (HashSet.empty.insert x).insert y |>.insert z\n  let len := s.size\n  if len == 3 then 0 else 4 - len\n\n#guard testThreeEqual 1 1 1 = 3\n#guard testThreeEqual (-1) (-2) (-3) = 0\n#guard testThreeEqual 1 2 2 = 2\n", "test_list": ["#guard testThreeEqual 1 1 1 = 3", "#guard testThreeEqual (-1) (-2) (-3) = 0", "#guard testThreeEqual 1 2 2 = 2"]}
{"text": "Write a python function to count the number of rotations required to generate a sorted array.", "task_id": 802, "code": "import Batteries\nopen Std\n\ndef countRotation (arr : List Nat) (n : Nat) : Nat :=\n  let arr' := arr.take n\n  let rec loop (lst : List Nat) (i : Nat) : Nat :=\n    match lst with\n    | x :: y :: xs =>\n      if y < x then\n        i\n      else\n        loop (y :: xs) (i + 1)\n    | _ => 0\n  loop arr' 1\n\n#guard countRotation [3, 2, 1] 3 = 1\n#guard countRotation [4, 5, 1, 2, 3] 5 = 2\n#guard countRotation [7, 8, 9, 1, 2, 3] 6 = 3\n", "test_list": ["#guard countRotation [3, 2, 1] 3 = 1", "#guard countRotation [4, 5, 1, 2, 3] 5 = 2", "#guard countRotation [7, 8, 9, 1, 2, 3] 6 = 3"]}
{"text": "Write a python function to check whether the given number is a perfect square or not.", "task_id": 803, "code": "import Batteries\n\nopen Std\n\ndef is_Perfect_Square (n : Nat) : Bool := Id.run do\n  let mut i := 1\n  while i * i <= n do\n    if (n % i == 0) && (n / i == i) then\n      return true\n    i := i + 1\n  return false\n\n#guard is_Perfect_Square 10 == false\n#guard is_Perfect_Square 36 == true\n#guard is_Perfect_Square 14 == false\n", "test_list": ["#guard is_Perfect_Square 10 == false", "#guard is_Perfect_Square 36 == true", "#guard is_Perfect_Square 14 == false"]}
{"text": "Write a python function to check whether the product of numbers is even or not.", "task_id": 804, "code": "import Batteries\nopen Std\n\ndef is_Product_Even (arr : List Nat) (n : Nat) : Bool :=\n  let rec go (xs : List Nat) (k : Nat) : Bool :=\n    match xs, k with\n    | _, 0 => false\n    | [], _ => false\n    | x :: xs', Nat.succ k' =>\n      if (x &&& 1) == 0 then true else go xs' k'\n  go arr n\n\n#guard is_Product_Even [1,2,3] 3 == true\n#guard is_Product_Even [1,2,1,4] 4 == true\n#guard is_Product_Even [1,1] 2 == false\n", "test_list": ["#guard is_Product_Even [1,2,3] 3 == true", "#guard is_Product_Even [1,2,1,4] 4 == true", "#guard is_Product_Even [1,1] 2 == false"]}
{"text": "Write a function to find the list in a list of lists whose sum of elements is the highest.", "task_id": 805, "code": "import Batteries\n\nopen Std\n\ndef sumList (xs : List Nat) : Nat :=\n  xs.foldl (fun acc x => acc + x) 0\n\ndef maxSumList (lists : List (List Nat)) : List Nat :=\n  match lists with\n  | [] => []\n  | x :: xs =>\n    let initSum := sumList x\n    let (best, _) :=\n      xs.foldl (fun (acc : List Nat × Nat) (curr : List Nat) =>\n        let s := sumList curr\n        if s > acc.snd then (curr, s) else acc\n      ) (x, initSum)\n    best\n\n#guard maxSumList [[1,2,3], [4,5,6], [10,11,12], [7,8,9]] == [10, 11, 12]\n#guard maxSumList [[3,2,1], [6,5,4], [12,11,10]] == [12,11,10]\n#guard maxSumList [[2,3,1]] == [2,3,1]\n", "test_list": ["#guard maxSumList [[1,2,3], [4,5,6], [10,11,12], [7,8,9]] == [10, 11, 12]", "#guard maxSumList [[3,2,1], [6,5,4], [12,11,10]] == [12,11,10]", "#guard maxSumList [[2,3,1]] == [2,3,1]"]}
{"text": "Write a function to find maximum run of uppercase characters in the given string.", "task_id": 806, "code": "import Batteries\n\nopen Std\n\ndef isUpperAscii (c : Char) : Bool :=\n  ('A' ≤ c) && (c ≤ 'Z')\n\ndef max_run_uppercase (test_str : String) : Nat := Id.run do\n  let mut cnt := 0\n  let mut res := 0\n  let mut lastIsUpper := false\n  for c in test_str.toList do\n    if isUpperAscii c then\n      cnt := cnt + 1\n      lastIsUpper := true\n    else\n      res := cnt\n      cnt := 0\n      lastIsUpper := false\n  if lastIsUpper then\n    res := cnt\n  return res\n\n#guard max_run_uppercase \"GeMKSForGERksISBESt\" == 5\n#guard max_run_uppercase \"PrECIOusMOVemENTSYT\" == 6\n#guard max_run_uppercase \"GooGLEFluTTER\" == 4\n", "test_list": ["#guard max_run_uppercase \"GeMKSForGERksISBESt\" == 5", "#guard max_run_uppercase \"PrECIOusMOVemENTSYT\" == 6", "#guard max_run_uppercase \"GooGLEFluTTER\" == 4"]}
{"text": "Write a python function to find the first odd number in a given list of numbers.", "task_id": 807, "code": "import Batteries\n\nopen Std\n\ndef firstOdd (nums : List Int) : Int :=\n  match nums.find? (fun el => el.natAbs % 2 != 0) with\n  | some el => el\n  | none => -1\n\n#guard firstOdd [1, 3, 5] = 1\n#guard firstOdd [2, 4, 1, 3] = 1\n#guard firstOdd [8, 9, 1] = 9\n", "test_list": ["#guard firstOdd [1, 3, 5] = 1", "#guard firstOdd [2, 4, 1, 3] = 1", "#guard firstOdd [8, 9, 1] = 9"]}
{"text": "Write a function to check if the given tuples contain the k or not.", "task_id": 808, "code": "import Batteries\n\nopen Std\n\ndef checkK (testTup : List Nat) (K : Nat) : Bool := Id.run do\n  let mut res := false\n  for ele in testTup do\n    if ele == K then\n      res := true\n      break\n  return res\n\n#guard checkK [10, 4, 5, 6, 8] 6 == true\n#guard checkK [1, 2, 3, 4, 5, 6] 7 == false\n#guard checkK [7, 8, 9, 44, 11, 12] 11 == true\n", "test_list": ["#guard checkK [10, 4, 5, 6, 8] 6 == true", "#guard checkK [1, 2, 3, 4, 5, 6] 7 == false", "#guard checkK [7, 8, 9, 44, 11, 12] 11 == true"]}
{"text": "Write a function to check if each element of second tuple is smaller than its corresponding index in first tuple.", "task_id": 809, "code": "import Batteries\n\nopen Std\n\ndef checkSmaller (test_tup1 : List Nat) (test_tup2 : List Nat) : Bool :=\n  let rec go : List Nat → List Nat → Bool\n  | x::xs, y::ys =>\n    if h : x > y then\n      go xs ys\n    else\n      false\n  | _, _ => true\n  go test_tup1 test_tup2\n\n#guard checkSmaller [1, 2, 3] [2, 3, 4] == false\n#guard checkSmaller [4, 5, 6] [3, 4, 5] == true\n#guard checkSmaller [11, 12, 13] [10, 11, 12] == true\n", "test_list": ["#guard checkSmaller [1, 2, 3] [2, 3, 4] == false", "#guard checkSmaller [4, 5, 6] [3, 4, 5] == true", "#guard checkSmaller [11, 12, 13] [10, 11, 12] == true"]}
{"text": "Write a function to iterate over elements repeating each as many times as its count.", "task_id": 810, "code": "import Batteries\n\nopen Std\n\ndef nonnegCount (x : Int) : Nat :=\n  if x <= 0 then 0 else Int.toNat x\n\ndef countVariable (a b c d : Int) : List String :=\n  (List.replicate (nonnegCount a) \"p\") ++\n  (List.replicate (nonnegCount b) \"q\") ++\n  (List.replicate (nonnegCount c) \"r\") ++\n  (List.replicate (nonnegCount d) \"s\")\n\n#guard countVariable 4 2 0 (-2) == [\"p\", \"p\", \"p\", \"p\", \"q\", \"q\"]\n#guard countVariable 0 1 2 3 == [\"q\", \"r\", \"r\", \"s\", \"s\", \"s\"]\n#guard countVariable 11 15 12 23 == (List.replicate 11 \"p\") ++ (List.replicate 15 \"q\") ++ (List.replicate 12 \"r\") ++ (List.replicate 23 \"s\")\n", "test_list": ["#guard countVariable 4 2 0 (-2) == [\"p\", \"p\", \"p\", \"p\", \"q\", \"q\"]", "#guard countVariable 0 1 2 3 == [\"q\", \"r\", \"r\", \"s\", \"s\", \"s\"]", "#guard countVariable 11 15 12 23 == (List.replicate 11 \"p\") ++ (List.replicate 15 \"q\") ++ (List.replicate 12 \"r\") ++ (List.replicate 23 \"s\")"]}
{"text": "Write a function to check if two lists of tuples are identical or not.", "task_id": 811, "code": "import Batteries\n\nopen Std\n\ndef checkIdentical (testList1 : List (Nat × Nat)) (testList2 : List (Nat × Nat)) : Bool :=\n  testList1 == testList2\n\n#guard checkIdentical [(10, 4), (2, 5)] [(10, 4), (2, 5)] == true\n#guard checkIdentical [(1, 2), (3, 7)] [(12, 14), (12, 45)] == false\n#guard checkIdentical [(2, 14), (12, 25)] [(2, 14), (12, 25)] == true\n", "test_list": ["#guard checkIdentical [(10, 4), (2, 5)] [(10, 4), (2, 5)] == true", "#guard checkIdentical [(1, 2), (3, 7)] [(12, 14), (12, 45)] == false", "#guard checkIdentical [(2, 14), (12, 25)] [(2, 14), (12, 25)] == true"]}
{"text": "Write a function to abbreviate 'road' as 'rd.' in a given string.", "task_id": 812, "code": "import Batteries\n\nopen Std\n\ndef road_rd (street : String) : String :=\n  let n := street.length\n  if street.drop (n - 4) == \"Road\" then\n    street.take (n - 4) ++ \"Rd.\"\n  else\n    street\n\n#guard road_rd \"ravipadu Road\" == \"ravipadu Rd.\"\n#guard road_rd \"palnadu Road\" == \"palnadu Rd.\"\n#guard road_rd \"eshwar enclave Road\" == \"eshwar enclave Rd.\"\n", "test_list": ["#guard road_rd \"ravipadu Road\" == \"ravipadu Rd.\"", "#guard road_rd \"palnadu Road\" == \"palnadu Rd.\"", "#guard road_rd \"eshwar enclave Road\" == \"eshwar enclave Rd.\""]}
{"text": "Write a function to find length of the string.", "task_id": 813, "code": "import Batteries\n\nopen Std\n\ndef string_length (str1 : String) : Nat :=\n  str1.length\n\n#guard string_length \"python\" == 6\n#guard string_length \"program\" == 7\n#guard string_length \"language\" == 8\n", "test_list": ["#guard string_length \"python\" == 6", "#guard string_length \"program\" == 7", "#guard string_length \"language\" == 8"]}
{"text": "Write a function to find the area of a rombus.", "task_id": 814, "code": "import Batteries\n\nopen Std\n\ndef rombus_area (p q : Nat) : Nat :=\n  (p * q) / 2\n\n#guard rombus_area 10 20 = 100\n#guard rombus_area 10 5 = 25\n#guard rombus_area 4 2 = 4\n", "test_list": ["#guard rombus_area 10 20 = 100", "#guard rombus_area 10 5 = 25", "#guard rombus_area 4 2 = 4"]}
{"text": "Write a function to sort the given array without using any sorting algorithm. the given array consists of only 0, 1, and 2.", "task_id": 815, "code": "import Batteries\nopen Std\n\ndef sortByDnf (arr : List Nat) (n : Nat) : List Nat :=\n  let (z, o, t) := count (arr.take n) 0 0 0\n  List.replicate z 0 ++ List.replicate o 1 ++ List.replicate t 2\nwhere\n  count (l : List Nat) (z o t : Nat) : Nat × Nat × Nat :=\n    match l with\n    | [] => (z, o, t)\n    | x :: xs =>\n      if x = 0 then\n        count xs (z + 1) o t\n      else if x = 1 then\n        count xs z (o + 1) t\n      else\n        count xs z o (t + 1)\n\n#guard sortByDnf [1,2,0,1,0,1,2,1,1] 9 == [0, 0, 1, 1, 1, 1, 1, 2, 2]\n#guard sortByDnf [1,0,0,1,2,1,2,2,1,0] 10 == [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\n#guard sortByDnf [2,2,1,0,0,0,1,1,2,1] 10 == [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\n", "test_list": ["#guard sortByDnf [1,2,0,1,0,1,2,1,1] 9 == [0, 0, 1, 1, 1, 1, 1, 2, 2]", "#guard sortByDnf [1,0,0,1,2,1,2,2,1,0] 10 == [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]", "#guard sortByDnf [2,2,1,0,0,0,1,1,2,1] 10 == [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]"]}
{"text": "Write a function to clear the values of the given tuples.", "task_id": 816, "code": "import Batteries\n\nopen Std\n\ndef clearTuple (test_tup : List Nat) : List Nat :=\n  let temp := test_tup\n  let temp := ([] : List Nat)\n  let test_tup := temp\n  test_tup\n\n#guard clearTuple [1, 5, 3, 6, 8] == []\n#guard clearTuple [2, 1, 4, 5, 6] == []\n#guard clearTuple [3, 2, 5, 6, 8] == []\n", "test_list": ["#guard clearTuple [1, 5, 3, 6, 8] == []", "#guard clearTuple [2, 1, 4, 5, 6] == []", "#guard clearTuple [3, 2, 5, 6, 8] == []"]}
{"text": "Write a function to find numbers divisible by m or n from a list of numbers using lambda function.", "task_id": 817, "code": "import Batteries\n\nopen Std\n\ndef divOfNums (nums : List Nat) (m n : Nat) : List Nat :=\n  nums.filter (fun x => x % m == 0 || x % n == 0)\n\n#guard divOfNums [19, 65, 57, 39, 152, 639, 121, 44, 90, 190] 19 13 == [19, 65, 57, 39, 152, 190]\n#guard divOfNums [1, 2, 3, 5, 7, 8, 10] 2 5 == [2, 5, 8, 10]\n#guard divOfNums [10,15,14,13,18,12,20] 10 5 == [10, 15, 20]\n", "test_list": ["#guard divOfNums [19, 65, 57, 39, 152, 639, 121, 44, 90, 190] 19 13 == [19, 65, 57, 39, 152, 190]", "#guard divOfNums [1, 2, 3, 5, 7, 8, 10] 2 5 == [2, 5, 8, 10]", "#guard divOfNums [10,15,14,13,18,12,20] 10 5 == [10, 15, 20]"]}
{"text": "Write a python function to count lower case letters in a given string.", "task_id": 818, "code": "import Batteries\n\nopen Std\n\ndef lowerCtr (str : String) : Nat := Id.run do\n  let mut lower_ctr := 0\n  for c in str.data do\n    if c >= 'a' && c <= 'z' then\n      lower_ctr := lower_ctr + 1\n  return lower_ctr\n\n#guard lowerCtr \"abc\" == 3\n#guard lowerCtr \"string\" == 6\n#guard lowerCtr \"Python\" == 5\n", "test_list": ["#guard lowerCtr \"abc\" == 3", "#guard lowerCtr \"string\" == 6", "#guard lowerCtr \"Python\" == 5"]}
{"text": "Write a function to count the frequency of consecutive duplicate elements in a given list of numbers.", "task_id": 819, "code": "import Batteries\n\nopen Std\n\ndef countDuplic (lists : List Nat) : (List Nat × List Nat) := Id.run do\n  let mut element : List Nat := []\n  let mut frequency : List Nat := []\n  match lists with\n  | [] => return (element, frequency)\n  | prev :: tail =>\n    let mut running := 1\n    let mut cur := prev\n    for x in tail do\n      if cur == x then\n        running := running + 1\n      else\n        frequency := frequency ++ [running]\n        element := element ++ [cur]\n        running := 1\n        cur := x\n    frequency := frequency ++ [running]\n    element := element ++ [cur]\n    return (element, frequency)\n\n#guard countDuplic [1,2,2,2,4,4,4,5,5,5,5] == ([1, 2, 4, 5], [1, 3, 3, 4])\n#guard countDuplic [2,2,3,1,2,6,7,9] == ([2, 3, 1, 2, 6, 7, 9], [2, 1, 1, 1, 1, 1, 1])\n#guard countDuplic [2,1,5,6,8,3,4,9,10,11,8,12] == ([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])\n", "test_list": ["#guard countDuplic [1,2,2,2,4,4,4,5,5,5,5] == ([1, 2, 4, 5], [1, 3, 3, 4])", "#guard countDuplic [2,2,3,1,2,6,7,9] == ([2, 3, 1, 2, 6, 7, 9], [2, 1, 1, 1, 1, 1, 1])", "#guard countDuplic [2,1,5,6,8,3,4,9,10,11,8,12] == ([2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])"]}
{"text": "Write a function to check whether the given month number contains 28 days or not.", "task_id": 820, "code": "import Batteries\n\nopen Std\n\ndef checkMonthnumNumber (monthnum1 : Nat) : Bool :=\n  if monthnum1 == 2 then true else false\n\n#guard checkMonthnumNumber 2 == true\n#guard checkMonthnumNumber 1 == false\n#guard checkMonthnumNumber 3 == false\n", "test_list": ["#guard checkMonthnumNumber 2 == true", "#guard checkMonthnumNumber 1 == false", "#guard checkMonthnumNumber 3 == false"]}
{"text": "Write a function to merge two dictionaries into a single expression.", "task_id": 821, "code": "import Batteries\nopen Std\n\ndef mergeDictionaries (dict1 dict2 : List (String × String)) : HashMap String String := Id.run do\n  let mut m : HashMap String String := {}\n  \n  for (k, v) in dict2 do\n    m := m.insert k v\n  for (k, v) in dict1 do\n    m := m.insert k v\n  return m\n\ndef lookupKey (m : HashMap String String) (k : String) : Option String :=\n  m.fold (fun acc k' v' =>\n    match acc with\n    | some _ => acc\n    | none => if k' == k then some v' else none\n  ) (none : Option String)\n\ndef allPairsMatch (m : HashMap String String) (xs : List (String × String)) : Bool :=\n  let rec loop (ys : List (String × String)) : Bool :=\n    match ys with\n    | [] => true\n    | (k, v) :: t =>\n      match lookupKey m k with\n      | some v' => if v' == v then loop t else false\n      | none => false\n  loop xs\n\n#guard\n  let got := mergeDictionaries [(\"R\", \"Red\"), (\"B\", \"Black\"), (\"P\", \"Pink\")] [(\"G\", \"Green\"), (\"W\", \"White\")]\n  let expected := [(\"B\", \"Black\"), (\"R\", \"Red\"), (\"P\", \"Pink\"), (\"G\", \"Green\"), (\"W\", \"White\")]\n  allPairsMatch got expected && got.size == expected.length\n\n#guard\n  let got := mergeDictionaries [(\"R\", \"Red\"), (\"B\", \"Black\"), (\"P\", \"Pink\")] [(\"O\", \"Orange\"), (\"W\", \"White\"), (\"B\", \"Black\")]\n  let expected := [(\"O\", \"Orange\"), (\"P\", \"Pink\"), (\"B\", \"Black\"), (\"W\", \"White\"), (\"R\", \"Red\")]\n  allPairsMatch got expected && got.size == expected.length\n\n#guard\n  let got := mergeDictionaries [(\"G\", \"Green\"), (\"W\", \"White\")] [(\"O\", \"Orange\"), (\"W\", \"White\"), (\"B\", \"Black\")]\n  let expected := [(\"W\", \"White\"), (\"O\", \"Orange\"), (\"G\", \"Green\"), (\"B\", \"Black\")]\n  allPairsMatch got expected && got.size == expected.length\n", "test_list": ["#guard", "#guard", "#guard"]}
{"text": "Write a function to return true if the password is valid.", "task_id": 822, "code": "import Batteries\n\nopen Std\n\ndef hasAsciiLower (s : String) : Bool :=\n  s.data.any (fun c => 'a' ≤ c && c ≤ 'z')\n\ndef hasAsciiUpper (s : String) : Bool :=\n  s.data.any (fun c => 'A' ≤ c && c ≤ 'Z')\n\ndef hasDigit (s : String) : Bool :=\n  s.data.any (fun c => '0' ≤ c && c ≤ '9')\n\ndef hasSpecial (s : String) : Bool :=\n  s.data.any (fun c => c = '$' || c = '#' || c = '@')\n\ndef hasWhitespace (s : String) : Bool :=\n  s.data.any (fun c => c.isWhitespace)\n\ndef pass_validity (p : String) : Bool :=\n  if p.length < 6 || p.length > 12 then\n    false\n  else if !hasAsciiLower p then\n    false\n  else if !hasDigit p then\n    false\n  else if !hasAsciiUpper p then\n    false\n  else if !hasSpecial p then\n    false\n  else if hasWhitespace p then\n    false\n  else\n    true\n\n#guard pass_validity \"password\" = false\n#guard pass_validity \"Password@10\" = true\n#guard pass_validity \"password@10\" = false\n", "test_list": ["#guard pass_validity \"password\" = false", "#guard pass_validity \"Password@10\" = true", "#guard pass_validity \"password@10\" = false"]}
{"text": "Write a function to check if the given string starts with a substring using regex.", "task_id": 823, "code": "import Batteries\n\nopen Std\n\ndef containsSubstr (s sub : String) : Bool := Id.run do\n  if sub.length == 0 then\n    return true\n  if s.length < sub.length then\n    return false\n  let limit := s.length - sub.length\n  for i in [0 : limit + 1] do\n    if (s.drop i).take sub.length == sub then\n      return true\n  return false\n\ndef check_substring (string sample : String) : String :=\n  if containsSubstr string sample then\n    let yStarts := (string.take sample.length) == sample\n    if yStarts then\n      \"string starts with the given substring\"\n    else\n      \"string doesnt start with the given substring\"\n  else\n    \"entered string isnt a substring\"\n\n#guard check_substring \"dreams for dreams makes life fun\" \"makes\" = \"string doesnt start with the given substring\"\n#guard check_substring \"Hi there how are you Hi alex\" \"Hi\" = \"string starts with the given substring\"\n#guard check_substring \"Its been a long day\" \"been\" = \"string doesnt start with the given substring\"\n", "test_list": ["#guard check_substring \"dreams for dreams makes life fun\" \"makes\" = \"string doesnt start with the given substring\"", "#guard check_substring \"Hi there how are you Hi alex\" \"Hi\" = \"string starts with the given substring\"", "#guard check_substring \"Its been a long day\" \"been\" = \"string doesnt start with the given substring\""]}
{"text": "Write a python function to remove even numbers from a given list.", "task_id": 824, "code": "import Batteries\nopen Std\n\ndef removeFirst (l : List Nat) (x : Nat) : List Nat :=\n  match l with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeFirst ys x\n\ndef getAt? {α : Type u} : List α → Nat → Option α\n  | [], _ => none\n  | x :: _, 0 => some x\n  | _ :: xs, Nat.succ j => getAt? xs j\n\ndef removeEven (l : List Nat) : List Nat := Id.run do\n  let mut arr := l\n  let mut idx := 0\n  while idx < arr.length do\n    match getAt? arr idx with\n    | none => break\n    | some i =>\n      if i % 2 == 0 then\n        arr := removeFirst arr i\n      idx := idx + 1\n  return arr\n\n#guard removeEven [1, 3, 5, 2] = [1, 3, 5]\n#guard removeEven [5, 6, 7] = [5, 7]\n#guard removeEven [1, 2, 3, 4] = [1, 3]\n", "test_list": ["#guard removeEven [1, 3, 5, 2] = [1, 3, 5]", "#guard removeEven [5, 6, 7] = [5, 7]", "#guard removeEven [1, 2, 3, 4] = [1, 3]"]}
{"text": "Write a python function to access multiple elements of specified index from a given list.", "task_id": 825, "code": "import Batteries\n\nopen Std\n\ndef accessElements (nums : List Nat) (listIndex : List Nat) : List Nat :=\n  \n  listIndex.map (fun i => nums.getD i 0)\n\n#guard accessElements [2,3,8,4,7,9] [0,3,5] = [2, 4, 9]\n#guard accessElements [1, 2, 3, 4, 5] [1,2] = [2,3]\n#guard accessElements [1,0,2,3] [0,1] = [1,0]\n", "test_list": ["#guard accessElements [2,3,8,4,7,9] [0,3,5] = [2, 4, 9]", "#guard accessElements [1, 2, 3, 4, 5] [1,2] = [2,3]", "#guard accessElements [1,0,2,3] [0,1] = [1,0]"]}
{"text": "Write a python function to find the type of triangle from the given sides.", "task_id": 826, "code": "import Batteries\n\nopen Std\n\ndef check_Type_Of_Triangle (a b c : Nat) : String :=\n  let sqa := a ^ 2\n  let sqb := b ^ 2\n  let sqc := c ^ 2\n  if (sqa == sqa + sqb) || (sqb == sqa + sqc) || (sqc == sqa + sqb) then\n    \"Right-angled Triangle\"\n  else if Nat.blt (sqc + sqb) sqa || Nat.blt (sqa + sqc) sqb || Nat.blt (sqa + sqb) sqc then\n    \"Obtuse-angled Triangle\"\n  else\n    \"Acute-angled Triangle\"\n\n#guard check_Type_Of_Triangle 1 2 3 == \"Obtuse-angled Triangle\"\n#guard check_Type_Of_Triangle 2 2 2 == \"Acute-angled Triangle\"\n#guard check_Type_Of_Triangle 1 0 1 == \"Right-angled Triangle\"\n", "test_list": ["#guard check_Type_Of_Triangle 1 2 3 == \"Obtuse-angled Triangle\"", "#guard check_Type_Of_Triangle 2 2 2 == \"Acute-angled Triangle\"", "#guard check_Type_Of_Triangle 1 0 1 == \"Right-angled Triangle\""]}
{"text": "Write a function to sum a specific column of a list in a given list of lists.", "task_id": 827, "code": "import Batteries\n\nopen Std\n\ndef sumColumn (list1 : List (List Nat)) (C : Nat) : Nat :=\n  list1.foldl (fun acc row => acc + row.getD C 0) 0\n\n#guard sumColumn [[1,2,3,2],[4,5,6,2],[7,8,9,5]] 0 = 12\n#guard sumColumn [[1,2,3,2],[4,5,6,2],[7,8,9,5]] 1 = 15\n#guard sumColumn [[1,2,3,2],[4,5,6,2],[7,8,9,5]] 3 = 9\n", "test_list": ["#guard sumColumn [[1,2,3,2],[4,5,6,2],[7,8,9,5]] 0 = 12", "#guard sumColumn [[1,2,3,2],[4,5,6,2],[7,8,9,5]] 1 = 15", "#guard sumColumn [[1,2,3,2],[4,5,6,2],[7,8,9,5]] 3 = 9"]}
{"text": "Write a function to count alphabets,digits and special charactes in a given string.", "task_id": 828, "code": "import Batteries\n\nopen Std\n\ndef inAsciiRange (c : Char) (lo hi : Char) : Bool :=\n  let n := c.toNat\n  let l := lo.toNat\n  let h := hi.toNat\n  Nat.ble l n && Nat.ble n h\n\ndef asciiIsAlpha (c : Char) : Bool :=\n  inAsciiRange c 'a' 'z' || inAsciiRange c 'A' 'Z'\n\ndef asciiIsDigit (c : Char) : Bool :=\n  inAsciiRange c '0' '9'\n\ndef countAlphaDigSpl (s : String) : Nat × Nat × Nat := Id.run do\n  let mut alphabets := 0\n  let mut digits := 0\n  let mut special := 0\n  for c in s.data do\n    if asciiIsAlpha c then\n      alphabets := alphabets + 1\n    else if asciiIsDigit c then\n      digits := digits + 1\n    else\n      special := special + 1\n  return (alphabets, digits, special)\n\n#guard countAlphaDigSpl \"abc!@#123\" = (3,3,3)\n#guard countAlphaDigSpl \"dgsuy@#$%&1255\" = (5,4,5)\n#guard countAlphaDigSpl \"fjdsif627348#%$^&\" = (6,6,5)\n", "test_list": ["#guard countAlphaDigSpl \"abc!@#123\" = (3,3,3)", "#guard countAlphaDigSpl \"dgsuy@#$%&1255\" = (5,4,5)", "#guard countAlphaDigSpl \"fjdsif627348#%$^&\" = (6,6,5)"]}
{"text": "Write a function to find out the second most repeated (or frequent) string in the given sequence.", "task_id": 829, "code": "import Batteries\nopen Std\n\ndef secondFrequent (input : List String) : String := Id.run do\n  \n  let rec inc (xs : List (String × Nat)) (k : String) : List (String × Nat) :=\n    match xs with\n    | [] => [(k, 1)]\n    | (k', n) :: t =>\n      if k = k' then\n        (k', n + 1) :: t\n      else\n        (k', n) :: inc t k\n  let mut m : List (String × Nat) := []\n  for s in input do\n    m := inc m s\n  \n  let mut max1 : Nat := 0\n  let mut max2 : Nat := 0\n  for p in m do\n    let c := p.snd\n    if c > max1 then\n      max2 := max1\n      max1 := c\n    else if c > max2 then\n      max2 := c\n  \n  for p in m do\n    let k := p.fst\n    let c := p.snd\n    if c == max2 then\n      return k\n  return \"\"\n\n#guard secondFrequent [\"aaa\",\"bbb\",\"ccc\",\"bbb\",\"aaa\",\"aaa\"] = \"bbb\"\n#guard secondFrequent [\"abc\",\"bcd\",\"abc\",\"bcd\",\"bcd\",\"bcd\"] = \"abc\"\n#guard secondFrequent [\"cdma\",\"gsm\",\"hspa\",\"gsm\",\"cdma\",\"cdma\"] = \"gsm\"\n", "test_list": ["#guard secondFrequent [\"aaa\",\"bbb\",\"ccc\",\"bbb\",\"aaa\",\"aaa\"] = \"bbb\"", "#guard secondFrequent [\"abc\",\"bcd\",\"abc\",\"bcd\",\"bcd\",\"bcd\"] = \"abc\"", "#guard secondFrequent [\"cdma\",\"gsm\",\"hspa\",\"gsm\",\"cdma\",\"cdma\"] = \"gsm\""]}
{"text": "Write a python function to count equal element pairs from the given array.", "task_id": 831, "code": "import Batteries\nopen Std\n\nprivate def getNth? {α} (xs : List α) (i : Nat) : Option α :=\n  match xs.drop i with\n  | [] => none\n  | a :: _ => some a\n\ndef count_Pairs (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let mut cnt := 0\n  for i in [0 : n] do\n    for j in [i+1 : n] do\n      match getNth? arr i, getNth? arr j with\n      | some vi, some vj =>\n        if decide (vi = vj) then\n          cnt := cnt + 1\n        else\n          ()\n      | _, _ => ()\n  return cnt\n\n#guard count_Pairs [1,1,1,1] 4 = 6\n#guard count_Pairs [1,5,1] 3 = 1\n#guard count_Pairs [3,2,1,7,8,9] 6 = 0\n", "test_list": ["#guard count_Pairs [1,1,1,1] 4 = 6", "#guard count_Pairs [1,5,1] 3 = 1", "#guard count_Pairs [3,2,1,7,8,9] 6 = 0"]}
{"text": "Write a function to extract the maximum numeric value from a string by using regex.", "task_id": 832, "code": "import Batteries\n\nopen Std\n\ndef isDigit (c : Char) : Bool := '0' ≤ c && c ≤ '9'\n\ndef extractMax (input : String) : Nat := Id.run do\n  let mut maxVal : Nat := 0\n  let mut curr : Nat := 0\n  let mut inNum : Bool := false\n  let mut found : Bool := false\n  for c in input.data do\n    if isDigit c then\n      curr := curr * 10 + (c.toNat - '0'.toNat)\n      inNum := true\n    else\n      if inNum then\n        if found then\n          maxVal := max maxVal curr\n        else\n          maxVal := curr\n          found := true\n        inNum := false\n        curr := 0\n  if inNum then\n    if found then\n      maxVal := max maxVal curr\n    else\n      maxVal := curr\n      found := true\n  return maxVal\n\n#guard extractMax \"100klh564abc365bg\" = 564\n#guard extractMax \"hello300how546mer231\" = 546\n#guard extractMax \"its233beenalong343journey234\" = 343\n", "test_list": ["#guard extractMax \"100klh564abc365bg\" = 564", "#guard extractMax \"hello300how546mer231\" = 546", "#guard extractMax \"its233beenalong343journey234\" = 343"]}
{"text": "Write a function to get dictionary keys as a list.", "task_id": 833, "code": "import Batteries\n\nopen Std\n\ndef get_key (dict : List (Nat × String)) : List Nat :=\n  dict.map (fun p => p.fst)\n\n#guard get_key [(1,\"python\"), (2,\"java\")] = [1, 2]\n#guard get_key [(10,\"red\"), (20,\"blue\"), (30,\"black\")] = [10, 20, 30]\n#guard get_key [(27,\"language\"), (39,\"java\"), (44,\"little\")] = [27, 39, 44]\n", "test_list": ["#guard get_key [(1,\"python\"), (2,\"java\")] = [1, 2]", "#guard get_key [(10,\"red\"), (20,\"blue\"), (30,\"black\")] = [10, 20, 30]", "#guard get_key [(27,\"language\"), (39,\"java\"), (44,\"little\")] = [27, 39, 44]"]}
{"text": "Write a function to generate a square matrix filled with elements from 1 to n raised to the power of 2 in spiral order.", "task_id": 834, "code": "import Batteries\nopen Std\n\ndef modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef generateMatrix (n : Nat) : List (List Nat) := Id.run do\n  if n == 0 then\n    return []\n  let mut matrix : Array (Array Nat) := Array.replicate n (Array.replicate n 0)\n  let mut rowSt : Int := 0\n  let mut rowEd : Int := (Int.ofNat n) - 1\n  let mut colSt : Int := 0\n  let mut colEd : Int := (Int.ofNat n) - 1\n  let mut current : Nat := 1\n  let n2 := n * n\n  while true do\n    if current > n2 then break\n    \n    let mut c : Int := colSt\n    while c ≤ colEd do\n      matrix := matrix.set2d? rowSt.toNat c.toNat current\n      current := current + 1\n      c := c + 1\n    rowSt := rowSt + 1\n    \n    let mut r : Int := rowSt\n    while r ≤ rowEd do\n      matrix := matrix.set2d? r.toNat colEd.toNat current\n      current := current + 1\n      r := r + 1\n    colEd := colEd - 1\n    \n    let mut c2 : Int := colEd\n    while c2 ≥ colSt do\n      matrix := matrix.set2d? rowEd.toNat c2.toNat current\n      current := current + 1\n      c2 := c2 - 1\n    rowEd := rowEd - 1\n    \n    let mut r2 : Int := rowEd\n    while r2 ≥ rowSt do\n      matrix := matrix.set2d? r2.toNat colSt.toNat current\n      current := current + 1\n      r2 := r2 - 1\n    colSt := colSt + 1\n  return matrix.toList.map (·.toList)\n\n#guard generateMatrix 3 == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]\n#guard generateMatrix 2 == [[1, 2], [4, 3]]\n#guard generateMatrix 7 == [[1, 2, 3, 4, 5, 6, 7], [24, 25, 26, 27, 28, 29, 8], [23, 40, 41, 42, 43, 30, 9], [22, 39, 48, 49, 44, 31, 10], [21, 38, 47, 46, 45, 32, 11], [20, 37, 36, 35, 34, 33, 12], [19, 18, 17, 16, 15, 14, 13]]\n", "test_list": ["#guard generateMatrix 3 == [[1, 2, 3], [8, 9, 4], [7, 6, 5]]", "#guard generateMatrix 2 == [[1, 2], [4, 3]]", "#guard generateMatrix 7 == [[1, 2, 3, 4, 5, 6, 7], [24, 25, 26, 27, 28, 29, 8], [23, 40, 41, 42, 43, 30, 9], [22, 39, 48, 49, 44, 31, 10], [21, 38, 47, 46, 45, 32, 11], [20, 37, 36, 35, 34, 33, 12], [19, 18, 17, 16, 15, 14, 13]]"]}
{"text": "Write a python function to find the slope of a line.", "task_id": 835, "code": "import Batteries\n\nopen Std\n\ndef slope (x1 y1 x2 y2 : Int) : Float :=\n  (Float.ofInt (y2 - y1)) / (Float.ofInt (x2 - x1))\n\n#guard slope 4 2 2 5 == (-1.5)\n#guard slope 2 4 4 6 == 1\n#guard slope 1 2 4 2 == 0\n", "test_list": ["#guard slope 4 2 2 5 == (-1.5)", "#guard slope 2 4 4 6 == 1", "#guard slope 1 2 4 2 == 0"]}
{"text": "Write a function to find length of the subarray having maximum sum.", "task_id": 836, "code": "import Batteries\nopen Std\n\ndef nthIntD (xs : List Int) (i : Nat) (d : Int) : Int :=\n  match xs, i with\n  | [], _ => d\n  | x :: _, 0 => x\n  | _ :: xs', Nat.succ j => nthIntD xs' j d\n\ndef max_sub_array_sum (a : List Int) (size : Nat) : Nat := Id.run do\n  \n  let mut max_so_far : Int := -1000000000000000000\n  let mut max_ending_here : Int := 0\n  let mut start : Nat := 0\n  let mut endIdx : Nat := 0\n  let mut s : Nat := 0\n  for i in [0 : size] do\n    let v := nthIntD a i 0\n    max_ending_here := max_ending_here + v\n    if max_so_far < max_ending_here then\n      max_so_far := max_ending_here\n      start := s\n      endIdx := i\n    if max_ending_here < 0 then\n      max_ending_here := 0\n      s := i + 1\n  return endIdx - start + 1\n\n#guard max_sub_array_sum [-2, -3, 4, -1, -2, 1, 5, -3] 8 = 5\n#guard max_sub_array_sum [1, -2, 1, 1, -2, 1] 6 = 2\n#guard max_sub_array_sum [-1, -2, 3, 4, 5] 5 = 3\n", "test_list": ["#guard max_sub_array_sum [-2, -3, 4, -1, -2, 1, 5, -3] 8 = 5", "#guard max_sub_array_sum [1, -2, 1, 1, -2, 1] 6 = 2", "#guard max_sub_array_sum [-1, -2, 3, 4, 5] 5 = 3"]}
{"text": "Write a python function to find the cube sum of first n odd natural numbers.", "task_id": 837, "code": "import Batteries\n\nopen Std\n\ndef cube_Sum (n : Nat) : Nat := Id.run do\n  let mut s := 0\n  for i in [: n] do\n    s := s + (2*i + 1) * (2*i + 1) * (2*i + 1)\n  return s\n\n#guard cube_Sum 2 == 28\n#guard cube_Sum 3 == 153\n#guard cube_Sum 4 == 496\n", "test_list": ["#guard cube_Sum 2 == 28", "#guard cube_Sum 3 == 153", "#guard cube_Sum 4 == 496"]}
{"text": "Write a python function to find minimum number swaps required to make two binary strings equal.", "task_id": 838, "code": "import Batteries\n\nopen Std\n\ndef min_Swaps (s1 s2 : String) : Int :=\n  let rec loop (l1 l2 : List Char) (c0 c1 : Nat) : Nat × Nat :=\n    match l1, l2 with\n    | c :: t1, d :: t2 =>\n      let c0' := if (c == '0' && d == '1') then c0 + 1 else c0\n      let c1' := if (c == '1' && d == '0') then c1 + 1 else c1\n      loop t1 t2 c0' c1'\n    | _, _ => (c0, c1)\n  let (c0, c1) := loop s1.data s2.data 0 0\n  let result : Nat := c0 / 2 + c1 / 2\n  if c0 % 2 == 0 && c1 % 2 == 0 then\n    Int.ofNat result\n  else if (c0 + c1) % 2 == 0 then\n    Int.ofNat (result + 2)\n  else\n    (-1)\n\n#guard min_Swaps \"0011\" \"1111\" = (1 : Int)\n#guard min_Swaps \"00011\" \"01001\" = (2 : Int)\n#guard min_Swaps \"111\" \"111\" = (0 : Int)\n", "test_list": ["#guard min_Swaps \"0011\" \"1111\" = (1 : Int)", "#guard min_Swaps \"00011\" \"01001\" = (2 : Int)", "#guard min_Swaps \"111\" \"111\" = (0 : Int)"]}
{"text": "Write a function to sort the tuples alphabetically by the first item of each tuple.", "task_id": 839, "code": "import Batteries\nopen Std\n\ndef bubblePass (l : List (String × Sum Nat String)) : List (String × Sum Nat String) :=\n  match l with\n  | [] => []\n  | [a] => [a]\n  | a :: b :: rest =>\n    match compare a.fst b.fst with\n    | .gt => b :: bubblePass (a :: rest)\n    | _ => a :: bubblePass (b :: rest)\n\ndef sortTuple (tup : List (String × Sum Nat String)) : List (String × Sum Nat String) :=\n  let rec loop (k : Nat) (l : List (String × Sum Nat String)) : List (String × Sum Nat String) :=\n    match k with\n    | 0 => l\n    | k+1 => loop k (bubblePass l)\n  loop tup.length tup\n\n#guard sortTuple [(\"Amana\", .inl 28), (\"Zenat\", .inl 30), (\"Abhishek\", .inl 29), (\"Nikhil\", .inl 21), (\"B\", .inr \"C\")] = [(\"Abhishek\", .inl 29), (\"Amana\", .inl 28), (\"B\", .inr \"C\"), (\"Nikhil\", .inl 21), (\"Zenat\", .inl 30)]\n#guard sortTuple [(\"aaaa\", .inl 28), (\"aa\", .inl 30), (\"bab\", .inl 29), (\"bb\", .inl 21), (\"csa\", .inr \"C\")] = [(\"aa\", .inl 30), (\"aaaa\", .inl 28), (\"bab\", .inl 29), (\"bb\", .inl 21), (\"csa\", .inr \"C\")]\n#guard sortTuple [(\"Sarala\", .inl 28), (\"Ayesha\", .inl 30), (\"Suman\", .inl 29), (\"Sai\", .inl 21), (\"G\", .inr \"H\")] = [(\"Ayesha\", .inl 30), (\"G\", .inr \"H\"), (\"Sai\", .inl 21), (\"Sarala\", .inl 28), (\"Suman\", .inl 29)]\n", "test_list": ["#guard sortTuple [(\"Amana\", .inl 28), (\"Zenat\", .inl 30), (\"Abhishek\", .inl 29), (\"Nikhil\", .inl 21), (\"B\", .inr \"C\")] = [(\"Abhishek\", .inl 29), (\"Amana\", .inl 28), (\"B\", .inr \"C\"), (\"Nikhil\", .inl 21), (\"Zenat\", .inl 30)]", "#guard sortTuple [(\"aaaa\", .inl 28), (\"aa\", .inl 30), (\"bab\", .inl 29), (\"bb\", .inl 21), (\"csa\", .inr \"C\")] = [(\"aa\", .inl 30), (\"aaaa\", .inl 28), (\"bab\", .inl 29), (\"bb\", .inl 21), (\"csa\", .inr \"C\")]", "#guard sortTuple [(\"Sarala\", .inl 28), (\"Ayesha\", .inl 30), (\"Suman\", .inl 29), (\"Sai\", .inl 21), (\"G\", .inr \"H\")] = [(\"Ayesha\", .inl 30), (\"G\", .inr \"H\"), (\"Sai\", .inl 21), (\"Sarala\", .inl 28), (\"Suman\", .inl 29)]"]}
{"text": "Write a python function to check whether the roots of a quadratic equation are numerically equal but opposite in sign or not.", "task_id": 840, "code": "import Batteries\n\nopen Std\n\ndef Check_Solution (a b c : Int) : String :=\n  if b == 0 then \"Yes\" else \"No\"\n\n#guard Check_Solution 2 0 (-1) == \"Yes\"\n#guard Check_Solution 1 (-5) 6 == \"No\"\n#guard Check_Solution 2 0 2 == \"Yes\"\n", "test_list": ["#guard Check_Solution 2 0 (-1) == \"Yes\"", "#guard Check_Solution 1 (-5) 6 == \"No\"", "#guard Check_Solution 2 0 2 == \"Yes\""]}
{"text": "Write a function to count the number of inversions in the given array.", "task_id": 841, "code": "import Batteries\n\nopen Std\n\ndef getInvCount (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let mut invCount := 0\n  for i in [: n] do\n    for j in [i+1 : n] do\n      let ai := arr.getD i 0\n      let aj := arr.getD j 0\n      if Nat.blt aj ai then\n        invCount := invCount + 1\n  return invCount\n\n#guard getInvCount [1, 20, 6, 4, 5] 5 = 5\n#guard getInvCount [8, 4, 2, 1] 4 = 6\n#guard getInvCount [3, 1, 2] 3 = 2\n", "test_list": ["#guard getInvCount [1, 20, 6, 4, 5] 5 = 5", "#guard getInvCount [8, 4, 2, 1] 4 = 6", "#guard getInvCount [3, 1, 2] 3 = 2"]}
{"text": "Write a function to find the number which occurs for odd number of times in the given array.", "task_id": 842, "code": "import Batteries\n\nopen Std\n\ndef get_odd_occurence (arr : List Int) (arr_size : Nat) : Int := Id.run do\n  \n  let a := arr.toArray\n  for i in [0 : arr_size] do\n    let ai := a[i]!\n    let mut count : Nat := 0\n    for j in [0 : arr_size] do\n      if ai == a[j]! then\n        count := count + 1\n    if count % 2 != 0 then\n      return ai\n  return (-1 : Int)\n\n#guard get_odd_occurence ([2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2] : List Int) 13 = 5\n#guard get_odd_occurence ([1, 2, 3, 2, 3, 1, 3] : List Int) 7 = 3\n#guard get_odd_occurence ([5, 7, 2, 7, 5, 2, 5] : List Int) 7 = 5\n", "test_list": ["#guard get_odd_occurence ([2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2] : List Int) 13 = 5", "#guard get_odd_occurence ([1, 2, 3, 2, 3, 1, 3] : List Int) 7 = 3", "#guard get_odd_occurence ([5, 7, 2, 7, 5, 2, 5] : List Int) 7 = 5"]}
{"text": "Write a function to find the nth super ugly number from a given prime list of size k using heap queue algorithm.", "task_id": 843, "code": "import Batteries\n\nopen Std\n\ndef nthSuperUglyNumber (n : Nat) (primes : List Nat) : Nat := Id.run do\n  \n  \n  let k := primes.length\n  let primesArr := primes.toArray\n  let mut idx : Array Nat := Array.replicate k 0\n  let mut uglies : Array Nat := #[1]\n  \n  for _ in [1 : n] do\n    \n    let mut minVal := primesArr[0]! * uglies[idx[0]!]!\n    for j in [1 : k] do\n      let p := primesArr[j]!\n      let i := idx[j]!\n      let u := uglies[i]!\n      let cand := p * u\n      if cand < minVal then\n        minVal := cand\n    \n    let last := uglies[uglies.size - 1]!\n    if minVal != last then\n      uglies := uglies.push minVal\n    \n    for j in [0 : k] do\n      let p := primesArr[j]!\n      let i := idx[j]!\n      let u := uglies[i]!\n      if p * u == minVal then\n        idx := idx.set! j (i + 1)\n  return uglies[n - 1]!\n\n#guard nthSuperUglyNumber 12 [2, 7, 13, 19] = 32\n#guard nthSuperUglyNumber 10 [2, 7, 13, 19] = 26\n#guard nthSuperUglyNumber 100 [2, 7, 13, 19] = 5408\n", "test_list": ["#guard nthSuperUglyNumber 12 [2, 7, 13, 19] = 32", "#guard nthSuperUglyNumber 10 [2, 7, 13, 19] = 26", "#guard nthSuperUglyNumber 100 [2, 7, 13, 19] = 5408"]}
{"text": "Write a python function to find the kth element in an array containing odd elements first and then even elements.", "task_id": 844, "code": "import Batteries\n\nopen Std\n\ndef getNumber (n k : Nat) : Nat := Id.run do\n  let mut arr := Array.replicate n 0\n  let mut i := 0\n  let countOdds := (n + 1) / 2\n  for j in [: countOdds] do\n    arr := arr.set! i (2 * j + 1)\n    i := i + 1\n  let countEvens := n / 2\n  for j in [: countEvens] do\n    arr := arr.set! i (2 * (j + 1))\n    i := i + 1\n  return arr[k - 1]!\n\n#guard getNumber 8 5 = 2\n#guard getNumber 7 2 = 3\n#guard getNumber 5 2 = 3\n", "test_list": ["#guard getNumber 8 5 = 2", "#guard getNumber 7 2 = 3", "#guard getNumber 5 2 = 3"]}
{"text": "Write a python function to count the number of digits in factorial of a given number.", "task_id": 845, "code": "import Batteries\n\nopen Std\n\ndef natDigitsCount (n : Nat) : Nat :=\n  if n == 0 then 1 else\n  Id.run do\n    let mut x := n\n    let mut c := 0\n    while x != 0 do\n      c := c + 1\n      x := x / 10\n    return c\n\ndef factorial (n : Nat) : Nat := Id.run do\n  let mut acc := 1\n  for k in [1 : n+1] do\n    acc := acc * k\n  return acc\n\ndef findDigits (n : Int) : Nat :=\n  if n < 0 then 0\n  else\n    let nn := Int.toNat n\n    if nn <= 1 then 1\n    else natDigitsCount (factorial nn)\n\n#guard findDigits 7 = 4\n#guard findDigits 5 = 3\n#guard findDigits 4 = 2\n", "test_list": ["#guard findDigits 7 = 4", "#guard findDigits 5 = 3", "#guard findDigits 4 = 2"]}
{"text": "Write a function to find the minimum number of platforms required for a railway/bus station.", "task_id": 846, "code": "import Batteries\nopen Std\n\ndef insertOrdered (x : Nat) (l : List Nat) : List Nat :=\n  match l with\n  | [] => [x]\n  | y :: ys => if x ≤ y then x :: l else y :: insertOrdered x ys\n\ndef isort (l : List Nat) : List Nat :=\n  l.foldl (fun acc x => insertOrdered x acc) []\n\ndef listGetD {α} (l : List α) (i : Nat) (d : α) : α :=\n  match l, i with\n  | [], _ => d\n  | x :: _, 0 => x\n  | _ :: xs, i+1 => listGetD xs i d\n\ndef findPlatform (arr dep : List Nat) (n : Nat) : Nat := Id.run do\n  let arrS := isort arr\n  let depS := isort dep\n  let mut plat_needed : Int := 1\n  let mut result : Int := 1\n  let mut i : Nat := 1\n  let mut j : Nat := 0\n  while decide (i < n) && decide (j < n) do\n    let ai := listGetD arrS i 0\n    let dj := listGetD depS j 0\n    if ai ≤ dj then\n      plat_needed := plat_needed + 1\n      i := i + 1\n    else\n      plat_needed := plat_needed - 1\n      j := j + 1\n    if plat_needed > result then\n      result := plat_needed\n  return Int.toNat result\n\n#guard findPlatform [900, 940, 950, 1100, 1500, 1800] [910, 1200, 1120, 1130, 1900, 2000] 6 = 3\n#guard findPlatform [100,200,300,400] [700,800,900,1000] 4 = 4\n#guard findPlatform [5,6,7,8] [4,3,2,1] 4 = 1\n", "test_list": ["#guard findPlatform [900, 940, 950, 1100, 1500, 1800] [910, 1200, 1120, 1130, 1900, 2000] 6 = 3", "#guard findPlatform [100,200,300,400] [700,800,900,1000] 4 = 4", "#guard findPlatform [5,6,7,8] [4,3,2,1] 4 = 1"]}
{"text": "Write a python function to copy a list from a singleton tuple.", "task_id": 847, "code": "import Batteries\n\nopen Std\n\ndef lcopy (xs : List Nat) : List Nat :=\n  \n  xs\n\n#guard lcopy [1, 2, 3] = [1, 2, 3]\n#guard lcopy [4, 8, 2, 10, 15, 18] = [4, 8, 2, 10, 15, 18]\n#guard lcopy [4, 5, 6] = [4, 5, 6]\n", "test_list": ["#guard lcopy [1, 2, 3] = [1, 2, 3]", "#guard lcopy [4, 8, 2, 10, 15, 18] = [4, 8, 2, 10, 15, 18]", "#guard lcopy [4, 5, 6] = [4, 5, 6]"]}
{"text": "Write a function to find the area of a trapezium.", "task_id": 848, "code": "import Batteries\n\nopen Std\n\ndef areaTrapezium (base1 base2 height : Nat) : Nat :=\n  ((base1 + base2) * height) / 2\n\n#guard areaTrapezium 6 9 4 = 30\n#guard areaTrapezium 10 20 30 = 450\n#guard areaTrapezium 15 25 35 = 700\n", "test_list": ["#guard areaTrapezium 6 9 4 = 30", "#guard areaTrapezium 10 20 30 = 450", "#guard areaTrapezium 15 25 35 = 700"]}
{"text": "Write a python function to find sum of all prime divisors of a given number.", "task_id": 849, "code": "import Batteries\n\nopen Std\n\ndef sum (N : Nat) : Nat := Id.run do\n  let mut sumOfPrimeDivisors := Array.replicate (N + 1) 0\n  for i in [2 : N + 1] do\n    if sumOfPrimeDivisors[i]! == 0 then\n      let mut j := i\n      while h : j ≤ N do\n        sumOfPrimeDivisors := sumOfPrimeDivisors.set! j (sumOfPrimeDivisors[j]! + i)\n        j := j + i\n  return sumOfPrimeDivisors[N]!\n\n#guard sum 60 = 10\n#guard sum 39 = 16\n#guard sum 40 = 7\n", "test_list": ["#guard sum 60 = 10", "#guard sum 39 = 16", "#guard sum 40 = 7"]}
{"text": "Write a function to check if a triangle of positive area is possible with the given angles.", "task_id": 850, "code": "import Batteries\n\nopen Std\n\ndef isTriangleexists (a b c : Nat) : Bool :=\n  if a != 0 && b != 0 && c != 0 && (a + b + c == 180) then\n    if Nat.ble c (a + b) || Nat.ble a (b + c) || Nat.ble b (a + c) then true else false\n  else\n    false\n\n#guard isTriangleexists 50 60 70 == true\n#guard isTriangleexists 90 45 45 == true\n#guard isTriangleexists 150 30 70 == false\n", "test_list": ["#guard isTriangleexists 50 60 70 == true", "#guard isTriangleexists 90 45 45 == true", "#guard isTriangleexists 150 30 70 == false"]}
{"text": "Write a python function to find sum of inverse of divisors.", "task_id": 851, "code": "import Batteries\n\nopen Std\n\ndef Sum_of_Inverse_Divisors (N Sum : Nat) : Float :=\n  \n  let numerator := Sum * 100\n  let rounded := (numerator + N / 2) / N\n  (Float.ofNat rounded) / 100.0\n\n#guard Sum_of_Inverse_Divisors 6 12 == (2.0 : Float)\n#guard Sum_of_Inverse_Divisors 9 13 == (1.44 : Float)\n#guard Sum_of_Inverse_Divisors 1 4 == (4.0 : Float)\n", "test_list": ["#guard Sum_of_Inverse_Divisors 6 12 == (2.0 : Float)", "#guard Sum_of_Inverse_Divisors 9 13 == (1.44 : Float)", "#guard Sum_of_Inverse_Divisors 1 4 == (4.0 : Float)"]}
{"text": "Write a python function to remove negative numbers from a list.", "task_id": 852, "code": "import Batteries\n\nopen Std\n\ndef removeFirst (l : List Int) (x : Int) : List Int :=\n  match l with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeFirst ys x\n\ndef removeNegs (num_list : List Int) : List Int := Id.run do\n  let mut curr := num_list\n  for item in num_list do\n    if item < 0 then\n      curr := removeFirst curr item\n    else\n      ()\n  return curr\n\n#guard removeNegs [1, -2, 3, -4] = [1, 3]\n#guard removeNegs [1, 2, 3, -4] = [1, 2, 3]\n#guard removeNegs [4, 5, -6, 7, -8] = [4, 5, 7]\n", "test_list": ["#guard removeNegs [1, -2, 3, -4] = [1, 3]", "#guard removeNegs [1, 2, 3, -4] = [1, 2, 3]", "#guard removeNegs [4, 5, -6, 7, -8] = [4, 5, 7]"]}
{"text": "Write a python function to find sum of odd factors of a number.", "task_id": 853, "code": "import Batteries\n\nopen Std\n\ndef sumOfOddFactors (n : Nat) : Nat := Id.run do\n  \n  let mut m := n\n  let mut res := 1\n  while m % 2 == 0 do\n    m := m / 2\n  let ub := Nat.sqrt m + 1\n  for i in [3 : ub] do\n    let mut count := 0\n    let mut curr_sum := 1\n    let mut curr_term := 1\n    while m % i == 0 do\n      count := count + 1\n      m := m / i\n      curr_term := curr_term * i\n      curr_sum := curr_sum + curr_term\n    res := res * curr_sum\n  if m >= 2 then\n    res := res * (1 + m)\n  return res\n\n#guard sumOfOddFactors 30 = 24\n#guard sumOfOddFactors 18 = 13\n#guard sumOfOddFactors 2 = 1\n", "test_list": ["#guard sumOfOddFactors 30 = 24", "#guard sumOfOddFactors 18 = 13", "#guard sumOfOddFactors 2 = 1"]}
{"text": "Write a function which accepts an arbitrary list and converts it to a heap using heap queue algorithm.", "task_id": 854, "code": "import Batteries\nopen Std\n\ndef siftDown (a : Array Nat) (start n : Nat) : Array Nat := Id.run do\n  let mut arr := a\n  let x := arr[start]!\n  let mut i := start\n  let mut j := 2 * i + 1\n  while j < n do\n    let mut smallest := j\n    if j + 1 < n then\n      if arr[j + 1]! < arr[j]! then\n        smallest := j + 1\n    if arr[smallest]! < x then\n      arr := Array.set! arr i (arr[smallest]!)\n      i := smallest\n      j := 2 * i + 1\n    else\n      break\n  arr := Array.set! arr i x\n  return arr\n\ndef rawHeap (rawheap : List Nat) : List Nat := Id.run do\n  let mut arr := rawheap.toArray\n  let n := arr.size\n  let mut i := n / 2\n  while i > 0 do\n    i := i - 1\n    arr := siftDown arr i n\n  return arr.toList\n\n#guard rawHeap [25, 44, 68, 21, 39, 23, 89] == [21, 25, 23, 44, 39, 68, 89]\n#guard rawHeap [25, 35, 22, 85, 14, 65, 75, 25, 58] == [14, 25, 22, 25, 35, 65, 75, 85, 58]\n#guard rawHeap [4, 5, 6, 2] == [2, 4, 6, 5]\n", "test_list": ["#guard rawHeap [25, 44, 68, 21, 39, 23, 89] == [21, 25, 23, 44, 39, 68, 89]", "#guard rawHeap [25, 35, 22, 85, 14, 65, 75, 25, 58] == [14, 25, 22, 25, 35, 65, 75, 85, 58]", "#guard rawHeap [4, 5, 6, 2] == [2, 4, 6, 5]"]}
{"text": "Write a python function to check for even parity of a given number.", "task_id": 855, "code": "import Batteries\n\nopen Std\n\ndef checkEvenParity (x : Nat) : Bool := Id.run do\n  let mut x := x\n  let mut parity := 0\n  while x != 0 do\n    x := x &&& (x - 1)\n    parity := parity + 1\n  if parity % 2 == 0 then\n    return true\n  else\n    return false\n\n#guard checkEvenParity 10 == true\n#guard checkEvenParity 11 == false\n#guard checkEvenParity 18 == true\n", "test_list": ["#guard checkEvenParity 10 == true", "#guard checkEvenParity 11 == false", "#guard checkEvenParity 18 == true"]}
{"text": "Write a python function to find minimum adjacent swaps required to sort binary array.", "task_id": 856, "code": "import Batteries\nopen Std\n\ndef find_Min_Swaps (arr : List Nat) (n : Nat) : Nat :=\n  let xs := (arr.take n).reverse\n  let rec go (xs : List Nat) (zeros acc : Nat) : Nat :=\n    match xs with\n    | [] => acc\n    | x :: xs' =>\n      if x = 0 then\n        go xs' (zeros + 1) acc\n      else if x = 1 then\n        go xs' zeros (acc + zeros)\n      else\n        go xs' zeros acc\n  go xs 0 0\n\n#guard find_Min_Swaps [1,0,1,0] 4 = 3\n#guard find_Min_Swaps [0,1,0] 3 = 1\n#guard find_Min_Swaps [0,0,1,1,0] 5 = 2\n", "test_list": ["#guard find_Min_Swaps [1,0,1,0] 4 = 3", "#guard find_Min_Swaps [0,1,0] 3 = 1", "#guard find_Min_Swaps [0,0,1,1,0] 5 = 2"]}
{"text": "Write a function to list out the list of given strings individually using map function.", "task_id": 857, "code": "import Batteries\n\nopen Std\n\ndef listifyList (list1 : List String) : List (List String) :=\n  list1.map (fun s => s.data.map (fun c => String.singleton c))\n\n#guard listifyList [\"Red\", \"Blue\", \"Black\", \"White\", \"Pink\"] == [[\"R\", \"e\", \"d\"], [\"B\", \"l\", \"u\", \"e\"], [\"B\", \"l\", \"a\", \"c\", \"k\"], [\"W\", \"h\", \"i\", \"t\", \"e\"], [\"P\", \"i\", \"n\", \"k\"]]\n#guard listifyList [\"python\"] == [[\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]]\n#guard listifyList [\" red \", \"green\", \" black\", \"blue \", \" orange\", \"brown\"] == [[\" \", \"r\", \"e\", \"d\", \" \"], [\"g\", \"r\", \"e\", \"e\", \"n\"], [\" \", \"b\", \"l\", \"a\", \"c\", \"k\"], [\"b\", \"l\", \"u\", \"e\", \" \"], [\" \", \"o\", \"r\", \"a\", \"n\", \"g\", \"e\"], [\"b\", \"r\", \"o\", \"w\", \"n\"]]\n", "test_list": ["#guard listifyList [\"Red\", \"Blue\", \"Black\", \"White\", \"Pink\"] == [[\"R\", \"e\", \"d\"], [\"B\", \"l\", \"u\", \"e\"], [\"B\", \"l\", \"a\", \"c\", \"k\"], [\"W\", \"h\", \"i\", \"t\", \"e\"], [\"P\", \"i\", \"n\", \"k\"]]", "#guard listifyList [\"python\"] == [[\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]]", "#guard listifyList [\" red \", \"green\", \" black\", \"blue \", \" orange\", \"brown\"] == [[\" \", \"r\", \"e\", \"d\", \" \"], [\"g\", \"r\", \"e\", \"e\", \"n\"], [\" \", \"b\", \"l\", \"a\", \"c\", \"k\"], [\"b\", \"l\", \"u\", \"e\", \" \"], [\" \", \"o\", \"r\", \"a\", \"n\", \"g\", \"e\"], [\"b\", \"r\", \"o\", \"w\", \"n\"]]"]}
{"text": "Write a function to count number of lists in a given list of lists and square the count.", "task_id": 858, "code": "import Batteries\n\nopen Std\n\ndef countList {α : Type} (input_list : List (List α)) : Nat :=\n  let n := input_list.length\n  n * n\n\n#guard countList [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] == 25\n#guard countList [[1, 3], [5, 7], [9, 11], [13, 15, 17]] == 16\n#guard countList [[[2, 4]], [[6, 8], [4, 5, 8]], [[10, 12, 14]]] == 9\n", "test_list": ["#guard countList [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]] == 25", "#guard countList [[1, 3], [5, 7], [9, 11], [13, 15, 17]] == 16", "#guard countList [[[2, 4]], [[6, 8], [4, 5, 8]], [[10, 12, 14]]] == 9"]}
{"text": "Write a function to generate all sublists of a given list.", "task_id": 859, "code": "import Batteries\n\nopen Std\n\ndef combinations {α} (xs : List α) (k : Nat) : List (List α) :=\n  match xs, k with\n  | _, 0 => [[]]\n  | [], _ => []\n  | x :: xs', Nat.succ k' =>\n      (combinations xs' k' |>.map (fun ys => x :: ys)) ++ (combinations xs' (Nat.succ k'))\n\ndef subLists {α} (myList : List α) : List (List α) := Id.run do\n  let mut subs : List (List α) := []\n  let len := myList.length\n  for i in [0 : len + 1] do\n    let temp := combinations myList i\n    if temp.length > 0 then\n      subs := subs ++ temp\n  return subs\n\n#guard subLists [10, 20, 30, 40] == [[], [10], [20], [30], [40], [10, 20], [10, 30], [10, 40], [20, 30], [20, 40], [30, 40], [10, 20, 30], [10, 20, 40], [10, 30, 40], [20, 30, 40], [10, 20, 30, 40]]\n#guard subLists [\"X\", \"Y\", \"Z\"] == [[], [\"X\"], [\"Y\"], [\"Z\"], [\"X\", \"Y\"], [\"X\", \"Z\"], [\"Y\", \"Z\"], [\"X\", \"Y\", \"Z\"]]\n#guard subLists [1, 2, 3] == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n", "test_list": ["#guard subLists [10, 20, 30, 40] == [[], [10], [20], [30], [40], [10, 20], [10, 30], [10, 40], [20, 30], [20, 40], [30, 40], [10, 20, 30], [10, 20, 40], [10, 30, 40], [20, 30, 40], [10, 20, 30, 40]]", "#guard subLists [\"X\", \"Y\", \"Z\"] == [[], [\"X\"], [\"Y\"], [\"Z\"], [\"X\", \"Y\"], [\"X\", \"Z\"], [\"Y\", \"Z\"], [\"X\", \"Y\", \"Z\"]]", "#guard subLists [1, 2, 3] == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]"]}
{"text": "Write a function to check whether the given string is ending with only alphanumeric characters or not using regex.", "task_id": 860, "code": "import Batteries\n\nopen Std\n\ndef isAsciiAlphaNum (c : Char) : Bool :=\n  let n := c.toNat\n  ((n >= 'a'.toNat && n <= 'z'.toNat) ||\n   (n >= 'A'.toNat && n <= 'Z'.toNat) ||\n   (n >= '0'.toNat && n <= '9'.toNat))\n\ndef checkAlphanumeric (string : String) : String :=\n  let lastStr := string.drop (string.length - 1)\n  match lastStr.toList.head? with\n  | some c => if isAsciiAlphaNum c then \"Accept\" else \"Discard\"\n  | none => \"Discard\"\n\n#guard checkAlphanumeric \"dawood@\" = \"Discard\"\n#guard checkAlphanumeric \"skdmsam326\" = \"Accept\"\n#guard checkAlphanumeric \"cooltricks@\" = \"Discard\"\n", "test_list": ["#guard checkAlphanumeric \"dawood@\" = \"Discard\"", "#guard checkAlphanumeric \"skdmsam326\" = \"Accept\"", "#guard checkAlphanumeric \"cooltricks@\" = \"Discard\""]}
{"text": "Write a function to find all anagrams of a string in a given list of strings using lambda function.", "task_id": 861, "code": "import Batteries\nopen Std\n\nprivate def insertChar (x : Char) (xs : List Char) : List Char :=\n  match xs with\n  | [] => [x]\n  | y :: ys =>\n    if x < y then\n      x :: y :: ys\n    else\n      y :: insertChar x ys\n\nprivate def sortChars (xs : List Char) : List Char :=\n  match xs with\n  | [] => []\n  | x :: xr => insertChar x (sortChars xr)\n\nprivate def sortString (s : String) : String :=\n  String.mk (sortChars s.data)\n\ndef isAnagram (a b : String) : Bool :=\n  if a.length != b.length then\n    false\n  else\n    sortString a == sortString b\n\ndef anagram_lambda (texts : List String) (str : String) : List String :=\n  texts.filter (fun x => isAnagram str x)\n\n#guard anagram_lambda [\"bcda\", \"abce\", \"cbda\", \"cbea\", \"adcb\"] \"abcd\" = [\"bcda\", \"cbda\", \"adcb\"]\n#guard anagram_lambda [\"recitals\", \" python\"] \"articles\" = [\"recitals\"]\n#guard anagram_lambda [\" keep\", \" abcdef\", \" xyz\"] \" peek\" = [\" keep\"]\n", "test_list": ["#guard anagram_lambda [\"bcda\", \"abce\", \"cbda\", \"cbea\", \"adcb\"] \"abcd\" = [\"bcda\", \"cbda\", \"adcb\"]", "#guard anagram_lambda [\"recitals\", \" python\"] \"articles\" = [\"recitals\"]", "#guard anagram_lambda [\" keep\", \" abcdef\", \" xyz\"] \" peek\" = [\" keep\"]"]}
{"text": "Write a function to find the occurrences of n most common words in a given text.", "task_id": 862, "code": "import Batteries\nopen Std\n\ndef tokenize (text : String) : List String :=\n  (text.splitOn \" \").filter (fun x => x ≠ \"\")\n\ndef better (a b : String × Nat × Nat) : Bool :=\n  match a, b with\n  | (_, ca, ia), (_, cb, ib) =>\n    if ca > cb then true\n    else if ca < cb then false\n    else ia < ib\n\ndef pickBest (xs : List (String × Nat × Nat)) : Option (String × Nat × Nat) :=\n  match xs with\n  | [] => none\n  | x :: xs' => some (xs'.foldl (fun best y => if better y best then y else best) x)\n\ndef removeByKey (xs : List (String × Nat × Nat)) (k : String) : List (String × Nat × Nat) :=\n  match xs with\n  | [] => []\n  | (w,c,i) :: xs' => if w == k then xs' else (w,c,i) :: removeByKey xs' k\n\ndef findVal (m : Std.HashMap String Nat) (k : String) : Option Nat :=\n  let rec go (ls : List (String × Nat)) : Option Nat :=\n    match ls with\n    | [] => none\n    | (k', v) :: tl => if k' == k then some v else go tl\n  go m.toList\n\ndef nCommonWords (text : String) (n : Nat) : List (String × Nat) := Id.run do\n  let words := tokenize text\n  let mut cnt : Std.HashMap String Nat := {}\n  let mut first : Std.HashMap String Nat := {}\n  let mut idx : Nat := 0\n  for w in words do\n    let c := (findVal cnt w).getD 0\n    cnt := cnt.insert w (c + 1)\n    if (findVal first w).isSome then\n      ()\n    else\n      first := first.insert w idx\n    idx := idx + 1\n  let triples : List (String × Nat × Nat) :=\n    cnt.toList.map (fun (kv : String × Nat) =>\n      let w := kv.fst\n      let c := kv.snd\n      let i := (findVal first w).getD 0\n      (w, c, i))\n  let mut xs := triples\n  let mut res : List (String × Nat) := []\n  for _ in [: n] do\n    match pickBest xs with\n    | none => break\n    | some (w,c,_) =>\n      res := res ++ [(w, c)]\n      xs := removeByKey xs w\n  return res\n\n#guard nCommonWords \"python is a programming language\" 1 == [(\"python\", 1)]\n#guard nCommonWords \"python is a programming language\" 1 == [(\"python\", 1)]\n#guard nCommonWords \"python is a programming language\" 5 == [(\"python\", 1), (\"is\", 1), (\"a\", 1), (\"programming\", 1), (\"language\", 1)]\n", "test_list": ["#guard nCommonWords \"python is a programming language\" 1 == [(\"python\", 1)]", "#guard nCommonWords \"python is a programming language\" 1 == [(\"python\", 1)]", "#guard nCommonWords \"python is a programming language\" 5 == [(\"python\", 1), (\"is\", 1), (\"a\", 1), (\"programming\", 1), (\"language\", 1)]"]}
{"text": "Write a function to find the length of the longest sub-sequence such that elements in the subsequences are consecutive integers.", "task_id": 863, "code": "import Batteries\n\nopen Std\n\npartial def listMin (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => xs.foldl (fun m a => if a < m then a else m) x\n\npartial def removeOne (l : List Nat) (x : Nat) : List Nat :=\n  match l with\n  | [] => []\n  | y :: ys => if y == x then ys else y :: removeOne ys x\n\npartial def selectionSortAux (xs acc : List Nat) : List Nat :=\n  match xs with\n  | [] => acc.reverse\n  | _ =>\n    let m := listMin xs\n    selectionSortAux (removeOne xs m) (m :: acc)\n\npartial def selectionSort (l : List Nat) : List Nat :=\n  selectionSortAux l []\n\ndef uniqueSorted (l : List Nat) : List Nat :=\n  match l with\n  | [] => []\n  | x :: xs =>\n    let (_, accRev) := xs.foldl (fun (p : Nat × List Nat) a =>\n      let (last, accRev) := p\n      if a != last then (a, a :: accRev) else (last, accRev)\n    ) (x, [x])\n    accRev.reverse\n\ndef longestConsecutiveFromUnique (v : List Nat) : Nat :=\n  let (_, count, ans) := v.foldl (fun (state : Option Nat × Nat × Nat) a =>\n    let (prev?, count, ans) := state\n    let count' :=\n      match prev? with\n      | some p => if a == p + 1 then count + 1 else 1\n      | none => 1\n    let ans' := if ans < count' then count' else ans\n    (some a, count', ans')\n  ) (none, 0, 0)\n  ans\n\ndef findLongestConseqSubseq (arr : List Nat) (n : Nat) : Nat :=\n  let arrN := arr.take n\n  let sorted := selectionSort arrN\n  let v := uniqueSorted sorted\n  longestConsecutiveFromUnique v\n\n#guard findLongestConseqSubseq [1, 2, 2, 3] 4 == 3\n#guard findLongestConseqSubseq [1, 9, 3, 10, 4, 20, 2] 7 == 4\n#guard findLongestConseqSubseq [36, 41, 56, 35, 44, 33, 34, 92, 43, 32, 42] 11 == 5\n", "test_list": ["#guard findLongestConseqSubseq [1, 2, 2, 3] 4 == 3", "#guard findLongestConseqSubseq [1, 9, 3, 10, 4, 20, 2] 7 == 4", "#guard findLongestConseqSubseq [36, 41, 56, 35, 44, 33, 34, 92, 43, 32, 42] 11 == 5"]}
{"text": "Write a function to find palindromes in a given list of strings using lambda function.", "task_id": 864, "code": "import Batteries\n\nopen Std\n\ndef palindromeLambda (texts : List String) : List String :=\n  texts.filter (fun x => x == String.mk (x.toList.reverse))\n\n#guard palindromeLambda [\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"] = [\"php\", \"aaa\"]\n#guard palindromeLambda [\"abcd\", \"Python\", \"abba\", \"aba\"] = [\"abba\", \"aba\"]\n#guard palindromeLambda [\"abcd\", \"abbccbba\", \"abba\", \"aba\"] = [\"abbccbba\", \"abba\", \"aba\"]\n", "test_list": ["#guard palindromeLambda [\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"] = [\"php\", \"aaa\"]", "#guard palindromeLambda [\"abcd\", \"Python\", \"abba\", \"aba\"] = [\"abba\", \"aba\"]", "#guard palindromeLambda [\"abcd\", \"abbccbba\", \"abba\", \"aba\"] = [\"abbccbba\", \"abba\", \"aba\"]"]}
{"text": "Write a function to print n-times a list using map function.", "task_id": 865, "code": "import Batteries\n\nopen Std\n\ndef ntimes_list (nums : List Nat) (n : Nat) : List Nat :=\n  nums.map (fun x => n * x)\n\n#guard ntimes_list [1, 2, 3, 4, 5, 6, 7] 3 == [3, 6, 9, 12, 15, 18, 21]\n#guard ntimes_list [1, 2, 3, 4, 5, 6, 7] 4 == [4, 8, 12, 16, 20, 24, 28]\n#guard ntimes_list [1, 2, 3, 4, 5, 6, 7] 10 == [10, 20, 30, 40, 50, 60, 70]\n", "test_list": ["#guard ntimes_list [1, 2, 3, 4, 5, 6, 7] 3 == [3, 6, 9, 12, 15, 18, 21]", "#guard ntimes_list [1, 2, 3, 4, 5, 6, 7] 4 == [4, 8, 12, 16, 20, 24, 28]", "#guard ntimes_list [1, 2, 3, 4, 5, 6, 7] 10 == [10, 20, 30, 40, 50, 60, 70]"]}
{"text": "Write a function to check whether the given month name contains 31 days or not.", "task_id": 866, "code": "import Batteries\n\nopen Std\n\ndef checkMonthnumb (monthname2 : String) : Bool :=\n  if monthname2 == \"January\" || monthname2 == \"March\" || monthname2 == \"May\" || monthname2 == \"July\" || monthname2 == \"Augest\" || monthname2 == \"October\" || monthname2 == \"December\" then\n    true\n  else\n    false\n\n#guard checkMonthnumb \"February\" == false\n#guard checkMonthnumb \"January\" == true\n#guard checkMonthnumb \"March\" == true\n", "test_list": ["#guard checkMonthnumb \"February\" == false", "#guard checkMonthnumb \"January\" == true", "#guard checkMonthnumb \"March\" == true"]}
{"text": "Write a python function to add a minimum number such that the sum of array becomes even.", "task_id": 867, "code": "import Batteries\n\nopen Std\n\ndef min_Num (arr : List Nat) (n : Nat) : Nat := Id.run do\n  let a := arr.toArray\n  let mut odd := 0\n  for i in [: n] do\n    if a[i]! % 2 == 1 then\n      odd := odd + 1\n  if odd % 2 == 1 then\n    return 1\n  return 2\n\n#guard min_Num [1,2,3,4,5,6,7,8,9] 9 = 1\n#guard min_Num [1,2,3,4,5,6,7,8] 8 = 2\n#guard min_Num [1,2,3] 3 = 2\n", "test_list": ["#guard min_Num [1,2,3,4,5,6,7,8,9] 9 = 1", "#guard min_Num [1,2,3,4,5,6,7,8] 8 = 2", "#guard min_Num [1,2,3] 3 = 2"]}
{"text": "Write a python function to find the length of the last word in a given string.", "task_id": 868, "code": "import Batteries\n\nopen Std\n\ndef length_Of_Last_Word (a : String) : Nat :=\n  let parts := a.splitOn \" \"\n  let rec go (l : List String) (lastLen : Nat) : Nat :=\n    match l with\n    | [] => lastLen\n    | s :: t =>\n      let lastLen' := if s == \"\" then lastLen else s.length\n      go t lastLen'\n  go parts 0\n\n#guard length_Of_Last_Word \"python language\" = 8\n#guard length_Of_Last_Word \"PHP\" = 3\n#guard length_Of_Last_Word \"\" = 0\n", "test_list": ["#guard length_Of_Last_Word \"python language\" = 8", "#guard length_Of_Last_Word \"PHP\" = 3", "#guard length_Of_Last_Word \"\" = 0"]}
{"text": "Write a function to remove sublists from a given list of lists, which are outside a given range.", "task_id": 869, "code": "import Batteries\n\nopen Std\n\ndef listMin (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => xs.foldl Nat.min x\n\ndef listMax (l : List Nat) : Nat :=\n  match l with\n  | [] => 0\n  | x :: xs => xs.foldl Nat.max x\n\ndef removeListRange (list1 : List (List Nat)) (leftrange rigthrange : Nat) : List (List Nat) :=\n  list1.filter (fun i => listMin i >= leftrange && listMax i <= rigthrange)\n\n#guard removeListRange [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]] 13 17 = [[13, 14, 15, 17]]\n#guard removeListRange [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]] 1 3 = [[2], [1, 2, 3]]\n#guard removeListRange [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]] 0 7 = [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7]]\n", "test_list": ["#guard removeListRange [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]] 13 17 = [[13, 14, 15, 17]]", "#guard removeListRange [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]] 1 3 = [[2], [1, 2, 3]]", "#guard removeListRange [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7], [9, 11], [13, 14, 15, 17]] 0 7 = [[2], [0], [1, 2, 3], [0, 1, 2, 3, 6, 7]]"]}
{"text": "Write a function to calculate the sum of the positive numbers of a given list of numbers using lambda function.", "task_id": 870, "code": "import Batteries\n\nopen Std\n\ndef sumPositivenum (nums : List Int) : Int :=\n  let sum_positivenum := nums.filter (fun nums => nums > 0)\n  sum_positivenum.foldl (fun acc x => acc + x) 0\n\n#guard sumPositivenum [2, 4, -6, -9, 11, -12, 14, -5, 17] = 48\n#guard sumPositivenum [10, 15, -14, 13, -18, 12, -20] = 50\n#guard sumPositivenum [19, -65, 57, 39, 152, -639, 121, 44, 90, -190] = 522\n", "test_list": ["#guard sumPositivenum [2, 4, -6, -9, 11, -12, 14, -5, 17] = 48", "#guard sumPositivenum [10, 15, -14, 13, -18, 12, -20] = 50", "#guard sumPositivenum [19, -65, 57, 39, 152, -639, 121, 44, 90, -190] = 522"]}
{"text": "Write a python function to check whether the given strings are rotations of each other or not.", "task_id": 871, "code": "import Batteries\n\nopen Std\n\ndef areRotations (string1 string2 : String) : Bool := Id.run do\n  let size1 := string1.length\n  let size2 := string2.length\n  if size1 != size2 then\n    return false\n  let temp := string1 ++ string1\n  for i in [0 : size1 + 1] do\n    if string2 == (temp.drop i).take size1 then\n      return true\n  return false\n\n#guard areRotations \"abc\" \"cba\" == false\n#guard areRotations \"abcd\" \"cdba\" == false\n#guard areRotations \"abacd\" \"cdaba\" == true\n", "test_list": ["#guard areRotations \"abc\" \"cba\" == false", "#guard areRotations \"abcd\" \"cdba\" == false", "#guard areRotations \"abacd\" \"cdaba\" == true"]}
{"text": "Write a function to check if a nested list is a subset of another nested list.", "task_id": 872, "code": "import Batteries\n\nopen Std\n\ndef checkSubset {α : Type} [DecidableEq α] (list1 list2 : List α) : Bool :=\n  list2.all (fun x => list1.contains x)\n\n#guard checkSubset [[1, 3], [5, 7], [9, 11], [13, 15, 17]] [[1, 3], [13, 15, 17]] == true\n#guard checkSubset [[1, 2], [2, 3], [3, 4], [5, 6]] [[3, 4], [5, 6]] == true\n#guard checkSubset [[[1, 2], [2, 3]], [[3, 4], [5, 7]]] [[[3, 4], [5, 6]]] == false\n", "test_list": ["#guard checkSubset [[1, 3], [5, 7], [9, 11], [13, 15, 17]] [[1, 3], [13, 15, 17]] == true", "#guard checkSubset [[1, 2], [2, 3], [3, 4], [5, 6]] [[3, 4], [5, 6]] == true", "#guard checkSubset [[[1, 2], [2, 3]], [[3, 4], [5, 7]]] [[[3, 4], [5, 6]]] == false"]}
{"text": "Write a function to solve the fibonacci sequence using recursion.", "task_id": 873, "code": "import Batteries\n\nopen Std\n\npartial def fibonacci (n : Nat) : Nat :=\n  if n == 1 || n == 2 then 1\n  else fibonacci (n - 1) + fibonacci (n - 2)\n\n#guard fibonacci 7 = 13\n#guard fibonacci 8 = 21\n#guard fibonacci 9 = 34\n", "test_list": ["#guard fibonacci 7 = 13", "#guard fibonacci 8 = 21", "#guard fibonacci 9 = 34"]}
{"text": "Write a python function to check if the string is a concatenation of another string.", "task_id": 874, "code": "import Batteries\n\nopen Std\n\ndef check_Concat (str1 str2 : String) : Bool := Id.run do\n  let N := str1.length\n  let M := str2.length\n  if N % M != 0 then\n    return false\n  for i in [0 : N] do\n    let c1 := (str1.drop i).take 1\n    let c2 := (str2.drop (i % M)).take 1\n    if c1 != c2 then return false\n  return true\n\n#guard check_Concat \"abcabcabc\" \"abc\" == true\n#guard check_Concat \"abcab\" \"abc\" == false\n#guard check_Concat \"aba\" \"ab\" == false\n", "test_list": ["#guard check_Concat \"abcabcabc\" \"abc\" == true", "#guard check_Concat \"abcab\" \"abc\" == false", "#guard check_Concat \"aba\" \"ab\" == false"]}
{"text": "Write a function to find the minimum difference in the tuple pairs of given tuples.", "task_id": 875, "code": "import Batteries\n\nopen Std\n\ndef minDifference (test_list : List (Nat × Nat)) : Nat :=\n  let temp := test_list.map (fun (a, b) => if b ≥ a then b - a else a - b)\n  match temp with\n  | [] => 0\n  | t :: ts => ts.foldl (fun acc x => if x < acc then x else acc) t\n\n#guard minDifference [(3, 5), (1, 7), (10, 3), (1, 2)] = 1\n#guard minDifference [(4, 6), (12, 8), (11, 4), (2, 13)] = 2\n#guard minDifference [(5, 17), (3, 9), (12, 5), (3, 24)] = 6\n", "test_list": ["#guard minDifference [(3, 5), (1, 7), (10, 3), (1, 2)] = 1", "#guard minDifference [(4, 6), (12, 8), (11, 4), (2, 13)] = 2", "#guard minDifference [(5, 17), (3, 9), (12, 5), (3, 24)] = 6"]}
{"text": "Write a python function to find lcm of two positive integers.", "task_id": 876, "code": "import Batteries\n\nopen Std\n\ndef lcm (x y : Nat) : Nat :=\n  \n  let z0 := if x > y then x else y\n  let rec loop (z remaining : Nat) : Nat :=\n    match remaining with\n    | 0 => z\n    | Nat.succ r =>\n      if z % x == 0 && z % y == 0 then z\n      else loop (z+1) r\n  loop z0 (x * y + 1)\n\n#guard lcm 4 6 = 12\n#guard lcm 15 17 = 255\n#guard lcm 2 6 = 6\n", "test_list": ["#guard lcm 4 6 = 12", "#guard lcm 15 17 = 255", "#guard lcm 2 6 = 6"]}
{"text": "Write a python function to sort the given string.", "task_id": 877, "code": "import Batteries\n\nopen Std\n\nprivate def minOfList (h : Char) (t : List Char) : Char :=\n  t.foldl (fun m y => if y ≤ m then y else m) h\n\nprivate def removeFirst (xs : List Char) (c : Char) : List Char :=\n  match xs with\n  | [] => []\n  | x :: xs' => if x == c then xs' else x :: removeFirst xs' c\n\nprivate def takeMin (xs : List Char) : Option (Char × List Char) :=\n  match xs with\n  | [] => none\n  | h :: t =>\n    let m := minOfList h t\n    let rest := removeFirst (h :: t) m\n    some (m, rest)\n\nprivate def selectionSort (xs : List Char) : List Char :=\n  let rec loop (k : Nat) (ys : List Char) (acc : List Char) : List Char :=\n    match k with\n    | 0 => acc.reverse\n    | Nat.succ k' =>\n      match takeMin ys with\n      | none => acc.reverse\n      | some (m, ys') => loop k' ys' (m :: acc)\n  loop xs.length xs []\n\ndef sort_String (str : String) : String :=\n  String.mk (selectionSort str.data)\n\n#guard sort_String \"cba\" = \"abc\"\n#guard sort_String \"data\" = \"aadt\"\n#guard sort_String \"zxy\" = \"xyz\"\n", "test_list": ["#guard sort_String \"cba\" = \"abc\"", "#guard sort_String \"data\" = \"aadt\"", "#guard sort_String \"zxy\" = \"xyz\""]}
{"text": "Write a function to check if the given tuple contains only k elements.", "task_id": 878, "code": "import Batteries\n\nopen Std\n\ndef containsNat (l : List Nat) (x : Nat) : Bool :=\n  l.foldl (fun acc y => acc || y == x) false\n\ndef checkTuples (testTuple : List Nat) (K : List Nat) : Bool :=\n  testTuple.foldl (fun acc ele => acc && containsNat K ele) true\n\n#guard checkTuples [3, 5, 6, 5, 3, 6] [3, 6, 5] == true\n#guard checkTuples [4, 5, 6, 4, 6, 5] [4, 5, 6] == true\n#guard checkTuples [9, 8, 7, 6, 8, 9] [9, 8, 1] == false\n", "test_list": ["#guard checkTuples [3, 5, 6, 5, 3, 6] [3, 6, 5] == true", "#guard checkTuples [4, 5, 6, 4, 6, 5] [4, 5, 6] == true", "#guard checkTuples [9, 8, 7, 6, 8, 9] [9, 8, 1] == false"]}
{"text": "Write a function that matches a string that has an 'a' followed by anything, ending in 'b' by using regex.", "task_id": 879, "code": "import Batteries\n\nopen Std\n\ndef containsA (s : String) : Bool := Id.run do\n  let n := s.length\n  for i in [0 : n] do\n    if (s.drop i).take 1 = \"a\" then\n      return true\n  return false\n\ndef text_match (text : String) : String :=\n  let patterns := \"a.*?b$\"\n  let len := text.length\n  if len = 0 then \"Not matched!\"\n  else\n    let endsWithB := text.drop (len - 1) = \"b\"\n    let hasA := containsA (text.take (len - 1))\n    if endsWithB && hasA then \"Found a match!\" else \"Not matched!\"\n\n#guard text_match \"aabbbbd\" == \"Not matched!\"\n#guard text_match \"aabAbbbc\" == \"Not matched!\"\n#guard text_match \"accddbbjjjb\" == \"Found a match!\"\n", "test_list": ["#guard text_match \"aabbbbd\" == \"Not matched!\"", "#guard text_match \"aabAbbbc\" == \"Not matched!\"", "#guard text_match \"accddbbjjjb\" == \"Found a match!\""]}
{"text": "Write a python function to find number of solutions in quadratic equation.", "task_id": 880, "code": "import Batteries\n\nopen Std\n\ndef Check_Solution (a b c : Int) : String :=\n  let d := (b*b) - (4*a*c)\n  if h : d > 0 then\n    \"2 solutions\"\n  else if h2 : d = 0 then\n    \"1 solution\"\n  else\n    \"No solutions\"\n\n#guard Check_Solution 2 5 2 = \"2 solutions\"\n#guard Check_Solution 1 1 1 = \"No solutions\"\n#guard Check_Solution 1 2 1 = \"1 solution\"\n", "test_list": ["#guard Check_Solution 2 5 2 = \"2 solutions\"", "#guard Check_Solution 1 1 1 = \"No solutions\"", "#guard Check_Solution 1 2 1 = \"1 solution\""]}
{"text": "Write a function to find the sum of first even and odd number of a given list.", "task_id": 881, "code": "import Batteries\n\nopen Std\n\ndef sumEvenOdd (list1 : List Int) : Int :=\n  let rec firstWith (l : List Int) (p : Int → Bool) : Int :=\n    match l with\n    | [] => -1\n    | x :: xs => if p x then x else firstWith xs p\n  let first_even := firstWith list1 (fun el => el % 2 == 0)\n  let first_odd := firstWith list1 (fun el => el % 2 != 0)\n  first_even + first_odd\n\n#guard sumEvenOdd [1, 3, 5, 7, 4, 1, 6, 8] == 5\n#guard sumEvenOdd [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == 3\n#guard sumEvenOdd [1, 5, 7, 9, 10] == 11\n", "test_list": ["#guard sumEvenOdd [1, 3, 5, 7, 4, 1, 6, 8] == 5", "#guard sumEvenOdd [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] == 3", "#guard sumEvenOdd [1, 5, 7, 9, 10] == 11"]}
{"text": "Write a function to caluclate perimeter of a parallelogram.", "task_id": 882, "code": "import Batteries\n\nopen Std\n\ndef parallelogramPerimeter (b h : Nat) : Nat :=\n  2 * (b * h)\n\n#guard parallelogramPerimeter 10 20 = 400\n#guard parallelogramPerimeter 15 20 = 600\n#guard parallelogramPerimeter 8 9 = 144\n", "test_list": ["#guard parallelogramPerimeter 10 20 = 400", "#guard parallelogramPerimeter 15 20 = 600", "#guard parallelogramPerimeter 8 9 = 144"]}
{"text": "Write a function to find numbers divisible by m and n from a list of numbers using lambda function.", "task_id": 883, "code": "import Batteries\n\nopen Std\n\ndef divOfNums (nums : List Nat) (m n : Nat) : List Nat :=\n  nums.filter (fun x => (x % m == 0) && (x % n == 0))\n\n#guard divOfNums [19, 65, 57, 39, 152, 639, 121, 44, 90, 190] 2 4 = [152, 44]\n#guard divOfNums [1, 2, 3, 5, 7, 8, 10] 2 5 = [10]\n#guard divOfNums [10, 15, 14, 13, 18, 12, 20] 10 5 = [10, 20]\n", "test_list": ["#guard divOfNums [19, 65, 57, 39, 152, 639, 121, 44, 90, 190] 2 4 = [152, 44]", "#guard divOfNums [1, 2, 3, 5, 7, 8, 10] 2 5 = [10]", "#guard divOfNums [10, 15, 14, 13, 18, 12, 20] 10 5 = [10, 20]"]}
{"text": "Write a python function to check whether all the bits are within a given range or not.", "task_id": 884, "code": "import Batteries\n\nopen Std\n\ndef all_Bits_Set_In_The_Given_Range (n l r : Nat) : Bool :=\n  let num := ((2 ^ r) - 1) ^^^ ((2 ^ (l - 1)) - 1)\n  let new_num := n &&& num\n  if num == new_num then\n    true\n  else\n    false\n\n#guard all_Bits_Set_In_The_Given_Range 10 2 1 == true\n#guard all_Bits_Set_In_The_Given_Range 5 2 4 == false\n#guard all_Bits_Set_In_The_Given_Range 22 2 3 == true\n", "test_list": ["#guard all_Bits_Set_In_The_Given_Range 10 2 1 == true", "#guard all_Bits_Set_In_The_Given_Range 5 2 4 == false", "#guard all_Bits_Set_In_The_Given_Range 22 2 3 == true"]}
{"text": "Write a python function to check whether the two given strings are isomorphic to each other or not.", "task_id": 885, "code": "import Batteries\nopen Std\n\ndef insertBy {α} (le : α → α → Bool) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys => if le x y then x :: y :: ys else y :: insertBy le x ys\n\ndef isort {α} (le : α → α → Bool) : List α → List α\n  | [] => []\n  | x :: xs => insertBy le x (isort le xs)\n\ndef lexLe : List Nat → List Nat → Bool\n  | [], [] => true\n  | [], _ => true\n  | _, [] => false\n  | x :: xs, y :: ys =>\n    if x < y then true\n    else if y < x then false\n    else lexLe xs ys\n\ndef buildIndexMap (s : String) : HashMap Char (List Nat) := Id.run do\n  let mut m : HashMap Char (List Nat) := {}\n  let mut i : Nat := 0\n  for c in s.data do\n    let old := (m.get? c).getD []\n    m := m.insert c (old ++ [i])\n    i := i + 1\n  return m\n\ndef collectValues (m : HashMap Char (List Nat)) : List (List Nat) :=\n  m.fold (fun acc _ v => v :: acc) []\n\ndef is_Isomorphic (str1 str2 : String) : Bool :=\n  let dictStr1 := buildIndexMap str1\n  let dictStr2 := buildIndexMap str2\n  let vals1 := collectValues dictStr1\n  let vals2 := collectValues dictStr2\n  let s1 := isort lexLe vals1\n  let s2 := isort lexLe vals2\n  s1 == s2\n\n#guard is_Isomorphic \"paper\" \"title\" == true\n#guard is_Isomorphic \"ab\" \"ba\" == true\n#guard is_Isomorphic \"ab\" \"aa\" == false\n", "test_list": ["#guard is_Isomorphic \"paper\" \"title\" == true", "#guard is_Isomorphic \"ab\" \"ba\" == true", "#guard is_Isomorphic \"ab\" \"aa\" == false"]}
{"text": "Write a function to add all the numbers in a list and divide it with the length of the list.", "task_id": 886, "code": "import Batteries\n\nopen Std\n\ndef sumNum (numbers : List Int) : Float := Id.run do\n  let mut total : Int := 0\n  for x in numbers do\n    total := total + x\n  let n := numbers.length\n  return (Float.ofInt total) / (Float.ofNat n)\n\n#guard sumNum [8, 2, 3, 0, 7] == 4.0\n#guard sumNum [-10, -20, -30] == -20.0\n#guard sumNum [19, 15, 18] == 17.333333333333332\n", "test_list": ["#guard sumNum [8, 2, 3, 0, 7] == 4.0", "#guard sumNum [-10, -20, -30] == -20.0", "#guard sumNum [19, 15, 18] == 17.333333333333332"]}
{"text": "Write a python function to check whether the given number is odd or not using bitwise operator.", "task_id": 887, "code": "import Batteries\n\nopen Std\n\ndef is_odd (n : Nat) : Bool :=\n  (n ^^^ 1) == (n - 1)\n\n#guard is_odd 5 == true\n#guard is_odd 6 == false\n#guard is_odd 7 == true\n", "test_list": ["#guard is_odd 5 == true", "#guard is_odd 6 == false", "#guard is_odd 7 == true"]}
{"text": "Write a function to substract the elements of the given nested tuples.", "task_id": 888, "code": "import Batteries\n\nopen Std\n\ndef substract_elements (test_tup1 test_tup2 : List (List Int)) : List (List Int) :=\n  (List.zip test_tup1 test_tup2).map (fun p =>\n    let tup1 := p.fst\n    let tup2 := p.snd\n    (List.zip tup1 tup2).map (fun q => q.fst - q.snd)\n  )\n\n#guard substract_elements [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] == [[-5, -4], [1, -4], [1, 8], [-6, 7]]\n#guard substract_elements [[13, 4], [14, 6], [13, 10], [12, 11]] [[19, 8], [14, 10], [12, 2], [18, 4]] == [[-6, -4], [0, -4], [1, 8], [-6, 7]]\n#guard substract_elements [[19, 5], [18, 7], [19, 11], [17, 12]] [[12, 9], [17, 11], [13, 3], [19, 5]] == [[7, -4], [1, -4], [6, 8], [-2, 7]]\n", "test_list": ["#guard substract_elements [[1, 3], [4, 5], [2, 9], [1, 10]] [[6, 7], [3, 9], [1, 1], [7, 3]] == [[-5, -4], [1, -4], [1, 8], [-6, 7]]", "#guard substract_elements [[13, 4], [14, 6], [13, 10], [12, 11]] [[19, 8], [14, 10], [12, 2], [18, 4]] == [[-6, -4], [0, -4], [1, 8], [-6, 7]]", "#guard substract_elements [[19, 5], [18, 7], [19, 11], [17, 12]] [[12, 9], [17, 11], [13, 3], [19, 5]] == [[7, -4], [1, -4], [6, 8], [-2, 7]]"]}
{"text": "Write a function to reverse each list in a given list of lists.", "task_id": 889, "code": "import Batteries\n\nopen Std\n\ndef reverseListLists (lists : List (List Nat)) : List (List Nat) :=\n  lists.map (fun l => l.reverse)\n\n#guard reverseListLists [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] = [[4, 3, 2, 1], [8, 7, 6, 5], [12, 11, 10, 9], [16, 15, 14, 13]]\n#guard reverseListLists [[1,2],[2,3],[3,4]] = [[2,1],[3,2],[4,3]]\n#guard reverseListLists [[10,20],[30,40]] = [[20,10],[40,30]]\n", "test_list": ["#guard reverseListLists [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]] = [[4, 3, 2, 1], [8, 7, 6, 5], [12, 11, 10, 9], [16, 15, 14, 13]]", "#guard reverseListLists [[1,2],[2,3],[3,4]] = [[2,1],[3,2],[4,3]]", "#guard reverseListLists [[10,20],[30,40]] = [[20,10],[40,30]]"]}
{"text": "Write a python function to find the index of an extra element present in one sorted array.", "task_id": 890, "code": "import Batteries\n\nopen Std\n\ndef find_Extra (arr1 arr2 : List Nat) (n : Nat) : Nat := Id.run do\n  for i in [0 : n] do\n    if (arr1.getD i 0) != (arr2.getD i 0) then\n      return i\n  return n\n\n#guard find_Extra [1,2,3,4] [1,2,3] 3 = 3\n#guard find_Extra [2,4,6,8,10] [2,4,6,8] 4 = 4\n#guard find_Extra [1,3,5,7,9,11] [1,3,5,7,9] 5 = 5\n", "test_list": ["#guard find_Extra [1,2,3,4] [1,2,3] 3 = 3", "#guard find_Extra [2,4,6,8,10] [2,4,6,8] 4 = 4", "#guard find_Extra [1,3,5,7,9,11] [1,3,5,7,9] 5 = 5"]}
{"text": "Write a python function to check whether the given two numbers have same number of digits or not.", "task_id": 891, "code": "import Batteries\n\nopen Std\n\ndef sameLength (A B : Nat) : Bool := Id.run do\n  let mut a := A\n  let mut b := B\n  while a > 0 && b > 0 do\n    a := a / 10\n    b := b / 10\n  return a == 0 && b == 0\n\n#guard sameLength 12 1 == false\n#guard sameLength 2 2 == true\n#guard sameLength 10 20 == true\n", "test_list": ["#guard sameLength 12 1 == false", "#guard sameLength 2 2 == true", "#guard sameLength 10 20 == true"]}
{"text": "Write a function to remove multiple spaces in a string.", "task_id": 892, "code": "import Batteries\n\nopen Std\n\ndef removeSpaces (text : String) : String :=\n  let (_, acc) := text.foldl (fun (st : Bool × List Char) (c : Char) =>\n    let (prevSpace, acc) := st\n    if c == ' ' then\n      if prevSpace then (true, acc) else (true, ' ' :: acc)\n    else\n      (false, c :: acc)) (false, [])\n  String.mk acc.reverse\n\n#guard removeSpaces \"python  program\" = \"python program\"\n#guard removeSpaces \"python   programming    language\" = \"python programming language\"\n#guard removeSpaces \"python                     program\" = \"python program\"\n", "test_list": ["#guard removeSpaces \"python  program\" = \"python program\"", "#guard removeSpaces \"python   programming    language\" = \"python programming language\"", "#guard removeSpaces \"python                     program\" = \"python program\""]}
{"text": "Write a python function to get the last element of each sublist.", "task_id": 893, "code": "import Batteries\n\nopen Std\n\ndef lastElem {α : Type} [Inhabited α] : List α → α\n| [] => default\n| [a] => a\n| _ :: xs => lastElem xs\n\ndef Extract {α : Type} [Inhabited α] (lst : List (List α)) : List α :=\n  lst.map lastElem\n\n#guard Extract [[1, 2, 3], [4, 5], [6, 7, 8, 9]] == [3, 5, 9]\n#guard Extract [[\"x\", \"y\", \"z\"], [\"m\"], [\"a\", \"b\"], [\"u\", \"v\"]] == [\"z\", \"m\", \"b\", \"v\"]\n#guard Extract [[1, 2, 3], [4, 5]] == [3, 5]\n", "test_list": ["#guard Extract [[1, 2, 3], [4, 5], [6, 7, 8, 9]] == [3, 5, 9]", "#guard Extract [[\"x\", \"y\", \"z\"], [\"m\"], [\"a\", \"b\"], [\"u\", \"v\"]] == [\"z\", \"m\", \"b\", \"v\"]", "#guard Extract [[1, 2, 3], [4, 5]] == [3, 5]"]}
{"text": "Write a function to convert the given string of float type into tuple.", "task_id": 894, "code": "import Batteries\nopen Std\n\ndef pow10 : Nat → Float\n  | 0 => 1.0\n  | n+1 => pow10 n * 10.0\n\ndef parseSimpleFloat (s : String) : Option Float :=\n  let neg := s.startsWith \"-\"\n  let core := if neg then s.drop 1 else s\n  let parts := core.splitOn \".\"\n  match parts with\n  | [intStr] =>\n      match intStr.toInt? with\n      | some i =>\n          let base := Float.ofInt i\n          some (if neg then -base else base)\n      | none => none\n  | [intStr, fracStr] =>\n      match intStr.toInt?, fracStr.toNat? with\n      | some i, some n =>\n          let base := Float.ofInt i\n          let denom := pow10 fracStr.length\n          let frac := (Float.ofInt (Int.ofNat n)) / denom\n          let total := base + frac\n          some (if neg then -total else total)\n      | _, _ => none\n  | _ => none\n\ndef floatToTuple (test_str : String) : List Float :=\n  (test_str.splitOn \", \").map (fun s => (parseSimpleFloat s).getD 0.0)\n\n#guard floatToTuple \"1.2, 1.3, 2.3, 2.4, 6.5\" == [1.2, 1.3, 2.3, 2.4, 6.5]\n#guard floatToTuple \"2.3, 2.4, 5.6, 5.4, 8.9\" == [2.3, 2.4, 5.6, 5.4, 8.9]\n#guard floatToTuple \"0.3, 0.5, 7.8, 9.4\" == [0.3, 0.5, 7.8, 9.4]\n", "test_list": ["#guard floatToTuple \"1.2, 1.3, 2.3, 2.4, 6.5\" == [1.2, 1.3, 2.3, 2.4, 6.5]", "#guard floatToTuple \"2.3, 2.4, 5.6, 5.4, 8.9\" == [2.3, 2.4, 5.6, 5.4, 8.9]", "#guard floatToTuple \"0.3, 0.5, 7.8, 9.4\" == [0.3, 0.5, 7.8, 9.4]"]}
{"text": "Write a function to find the maximum sum of subsequences of given array with no adjacent elements.", "task_id": 895, "code": "import Batteries\n\nopen Std\n\ndef maxSumSubseq (A : List Nat) : Nat := Id.run do\n  let n := A.length\n  \n  let arr := A.toArray\n  if n == 1 then\n    return arr[0]!\n  let mut look := Array.replicate n 0\n  look := look.set! 0 arr[0]!\n  look := look.set! 1 (max arr[0]! arr[1]!)\n  for i in [2 : n] do\n    let v1 := look[i-1]!\n    let v2 := look[i-2]! + arr[i]!\n    let m := max v1 v2\n    let m2 := max m arr[i]!\n    look := look.set! i m2\n  return look[n-1]!\n\n#guard maxSumSubseq [1, 2, 9, 4, 5, 0, 4, 11, 6] = 26\n#guard maxSumSubseq [1, 2, 9, 5, 6, 0, 5, 12, 7] = 28\n#guard maxSumSubseq [1, 3, 10, 5, 6, 0, 6, 14, 21] = 44\n", "test_list": ["#guard maxSumSubseq [1, 2, 9, 4, 5, 0, 4, 11, 6] = 26", "#guard maxSumSubseq [1, 2, 9, 5, 6, 0, 5, 12, 7] = 28", "#guard maxSumSubseq [1, 3, 10, 5, 6, 0, 6, 14, 21] = 44"]}
{"text": "Write a function to sort a list in increasing order by the last element in each tuple from a given list of non-empty tuples.", "task_id": 896, "code": "import Batteries\n\nopen Std\n\ndef last (n : Nat × Nat) : Nat := n.snd\n\nprivate def insertByLast (x : Nat × Nat) (xs : List (Nat × Nat)) : List (Nat × Nat) :=\n  match xs with\n  | [] => [x]\n  | y :: ys =>\n    if last x < last y then x :: xs else y :: insertByLast x ys\n\nprivate def isortByLast (xs : List (Nat × Nat)) : List (Nat × Nat) :=\n  match xs with\n  | [] => []\n  | x :: xs' => insertByLast x (isortByLast xs')\n\ndef sort_list_last (tuples : List (Nat × Nat)) : List (Nat × Nat) :=\n  isortByLast tuples\n\n#guard sort_list_last [(2, 5), (1, 2), (4, 4), (2, 3), (2, 1)] == [(2, 1), (1, 2), (2, 3), (4, 4), (2, 5)]\n#guard sort_list_last [(9, 8), (4, 7), (3, 5), (7, 9), (1, 2)] == [(1, 2), (3, 5), (4, 7), (9, 8), (7, 9)]\n#guard sort_list_last [(20, 50), (10, 20), (40, 40)] == [(10, 20), (40, 40), (20, 50)]\n", "test_list": ["#guard sort_list_last [(2, 5), (1, 2), (4, 4), (2, 3), (2, 1)] == [(2, 1), (1, 2), (2, 3), (4, 4), (2, 5)]", "#guard sort_list_last [(9, 8), (4, 7), (3, 5), (7, 9), (1, 2)] == [(1, 2), (3, 5), (4, 7), (9, 8), (7, 9)]", "#guard sort_list_last [(20, 50), (10, 20), (40, 40)] == [(10, 20), (40, 40), (20, 50)]"]}
{"text": "Write a python function to check whether the word is present in a given sentence or not.", "task_id": 897, "code": "import Batteries\n\nopen Std\n\ndef isWordPresent (sentence : String) (word : String) : Bool := Id.run do\n  let s := sentence.splitOn \" \"\n  for i in s do\n    if i == word then\n      return true\n  return false\n\n#guard isWordPresent \"machine learning\" \"machine\" == true\n#guard isWordPresent \"easy\" \"fun\" == false\n#guard isWordPresent \"python language\" \"code\" == false\n", "test_list": ["#guard isWordPresent \"machine learning\" \"machine\" == true", "#guard isWordPresent \"easy\" \"fun\" == false", "#guard isWordPresent \"python language\" \"code\" == false"]}
{"text": "Write a function to extract specified number of elements from a given list, which follow each other continuously.", "task_id": 898, "code": "import Batteries\n\nopen Std\n\ndef extractElements (numbers : List Nat) (n : Nat) : List Nat :=\n  let rec loop (lst : List Nat) (curVal : Option Nat) (curCount : Nat) (acc : List Nat) : List Nat :=\n    match lst with\n    | [] =>\n      let acc := match curVal with\n        | some v => if curCount == n then v :: acc else acc\n        | none => acc\n      acc.reverse\n    | x :: xs =>\n      match curVal with\n      | none => loop xs (some x) 1 acc\n      | some v =>\n        if x == v then\n          loop xs (some v) (curCount + 1) acc\n        else\n          let acc := if curCount == n then v :: acc else acc\n          loop xs (some x) 1 acc\n  loop numbers none 0 []\n\n#guard extractElements [1, 1, 3, 4, 4, 5, 6, 7] 2 == [1, 4]\n#guard extractElements [0, 1, 2, 3, 4, 4, 4, 4, 5, 7] 4 == [4]\n#guard extractElements [0, 0, 0, 0, 0] 5 == [0]\n", "test_list": ["#guard extractElements [1, 1, 3, 4, 4, 5, 6, 7] 2 == [1, 4]", "#guard extractElements [0, 1, 2, 3, 4, 4, 4, 4, 5, 7] 4 == [4]", "#guard extractElements [0, 0, 0, 0, 0] 5 == [0]"]}
{"text": "Write a python function to check whether an array can be sorted or not by picking only the corner elements.", "task_id": 899, "code": "import Batteries\nopen Std\n\ndef nthD {α} (xs : List α) (i : Nat) (d : α) : α :=\n  match xs, i with\n  | [], _ => d\n  | x :: _, 0 => x\n  | _ :: xs, i+1 => nthD xs i d\n\ndef check (arr : List Nat) (n : Nat) : Bool := Id.run do\n  let mut g : Nat := 0\n  for i in [1 : n] do\n    if g == 1 then\n      let cur := nthD arr i 0\n      let prev := nthD arr (i - 1) 0\n      if decide ((cur - prev) > 0) then\n        return false\n    let cur2 := nthD arr i 0\n    if decide ((cur2 - cur2) < 0) then\n      g := 1\n  return true\n\n#guard check [3,2,1,2,3,4] 6 = true\n#guard check [2,1,4,5,1] 5 = true\n#guard check [1,2,2,1,2,3] 6 = true\n", "test_list": ["#guard check [3,2,1,2,3,4] 6 = true", "#guard check [2,1,4,5,1] 5 = true", "#guard check [1,2,2,1,2,3] 6 = true"]}
{"text": "Write a function where a string will start with a specific number.", "task_id": 900, "code": "import Batteries\n\nopen Std\n\ndef matchNum (string : String) : Bool :=\n  if string.take 1 == \"5\" then true else false\n\n#guard matchNum \"5-2345861\" == true\n#guard matchNum \"6-2345861\" == false\n#guard matchNum \"78910\" == false\n", "test_list": ["#guard matchNum \"5-2345861\" == true", "#guard matchNum \"6-2345861\" == false", "#guard matchNum \"78910\" == false"]}
{"text": "Write a function to combine two dictionaries by adding values for common keys.", "task_id": 902, "code": "import Batteries\nopen Std\n\nprivate def lookupOr (m : Std.HashMap String Nat) (k : String) (default : Nat) : Nat :=\n  let rec go (l : List (String × Nat)) : Nat :=\n    match l with\n    | [] => default\n    | (k', v') :: t => if k' == k then v' else go t\n  go m.toList\n\ndef addDict (d1 d2 : Std.HashMap String Nat) : Std.HashMap String Nat := Id.run do\n  let mut res := d1\n  for (k, v) in d2.toList do\n    let prev := lookupOr res k 0\n    res := res.insert k (prev + v)\n  return res\n\ndef HashMap.findD {α β} [BEq α] [Hashable α] (m : Std.HashMap α β) (a : α) (default : β) : β :=\n  let rec go (l : List (α × β)) : Option β :=\n    match l with\n    | [] => none\n    | (k, v) :: t => if k == a then some v else go t\n  match go m.toList with\n  | some v => v\n  | none => default\n\n#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).size = 4\n#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"a\" 0 = 400\n#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"b\" 0 = 400\n#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"c\" 0 = 300\n#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"d\" 0 = 400\n\n#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).size = 4\n#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"a\" 0 = 1000\n#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"b\" 0 = 1300\n#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"c\" 0 = 900\n#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"d\" 0 = 900\n\n#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).size = 3\n#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).findD \"a\" 0 = 1800\n#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).findD \"b\" 0 = 1800\n#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).findD \"d\" 0 = 1800\n", "test_list": ["#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).size = 4", "#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"a\" 0 = 400", "#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"b\" 0 = 400", "#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"c\" 0 = 300", "#guard (addDict (Std.HashMap.ofList [(\"a\", 100), (\"b\", 200), (\"c\", 300)]) (Std.HashMap.ofList [(\"a\", 300), (\"b\", 200), (\"d\", 400)])).findD \"d\" 0 = 400", "#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).size = 4", "#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"a\" 0 = 1000", "#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"b\" 0 = 1300", "#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"c\" 0 = 900", "#guard (addDict (Std.HashMap.ofList [(\"a\", 500), (\"b\", 700), (\"c\", 900)]) (Std.HashMap.ofList [(\"a\", 500), (\"b\", 600), (\"d\", 900)])).findD \"d\" 0 = 900", "#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).size = 3", "#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).findD \"a\" 0 = 1800", "#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).findD \"b\" 0 = 1800", "#guard (addDict (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)]) (Std.HashMap.ofList [(\"a\", 900), (\"b\", 900), (\"d\", 900)])).findD \"d\" 0 = 1800"]}
{"text": "Write a python function to count the total unset bits from 1 to n.", "task_id": 903, "code": "import Batteries\n\nopen Std\n\ndef countUnsetBits (n : Nat) : Nat := Id.run do\n  let mut cnt := 0\n  for i in [1 : n + 1] do\n    let mut temp := i\n    while temp != 0 do\n      if temp % 2 == 0 then\n        cnt := cnt + 1\n      temp := temp / 2\n  return cnt\n\n#guard countUnsetBits 2 == 1\n#guard countUnsetBits 5 == 4\n#guard countUnsetBits 14 == 17\n", "test_list": ["#guard countUnsetBits 2 == 1", "#guard countUnsetBits 5 == 4", "#guard countUnsetBits 14 == 17"]}
{"text": "Write a python function to find the sum of squares of binomial co-efficients.", "task_id": 905, "code": "import Batteries\n\nopen Std\n\ndef factorial (start end_ : Nat) : Nat := Id.run do\n  let mut res := 1\n  for i in [start : end_ + 1] do\n    res := res * i\n  return res\n\ndef sumOfSquare (n : Nat) : Nat :=\n  (factorial (n + 1) (2 * n)) / (factorial 1 n)\n\n#guard sumOfSquare 4 = 70\n#guard sumOfSquare 5 = 252\n#guard sumOfSquare 2 = 6\n", "test_list": ["#guard sumOfSquare 4 = 70", "#guard sumOfSquare 5 = 252", "#guard sumOfSquare 2 = 6"]}
{"text": "Write a function to find the fixed point in the given array.", "task_id": 908, "code": "import Batteries\n\nopen Std\n\ndef findFixedPoint (arr : List Int) (n : Nat) : Int := Id.run do\n  \n  let a := arr.toArray\n  for i in [: n] do\n    let v := a[i]!\n    if v == (Int.ofNat i) then\n      return Int.ofNat i\n  return (-1)\n\n#guard findFixedPoint [-10, -1, 0, 3, 10, 11, 30, 50, 100] 9 = 3\n#guard findFixedPoint [1, 2, 3, 4, 5, 6, 7, 8] 8 = (-1)\n#guard findFixedPoint [0, 2, 5, 8, 17] 5 = 0\n", "test_list": ["#guard findFixedPoint [-10, -1, 0, 3, 10, 11, 30, 50, 100] 9 = 3", "#guard findFixedPoint [1, 2, 3, 4, 5, 6, 7, 8] 8 = (-1)", "#guard findFixedPoint [0, 2, 5, 8, 17] 5 = 0"]}
{"text": "Write a function to find the previous palindrome of a specified number.", "task_id": 909, "code": "import Batteries\n\nopen Std\n\ndef isPalindromeStr (s : String) : Bool :=\n  s == String.mk (s.toList.reverse)\n\ndef previousPalindrome (num : Nat) : Nat := Id.run do\n  if num = 0 then\n    return 0\n  let mut x := num - 1\n  while x > 0 do\n    let s := toString x\n    if isPalindromeStr s then\n      return x\n    x := x - 1\n  return 0\n\n#guard previousPalindrome 99 = 88\n#guard previousPalindrome 1221 = 1111\n#guard previousPalindrome 120 = 111\n", "test_list": ["#guard previousPalindrome 99 = 88", "#guard previousPalindrome 1221 = 1111", "#guard previousPalindrome 120 = 111"]}
{"text": "Write a function to compute maximum product of three numbers of a given array of integers using heap queue algorithm.", "task_id": 911, "code": "import Batteries\nopen Std\n\ndef insertDescAux (x : Int) (xs : List Int) (acc : List Int) (k : Nat) : List Int :=\n  match xs with\n  | [] =>\n    let res := acc.reverse ++ [x]\n    res.take k\n  | y :: ys =>\n    if x ≥ y then\n      let res := acc.reverse ++ (x :: y :: ys)\n      res.take k\n    else\n      insertDescAux x ys (y :: acc) k\n\ndef insertDesc (x : Int) (xs : List Int) (k : Nat) : List Int :=\n  insertDescAux x xs [] k\n\ndef insertAscAux (x : Int) (xs : List Int) (acc : List Int) (k : Nat) : List Int :=\n  match xs with\n  | [] =>\n    let res := acc.reverse ++ [x]\n    res.take k\n  | y :: ys =>\n    if x ≤ y then\n      let res := acc.reverse ++ (x :: y :: ys)\n      res.take k\n    else\n      insertAscAux x ys (y :: acc) k\n\ndef insertAsc (x : Int) (xs : List Int) (k : Nat) : List Int :=\n  insertAscAux x xs [] k\n\ndef maximumProduct (nums : List Int) : Int :=\n  let a := nums.foldl (fun acc x => insertDesc x acc 3) []   \n  let b := nums.foldl (fun acc x => insertAsc x acc 2) []    \n  let prod1 := match a with\n    | x1 :: x2 :: x3 :: _ => x1 * x2 * x3\n    | _ => 0\n  let prod2 := match a, b with\n    | x1 :: _, y1 :: y2 :: _ => x1 * y1 * y2\n    | _, _ => 0\n  if prod1 ≥ prod2 then prod1 else prod2\n\n#guard maximumProduct [12, 74, 9, 50, 61, 41] = (225700 : Int)\n#guard maximumProduct [25, 35, 22, 85, 14, 65, 75, 25, 58] = (414375 : Int)\n#guard maximumProduct [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1] = (2520 : Int)\n", "test_list": ["#guard maximumProduct [12, 74, 9, 50, 61, 41] = (225700 : Int)", "#guard maximumProduct [25, 35, 22, 85, 14, 65, 75, 25, 58] = (414375 : Int)", "#guard maximumProduct [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1] = (2520 : Int)"]}
{"text": "Write a function to find ln, m lobb number.", "task_id": 912, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef binomialCoeff (n k : Nat) : Nat := Id.run do\n  let mut C : Array (Array Nat) := Array.replicate (n+1) (Array.replicate (k+1) 0)\n  for i in [0 : n+1] do\n    let upto := min i k\n    for j in [0 : upto+1] do\n      if j == 0 || j == i then\n        C := C.set2d? i j 1\n      else\n        let val := C.get2d (i-1) (j-1) 0 + C.get2d (i-1) j 0\n        C := C.set2d? i j val\n  return C.get2d n k 0\n\ndef lobbNum (n m : Nat) : Nat :=\n  ((2 * m + 1) * binomialCoeff (2 * n) (m + n)) / (m + n + 1)\n\n#guard lobbNum 5 3 = 35\n#guard lobbNum 3 2 = 5\n#guard lobbNum 4 2 = 20\n", "test_list": ["#guard lobbNum 5 3 = 35", "#guard lobbNum 3 2 = 5", "#guard lobbNum 4 2 = 20"]}
{"text": "Write a function to check for a number at the end of a string.", "task_id": 913, "code": "import Batteries\n\nopen Std\n\ndef endNum (string : String) : Bool :=\n  let n := string.length\n  if n = 0 then\n    false\n  else\n    let last := string.drop (n - 1)\n    last == \"0\" || last == \"1\" || last == \"2\" || last == \"3\" || last == \"4\" || last == \"5\" || last == \"6\" || last == \"7\" || last == \"8\" || last == \"9\"\n\n#guard endNum \"abcdef\" == false\n#guard endNum \"abcdef7\" == true\n#guard endNum \"abc\" == false\n", "test_list": ["#guard endNum \"abcdef\" == false", "#guard endNum \"abcdef7\" == true", "#guard endNum \"abc\" == false"]}
{"text": "Write a python function to check whether the given string is made up of two alternating characters or not.", "task_id": 914, "code": "import Batteries\n\nopen Std\n\ndef checkPairs (cs : List Char) : Bool :=\n  match cs with\n  | a :: b :: c :: rest =>\n      if a == c then\n        checkPairs (b :: c :: rest)\n      else\n        false\n  | _ => true\n\ndef is_Two_Alter (s : String) : Bool :=\n  let cs := s.data\n  if !checkPairs cs then\n    false\n  else\n    match cs with\n    | a :: b :: _ => if a == b then false else true\n    | _ => false\n\n#guard is_Two_Alter \"abab\" == true\n#guard is_Two_Alter \"aaaa\" == false\n#guard is_Two_Alter \"xyz\" == false\n", "test_list": ["#guard is_Two_Alter \"abab\" == true", "#guard is_Two_Alter \"aaaa\" == false", "#guard is_Two_Alter \"xyz\" == false"]}
{"text": "Write a function to find if there is a triplet in the array whose sum is equal to a given value.", "task_id": 916, "code": "import Batteries\n\nopen Std\n\ndef findTripletArray (A : List Nat) (arr_size : Nat) (sum : Nat) : Option (Nat × Nat × Nat) := Id.run do\n  \n  for i in [0 : arr_size - 2] do\n    for j in [i + 1 : arr_size - 1] do\n      for k in [j + 1 : arr_size] do\n        if A.getD i 0 + A.getD j 0 + A.getD k 0 == sum then\n          return some (A.getD i 0, A.getD j 0, A.getD k 0)\n  return none\n\n#guard findTripletArray [1, 4, 45, 6, 10, 8] 6 22 == some (4, 10, 8)\n#guard findTripletArray [12, 3, 5, 2, 6, 9] 6 24 == some (12, 3, 9)\n#guard findTripletArray [1, 2, 3, 4, 5] 5 9 == some (1, 3, 5)\n", "test_list": ["#guard findTripletArray [1, 4, 45, 6, 10, 8] 6 22 == some (4, 10, 8)", "#guard findTripletArray [12, 3, 5, 2, 6, 9] 6 24 == some (12, 3, 9)", "#guard findTripletArray [1, 2, 3, 4, 5] 5 9 == some (1, 3, 5)"]}
{"text": "Write a function to find the sequences of one upper case letter followed by lower case letters.", "task_id": 917, "code": "import Batteries\n\nopen Std\n\ndef isUpperASCII (c : Char) : Bool := 'A' ≤ c && c ≤ 'Z'\ndef isLowerASCII (c : Char) : Bool := 'a' ≤ c && c ≤ 'z'\n\ndef countPrefix {α} (p : α → Bool) : List α → Nat\n  | [] => 0\n  | x :: xs => if p x then 1 + countPrefix p xs else 0\n\ndef textUppercaseLowercase (text : String) : String :=\n  let rev := text.data.reverse\n  let lowerCount := countPrefix isLowerASCII rev\n  if lowerCount = 0 then\n    \"Not matched!\"\n  else\n    let rest := rev.drop lowerCount\n    let upperCount := countPrefix isUpperASCII rest\n    if upperCount = 0 then \"Not matched!\" else \"Found a match!\"\n\n#guard textUppercaseLowercase \"AaBbGg\" == \"Found a match!\"\n#guard textUppercaseLowercase \"aA\" == \"Not matched!\"\n#guard textUppercaseLowercase \"PYTHON\" == \"Not matched!\"\n", "test_list": ["#guard textUppercaseLowercase \"AaBbGg\" == \"Found a match!\"", "#guard textUppercaseLowercase \"aA\" == \"Not matched!\"", "#guard textUppercaseLowercase \"PYTHON\" == \"Not matched!\""]}
{"text": "Write a function to count coin change.", "task_id": 918, "code": "import Batteries\n\nopen Std\n\ndef Array.modify2d {α : Type} (a : Array (Array α)) (y x : Nat) (f : α → α) :=\n  a.modify y (fun row => row.modify x f)\n\ndef Array.set2d? {α : Type} (a : Array (Array α)) (y x : Nat) (value : α) :=\n  a.modify2d y x (fun _ => value)\n\ndef Array.get2d {α : Type} (a : Array (Array α)) (y x : Nat) (fallback : α) :=\n  (a.getD y #[]).getD x fallback\n\ndef coinChange (S : List Nat) (m n : Nat) : Nat := Id.run do\n  let mut table : Array (Array Nat) := Array.replicate (n+1) (Array.replicate m 0)\n  \n  for j in [: m] do\n    table := table.set2d? 0 j 1\n  \n  for i in [1 : n+1] do\n    for j in [: m] do\n      let coin := S.getD j 0\n      let x := if i >= coin then table.get2d (i - coin) j 0 else 0\n      let y := if j >= 1 then table.get2d i (j-1) 0 else 0\n      table := table.set2d? i j (x + y)\n  return table.get2d n (m-1) 0\n\n#guard coinChange [1, 2, 3] 3 4 = 4\n#guard coinChange [4, 5, 6, 7, 8, 9] 6 9 = 2\n#guard coinChange [4, 5, 6, 7, 8, 9] 6 4 = 1\n", "test_list": ["#guard coinChange [1, 2, 3] 3 4 = 4", "#guard coinChange [4, 5, 6, 7, 8, 9] 6 9 = 2", "#guard coinChange [4, 5, 6, 7, 8, 9] 6 4 = 1"]}
{"text": "Write a python function to multiply all items in the list.", "task_id": 919, "code": "import Batteries\n\nopen Std\n\ndef multiplyList (items : List Int) : Int := Id.run do\n  let mut tot : Int := 1\n  for x in items do\n    tot := tot * x\n  return tot\n\n#guard multiplyList [1, -2, 3] = -6\n#guard multiplyList [1, 2, 3, 4] = 24\n#guard multiplyList [3, 1, 2, 3] = 18\n", "test_list": ["#guard multiplyList [1, -2, 3] = -6", "#guard multiplyList [1, 2, 3, 4] = 24", "#guard multiplyList [3, 1, 2, 3] = 18"]}
{"text": "Write a function to remove all tuples with all none values in the given tuple list.", "task_id": 920, "code": "import Batteries\n\nopen Std\n\ndef joinSep (l : List String) (sep : String) : String :=\n  match l with\n  | [] => \"\"\n  | s :: ss => ss.foldl (fun acc x => acc ++ sep ++ x) s\n\ndef allNone : List (Option Nat) → Bool\n  | [] => true\n  | none :: xs => allNone xs\n  | some _ :: _ => false\n\ndef reprElem : Option Nat → String\n  | none => \"None\"\n  | some n => toString n\n\ndef reprTuple (xs : List (Option Nat)) : String :=\n  match xs with\n  | [a] => \"(\" ++ reprElem a ++ \",)\"\n  | _ => \"(\" ++ joinSep (xs.map reprElem) \", \" ++ \")\"\n\ndef reprListTuples (xss : List (List (Option Nat))) : String :=\n  \"[\" ++ joinSep (xss.map reprTuple) \", \" ++ \"]\"\n\ndef removeTuple (test_list : List (List (Option Nat))) : String :=\n  let res := test_list.filter (fun sub => !(allNone sub))\n  reprListTuples res\n\n#guard removeTuple [[none, some 2], [none, none], [some 3, some 4], [some 12, some 3], [none]] = \"[(None, 2), (3, 4), (12, 3)]\"\n#guard removeTuple [[none, none], [none, none], [some 3, some 6], [some 17, some 3], [none, some 1]] = \"[(3, 6), (17, 3), (None, 1)]\"\n#guard removeTuple [[some 1, some 2], [some 2, none], [some 3, none], [some 24, some 3], [none, none]] = \"[(1, 2), (2, None), (3, None), (24, 3)]\"\n", "test_list": ["#guard removeTuple [[none, some 2], [none, none], [some 3, some 4], [some 12, some 3], [none]] = \"[(None, 2), (3, 4), (12, 3)]\"", "#guard removeTuple [[none, none], [none, none], [some 3, some 6], [some 17, some 3], [none, some 1]] = \"[(3, 6), (17, 3), (None, 1)]\"", "#guard removeTuple [[some 1, some 2], [some 2, none], [some 3, none], [some 24, some 3], [none, none]] = \"[(1, 2), (2, None), (3, None), (24, 3)]\""]}
{"text": "Write a function to perform chunking of tuples each of size n.", "task_id": 921, "code": "import Batteries\nopen Std\n\ndef chunkTuples (test_tup : List Nat) (N : Nat) : List (List Nat) :=\n  if N = 0 then\n    []\n  else\n    let acc : List (List Nat) × (List Nat × Nat) :=\n      test_tup.foldl\n        (fun (acc : List (List Nat) × (List Nat × Nat)) (x : Nat) =>\n          let res := acc.fst\n          let cur := acc.snd.fst\n          let cnt := acc.snd.snd\n          let cnt' := cnt + 1\n          if cnt' = N then\n            (res ++ [cur ++ [x]], ([], 0))\n          else\n            (res, (cur ++ [x], cnt'))\n        )\n        ([], ([], 0))\n    let res := acc.fst\n    let cur := acc.snd.fst\n    let cnt := acc.snd.snd\n    if cnt = 0 then res else res ++ [cur]\n\n#guard chunkTuples [10, 4, 5, 6, 7, 6, 8, 3, 4] 3 == [[10, 4, 5], [6, 7, 6], [8, 3, 4]]\n#guard chunkTuples [1, 2, 3, 4, 5, 6, 7, 8, 9] 2 == [[1, 2], [3, 4], [5, 6], [7, 8], [9]]\n#guard chunkTuples [11, 14, 16, 17, 19, 21, 22, 25] 4 == [[11, 14, 16, 17], [19, 21, 22, 25]]\n", "test_list": ["#guard chunkTuples [10, 4, 5, 6, 7, 6, 8, 3, 4] 3 == [[10, 4, 5], [6, 7, 6], [8, 3, 4]]", "#guard chunkTuples [1, 2, 3, 4, 5, 6, 7, 8, 9] 2 == [[1, 2], [3, 4], [5, 6], [7, 8], [9]]", "#guard chunkTuples [11, 14, 16, 17, 19, 21, 22, 25] 4 == [[11, 14, 16, 17], [19, 21, 22, 25]]"]}
{"text": "Write a function to find a pair with the highest product from a given array of integers.", "task_id": 922, "code": "import Batteries\nopen Std\n\ndef maxProduct (arr : List Int) : Option (Int × Int) :=\n  match arr with\n  | x :: y :: t =>\n    let rec pairMaxWith (a : Int) (lst : List Int) (best : Int × Int) : Int × Int :=\n      match lst with\n      | [] => best\n      | b :: bs =>\n        let best' := if a * b > best.fst * best.snd then (a, b) else best\n        pairMaxWith a bs best'\n    let rec outer (lst : List Int) (best : Int × Int) : Int × Int :=\n      match lst with\n      | [] => best\n      | [_] => best\n      | a :: bs =>\n        let best' := pairMaxWith a bs best\n        outer bs best'\n    let best0 := (x, y)\n    let best := outer (x :: y :: t) best0\n    some best\n  | _ => none\n\n#guard maxProduct [1, 2, 3, 4, 7, 0, 8, 4] == some (7, 8)\n#guard maxProduct [0, -1, -2, -4, 5, 0, -6] == some (-4, -6)\n#guard maxProduct [1, 3, 5, 6, 8, 9] == some (8, 9)\n", "test_list": ["#guard maxProduct [1, 2, 3, 4, 7, 0, 8, 4] == some (7, 8)", "#guard maxProduct [0, -1, -2, -4, 5, 0, -6] == some (-4, -6)", "#guard maxProduct [1, 3, 5, 6, 8, 9] == some (8, 9)"]}
{"text": "Write a function to find the length of the shortest string that has both str1 and str2 as subsequences.", "task_id": 923, "code": "import Batteries\n\nopen Std\n\npartial def superSeq (X Y : String) (m n : Nat) : Nat :=\n  if m = 0 then n\n  else if n = 0 then m\n  else\n    let xm1 := (X.drop (m - 1)).take 1\n    let yn1 := (Y.drop (n - 1)).take 1\n    if xm1 = yn1 then\n      1 + superSeq X Y (m - 1) (n - 1)\n    else\n      1 + min (superSeq X Y (m - 1) n) (superSeq X Y m (n - 1))\n\n#guard superSeq \"AGGTAB\" \"GXTXAYB\" 6 7 = 9\n#guard superSeq \"feek\" \"eke\" 4 3 = 5\n#guard superSeq \"PARRT\" \"RTA\" 5 3 = 6\n", "test_list": ["#guard superSeq \"AGGTAB\" \"GXTXAYB\" 6 7 = 9", "#guard superSeq \"feek\" \"eke\" 4 3 = 5", "#guard superSeq \"PARRT\" \"RTA\" 5 3 = 6"]}
{"text": "Write a function to find maximum of two numbers.", "task_id": 924, "code": "import Batteries\n\nopen Std\n\ndef maxOfTwo (x y : Int) : Int :=\n  if x > y then x else y\n\n#guard maxOfTwo 10 20 = 20\n#guard maxOfTwo 19 15 = 19\n#guard maxOfTwo (-10) (-20) = (-10)\n", "test_list": ["#guard maxOfTwo 10 20 = 20", "#guard maxOfTwo 19 15 = 19", "#guard maxOfTwo (-10) (-20) = (-10)"]}
{"text": "Write a python function to calculate the product of all the numbers of a given tuple.", "task_id": 925, "code": "import Batteries\n\nopen Std\n\ndef mutiple_tuple (nums : List Int) : Int := Id.run do\n  let temp := nums\n  let mut product : Int := 1\n  for x in temp do\n    product := product * x\n  return product\n\n#guard mutiple_tuple [4, 3, 2, 2, -1, 18] = -864\n#guard mutiple_tuple [1, 2, 3] = 6\n#guard mutiple_tuple [-2, -4, -6] = -48\n", "test_list": ["#guard mutiple_tuple [4, 3, 2, 2, -1, 18] = -864", "#guard mutiple_tuple [1, 2, 3] = 6", "#guard mutiple_tuple [-2, -4, -6] = -48"]}
{"text": "Write a function to find n-th rencontres number.", "task_id": 926, "code": "import Batteries\n\nopen Std\n\npartial def binomialCoeffi (n k : Nat) : Nat :=\n  if k == 0 || k == n then\n    1\n  else\n    binomialCoeffi (n - 1) (k - 1) + binomialCoeffi (n - 1) k\n\npartial def rencontresNumber (n m : Nat) : Nat :=\n  if n == 0 && m == 0 then\n    1\n  else if n == 1 && m == 0 then\n    0\n  else if m == 0 then\n    (n - 1) * (rencontresNumber (n - 1) 0 + rencontresNumber (n - 2) 0)\n  else\n    binomialCoeffi n m * rencontresNumber (n - m) 0\n\n#guard rencontresNumber 7 2 = 924\n#guard rencontresNumber 3 0 = 2\n#guard rencontresNumber 3 1 = 3\n", "test_list": ["#guard rencontresNumber 7 2 = 924", "#guard rencontresNumber 3 0 = 2", "#guard rencontresNumber 3 1 = 3"]}
{"text": "Write a function to calculate the height of the given binary tree.", "task_id": 927, "code": "import Batteries\nopen Std\n\nstructure Node where\n  data : Nat\n  left : Option Node := none\n  right : Option Node := none\n\nprivate def maxHeightFuel (fuel : Nat) (node : Option Node) : Nat :=\n  match fuel with\n  | 0 => 0\n  | fuel' + 1 =>\n    match node with\n    | none => 0\n    | some n =>\n      let leftHeight := maxHeightFuel fuel' n.left\n      let rightHeight := maxHeightFuel fuel' n.right\n      if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1\n\ndef max_height (node : Node) : Nat :=\n  maxHeightFuel 1000000 (some node)\n\ndef root : Task927.Node :=\n  { data := 1\n  , left := some { data := 2, left := some { data := 4 }, right := some { data := 5 } }\n  , right := some { data := 3 }\n  }\n\ndef root1 : Task927.Node :=\n  { data := 1\n  , left := some { data := 2, left := some { data := 4 } }\n  , right := some {\n      data := 3,\n      left := some { data := 5 },\n      right := some {\n        data := 6,\n        right := some {\n          data := 7,\n          right := some { data := 8 }\n        }\n      }\n    }\n  }\n\ndef root2 : Task927.Node :=\n  { data := 1\n  , left := some {\n      data := 2,\n      left := some { data := 4, left := some { data := 6 }, right := some { data := 7 } },\n      right := some { data := 5 }\n    },\n    right := some { data := 3 }\n  }\n\n#guard max_height root = 3\n#guard max_height root1 = 5\n#guard max_height root2 = 4\n", "test_list": ["#guard max_height root = 3", "#guard max_height root1 = 5", "#guard max_height root2 = 4"]}
{"text": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.", "task_id": 928, "code": "import Batteries\n\nopen Std\n\ndef changeDateFormat (dt : String) : String :=\n  let parts := dt.splitOn \"-\"\n  match parts with\n  | [y, m, d] => d ++ \"-\" ++ m ++ \"-\" ++ y\n  | _ => dt\n\n#guard changeDateFormat \"2026-01-02\" == \"02-01-2026\"\n#guard changeDateFormat \"2021-01-04\" == \"04-01-2021\"\n#guard changeDateFormat \"2030-06-06\" == \"06-06-2030\"\n", "test_list": ["#guard changeDateFormat \"2026-01-02\" == \"02-01-2026\"", "#guard changeDateFormat \"2021-01-04\" == \"04-01-2021\"", "#guard changeDateFormat \"2030-06-06\" == \"06-06-2030\""]}
{"text": "Write a function to count repeated items of a tuple.", "task_id": 929, "code": "import Batteries\n\nopen Std\n\ndef countTuplex (tuplex : List Nat) (value : Nat) : Nat :=\n  tuplex.foldl (fun acc x => if x == value then acc + 1 else acc) 0\n\n#guard countTuplex [2, 4, 5, 6, 2, 3, 4, 4, 7] 4 = 3\n#guard countTuplex [2, 4, 5, 6, 2, 3, 4, 4, 7] 2 = 2\n#guard countTuplex [2, 4, 7, 7, 7, 3, 4, 4, 7] 7 = 4\n", "test_list": ["#guard countTuplex [2, 4, 5, 6, 2, 3, 4, 4, 7] 4 = 3", "#guard countTuplex [2, 4, 5, 6, 2, 3, 4, 4, 7] 2 = 2", "#guard countTuplex [2, 4, 7, 7, 7, 3, 4, 4, 7] 7 = 4"]}
{"text": "Write a function that matches a string that has an a followed by zero or more b's by using regex.", "task_id": 930, "code": "import Batteries\n\nopen Std\n\ndef text_match (text : String) : String :=\n  let patterns := \"ab*?\"\n  if text.toList.any (fun c => c == 'a') then\n    \"Found a match!\"\n  else\n    \"Not matched!\"\n\n#guard text_match \"msb\" == \"Not matched!\"\n#guard text_match \"a0c\" == \"Found a match!\"\n#guard text_match \"abbc\" == \"Found a match!\"\n", "test_list": ["#guard text_match \"msb\" == \"Not matched!\"", "#guard text_match \"a0c\" == \"Found a match!\"", "#guard text_match \"abbc\" == \"Found a match!\""]}
{"text": "Write a function to calculate the sum of series 1³+2³+3³+….+n³.", "task_id": 931, "code": "import Batteries\n\nopen Std\n\ndef sumSeries (number : Nat) : Nat :=\n  let half := (number * (number + 1)) / 2\n  half * half\n\n#guard sumSeries 7 = 784\n#guard sumSeries 5 = 225\n#guard sumSeries 15 = 14400\n", "test_list": ["#guard sumSeries 7 = 784", "#guard sumSeries 5 = 225", "#guard sumSeries 15 = 14400"]}
{"text": "Write a function to remove duplicate words from a given list of strings.", "task_id": 932, "code": "import Batteries\n\nopen Std\n\ndef remove_duplic_list (l : List String) : List String :=\n  let rec go (l acc : List String) : List String :=\n    match l with\n    | [] => acc.reverse\n    | x :: xs =>\n      if acc.contains x then\n        go xs acc\n      else\n        go xs (x :: acc)\n  go l []\n\n#guard remove_duplic_list [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\"]\n  == [\"Python\", \"Exercises\", \"Practice\", \"Solution\"]\n#guard remove_duplic_list [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\", \"Java\"]\n  == [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Java\"]\n#guard remove_duplic_list [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\", \"C++\", \"C\", \"C++\"]\n  == [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"C++\", \"C\"]\n", "test_list": ["#guard remove_duplic_list [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\"]", "#guard remove_duplic_list [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\", \"Java\"]", "#guard remove_duplic_list [\"Python\", \"Exercises\", \"Practice\", \"Solution\", \"Exercises\", \"C++\", \"C\", \"C++\"]"]}
{"text": "Write a function to convert camel case string to snake case string by using regex.", "task_id": 933, "code": "import Batteries\n\nopen Std\n\ndef isUpperAscii (c : Char) : Bool := 'A' ≤ c && c ≤ 'Z'\n\ndef isLowerAscii (c : Char) : Bool := 'a' ≤ c && c ≤ 'z'\n\ndef isDigitAscii (c : Char) : Bool := '0' ≤ c && c ≤ '9'\n\ndef toLowerAscii (c : Char) : Char := if isUpperAscii c then Char.ofNat (c.toNat + 32) else c\n\ndef camelToSnake (text : String) : String :=\n  let chars := text.data\n  let rec loop (prev? : Option Char) (cs : List Char) (acc : List Char) : List Char :=\n    match cs with\n    | [] => acc\n    | c :: rest =>\n      let next? : Option Char := match rest with | [] => none | n :: _ => some n\n      let hasPrev := match prev? with | some _ => true | none => false\n      let nextIsLower := match next? with | some n => isLowerAscii n | none => false\n      let prevIsLowerOrDigit := match prev? with | some p => isLowerAscii p || isDigitAscii p | none => false\n      let needUnderscore := isUpperAscii c && hasPrev && (nextIsLower || prevIsLowerOrDigit)\n      let acc := if needUnderscore then '_' :: acc else acc\n      let acc := toLowerAscii c :: acc\n      loop (some c) rest acc\n  String.mk <| (loop none chars []).reverse\n\n#guard camelToSnake \"GoogleAssistant\" == \"google_assistant\"\n#guard camelToSnake \"ChromeCast\" == \"chrome_cast\"\n#guard camelToSnake \"QuadCore\" == \"quad_core\"\n", "test_list": ["#guard camelToSnake \"GoogleAssistant\" == \"google_assistant\"", "#guard camelToSnake \"ChromeCast\" == \"chrome_cast\"", "#guard camelToSnake \"QuadCore\" == \"quad_core\""]}
{"text": "Write a function to find the nth delannoy number.", "task_id": 934, "code": "import Batteries\n\nopen Std\n\npartial def dealnnoyNum (n m : Nat) : Nat :=\n  if m == 0 || n == 0 then\n    1\n  else\n    dealnnoyNum (m - 1) n\n    + dealnnoyNum (m - 1) (n - 1)\n    + dealnnoyNum m (n - 1)\n\n#guard dealnnoyNum 3 4 = 129\n#guard dealnnoyNum 3 3 = 63\n#guard dealnnoyNum 4 5 = 681\n", "test_list": ["#guard dealnnoyNum 3 4 = 129", "#guard dealnnoyNum 3 3 = 63", "#guard dealnnoyNum 4 5 = 681"]}
{"text": "Write a function to calculate the sum of series 1²+2²+3²+….+n².", "task_id": 935, "code": "import Batteries\n\nopen Std\n\ndef seriesSum (number : Nat) : Nat :=\n  let total := 0\n  let total := (number * (number + 1) * (2 * number + 1)) / 6\n  total\n\n#guard seriesSum 6 = 91\n#guard seriesSum 7 = 140\n#guard seriesSum 12 = 650\n", "test_list": ["#guard seriesSum 6 = 91", "#guard seriesSum 7 = 140", "#guard seriesSum 12 = 650"]}
{"text": "Write a function to re-arrange the given tuples based on the given ordered list.", "task_id": 936, "code": "import Batteries\nopen Std\n\ndef reArrangeTuples (testList : List (Nat × Nat)) (ordList : List Nat) : List (Nat × Nat) :=\n  let rec find (l : List (Nat × Nat)) (k : Nat) : Nat :=\n    match l with\n    | [] => 0\n    | (a, b) :: t => if a = k then b else find t k\n  ordList.map (fun key => (key, find testList key))\n\n#guard reArrangeTuples [(4, 3), (1, 9), (2, 10), (3, 2)] [1, 4, 2, 3] = [(1, 9), (4, 3), (2, 10), (3, 2)]\n#guard reArrangeTuples [(5, 4), (2, 10), (3, 11), (4, 3)] [3, 4, 2, 3] = [(3, 11), (4, 3), (2, 10), (3, 11)]\n#guard reArrangeTuples [(6, 3), (3, 8), (5, 7), (2, 4)] [2, 5, 3, 6] = [(2, 4), (5, 7), (3, 8), (6, 3)]\n", "test_list": ["#guard reArrangeTuples [(4, 3), (1, 9), (2, 10), (3, 2)] [1, 4, 2, 3] = [(1, 9), (4, 3), (2, 10), (3, 2)]", "#guard reArrangeTuples [(5, 4), (2, 10), (3, 11), (4, 3)] [3, 4, 2, 3] = [(3, 11), (4, 3), (2, 10), (3, 11)]", "#guard reArrangeTuples [(6, 3), (3, 8), (5, 7), (2, 4)] [2, 5, 3, 6] = [(2, 4), (5, 7), (3, 8), (6, 3)]"]}
{"text": "Write a function to count the most common character in a given string.", "task_id": 937, "code": "import Batteries\nopen Std\n\nprivate def updateCount (c : Char) (counts : List (Char × Nat)) : (List (Char × Nat) × Nat) :=\n  let rec upd (l : List (Char × Nat)) : (List (Char × Nat) × Nat) :=\n    match l with\n    | [] => ([(c, 1)], 1)\n    | (d, n) :: rs =>\n      if d = c then\n        ((d, n + 1) :: rs, n + 1)\n      else\n        let (rs', cnt) := upd rs\n        ((d, n) :: rs', cnt)\n  upd counts\n\ndef maxChar (str1 : String) : Char := Id.run do\n  \n  let mut counts : List (Char × Nat) := []\n  let mut best : Char := ' '\n  let mut bestCount : Nat := 0\n  for c in str1.data do\n    let (counts', cnt) := updateCount c counts\n    counts := counts'\n    if cnt > bestCount then\n      best := c\n      bestCount := cnt\n  return best\n\n#guard maxChar \"hello world\" == 'l'\n#guard maxChar \"hello \" == 'l'\n#guard maxChar \"python pr\" == 'p'\n", "test_list": ["#guard maxChar \"hello world\" == 'l'", "#guard maxChar \"hello \" == 'l'", "#guard maxChar \"python pr\" == 'p'"]}
{"text": "Write a function to find three closest elements from three sorted arrays.", "task_id": 938, "code": "import Batteries\n\nopen Std\n\ndef findCloset (A B C : List Nat) (p q r : Nat) : Nat × Nat × Nat := Id.run do\n  \n  \n  let a := A.toArray\n  let b := B.toArray\n  let c := C.toArray\n  let mut diff : Nat := 1000000000\n  let mut res_i := 0\n  let mut res_j := 0\n  let mut res_k := 0\n  let mut i := 0\n  let mut j := 0\n  let mut k := 0\n  let mut done := false\n  while i < p && j < q && k < r && !done do\n    let ai := a[i]!\n    let bj := b[j]!\n    let ck := c[k]!\n    let minimum := min ai (min bj ck)\n    let maximum := max ai (max bj ck)\n    let d := maximum - minimum\n    if d < diff then\n      res_i := i\n      res_j := j\n      res_k := k\n      diff := d\n    if diff == 0 then\n      done := true\n    else\n      if ai == minimum then\n        i := i + 1\n      else if bj == minimum then\n        j := j + 1\n      else\n        k := k + 1\n  return (a[res_i]!, b[res_j]!, c[res_k]!)\n\n#guard findCloset [1, 4, 10] [2, 15, 20] [10, 12] 3 3 2 = (10, 15, 10)\n#guard findCloset [20, 24, 100] [2, 19, 22, 79, 800] [10, 12, 23, 24, 119] 3 5 5 = (24, 22, 23)\n#guard findCloset [2, 5, 11] [3, 16, 21] [11, 13] 3 3 2 = (11, 16, 11)\n", "test_list": ["#guard findCloset [1, 4, 10] [2, 15, 20] [10, 12] 3 3 2 = (10, 15, 10)", "#guard findCloset [20, 24, 100] [2, 19, 22, 79, 800] [10, 12, 23, 24, 119] 3 5 5 = (24, 22, 23)", "#guard findCloset [2, 5, 11] [3, 16, 21] [11, 13] 3 3 2 = (11, 16, 11)"]}
{"text": "Write a function to sort a list of dictionaries using lambda function.", "task_id": 939, "code": "import Batteries\n\nopen Std\n\nstructure Model where\n  make : String\n  model : Nat\n  color : String\n  deriving Repr, BEq, DecidableEq\n\ndef insertBy {α β} [Ord β] (key : α → β) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys =>\n    match compare (key x) (key y) with\n    | Ordering.lt => x :: y :: ys\n    | _ => y :: insertBy key x ys\n\ndef insertionSortBy {α β} [Ord β] (key : α → β) (xs : List α) : List α :=\n  xs.foldl (fun acc x => insertBy key x acc) []\n\ndef sortedModels (models : List Model) : List Model :=\n  insertionSortBy (fun m => m.color) models\n\n#guard sortedModels [\n  { make := \"Nokia\", model := 216, color := \"Black\" },\n  { make := \"Mi Max\", model := 2, color := \"Gold\" },\n  { make := \"Samsung\", model := 7, color := \"Blue\" }\n] = [\n  { make := \"Nokia\", model := 216, color := \"Black\" },\n  { make := \"Samsung\", model := 7, color := \"Blue\" },\n  { make := \"Mi Max\", model := 2, color := \"Gold\" }\n]\n\n#guard sortedModels [\n  { make := \"Vivo\", model := 20, color := \"Blue\" },\n  { make := \"oppo\", model := 17, color := \"Gold\" },\n  { make := \"Apple\", model := 11, color := \"red\" }\n] = [\n  { make := \"Vivo\", model := 20, color := \"Blue\" },\n  { make := \"oppo\", model := 17, color := \"Gold\" },\n  { make := \"Apple\", model := 11, color := \"red\" }\n]\n\n#guard sortedModels [\n  { make := \"micromax\", model := 40, color := \"grey\" },\n  { make := \"poco\", model := 60, color := \"blue\" }\n] = [\n  { make := \"poco\", model := 60, color := \"blue\" },\n  { make := \"micromax\", model := 40, color := \"grey\" }\n]\n", "test_list": ["#guard sortedModels [", "#guard sortedModels [", "#guard sortedModels ["]}
{"text": "Write a function to sort the given array by using heap sort.", "task_id": 940, "code": "import Batteries\n\nopen Std\n\ndef shift_down (arr : Array Nat) (start end_ : Nat) : Array Nat := Id.run do\n  let mut a := arr\n  let mut root := start\n  while true do\n    if hcond : root * 2 + 1 ≤ end_ then\n      let mut child := root * 2 + 1\n      if h2 : child + 1 ≤ end_ then\n        if a[child]! < a[child + 1]! then\n          child := child + 1\n      else\n        ()\n      if h3 : child ≤ end_ then\n        if a[root]! < a[child]! then\n          let tmp := a[root]!\n          a := a.set! root (a[child]!)\n          a := a.set! child tmp\n          root := child\n        else\n          return a\n      else\n        return a\n    else\n      break\n  return a\n\ndef heapify (arr : Array Nat) : Array Nat := Id.run do\n  let n := arr.size\n  let end_ := match n with\n    | 0 => 0\n    | k+1 => k\n  let mut a := arr\n  match n with\n  | 0 => return a\n  | _ =>\n    let mut start := n / 2\n    while true do\n      a := shift_down a start end_\n      if h : start = 0 then\n        break\n      else\n        start := start - 1\n    return a\n\ndef heap_sort (arr : List Nat) : List Nat := Id.run do\n  let mut a := arr.toArray\n  a := heapify a\n  let n := a.size\n  let mut end_ := match n with\n    | 0 => 0\n    | k+1 => k\n  while true do\n    if h : end_ = 0 then\n      break\n    else\n      let tmp := a[0]!\n      a := a.set! 0 (a[end_]!)\n      a := a.set! end_ tmp\n      a := shift_down a 0 (end_ - 1)\n      end_ := end_ - 1\n  return a.toList\n\n#guard heap_sort [12, 2, 4, 5, 2, 3] = [2, 2, 3, 4, 5, 12]\n#guard heap_sort [32, 14, 5, 6, 7, 19] = [5, 6, 7, 14, 19, 32]\n#guard heap_sort [21, 15, 29, 78, 65] = [15, 21, 29, 65, 78]\n", "test_list": ["#guard heap_sort [12, 2, 4, 5, 2, 3] = [2, 2, 3, 4, 5, 12]", "#guard heap_sort [32, 14, 5, 6, 7, 19] = [5, 6, 7, 14, 19, 32]", "#guard heap_sort [21, 15, 29, 78, 65] = [15, 21, 29, 65, 78]"]}
{"text": "Write a function to count the elements in a list until an element is a tuple.", "task_id": 941, "code": "import Batteries\n\nopen Std\n\ninductive PyVal where\n  | num : Nat → PyVal\n  | tup : List PyVal → PyVal\n\ndef countElim (num : List PyVal) : Nat :=\n  let rec loop (l : List PyVal) (acc : Nat) : Nat :=\n    match l with\n    | [] => acc\n    | PyVal.tup _ :: _ => acc\n    | PyVal.num _ :: xs => loop xs (acc + 1)\n  loop num 0\n\n#guard countElim [PyVal.num 10, PyVal.num 20, PyVal.num 30, PyVal.tup [PyVal.num 10, PyVal.num 20], PyVal.num 40] = 3\n#guard countElim [PyVal.num 10, PyVal.tup [PyVal.num 20, PyVal.num 30], PyVal.tup [PyVal.num 10, PyVal.num 20], PyVal.num 40] = 1\n#guard countElim [PyVal.tup [PyVal.num 10, PyVal.tup [PyVal.num 20, PyVal.num 30, PyVal.tup [PyVal.num 10, PyVal.num 20], PyVal.num 40]]] = 0\n", "test_list": ["#guard countElim [PyVal.num 10, PyVal.num 20, PyVal.num 30, PyVal.tup [PyVal.num 10, PyVal.num 20], PyVal.num 40] = 3", "#guard countElim [PyVal.num 10, PyVal.tup [PyVal.num 20, PyVal.num 30], PyVal.tup [PyVal.num 10, PyVal.num 20], PyVal.num 40] = 1", "#guard countElim [PyVal.tup [PyVal.num 10, PyVal.tup [PyVal.num 20, PyVal.num 30, PyVal.tup [PyVal.num 10, PyVal.num 20], PyVal.num 40]]] = 0"]}
{"text": "Write a function to check if any list element is present in the given list.", "task_id": 942, "code": "import Batteries\n\nopen Std\n\ndef checkElement (testTup : List Nat) (checkList : List Nat) : Bool := Id.run do\n  let mut res := false\n  for ele in checkList do\n    if testTup.contains ele then\n      res := true\n      break\n  return res\n\n#guard checkElement [4, 5, 7, 9, 3] [6, 7, 10, 11] == true\n#guard checkElement [1, 2, 3, 4] [4, 6, 7, 8, 9] == true\n#guard checkElement [3, 2, 1, 4, 5] [9, 8, 7, 6] == false\n", "test_list": ["#guard checkElement [4, 5, 7, 9, 3] [6, 7, 10, 11] == true", "#guard checkElement [1, 2, 3, 4] [4, 6, 7, 8, 9] == true", "#guard checkElement [3, 2, 1, 4, 5] [9, 8, 7, 6] == false"]}
{"text": "Write a function to combine two given sorted lists using heapq module.", "task_id": 943, "code": "import Batteries\n\nopen Std\n\npartial def mergeGo (xs ys acc : List Nat) : List Nat :=\n  match xs, ys with\n  | [], _ => acc.reverse ++ ys\n  | _, [] => acc.reverse ++ xs\n  | x::xs', y::ys' =>\n    if x ≤ y then mergeGo xs' (y::ys') (x :: acc)\n    else mergeGo (x::xs') ys' (y :: acc)\n\ndef combine_lists (num1 num2 : List Nat) : List Nat :=\n  mergeGo num1 num2 []\n\n#guard combine_lists [1, 3, 5, 7, 9, 11] [0, 2, 4, 6, 8, 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n#guard combine_lists [1, 3, 5, 6, 8, 9] [2, 5, 7, 11] = [1, 2, 3, 5, 5, 6, 7, 8, 9, 11]\n#guard combine_lists [1, 3, 7] [2, 4, 6] = [1, 2, 3, 4, 6, 7]\n", "test_list": ["#guard combine_lists [1, 3, 5, 7, 9, 11] [0, 2, 4, 6, 8, 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]", "#guard combine_lists [1, 3, 5, 6, 8, 9] [2, 5, 7, 11] = [1, 2, 3, 5, 5, 6, 7, 8, 9, 11]", "#guard combine_lists [1, 3, 7] [2, 4, 6] = [1, 2, 3, 4, 6, 7]"]}
{"text": "Write a function to separate and print the numbers and their position of a given string.", "task_id": 944, "code": "import Batteries\n\nopen Std\n\ndef numPosition (text : String) : Nat :=\n  let rec loop (cs : List Char) (i : Nat) : Nat :=\n    match cs with\n    | [] => 0  \n    | c :: cs' => if c.isDigit then i else loop cs' (i+1)\n  loop text.toList 0\n\n#guard numPosition \"there are 70 flats in this apartment\" = 10\n#guard numPosition \"every adult have 32 teeth\" = 17\n#guard numPosition \"isha has 79 chocolates in her bag\" = 9\n", "test_list": ["#guard numPosition \"there are 70 flats in this apartment\" = 10", "#guard numPosition \"every adult have 32 teeth\" = 17", "#guard numPosition \"isha has 79 chocolates in her bag\" = 9"]}
{"text": "Write a function to convert the given tuples into set.", "task_id": 945, "code": "import Batteries\n\nopen Std\n\ndef tupleToSet (t : List String) : HashSet String :=\n  HashSet.ofList t\n\n#guard tupleToSet [\"x\", \"y\", \"z\"] == HashSet.ofList [\"y\", \"x\", \"z\"]\n#guard tupleToSet [\"a\", \"b\", \"c\"] == HashSet.ofList [\"c\", \"a\", \"b\"]\n#guard tupleToSet [\"z\", \"d\", \"e\"] == HashSet.ofList [\"d\", \"e\", \"z\"]\n", "test_list": ["#guard tupleToSet [\"x\", \"y\", \"z\"] == HashSet.ofList [\"y\", \"x\", \"z\"]", "#guard tupleToSet [\"a\", \"b\", \"c\"] == HashSet.ofList [\"c\", \"a\", \"b\"]", "#guard tupleToSet [\"z\", \"d\", \"e\"] == HashSet.ofList [\"d\", \"e\", \"z\"]"]}
{"text": "Write a python function to find the length of the shortest word.", "task_id": 947, "code": "import Batteries\n\nopen Std\n\ndef len_log (list1 : List String) : Nat := Id.run do\n  match list1 with\n  | [] => return 0\n  | x :: xs =>\n    let mut mn := x.length\n    for s in (x :: xs) do\n      if s.length < mn then\n        mn := s.length\n    return mn\n\n#guard len_log [\"win\",\"lose\",\"great\"] = 3\n#guard len_log [\"a\",\"ab\",\"abc\"] = 1\n#guard len_log [\"12\",\"12\",\"1234\"] = 2\n", "test_list": ["#guard len_log [\"win\",\"lose\",\"great\"] = 3", "#guard len_log [\"a\",\"ab\",\"abc\"] = 1", "#guard len_log [\"12\",\"12\",\"1234\"] = 2"]}
{"text": "Write a function to get an item of a tuple.", "task_id": 948, "code": "import Batteries\nopen Std\n\ndef getItem (tup1 : List (Sum String Nat)) (index : Int) : Sum String Nat :=\n  let len := tup1.length\n  let n : Nat :=\n    if index >= 0 then\n      Int.toNat index\n    else\n      let k := Int.toNat (-index)\n      len - k\n  let rec getAt (xs : List (Sum String Nat)) (i : Nat) : Option (Sum String Nat) :=\n    match xs, i with\n    | [], _ => none\n    | x :: _, 0 => some x\n    | _ :: xs', i' + 1 => getAt xs' i'\n  (getAt tup1 n).getD (Sum.inl \"\")\n\ndef t : List (Sum String Nat) := [Sum.inl \"w\", Sum.inr 3, Sum.inl \"r\", Sum.inl \"e\", Sum.inl \"s\", Sum.inl \"o\", Sum.inl \"u\", Sum.inl \"r\", Sum.inl \"c\", Sum.inl \"e\"]\n#guard getItem t 3 = Sum.inl \"e\"\n#guard getItem t (-4 : Int) = Sum.inl \"u\"\n#guard getItem t (-3 : Int) = Sum.inl \"r\"\n", "test_list": ["#guard getItem t 3 = Sum.inl \"e\"", "#guard getItem t (-4 : Int) = Sum.inl \"u\"", "#guard getItem t (-3 : Int) = Sum.inl \"r\""]}
{"text": "Write a function to sort the given tuple list basis the total digits in tuple.", "task_id": 949, "code": "import Batteries\n\nopen Std\n\ndef digitCount (n : Nat) : Nat := (toString n).length\n\ndef countDigs (tup : List Nat) : Nat :=\n  tup.foldl (fun acc x => acc + digitCount x) 0\n\nprivate def insertByKey {α} (key : α → Nat) (x : α) : List α → List α\n  | [] => [x]\n  | y :: ys =>\n    if Nat.ble (key y) (key x) then\n      y :: insertByKey key x ys\n    else\n      x :: y :: ys\n\nprivate def isortByKey {α} (key : α → Nat) (l : List α) : List α :=\n  l.foldl (fun acc x => insertByKey key x acc) []\n\nprivate def joinWith (sep : String) (xs : List String) : String :=\n  match xs with\n  | [] => \"\"\n  | x :: rs => rs.foldl (fun acc s => acc ++ sep ++ s) x\n\nprivate def reprTuple (t : List Nat) : String :=\n  match t with\n  | [] => \"()\"\n  | [x] => \"(\" ++ toString x ++ \",)\"\n  | _ => \"(\" ++ joinWith \", \" (t.map (fun n => toString n)) ++ \")\"\n\nprivate def reprListOfTuples (ts : List (List Nat)) : String :=\n  \"[\" ++ joinWith \", \" (ts.map reprTuple) ++ \"]\"\n\ndef sortList (testList : List (List Nat)) : String :=\n  let sorted := isortByKey countDigs testList\n  reprListOfTuples sorted\n\n#guard sortList [( [3, 4, 6, 723] ), ( [1, 2] ), ( [12345] ), ( [134, 234, 34] )] = \"[(1, 2), (12345,), (3, 4, 6, 723), (134, 234, 34)]\"\n#guard sortList [( [3, 4, 8] ), ( [1, 2] ), ( [1234335] ), ( [1345, 234, 334] )] = \"[(1, 2), (3, 4, 8), (1234335,), (1345, 234, 334)]\"\n#guard sortList [( [34, 4, 61, 723] ), ( [1, 2] ), ( [145] ), ( [134, 23] )] = \"[(1, 2), (145,), (134, 23), (34, 4, 61, 723)]\"\n", "test_list": ["#guard sortList [( [3, 4, 6, 723] ), ( [1, 2] ), ( [12345] ), ( [134, 234, 34] )] = \"[(1, 2), (12345,), (3, 4, 6, 723), (134, 234, 34)]\"", "#guard sortList [( [3, 4, 8] ), ( [1, 2] ), ( [1234335] ), ( [1345, 234, 334] )] = \"[(1, 2), (3, 4, 8), (1234335,), (1345, 234, 334)]\"", "#guard sortList [( [34, 4, 61, 723] ), ( [1, 2] ), ( [145] ), ( [134, 23] )] = \"[(1, 2), (145,), (134, 23), (34, 4, 61, 723)]\""]}
{"text": "Write a function to display sign of the chinese zodiac for given year.", "task_id": 950, "code": "import Batteries\n\nopen Std\n\ndef chineseZodiac (year : Nat) : String :=\n  let r := (year + 12*2000 - 2000) % 12\n  if r == 0 then \"Dragon\"\n  else if r == 1 then \"Snake\"\n  else if r == 2 then \"Horse\"\n  else if r == 3 then \"sheep\"\n  else if r == 4 then \"Monkey\"\n  else if r == 5 then \"Rooster\"\n  else if r == 6 then \"Dog\"\n  else if r == 7 then \"Pig\"\n  else if r == 8 then \"Rat\"\n  else if r == 9 then \"Ox\"\n  else if r == 10 then \"Tiger\"\n  else \"Hare\"\n\n#guard chineseZodiac 1997 = \"Ox\"\n#guard chineseZodiac 1998 = \"Tiger\"\n#guard chineseZodiac 1994 = \"Dog\"\n", "test_list": ["#guard chineseZodiac 1997 = \"Ox\"", "#guard chineseZodiac 1998 = \"Tiger\"", "#guard chineseZodiac 1994 = \"Dog\""]}
{"text": "Write a function to find the maximum of similar indices in two lists of tuples.", "task_id": 951, "code": "import Batteries\n\nopen Std\n\ndef maxSimilarIndices (test_list1 test_list2 : List (Nat × Nat)) : List (Nat × Nat) :=\n  List.zipWith (fun x y => (Nat.max x.fst y.fst, Nat.max x.snd y.snd)) test_list1 test_list2\n\n#guard maxSimilarIndices [(2, 4), (6, 7), (5, 1)] [(5, 4), (8, 10), (8, 14)] = [(5, 4), (8, 10), (8, 14)]\n#guard maxSimilarIndices [(3, 5), (7, 8), (6, 2)] [(6, 5), (9, 11), (9, 15)] = [(6, 5), (9, 11), (9, 15)]\n#guard maxSimilarIndices [(4, 6), (8, 9), (7, 3)] [(7, 6), (10, 12), (10, 16)] = [(7, 6), (10, 12), (10, 16)]\n", "test_list": ["#guard maxSimilarIndices [(2, 4), (6, 7), (5, 1)] [(5, 4), (8, 10), (8, 14)] = [(5, 4), (8, 10), (8, 14)]", "#guard maxSimilarIndices [(3, 5), (7, 8), (6, 2)] [(6, 5), (9, 11), (9, 15)] = [(6, 5), (9, 11), (9, 15)]", "#guard maxSimilarIndices [(4, 6), (8, 9), (7, 3)] [(7, 6), (10, 12), (10, 16)] = [(7, 6), (10, 12), (10, 16)]"]}
{"text": "Write a function to compute the value of ncr mod p.", "task_id": 952, "code": "import Batteries\n\nopen Std\n\ndef nCr_mod_p (n r p : Nat) : Nat := Id.run do\n  let r := if r > n - r then n - r else r\n  let mut C := Array.replicate (r + 1) 0\n  C := C.set! 0 1\n  for i in [1 : n + 1] do\n    let maxJ := min i r\n    for t in [0 : maxJ] do\n      let j := maxJ - t\n      let val := (C[j]! + C[j - 1]!) % p\n      C := C.set! j val\n  return C[r]!\n\n#guard nCr_mod_p 10 2 13 == 6\n#guard nCr_mod_p 11 3 14 == 11\n#guard nCr_mod_p 18 14 19 == 1\n", "test_list": ["#guard nCr_mod_p 10 2 13 == 6", "#guard nCr_mod_p 11 3 14 == 11", "#guard nCr_mod_p 18 14 19 == 1"]}
{"text": "Write a python function to find the minimun number of subsets with distinct elements.", "task_id": 953, "code": "import Batteries\n\nopen Std\n\ndef subset (ar : List Nat) (n : Nat) : Nat := Id.run do\n  let mut res := 0\n  if ar.isEmpty then\n    return 0\n  let mut mn := ar.head!\n  for x in ar.drop 1 do\n    if x < mn then\n      mn := x\n  let mut count := 0\n  for x in ar do\n    if x == mn then\n      count := count + 1\n  if count > res then\n    res := count\n  return res\n\n#guard subset [1, 2, 3, 4] 4 = 1\n#guard subset [5, 6, 9, 3, 4, 3, 4] 7 = 2\n#guard subset [1, 2, 3] 3 = 1\n", "test_list": ["#guard subset [1, 2, 3, 4] 4 = 1", "#guard subset [5, 6, 9, 3, 4, 3, 4] 7 = 2", "#guard subset [1, 2, 3] 3 = 1"]}
{"text": "Write a function that gives profit amount if the given amount has profit else return none.", "task_id": 954, "code": "import Batteries\n\nopen Std\n\ndef profitAmount (actualCost saleAmount : Nat) : Option Nat :=\n  if actualCost > saleAmount then\n    let amount := actualCost - saleAmount\n    some amount\n  else\n    none\n\n#guard profitAmount 1500 1200 = some 300\n#guard profitAmount 100 200 = none\n#guard profitAmount 2000 5000 = none\n", "test_list": ["#guard profitAmount 1500 1200 = some 300", "#guard profitAmount 100 200 = none", "#guard profitAmount 2000 5000 = none"]}
{"text": "Write a function to find out, if the given number is abundant.", "task_id": 955, "code": "import Batteries\n\nopen Std\n\ndef isAbundant (n : Nat) : Bool := Id.run do\n  let mut fctrsum := 0\n  for fctr in [1 : n] do\n    if n % fctr == 0 then\n      fctrsum := fctrsum + fctr\n  return fctrsum > n\n\n#guard isAbundant 12 == true\n#guard isAbundant 13 == false\n#guard isAbundant 9 == false\n", "test_list": ["#guard isAbundant 12 == true", "#guard isAbundant 13 == false", "#guard isAbundant 9 == false"]}
{"text": "Write a function to split the given string at uppercase letters by using regex.", "task_id": 956, "code": "import Batteries\n\nopen Std\n\ndef isUpperASCII (c : Char) : Bool :=\n  let n := c.toNat\n  let a := ('A').toNat\n  let z := ('Z').toNat\n  n >= a && n <= z\n\ndef splitList (text : String) : List String :=\n  let rec loop (cs : List Char) (bufRev : List Char) (accRev : List String) : List String :=\n    match cs with\n    | [] =>\n      let accRev := if bufRev.isEmpty then accRev else (String.mk (bufRev.reverse)) :: accRev\n      accRev.reverse\n    | c :: cs' =>\n      if isUpperASCII c then\n        let accRev := if bufRev.isEmpty then accRev else (String.mk (bufRev.reverse)) :: accRev\n        loop cs' [c] accRev\n      else\n        if bufRev.isEmpty then\n          loop cs' [] accRev\n        else\n          loop cs' (c :: bufRev) accRev\n  loop text.data [] []\n\n#guard splitList \"LearnToBuildAnythingWithGoogle\" == [\"Learn\", \"To\", \"Build\", \"Anything\", \"With\", \"Google\"]\n#guard splitList \"ApmlifyingTheBlack+DeveloperCommunity\" == [\"Apmlifying\", \"The\", \"Black+\", \"Developer\", \"Community\"]\n#guard splitList \"UpdateInTheGoEcoSystem\" == [\"Update\", \"In\", \"The\", \"Go\", \"Eco\", \"System\"]\n", "test_list": ["#guard splitList \"LearnToBuildAnythingWithGoogle\" == [\"Learn\", \"To\", \"Build\", \"Anything\", \"With\", \"Google\"]", "#guard splitList \"ApmlifyingTheBlack+DeveloperCommunity\" == [\"Apmlifying\", \"The\", \"Black+\", \"Developer\", \"Community\"]", "#guard splitList \"UpdateInTheGoEcoSystem\" == [\"Update\", \"In\", \"The\", \"Go\", \"Eco\", \"System\"]"]}
{"text": "Write a python function to get the position of rightmost set bit.", "task_id": 957, "code": "import Batteries\n\nopen Std\n\ndef getFirstSetBitPos (n : Nat) : Nat := Id.run do\n  \n  if n == 0 then\n    return 0\n  let mut x := n\n  let mut pos := 1\n  while x % 2 == 0 do\n    x := x / 2\n    pos := pos + 1\n  return pos\n\n#guard getFirstSetBitPos 12 == 3\n#guard getFirstSetBitPos 18 == 2\n#guard getFirstSetBitPos 16 == 5\n", "test_list": ["#guard getFirstSetBitPos 12 == 3", "#guard getFirstSetBitPos 18 == 2", "#guard getFirstSetBitPos 16 == 5"]}
{"text": "Write a function to convert an integer into a roman numeral.", "task_id": 958, "code": "import Batteries\n\nopen Std\n\ndef repeatAppend (acc s : String) (k : Nat) : String :=\n  match k with\n  | 0 => acc\n  | Nat.succ k' => repeatAppend (acc ++ s) s k'\n\ndef int_to_roman (num : Nat) : String := Id.run do\n  let val : Array Nat := #[1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n  let syb : Array String := #[\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\n  let mut roman_num := \"\"\n  let mut n := num\n  for i in [: val.size] do\n    let v := val[i]!\n    let s := syb[i]!\n    let q := n / v\n    if q > 0 then\n      roman_num := repeatAppend roman_num s q\n      n := n % v\n  return roman_num\n\n#guard int_to_roman 1 = \"I\"\n#guard int_to_roman 50 = \"L\"\n#guard int_to_roman 4 = \"IV\"\n", "test_list": ["#guard int_to_roman 1 = \"I\"", "#guard int_to_roman 50 = \"L\"", "#guard int_to_roman 4 = \"IV\""]}
{"text": "Write a python function to find the average of a list.", "task_id": 959, "code": "import Batteries\n\nopen Std\n\ndef Average (lst : List Nat) : Float :=\n  let s := lst.foldl (fun acc x => acc + x) 0\n  Float.ofNat s / Float.ofNat lst.length\n\n#guard Average [15, 9, 55, 41, 35, 20, 62, 49] == 35.75\n#guard Average [4, 5, 1, 2, 9, 7, 10, 8] == 5.75\n#guard Average [1, 2, 3] == 2.0\n", "test_list": ["#guard Average [15, 9, 55, 41, 35, 20, 62, 49] == 35.75", "#guard Average [4, 5, 1, 2, 9, 7, 10, 8] == 5.75", "#guard Average [1, 2, 3] == 2.0"]}
{"text": "Write a function to solve tiling problem.", "task_id": 960, "code": "import Batteries\n\nopen Std\n\ndef get_noOfways : Nat -> Nat\n| 0 => 0\n| 1 => 1\n| Nat.succ (Nat.succ k) => get_noOfways (Nat.succ k) + get_noOfways k\n\n#guard get_noOfways 4 = 3\n#guard get_noOfways 3 = 2\n#guard get_noOfways 5 = 5\n", "test_list": ["#guard get_noOfways 4 = 3", "#guard get_noOfways 3 = 2", "#guard get_noOfways 5 = 5"]}
{"text": "Write a function to convert a roman numeral to an integer.", "task_id": 961, "code": "import Batteries\n\nopen Std\n\ndef romVal (c : Char) : Nat :=\n  match c with\n  | 'I' => 1\n  | 'V' => 5\n  | 'X' => 10\n  | 'L' => 50\n  | 'C' => 100\n  | 'D' => 500\n  | 'M' => 1000\n  | _ => 0\n\ndef roman_to_int (s : String) : Nat := Id.run do\n  let chars := s.toList\n  let mut intVal : Nat := 0\n  let mut prevVal : Nat := 0\n  for c in chars do\n    let curr := romVal c\n    if prevVal > 0 && curr > prevVal then\n      intVal := intVal + (curr - 2 * prevVal)\n    else\n      intVal := intVal + curr\n    prevVal := curr\n  return intVal\n\n#guard roman_to_int \"MMMCMLXXXVI\" == 3986\n#guard roman_to_int \"MMMM\" == 4000\n#guard roman_to_int \"C\" == 100\n", "test_list": ["#guard roman_to_int \"MMMCMLXXXVI\" == 3986", "#guard roman_to_int \"MMMM\" == 4000", "#guard roman_to_int \"C\" == 100"]}
{"text": "Write a python function to find the sum of all even natural numbers within the range l and r.", "task_id": 962, "code": "import Batteries\n\nopen Std\n\ndef sum_Natural (n : Nat) : Nat :=\n  n * (n + 1)\n\ndef sum_Even (l r : Nat) : Nat :=\n  sum_Natural (r / 2) - sum_Natural ((l - 1) / 2)\n\n#guard sum_Even 2 5 = 6\n#guard sum_Even 3 8 = 18\n#guard sum_Even 4 6 = 10\n", "test_list": ["#guard sum_Even 2 5 = 6", "#guard sum_Even 3 8 = 18", "#guard sum_Even 4 6 = 10"]}
{"text": "Write a function to calculate the discriminant value.", "task_id": 963, "code": "import Batteries\n\nopen Std\n\ndef discriminantValue (x y z : Int) : String × Int :=\n  let discriminant := y*y - 4*x*z\n  if _h : discriminant > 0 then\n    (\"Two solutions\", discriminant)\n  else if _h2 : discriminant = 0 then\n    (\"one solution\", discriminant)\n  else\n    (\"no real solution\", discriminant)\n\n#guard discriminantValue 4 8 2 = (\"Two solutions\", 32)\n#guard discriminantValue 5 7 9 = (\"no real solution\", -131)\n#guard discriminantValue 0 0 9 = (\"one solution\", 0)\n", "test_list": ["#guard discriminantValue 4 8 2 = (\"Two solutions\", 32)", "#guard discriminantValue 5 7 9 = (\"no real solution\", -131)", "#guard discriminantValue 0 0 9 = (\"one solution\", 0)"]}
{"text": "Write a python function to check whether the length of the word is even or not.", "task_id": 964, "code": "import Batteries\n\nopen Std\n\ndef wordLen (s : String) : Bool :=\n  let parts := s.splitOn \" \"\n  let word := parts.headD \"\"\n  if word.length % 2 = 0 then true else false\n\n#guard wordLen \"program\" = false\n#guard wordLen \"solution\" = true\n#guard wordLen \"data\" = true\n", "test_list": ["#guard wordLen \"program\" = false", "#guard wordLen \"solution\" = true", "#guard wordLen \"data\" = true"]}
{"text": "Write a function to convert camel case string to snake case string.", "task_id": 965, "code": "import Batteries\n\nopen Std\n\nprivate def isLowerASCII (c : Char) : Bool := 'a' ≤ c && c ≤ 'z'\nprivate def isUpperASCII (c : Char) : Bool := 'A' ≤ c && c ≤ 'Z'\nprivate def isDigitASCII (c : Char) : Bool := '0' ≤ c && c ≤ '9'\nprivate def asciiLower (c : Char) : Char := if isUpperASCII c then Char.ofNat (c.toNat + 32) else c\n\ndef camel_to_snake (text : String) : String :=\n  let chars : List Char := text.data\n  let rec go (prev? : Option Char) (cs : List Char) : List Char :=\n    match cs with\n    | [] => []\n    | c :: t =>\n      let needsUnderscore :=\n        match prev? with\n        | none => false\n        | some prev =>\n          let nextLower := match t with | d :: _ => isLowerASCII d | [] => false\n          isUpperASCII c && (isLowerASCII prev || isDigitASCII prev || nextLower)\n      if needsUnderscore then\n        '_' :: c :: go (some c) t\n      else\n        c :: go (some c) t\n  let lst := go none chars\n  String.mk (lst.map asciiLower)\n\n#guard camel_to_snake \"PythonProgram\" == \"python_program\"\n#guard camel_to_snake \"pythonLanguage\" == \"python_language\"\n#guard camel_to_snake \"ProgrammingLanguage\" == \"programming_language\"\n", "test_list": ["#guard camel_to_snake \"PythonProgram\" == \"python_program\"", "#guard camel_to_snake \"pythonLanguage\" == \"python_language\"", "#guard camel_to_snake \"ProgrammingLanguage\" == \"programming_language\""]}
{"text": "Write a function to remove an empty tuple from a list of tuples.", "task_id": 966, "code": "import Batteries\n\nopen Std\n\ninductive PyVal\n| tup : List String → PyVal\n| str : String → PyVal\nderiving BEq, Repr\n\ndef removeEmpty (tuple1 : List PyVal) : List PyVal :=\n  let tuple1 := tuple1.filter (fun t =>\n    match t with\n    | PyVal.tup xs => !xs.isEmpty\n    | PyVal.str s => s != \"\")\n  tuple1\n\n#guard removeEmpty [PyVal.tup [], PyVal.tup [], PyVal.tup [\"\"], PyVal.tup [\"a\",\"b\"], PyVal.tup [\"a\",\"b\",\"c\"], PyVal.str \"d\"]\n  == [PyVal.tup [\"\"], PyVal.tup [\"a\",\"b\"], PyVal.tup [\"a\",\"b\",\"c\"], PyVal.str \"d\"]\n#guard removeEmpty [PyVal.tup [], PyVal.tup [], PyVal.tup [\"\"], PyVal.str \"python\", PyVal.str \"program\"]\n  == [PyVal.tup [\"\"], PyVal.str \"python\", PyVal.str \"program\"]\n#guard removeEmpty [PyVal.tup [], PyVal.tup [], PyVal.tup [\"\"], PyVal.str \"java\"]\n  == [PyVal.tup [\"\"], PyVal.str \"java\"]\n", "test_list": ["#guard removeEmpty [PyVal.tup [], PyVal.tup [], PyVal.tup [\"\"], PyVal.tup [\"a\",\"b\"], PyVal.tup [\"a\",\"b\",\"c\"], PyVal.str \"d\"]", "#guard removeEmpty [PyVal.tup [], PyVal.tup [], PyVal.tup [\"\"], PyVal.str \"python\", PyVal.str \"program\"]", "#guard removeEmpty [PyVal.tup [], PyVal.tup [], PyVal.tup [\"\"], PyVal.str \"java\"]"]}
{"text": "Write a python function to accept the strings which contains all vowels.", "task_id": 967, "code": "import Batteries\n\nopen Std\n\ndef check (string : String) : String :=\n  let vowels := \"AEIOUaeiou\".toList\n  let found := string.toList.foldl (fun acc c =>\n    if (vowels.any (fun v => v == c)) && !(acc.any (fun v => v == c)) then\n      c :: acc\n    else acc\n  ) []\n  if found.length >= 5 then \"accepted\" else \"not accepted\"\n\n#guard check \"SEEquoiaL\" == \"accepted\"\n#guard check \"program\" == \"not accepted\"\n#guard check \"fine\" == \"not accepted\"\n", "test_list": ["#guard check \"SEEquoiaL\" == \"accepted\"", "#guard check \"program\" == \"not accepted\"", "#guard check \"fine\" == \"not accepted\""]}
{"text": "Write a python function to find maximum possible value for the given periodic function.", "task_id": 968, "code": "import Batteries\n\nopen Std\n\ndef floorMax (A B N : Nat) : Nat :=\n  let x := min (B - 1) N\n  Nat.div (A * x) B\n\n#guard floorMax 11 10 9 = 9\n#guard floorMax 5 7 4 = 2\n#guard floorMax 2 2 1 = 1\n", "test_list": ["#guard floorMax 11 10 9 = 9", "#guard floorMax 5 7 4 = 2", "#guard floorMax 2 2 1 = 1"]}
{"text": "Write a function to join the tuples if they have similar initial elements.", "task_id": 969, "code": "import Batteries\nopen Std\n\ndef joinTuples (testList : List (List Nat)) : List (List Nat) := Id.run do\n  let mut res : Array (Array Nat) := #[]\n  for sub in testList do\n    let subArr := sub.toArray\n    match res.back? with\n    | some last =>\n      let last0 :=\n        match last.toList with\n        | h :: _ => h\n        | [] => 0\n      let sub0 :=\n        match sub with\n        | h :: _ => h\n        | [] => 0\n      if last0 == sub0 then\n        let tail := subArr.extract 1 subArr.size\n        let idx := res.size - 1\n        res := res.set! idx (last ++ tail)\n      else\n        res := res.push subArr\n    | none =>\n      res := res.push subArr\n  return res.toList.map (fun a => a.toList)\n\n#guard joinTuples [[5, 6], [5, 7], [6, 8], [6, 10], [7, 13]] = [[5, 6, 7], [6, 8, 10], [7, 13]]\n#guard joinTuples [[6, 7], [6, 8], [7, 9], [7, 11], [8, 14]] = [[6, 7, 8], [7, 9, 11], [8, 14]]\n#guard joinTuples [[7, 8], [7, 9], [8, 10], [8, 12], [9, 15]] = [[7, 8, 9], [8, 10, 12], [9, 15]]\n", "test_list": ["#guard joinTuples [[5, 6], [5, 7], [6, 8], [6, 10], [7, 13]] = [[5, 6, 7], [6, 8, 10], [7, 13]]", "#guard joinTuples [[6, 7], [6, 8], [7, 9], [7, 11], [8, 14]] = [[6, 7, 8], [7, 9, 11], [8, 14]]", "#guard joinTuples [[7, 8], [7, 9], [8, 10], [8, 12], [9, 15]] = [[7, 8, 9], [8, 10, 12], [9, 15]]"]}
{"text": "Write a function to find minimum of two numbers.", "task_id": 970, "code": "import Batteries\n\nopen Std\n\ndef min_of_two (x y : Int) : Int :=\n  if h : x < y then x else y\n\n#guard min_of_two 10 20 = 10\n#guard min_of_two 19 15 = 15\n#guard min_of_two (-10) (-20) = (-20)\n", "test_list": ["#guard min_of_two 10 20 = 10", "#guard min_of_two 19 15 = 15", "#guard min_of_two (-10) (-20) = (-20)"]}
{"text": "Write a function to find the maximum number of segments of lengths a, b and c that can be formed from n.", "task_id": 971, "code": "import Batteries\n\nopen Std\n\ndef maximumSegments (n a b c : Nat) : Int := Id.run do\n  let mut dp : Array Int := Array.replicate (n + 10) (-1)\n  dp := dp.set! 0 0\n  for i in [0 : n] do\n    if dp[i]! != (-1) then\n      if h₁ : i + a ≤ n then\n        let cand := dp[i]! + 1\n        let cur := dp[i + a]!\n        let mx := max cand cur\n        dp := dp.set! (i + a) mx\n      else\n        pure ()\n      if h₂ : i + b ≤ n then\n        let cand := dp[i]! + 1\n        let cur := dp[i + b]!\n        let mx := max cand cur\n        dp := dp.set! (i + b) mx\n      else\n        pure ()\n      if h₃ : i + c ≤ n then\n        let cand := dp[i]! + 1\n        let cur := dp[i + c]!\n        let mx := max cand cur\n        dp := dp.set! (i + c) mx\n      else\n        pure ()\n  return dp[n]!\n\n#guard maximumSegments 7 5 2 5 = (2 : Int)\n#guard maximumSegments 17 2 1 3 = (17 : Int)\n#guard maximumSegments 18 16 3 6 = (6 : Int)\n", "test_list": ["#guard maximumSegments 7 5 2 5 = (2 : Int)", "#guard maximumSegments 17 2 1 3 = (17 : Int)", "#guard maximumSegments 18 16 3 6 = (6 : Int)"]}
{"text": "Write a function to concatenate the given two tuples to a nested tuple.", "task_id": 972, "code": "import Batteries\n\nopen Std\n\ndef concatenateNested (test_tup1 test_tup2 : List Nat) : List Nat :=\n  let res := test_tup1 ++ test_tup2\n  res\n\n#guard concatenateNested [3, 4] [5, 6] = [3, 4, 5, 6]\n#guard concatenateNested [1, 2] [3, 4] = [1, 2, 3, 4]\n#guard concatenateNested [4, 5] [6, 8] = [4, 5, 6, 8]\n", "test_list": ["#guard concatenateNested [3, 4] [5, 6] = [3, 4, 5, 6]", "#guard concatenateNested [1, 2] [3, 4] = [1, 2, 3, 4]", "#guard concatenateNested [4, 5] [6, 8] = [4, 5, 6, 8]"]}
{"text": "Write a python function to left rotate the string.", "task_id": 973, "code": "import Batteries\n\nopen Std\n\ndef leftRotate (s : String) (d : Nat) : String :=\n  let tmp := s.drop d ++ s.take d\n  tmp\n\n#guard leftRotate \"python\" 2 == \"thonpy\"\n#guard leftRotate \"bigdata\" 3 == \"databig\"\n#guard leftRotate \"hadoop\" 1 == \"adooph\"\n", "test_list": ["#guard leftRotate \"python\" 2 == \"thonpy\"", "#guard leftRotate \"bigdata\" 3 == \"databig\"", "#guard leftRotate \"hadoop\" 1 == \"adooph\""]}
{"text": "Write a function to find the minimum total path sum in the given triangle.", "task_id": 974, "code": "import Batteries\n\nopen Std\n\ndef minSumPath (A : List (List Nat)) : Nat := Id.run do\n  let arr : Array (Array Nat) := A.toArray.map (fun row => row.toArray)\n  if arr.size = 0 then\n    return 0\n  let n := arr.size - 1\n  let last := arr[n]!\n  let m := last.size\n  \n  let mut memo : Array Nat := Array.replicate arr.size 0\n  \n  for i in [0:m] do\n    memo := memo.set! i (last[i]!)\n  \n  for k in [0 : arr.size - 1] do\n    let i := (arr.size - 2) - k\n    let row := arr[i]!\n    let width := row.size\n    for j in [0:width] do\n      memo := memo.set! j (row[j]! + Nat.min (memo[j]!) (memo[j+1]!))\n  return memo[0]!\n\n#guard minSumPath [[2], [3, 9], [1, 6, 7]] == 6\n#guard minSumPath [[2], [3, 7], [8, 5, 6]] == 10\n#guard minSumPath [[3], [6, 4], [5, 2, 7]] == 9\n", "test_list": ["#guard minSumPath [[2], [3, 9], [1, 6, 7]] == 6", "#guard minSumPath [[2], [3, 7], [8, 5, 6]] == 10", "#guard minSumPath [[3], [6, 4], [5, 2, 7]] == 9"]}
