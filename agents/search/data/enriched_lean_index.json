{
  "subsingleton_of_forall_eq": {
    "name": "subsingleton_of_forall_eq",
    "type": "theorem",
    "signature": "subsingleton_of_forall_eq : Subsingleton α",
    "docstring": "If all points are equal to a given point `x`, then `α` is a subsingleton.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Logic.lean",
    "line_number": 112,
    "source": "batteries",
    "description": "If all points are equal to a given point `x`, then `α` is a subsingleton."
  },
  "log2p1": {
    "name": "log2p1",
    "type": "def",
    "signature": "log2p1 : Nat → Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/WF.lean",
    "line_number": 24,
    "source": "batteries",
    "description": "Calculates the logarithm base 2 of a natural number plus one, returning a natural number."
  },
  "otherWF": {
    "name": "otherWF",
    "type": "def",
    "signature": "otherWF : WellFounded Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/WF.lean",
    "line_number": 99,
    "source": "batteries",
    "description": "A well-founded relation on natural numbers, ensuring that every non-empty subset has a minimal element."
  },
  "AliasInfo.name": {
    "name": "AliasInfo.name",
    "type": "def",
    "signature": "AliasInfo.name : AliasInfo → Name",
    "docstring": "The name underlying an alias target",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "The name underlying an alias target"
  },
  "AliasInfo.toString": {
    "name": "AliasInfo.toString",
    "type": "def",
    "signature": "AliasInfo.toString : AliasInfo → String",
    "docstring": "The docstring for an alias.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "The docstring for an alias."
  },
  "setDeprecatedTarget": {
    "name": "setDeprecatedTarget",
    "type": "def",
    "signature": "setDeprecatedTarget : Array Attribute × Bool",
    "docstring": "Updates the `deprecated` declaration to point to `target` if no target is provided.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 67,
    "source": "batteries",
    "description": "Updates the `deprecated` declaration to point to `target` if no target is provided."
  },
  "mkIffMpApp": {
    "name": "mkIffMpApp",
    "type": "def",
    "signature": "mkIffMpApp : MetaM Expr",
    "docstring": "Given a possibly forall-quantified iff expression `prf`, produce a value for one of the implication directions (determined by `mp`).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 142,
    "source": "batteries",
    "description": "Given a possibly forall-quantified iff expression `prf`, produce a value for one of the implication directions (determined by `mp`)."
  },
  "addSide": {
    "name": "addSide",
    "type": "def",
    "signature": "addSide : TermElabM Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 148,
    "source": "batteries",
    "description": "Adds a side effect in the term elaboration monad, typically for managing state or context during elaboration."
  },
  "AliasInfo": {
    "name": "AliasInfo",
    "type": "inductive",
    "signature": "AliasInfo",
    "docstring": "An alias can be in one of three forms",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Alias.lean",
    "line_number": 29,
    "source": "batteries",
    "description": "An alias can be in one of three forms"
  },
  "State": {
    "name": "State",
    "type": "structure",
    "signature": "State",
    "docstring": "Collects the result of a `CollectOpaques` query.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintOpaques.lean",
    "line_number": 18,
    "source": "batteries",
    "description": "Collects the result of a `CollectOpaques` query."
  },
  "M": {
    "name": "M",
    "type": "abbrev",
    "signature": "M",
    "docstring": "The monad used by `CollectOpaques`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintOpaques.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "The monad used by `CollectOpaques`."
  },
  "splitGoalsAndGetNth": {
    "name": "splitGoalsAndGetNth",
    "type": "def",
    "signature": "splitGoalsAndGetNth : TacticM (MVarId × List MVarId × List MVarId)",
    "docstring": "If the current goals are `g₁ ⋯ gᵢ ⋯ gₙ`, `splitGoalsAndGetNth i` returns `(gᵢ, [g₁, ⋯, gᵢ₋₁], [gᵢ₊₁, ⋯, gₙ])`. If `reverse` is passed as `true`, the `i`-th goal is picked by counting backwards. For instance, `splitGoalsAndGetNth 1 true` puts the last goal in the first component of the returned term.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PermuteGoals.lean",
    "line_number": 36,
    "source": "batteries",
    "description": "If the current goals are `g₁ ⋯ gᵢ ⋯ gₙ`, `splitGoalsAndGetNth i` returns `(gᵢ, [g₁, ⋯, gᵢ₋₁], [gᵢ₊₁, ⋯, gₙ])`. If `reverse` is passed as `true`, the `i`-th goal is picked by counting backwards. For instance, `splitGoalsAndGetNth 1 true` puts the last goal in the first component of the returned term."
  },
  "Congr.Config": {
    "name": "Congr.Config",
    "type": "structure",
    "signature": "Congr.Config",
    "docstring": "Configuration options for `congr` & `rcongr`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Congr.lean",
    "line_number": 21,
    "source": "batteries",
    "description": "Configuration options for `congr` & `rcongr`"
  },
  "filterTag": {
    "name": "filterTag",
    "type": "def",
    "signature": "filterTag : TacticM (List MVarId)",
    "docstring": "Filter the `mvarIds` by tag. Returns those `MVarId`s that have `tag` either as its user name, as a suffix of its user name, or as a prefix of its user name. The results are sorted in this order. This is like `Lean.Elab.Tactic.findTag?` but it returns all results rather than just the first.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Case.lean",
    "line_number": 84,
    "source": "batteries",
    "description": "Filter the `mvarIds` by tag. Returns those `MVarId`s that have `tag` either as its user name, as a suffix of its user name, or as a prefix of its user name. The results are sorted in this order. This is like `Lean.Elab.Tactic.findTag?` but it returns all results rather than just the first."
  },
  "processCasePattBody": {
    "name": "processCasePattBody",
    "type": "def",
    "signature": "processCasePattBody : TacticM (Term ⊕ (Syntax × TSyntax ``Parser.Tactic.tacticSeq))",
    "docstring": "Given a `casePattBody`, either give a synthetic hole or a tactic sequence (along with the syntax for the `=>`). Converts holes into synthetic holes since they are processed with `elabTermWithHoles`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Case.lean",
    "line_number": 141,
    "source": "batteries",
    "description": "Given a `casePattBody`, either give a synthetic hole or a tactic sequence (along with the syntax for the `=>`). Converts holes into synthetic holes since they are processed with `elabTermWithHoles`."
  },
  "Lean.MVarId.assignIfDefEq": {
    "name": "Lean.MVarId.assignIfDefEq",
    "type": "def",
    "signature": "Lean.MVarId.assignIfDefEq : MetaM Unit",
    "docstring": "`MetaM` version of `Lean.Elab.Tactic.evalExact`: add `mvarId := x` to the metavariable assignment. This method wraps `Lean.MVarId.assign`, checking whether `mvarId` is already assigned, and whether the expression has the right type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Exact.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "`MetaM` version of `Lean.Elab.Tactic.evalExact`: add `mvarId := x` to the metavariable assignment. This method wraps `Lean.MVarId.assign`, checking whether `mvarId` is already assigned, and whether the expression has the right type."
  },
  "mkState": {
    "name": "mkState",
    "type": "def",
    "signature": "mkState : State",
    "docstring": "Constructs the initial state, marking the constants in `cs`. The result of `collect` will say whether a given declaration depends transitively on one of these constants. If `otherAxiom` is true, any axiom not specified in `cs` will also be tracked.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintDependents.lean",
    "line_number": 42,
    "source": "batteries",
    "description": "Constructs the initial state, marking the constants in `cs`. The result of `collect` will say whether a given declaration depends transitively on one of these constants. If `otherAxiom` is true, any axiom not specified in `cs` will also be tracked."
  },
  "getExplicitRelArgCore": {
    "name": "getExplicitRelArgCore",
    "type": "def",
    "signature": "getExplicitRelArgCore : MetaM (Expr × Expr)",
    "docstring": "refining `tgt ← mkAppM' rel #[x, z]` dropping more arguments if possible",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Trans.lean",
    "line_number": 82,
    "source": "batteries",
    "description": "refining `tgt ← mkAppM' rel #[x, z]` dropping more arguments if possible"
  },
  "getRel": {
    "name": "getRel",
    "type": "def",
    "signature": "getRel : MetaM (Option (TransRelation × Expr × Expr))",
    "docstring": "Finds an explicit binary relation in the argument, if possible.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Trans.lean",
    "line_number": 106,
    "source": "batteries",
    "description": "Finds an explicit binary relation in the argument, if possible."
  },
  "TransRelation": {
    "name": "TransRelation",
    "type": "inductive",
    "signature": "TransRelation",
    "docstring": "Internal definition for `trans` tactic. Either a binary relation or a non-dependent arrow.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Trans.lean",
    "line_number": 99,
    "source": "batteries",
    "description": "Internal definition for `trans` tactic. Either a binary relation or a non-dependent arrow."
  },
  "checkLangLemmaCmd": {
    "name": "checkLangLemmaCmd",
    "type": "def",
    "signature": "checkLangLemmaCmd : Bool",
    "docstring": "Check whether `lang.lemmaCmd` option is enabled",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lemma.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Check whether `lang.lemmaCmd` option is enabled"
  },
  "takeNameSuffix": {
    "name": "takeNameSuffix",
    "type": "def",
    "signature": "takeNameSuffix : Name × Name",
    "docstring": "`takeNameSuffix n name` returns a pair `(pre, suf)` where `suf` contains the last `n` components of the name and `pre` contains the rest.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 49,
    "source": "batteries",
    "description": "`takeNameSuffix n name` returns a pair `(pre, suf)` where `suf` contains the last `n` components of the name and `pre` contains the rest."
  },
  "lexNameLt": {
    "name": "lexNameLt",
    "type": "def",
    "signature": "lexNameLt : Name -> Name -> Bool",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 72,
    "source": "batteries",
    "description": "Compares two names lexicographically and returns true if the first name is less than the second."
  },
  "matchingConstants": {
    "name": "matchingConstants",
    "type": "def",
    "signature": "matchingConstants : MetaM (Array MessageData)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 80,
    "source": "batteries",
    "description": "Retrieves an array of MessageData within the MetaM monad, typically used for handling meta-programming tasks."
  },
  "PrintPrefixConfig": {
    "name": "PrintPrefixConfig",
    "type": "structure",
    "signature": "PrintPrefixConfig",
    "docstring": "Options to control `#print prefix` command and `getMatchingConstants`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/PrintPrefix.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "Options to control `#print prefix` command and `getMatchingConstants`."
  },
  "Environment.declsInModuleIdx": {
    "name": "Environment.declsInModuleIdx",
    "type": "def",
    "signature": "Environment.declsInModuleIdx : List Name",
    "docstring": "Get the list of declarations in a module (referenced by index).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/OpenPrivate.lean",
    "line_number": 36,
    "source": "batteries",
    "description": "Get the list of declarations in a module (referenced by index)."
  },
  "elabHelpOption": {
    "name": "elabHelpOption",
    "type": "def",
    "signature": "elabHelpOption : CommandElabM Unit",
    "docstring": "The command `#help option` shows all options that have been defined in the current environment. Each option has a format like: ``` option pp.all : Bool := false (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing ``` This says that `pp.all` is an option which can be set to a `Bool` value, and the default value is `false`. If an option has been modified from the default using e.g. `set_option pp.all true`, it will appear as a `(currently: true)` note next to the option. The form `#help option id` will show only options that begin with `id`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 53,
    "source": "batteries",
    "description": "The command `#help option` shows all options that have been defined in the current environment. Each option has a format like: ``` option pp.all : Bool := false (pretty printer) display coercions, implicit parameters, proof terms, fully qualified names, universe, and disable beta reduction and notations during pretty printing ``` This says that `pp.all` is an option which can be set to a `Bool` value, and the default value is `false`. If an option has been modified from the default using e.g. `set_option pp.all true`, it will appear as a `(currently: true)` note next to the option. The form `#help option id` will show only options that begin with `id`."
  },
  "elabHelpAttr": {
    "name": "elabHelpAttr",
    "type": "def",
    "signature": "elabHelpAttr : CommandElabM Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 100,
    "source": "batteries",
    "description": "Provides elaboration assistance for attributes in Lean, typically used in command elaboration contexts."
  },
  "elabHelpCats": {
    "name": "elabHelpCats",
    "type": "def",
    "signature": "elabHelpCats : CommandElabM Unit",
    "docstring": "The command `#help cats` shows all syntax categories that have been defined in the current environment. Each syntax has a format like: ``` category command [Lean.Parser.initFn✝] ``` The name of the syntax category in this case is `command`, and `Lean.Parser.initFn✝` is the name of the declaration that introduced it. (It is often an anonymous declaration like this, but you can click to go to the definition.) It also shows the doc string if available. The form `#help cats id` will show only syntax categories that begin with `id`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 183,
    "source": "batteries",
    "description": "The command `#help cats` shows all syntax categories that have been defined in the current environment. Each syntax has a format like: ``` category command [Lean.Parser.initFn✝] ``` The name of the syntax category in this case is `command`, and `Lean.Parser.initFn✝` is the name of the declaration that introduced it. (It is often an anonymous declaration like this, but you can click to go to the definition.) It also shows the doc string if available. The form `#help cats id` will show only syntax categories that begin with `id`."
  },
  "elabHelpCat": {
    "name": "elabHelpCat",
    "type": "def",
    "signature": "elabHelpCat : CommandElabM Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/HelpCmd.lean",
    "line_number": 225,
    "source": "batteries",
    "description": "Provides elaboration assistance in the command elaboration monad, returning no value."
  },
  "inf": {
    "name": "inf",
    "type": "def",
    "signature": "inf : Float",
    "docstring": "The floating point value \"positive infinity\", also used to represent numerical computations which produce finite values outside of the representable range of `Float`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 16,
    "source": "batteries",
    "description": "The floating point value \"positive infinity\", also used to represent numerical computations which produce finite values outside of the representable range of `Float`."
  },
  "nan": {
    "name": "nan",
    "type": "def",
    "signature": "nan : Float",
    "docstring": "The floating point value \"not a number\", used to represent erroneous numerical computations such as `0 / 0`. Using `nan` in any float operation will return `nan`, and all comparisons involving `nan` return `false`, including in particular `nan == nan`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "The floating point value \"not a number\", used to represent erroneous numerical computations such as `0 / 0`. Using `nan` in any float operation will return `nan`, and all comparisons involving `nan` return `false`, including in particular `nan == nan`."
  },
  "toRatParts": {
    "name": "toRatParts",
    "type": "def",
    "signature": "toRatParts : Option (Int × Int)",
    "docstring": "Returns `v, exp` integers such that `f = v * 2^exp`. (`e` is not minimal, but `v.abs` will be at most `2^53 - 1`.) Returns `none` when `f` is not finite (i.e. `inf`, `-inf` or a `nan`).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Returns `v, exp` integers such that `f = v * 2^exp`. (`e` is not minimal, but `v.abs` will be at most `2^53 - 1`.) Returns `none` when `f` is not finite (i.e. `inf`, `-inf` or a `nan`)."
  },
  "toStringFull": {
    "name": "toStringFull",
    "type": "def",
    "signature": "toStringFull : String",
    "docstring": "Converts `f` to a string, including all decimal digits.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 60,
    "source": "batteries",
    "description": "Converts `f` to a string, including all decimal digits."
  },
  "Nat.divFloat": {
    "name": "Nat.divFloat",
    "type": "def",
    "signature": "Nat.divFloat : Float",
    "docstring": "Divide two natural numbers, to produce a correctly rounded (nearest-ties-to-even) `Float` result.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 83,
    "source": "batteries",
    "description": "Divide two natural numbers, to produce a correctly rounded (nearest-ties-to-even) `Float` result."
  },
  "Int.divFloat": {
    "name": "Int.divFloat",
    "type": "def",
    "signature": "Int.divFloat : Float",
    "docstring": "Divide two integers, to produce a correctly rounded (nearest-ties-to-even) `Float` result.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Float.lean",
    "line_number": 101,
    "source": "batteries",
    "description": "Divide two integers, to produce a correctly rounded (nearest-ties-to-even) `Float` result."
  },
  "mergeWith": {
    "name": "mergeWith",
    "type": "def",
    "signature": "mergeWith : HashMap α β",
    "docstring": "`O(|other|)` amortized. Merge two `HashMap`s. The values of keys which appear in both maps are combined using `f`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/HashMap.lean",
    "line_number": 32,
    "source": "batteries",
    "description": "`O(|other|)` amortized. Merge two `HashMap`s. The values of keys which appear in both maps are combined using `f`."
  },
  "emoji": {
    "name": "emoji",
    "type": "def",
    "signature": "emoji : Except ε α → String",
    "docstring": "Visualize an `Except` using a checkmark or a cross.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Except.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Visualize an `Except` using a checkmark or a cross."
  },
  "any": {
    "name": "any",
    "type": "def",
    "signature": "any : Bool",
    "docstring": "Returns `true` if `f` returns `true` for any element of the set.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Returns `true` if `f` returns `true` for any element of the set."
  },
  "all": {
    "name": "all",
    "type": "def",
    "signature": "all : Bool",
    "docstring": "Returns `true` if `f` returns `true` for all elements of the set.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "Returns `true` if `f` returns `true` for all elements of the set."
  },
  "merge": {
    "name": "merge",
    "type": "def",
    "signature": "merge : PersistentHashSet α",
    "docstring": "Merge two `PersistentHashSet`s.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashSet.lean",
    "line_number": 90,
    "source": "batteries",
    "description": "Merge two `PersistentHashSet`s."
  },
  "Lean.TagAttribute.getDecls": {
    "name": "Lean.TagAttribute.getDecls",
    "type": "def",
    "signature": "Lean.TagAttribute.getDecls : Array Name",
    "docstring": "Get the list of declarations tagged with the tag attribute `attr`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/TagAttribute.lean",
    "line_number": 13,
    "source": "batteries",
    "description": "Get the list of declarations tagged with the tag attribute `attr`."
  },
  "registerNameMapExtension": {
    "name": "registerNameMapExtension",
    "type": "def",
    "signature": "registerNameMapExtension : IO (NameMapExtension α)",
    "docstring": "Registers a new extension with the given name and type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Registers a new extension with the given name and type."
  },
  "registerNameMapAttribute": {
    "name": "registerNameMapAttribute",
    "type": "def",
    "signature": "registerNameMapAttribute : IO (NameMapExtension α)",
    "docstring": "Similar to `registerParametricAttribute` except that attributes do not have to be assigned in the same file as the declaration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean",
    "line_number": 59,
    "source": "batteries",
    "description": "Similar to `registerParametricAttribute` except that attributes do not have to be assigned in the same file as the declaration."
  },
  "NameMapAttributeImpl": {
    "name": "NameMapAttributeImpl",
    "type": "structure",
    "signature": "NameMapAttributeImpl",
    "docstring": "The inputs to `registerNameMapAttribute`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/NameMapAttribute.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "The inputs to `registerNameMapAttribute`."
  },
  "ofList": {
    "name": "ofList",
    "type": "def",
    "signature": "ofList : PersistentHashMap α β",
    "docstring": "Builds a `PersistentHashMap` from a list of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "Builds a `PersistentHashMap` from a list of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences."
  },
  "ofListWith": {
    "name": "ofListWith",
    "type": "def",
    "signature": "ofListWith : PersistentHashMap α β",
    "docstring": "Variant of `ofList` which accepts a function that combines values of duplicated keys.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "Variant of `ofList` which accepts a function that combines values of duplicated keys."
  },
  "ofArray": {
    "name": "ofArray",
    "type": "def",
    "signature": "ofArray : PersistentHashMap α β",
    "docstring": "Builds a `PersistentHashMap` from an array of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 38,
    "source": "batteries",
    "description": "Builds a `PersistentHashMap` from an array of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences."
  },
  "ofArrayWith": {
    "name": "ofArrayWith",
    "type": "def",
    "signature": "ofArrayWith : PersistentHashMap α β",
    "docstring": "Variant of `ofArray` which accepts a function that combines values of duplicated keys.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/PersistentHashMap.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "Variant of `ofArray` which accepts a function that combines values of duplicated keys."
  },
  "toSyntax": {
    "name": "toSyntax",
    "type": "def",
    "signature": "toSyntax : TermElabM Syntax.Term",
    "docstring": "Converts an `Expr` into a `Syntax`, by creating a fresh metavariable assigned to the expr and returning a named metavariable syntax `?a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Expr.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "Converts an `Expr` into a `Syntax`, by creating a fresh metavariable assigned to the expr and returning a named metavariable syntax `?a`."
  },
  "hasTag": {
    "name": "hasTag",
    "type": "def",
    "signature": "hasTag : Bool",
    "docstring": "Does declaration `decl` have the tag `attr`?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 55,
    "source": "batteries",
    "description": "Does declaration `decl` have the tag `attr`?"
  },
  "getDecls": {
    "name": "getDecls",
    "type": "def",
    "signature": "getDecls : Array Name",
    "docstring": "Get the list of declarations tagged with the tag attribute `attr`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 62,
    "source": "batteries",
    "description": "Get the list of declarations tagged with the tag attribute `attr`."
  },
  "TagAttributeExtra": {
    "name": "TagAttributeExtra",
    "type": "structure",
    "signature": "TagAttributeExtra",
    "docstring": "`TagAttributeExtra` works around a limitation of `TagAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 31,
    "source": "batteries",
    "description": "`TagAttributeExtra` works around a limitation of `TagAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal."
  },
  "ParametricAttributeExtra": {
    "name": "ParametricAttributeExtra",
    "type": "structure",
    "signature": "ParametricAttributeExtra",
    "docstring": "`ParametricAttributeExtra` works around a limitation of `ParametricAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/AttributeExtra.lean",
    "line_number": 80,
    "source": "batteries",
    "description": "`ParametricAttributeExtra` works around a limitation of `ParametricAttribute`, which is that definitions must be tagged in the same file that declares the definition. This works well for definitions in lean core, but for attributes declared outside the core this is problematic because we may want to tag declarations created before the attribute was defined. To resolve this, we allow a one-time exception to the rule that attributes must be applied in the same file as the declaration: During the declaration of the attribute itself, we can tag arbitrary other definitions, but once the attribute is declared we must tag things in the same file as normal."
  },
  "Lean.findLineStart": {
    "name": "Lean.findLineStart",
    "type": "def",
    "signature": "Lean.findLineStart : String.Pos.Raw",
    "docstring": "Return the beginning of the line contatining character `pos`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Position.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Return the beginning of the line contatining character `pos`."
  },
  "Lean.findIndentAndIsStart": {
    "name": "Lean.findIndentAndIsStart",
    "type": "def",
    "signature": "Lean.findIndentAndIsStart : Nat × Bool",
    "docstring": "Return the indentation (number of leading spaces) of the line containing `pos`, and whether `pos` is the first non-whitespace character in the line.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Position.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Return the indentation (number of leading spaces) of the line containing `pos`, and whether `pos` is the first non-whitespace character in the line."
  },
  "Cache.mk": {
    "name": "Cache.mk",
    "type": "def",
    "signature": "Cache.mk : IO (Cache α)",
    "docstring": "Creates a cache with an initialization function.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "Creates a cache with an initialization function."
  },
  "DeclCache.get": {
    "name": "DeclCache.get",
    "type": "def",
    "signature": "DeclCache.get : MetaM α",
    "docstring": "Access the cache. Calling this function for the first time will initialize the cache with the function provided in the constructor.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 128,
    "source": "batteries",
    "description": "Access the cache. Calling this function for the first time will initialize the cache with the function provided in the constructor."
  },
  "DiscrTreeCache.getMatch": {
    "name": "DiscrTreeCache.getMatch",
    "type": "def",
    "signature": "DiscrTreeCache.getMatch : MetaM (Array α)",
    "docstring": "Get matches from both the discrimination tree for declarations in the current file, and for the imports. Note that if you are calling this multiple times with the same environment, it will rebuild the discrimination tree for the current file multiple times, and it would be more efficient to call `c.get` once, and then call `DiscrTree.getMatch` multiple times.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 170,
    "source": "batteries",
    "description": "Get matches from both the discrimination tree for declarations in the current file, and for the imports. Note that if you are calling this multiple times with the same environment, it will rebuild the discrimination tree for the current file multiple times, and it would be more efficient to call `c.get` once, and then call `DiscrTree.getMatch` multiple times."
  },
  "DeclCache": {
    "name": "DeclCache",
    "type": "structure",
    "signature": "DeclCache",
    "docstring": "Cached fold over the environment's declarations, where a given function is applied to `α` for every constant.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Cache.lean",
    "line_number": 83,
    "source": "batteries",
    "description": "Cached fold over the environment's declarations, where a given function is applied to `α` for every constant."
  },
  "elabProofWanted": {
    "name": "elabProofWanted",
    "type": "def",
    "signature": "elabProofWanted : CommandElab",
    "docstring": "Elaborate a `proof_wanted` declaration. The declaration is translated to an axiom during elaboration, but it's then removed from the environment.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/ProofWanted.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Elaborate a `proof_wanted` declaration. The declaration is translated to an axiom during elaboration, but it's then removed from the environment."
  },
  "panicWith": {
    "name": "panicWith",
    "type": "def",
    "signature": "panicWith : α",
    "docstring": "Panic with a specific default value `v`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Util/Panic.lean",
    "line_number": 13,
    "source": "batteries",
    "description": "Panic with a specific default value `v`."
  },
  "getLinterUnnecessarySeqFocus": {
    "name": "getLinterUnnecessarySeqFocus",
    "type": "def",
    "signature": "getLinterUnnecessarySeqFocus : Bool",
    "docstring": "Gets the value of the `linter.unnecessarySeqFocus` option.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnnecessarySeqFocus.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "Gets the value of the `linter.unnecessarySeqFocus` option."
  },
  "unnecessarySeqFocusLinter": {
    "name": "unnecessarySeqFocusLinter",
    "type": "def",
    "signature": "unnecessarySeqFocusLinter : Linter where run",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnnecessarySeqFocus.lean",
    "line_number": 155,
    "source": "batteries",
    "description": "A linter that detects and reports unnecessary use of `Seq.focus` in Lean code, helping to improve code clarity."
  },
  "Entry": {
    "name": "Entry",
    "type": "structure",
    "signature": "Entry",
    "docstring": "The information we record for each `<;>` node appearing in the syntax.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnnecessarySeqFocus.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "The information we record for each `<;>` node appearing in the syntax."
  },
  "getLinterUnreachableTactic": {
    "name": "getLinterUnreachableTactic",
    "type": "def",
    "signature": "getLinterUnreachableTactic : Bool",
    "docstring": "Gets the value of the `linter.unreachableTactic` option.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Gets the value of the `linter.unreachableTactic` option."
  },
  "isIgnoreTacticKind": {
    "name": "isIgnoreTacticKind",
    "type": "def",
    "signature": "isIgnoreTacticKind : Bool",
    "docstring": "Is this a syntax kind that contains intentionally unevaluated tactic subterms?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 55,
    "source": "batteries",
    "description": "Is this a syntax kind that contains intentionally unevaluated tactic subterms?"
  },
  "addIgnoreTacticKind": {
    "name": "addIgnoreTacticKind",
    "type": "def",
    "signature": "addIgnoreTacticKind : IO Unit",
    "docstring": "Adds a new syntax kind whose children will be ignored by the `unreachableTactic` linter. This should be called from an `initialize` block.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 64,
    "source": "batteries",
    "description": "Adds a new syntax kind whose children will be ignored by the `unreachableTactic` linter. This should be called from an `initialize` block."
  },
  "unreachableTacticLinter": {
    "name": "unreachableTacticLinter",
    "type": "def",
    "signature": "unreachableTacticLinter : Linter where run",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Linter/UnreachableTactic.lean",
    "line_number": 96,
    "source": "batteries",
    "description": "A linter that checks for unreachable tactics in Lean proofs, helping to identify and remove redundant code."
  },
  "ge_trans": {
    "name": "ge_trans",
    "type": "theorem",
    "signature": "ge_trans : cmp x z ≠ .lt",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 73,
    "source": "batteries",
    "description": "Proves that if x is greater than or equal to y and y is greater than or equal to z, then x is also greater than or equal to z."
  },
  "OrientedCmp": {
    "name": "OrientedCmp",
    "type": "class",
    "signature": "OrientedCmp",
    "docstring": "`OrientedCmp cmp` asserts that `cmp` is determined by the relation `cmp x y = .lt`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`OrientedCmp cmp` asserts that `cmp` is determined by the relation `cmp x y = .lt`."
  },
  "TransCmp": {
    "name": "TransCmp",
    "type": "class",
    "signature": "TransCmp",
    "docstring": "`TransCmp cmp` asserts that `cmp` induces a transitive relation.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 62,
    "source": "batteries",
    "description": "`TransCmp cmp` asserts that `cmp` induces a transitive relation."
  },
  "BEqCmp": {
    "name": "BEqCmp",
    "type": "class",
    "signature": "BEqCmp",
    "docstring": "`BEqCmp cmp` asserts that `cmp x y = .eq` and `x == y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "`BEqCmp cmp` asserts that `cmp x y = .eq` and `x == y` coincide."
  },
  "LTCmp": {
    "name": "LTCmp",
    "type": "class",
    "signature": "LTCmp",
    "docstring": "`LTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 138,
    "source": "batteries",
    "description": "`LTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide."
  },
  "LECmp": {
    "name": "LECmp",
    "type": "class",
    "signature": "LECmp",
    "docstring": "`LECmp cmp` asserts that `cmp x y ≠ .gt` and `x ≤ y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 150,
    "source": "batteries",
    "description": "`LECmp cmp` asserts that `cmp x y ≠ .gt` and `x ≤ y` coincide."
  },
  "LawfulCmp": {
    "name": "LawfulCmp",
    "type": "class",
    "signature": "LawfulCmp",
    "docstring": "`LawfulCmp cmp` asserts that the `LE`, `LT`, `BEq` instances are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Deprecated.lean",
    "line_number": 163,
    "source": "batteries",
    "description": "`LawfulCmp cmp` asserts that the `LE`, `LT`, `BEq` instances are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry)."
  },
  "le_iff_ge": {
    "name": "le_iff_ge",
    "type": "theorem",
    "signature": "le_iff_ge : cmp x y ≠ .gt ↔ cmp y x ≠ .lt",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 41,
    "source": "batteries",
    "description": "Proves that the comparison of two values is equivalent when their order is reversed, indicating non-greater and non-less relationships."
  },
  "le_trans": {
    "name": "le_trans",
    "type": "theorem",
    "signature": "le_trans : cmp x y ≠ .gt → cmp y z ≠ .gt → cmp x z ≠ .gt",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 49,
    "source": "batteries",
    "description": "Proves that if x is less than or equal to y and y is less than or equal to z, then x is less than or equal to z."
  },
  "TotalBLE": {
    "name": "TotalBLE",
    "type": "class",
    "signature": "TotalBLE",
    "docstring": "`TotalBLE le` asserts that `le` has a total order, that is, `le a b ∨ le b a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`TotalBLE le` asserts that `le` has a total order, that is, `le a b ∨ le b a`."
  },
  "LawfulLTCmp": {
    "name": "LawfulLTCmp",
    "type": "class",
    "signature": "LawfulLTCmp",
    "docstring": "`LawfulLTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 71,
    "source": "batteries",
    "description": "`LawfulLTCmp cmp` asserts that `cmp x y = .lt` and `x < y` coincide."
  },
  "LawfulLECmp": {
    "name": "LawfulLECmp",
    "type": "class",
    "signature": "LawfulLECmp",
    "docstring": "`LawfulLECmp cmp` asserts that `(cmp x y).isLE` and `x ≤ y` coincide.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "`LawfulLECmp cmp` asserts that `(cmp x y).isLE` and `x ≤ y` coincide."
  },
  "LawfulBCmp": {
    "name": "LawfulBCmp",
    "type": "class",
    "signature": "LawfulBCmp",
    "docstring": "`LawfulBCmp cmp` asserts that the `LE`, `LT`, `BEq` are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/Order.lean",
    "line_number": 94,
    "source": "batteries",
    "description": "`LawfulBCmp cmp` asserts that the `LE`, `LT`, `BEq` are all coherent with each other and with `cmp`, describing a strict weak order (a linear order except for antisymmetry)."
  },
  "SatisfiesM_EStateM_eq": {
    "name": "SatisfiesM_EStateM_eq",
    "type": "theorem",
    "signature": "SatisfiesM_EStateM_eq : SatisfiesM (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/SatisfiesM.lean",
    "line_number": 173,
    "source": "batteries",
    "description": "Proves the equivalence of two monadic computations in the context of the state monad."
  },
  "MonadSatisfying": {
    "name": "MonadSatisfying",
    "type": "class",
    "signature": "MonadSatisfying",
    "docstring": "If a monad has `MonadSatisfying m`, then we can lift a `h : SatisfiesM (m := m) p x` predicate to monadic value `satisfying x p : m { x // p x }`. Reader, state, and exception monads have `MonadSatisfying` instances if the base monad does.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/SatisfiesM.lean",
    "line_number": 224,
    "source": "batteries",
    "description": "If a monad has `MonadSatisfying m`, then we can lift a `h : SatisfiesM (m := m) p x` predicate to monadic value `satisfying x p : m { x // p x }`. Reader, state, and exception monads have `MonadSatisfying` instances if the base monad does."
  },
  "RatCast": {
    "name": "RatCast",
    "type": "class",
    "signature": "RatCast",
    "docstring": "Type class for the canonical homomorphism `Rat → K`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Classes/RatCast.lean",
    "line_number": 11,
    "source": "batteries",
    "description": "Type class for the canonical homomorphism `Rat → K`."
  },
  "deprecatedCodeActionProvider": {
    "name": "deprecatedCodeActionProvider",
    "type": "def",
    "signature": "deprecatedCodeActionProvider : CodeActionProvider",
    "docstring": "A code action which applies replacements for `@[deprecated]` definitions.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Deprecated.lean",
    "line_number": 32,
    "source": "batteries",
    "description": "A code action which applies replacements for `@[deprecated]` definitions."
  },
  "mkTacticCodeAction": {
    "name": "mkTacticCodeAction",
    "type": "def",
    "signature": "mkTacticCodeAction : ImportM TacticCodeAction",
    "docstring": "Read a tactic code action from a declaration of the right type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Read a tactic code action from a declaration of the right type."
  },
  "mkTacticSeqCodeAction": {
    "name": "mkTacticSeqCodeAction",
    "type": "def",
    "signature": "mkTacticSeqCodeAction : ImportM TacticSeqCodeAction",
    "docstring": "Read a tacticSeq code action from a declaration of the right type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Read a tacticSeq code action from a declaration of the right type."
  },
  "TacticCodeActionEntry": {
    "name": "TacticCodeActionEntry",
    "type": "structure",
    "signature": "TacticCodeActionEntry",
    "docstring": "An entry in the tactic code actions extension, containing the attribute arguments.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 49,
    "source": "batteries",
    "description": "An entry in the tactic code actions extension, containing the attribute arguments."
  },
  "TacticCodeActions": {
    "name": "TacticCodeActions",
    "type": "structure",
    "signature": "TacticCodeActions",
    "docstring": "The state of the tactic code actions extension.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 57,
    "source": "batteries",
    "description": "The state of the tactic code actions extension."
  },
  "TacticCodeAction": {
    "name": "TacticCodeAction",
    "type": "abbrev",
    "signature": "TacticCodeAction",
    "docstring": "A tactic code action extension.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "A tactic code action extension."
  },
  "TacticSeqCodeAction": {
    "name": "TacticSeqCodeAction",
    "type": "abbrev",
    "signature": "TacticSeqCodeAction",
    "docstring": "A tactic code action extension.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Attr.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "A tactic code action extension."
  },
  "getExplicitArgs": {
    "name": "getExplicitArgs",
    "type": "def",
    "signature": "getExplicitArgs : Expr → Array Name → Array Name",
    "docstring": "Returns the explicit arguments given a type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 130,
    "source": "batteries",
    "description": "Returns the explicit arguments given a type."
  },
  "foo": {
    "name": "foo",
    "type": "def",
    "signature": "foo : Expr → Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 139,
    "source": "batteries",
    "description": "Processes an expression and performs an action without returning a value."
  },
  "removeAfterDoneAction": {
    "name": "removeAfterDoneAction",
    "type": "def",
    "signature": "removeAfterDoneAction : TacticCodeAction",
    "docstring": "The \"Remove tactics after 'no goals'\" code action deletes any tactics following a completed proof. ``` example : True := by trivial trivial -- <- remove this, proof is already done rfl ``` is transformed to ``` example : True := by trivial ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 222,
    "source": "batteries",
    "description": "The \"Remove tactics after 'no goals'\" code action deletes any tactics following a completed proof. ``` example : True := by trivial trivial -- <- remove this, proof is already done rfl ``` is transformed to ``` example : True := by trivial ```"
  },
  "getElimExprNames": {
    "name": "getElimExprNames",
    "type": "def",
    "signature": "getElimExprNames : MetaM (Array (Name × Array Name))",
    "docstring": "Similar to `getElimExprInfo`, but returns the names of binders instead of just the numbers; intended for code actions which need to name the binders.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 244,
    "source": "batteries",
    "description": "Similar to `getElimExprInfo`, but returns the names of binders instead of just the numbers; intended for code actions which need to name the binders."
  },
  "casesExpand": {
    "name": "casesExpand",
    "type": "def",
    "signature": "casesExpand : TacticCodeAction",
    "docstring": "Invoking tactic code action \"Generate an explicit pattern match for 'induction'\" in the following: ```lean example (x : Nat) : x = x := by induction x ``` produces: ```lean example (x : Nat) : x = x := by induction x with | zero => sorry | succ n ih => sorry ``` It also works for `cases`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 292,
    "source": "batteries",
    "description": "Invoking tactic code action \"Generate an explicit pattern match for 'induction'\" in the following: ```lean example (x : Nat) : x = x := by induction x ``` produces: ```lean example (x : Nat) : x = x := by induction x with | zero => sorry | succ n ih => sorry ``` It also works for `cases`."
  },
  "addSubgoalsSeqAction": {
    "name": "addSubgoalsSeqAction",
    "type": "def",
    "signature": "addSubgoalsSeqAction : TacticSeqCodeAction",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 435,
    "source": "batteries",
    "description": "Defines a tactic sequence action that adds subgoals to the current proof context."
  },
  "addSubgoalsAction": {
    "name": "addSubgoalsAction",
    "type": "def",
    "signature": "addSubgoalsAction : TacticCodeAction",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Misc.lean",
    "line_number": 441,
    "source": "batteries",
    "description": "Creates a tactic code action that adds subgoals during proof development."
  },
  "isMatchTerm": {
    "name": "isMatchTerm",
    "type": "def",
    "signature": "isMatchTerm : Info → Bool",
    "docstring": "Filter for the info-nodes to find the match-nodes.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 14,
    "source": "batteries",
    "description": "Filter for the info-nodes to find the match-nodes."
  },
  "pattern_from_constructor": {
    "name": "pattern_from_constructor",
    "type": "def",
    "signature": "pattern_from_constructor : Option String",
    "docstring": "From a constructor-name e.g. 'Option.some' construct the corresponding match pattern, e.g. '.some val'. We implement special cases for Nat and List, Option and Bool to e.g. produce 'n + 1' instead of 'Nat.succ n'.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "From a constructor-name e.g. 'Option.some' construct the corresponding match pattern, e.g. '.some val'. We implement special cases for Nat and List, Option and Bool to e.g. produce 'n + 1' instead of 'Nat.succ n'."
  },
  "myfun2": {
    "name": "myfun2",
    "type": "def",
    "signature": "myfun2 : Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 89,
    "source": "batteries",
    "description": "Defines a constant of type Nat, representing a natural number value."
  },
  "myfun3": {
    "name": "myfun3",
    "type": "def",
    "signature": "myfun3 : Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 101,
    "source": "batteries",
    "description": "Defines a function that returns a natural number."
  },
  "matchExpand": {
    "name": "matchExpand",
    "type": "def",
    "signature": "matchExpand : CommandCodeAction",
    "docstring": "Invoking tactic code action \"Generate a list of alternatives for this match.\" in the following: ```lean def myfun2 (n : Nat) : Nat := match n ``` produces: ```lean def myfun2 (n : Nat) : Nat := match n with | 0 => _ | n + 1 => _ ``` Also has support for multiple discriminants, e.g. ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with ``` can be expanded into ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with | none, 0 => _ | none, n_2 + 1 => _ | some val_1, 0 => _ | some val_1, n_2 + 1 => _ ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/CodeAction/Match.lean",
    "line_number": 115,
    "source": "batteries",
    "description": "Invoking tactic code action \"Generate a list of alternatives for this match.\" in the following: ```lean def myfun2 (n : Nat) : Nat := match n ``` produces: ```lean def myfun2 (n : Nat) : Nat := match n with | 0 => _ | n + 1 => _ ``` Also has support for multiple discriminants, e.g. ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with ``` can be expanded into ``` def myfun3 (o : Option Bool) (m : Nat) : Nat := match o, m with | none, 0 => _ | none, n_2 + 1 => _ | some val_1, 0 => _ | some val_1, n_2 + 1 => _ ```"
  },
  "testBit": {
    "name": "testBit",
    "type": "def",
    "signature": "testBit : Int → Nat → Bool",
    "docstring": "`testBit m n` returns whether the `(n+1)` least significant bit is `1` or `0`, using the two's complement convention for negative `m`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Int.lean",
    "line_number": 18,
    "source": "batteries",
    "description": "`testBit m n` returns whether the `(n+1)` least significant bit is `1` or `0`, using the two's complement convention for negative `m`."
  },
  "map": {
    "name": "map",
    "type": "def",
    "signature": "map : FloatArray",
    "docstring": "`map f a` applies the function `f` to each element of the array.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/FloatArray.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "`map f a` applies the function `f` to each element of the array."
  },
  "foldl": {
    "name": "foldl",
    "type": "def",
    "signature": "foldl : β",
    "docstring": "Folds a function over a `ByteSubarray` from left to right.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Folds a function over a `ByteSubarray` from left to right."
  },
  "toByteArray": {
    "name": "toByteArray",
    "type": "def",
    "signature": "toByteArray : ByteArray",
    "docstring": "`O(n)`. Extract a `ByteSubarray` to a `ByteArray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 113,
    "source": "batteries",
    "description": "`O(n)`. Extract a `ByteSubarray` to a `ByteArray`."
  },
  "get": {
    "name": "get",
    "type": "def",
    "signature": "get : UInt8",
    "docstring": "`O(1)`. Get the element at index `i` from the start of a `ByteSubarray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 118,
    "source": "batteries",
    "description": "`O(1)`. Get the element at index `i` from the start of a `ByteSubarray`."
  },
  "pop": {
    "name": "pop",
    "type": "def",
    "signature": "pop : ByteSubarray",
    "docstring": "`O(1)`. Pop the last element of a `ByteSubarray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 130,
    "source": "batteries",
    "description": "`O(1)`. Pop the last element of a `ByteSubarray`."
  },
  "popFront": {
    "name": "popFront",
    "type": "def",
    "signature": "popFront : ByteSubarray",
    "docstring": "`O(1)`. Pop the first element of a `ByteSubarray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 140,
    "source": "batteries",
    "description": "`O(1)`. Pop the first element of a `ByteSubarray`."
  },
  "ByteArray.toByteSubarray": {
    "name": "ByteArray.toByteSubarray",
    "type": "def",
    "signature": "ByteArray.toByteSubarray : Batteries.ByteSubarray where",
    "docstring": "`O(1)`. Coerce a byte array into a byte slice.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 183,
    "source": "batteries",
    "description": "`O(1)`. Coerce a byte array into a byte slice."
  },
  "ByteSubarray": {
    "name": "ByteSubarray",
    "type": "structure",
    "signature": "ByteSubarray",
    "docstring": "A subarray of a `ByteArray`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/ByteSlice.lean",
    "line_number": 69,
    "source": "batteries",
    "description": "A subarray of a `ByteArray`."
  },
  "Heap.size": {
    "name": "Heap.size",
    "type": "def",
    "signature": "Heap.size : Heap α → Nat",
    "docstring": "`O(n)`. The number of elements in the heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "`O(n)`. The number of elements in the heap."
  },
  "Heap.singleton": {
    "name": "Heap.singleton",
    "type": "def",
    "signature": "Heap.singleton : Heap α",
    "docstring": "A node containing a single element `a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 38,
    "source": "batteries",
    "description": "A node containing a single element `a`."
  },
  "Heap.isEmpty": {
    "name": "Heap.isEmpty",
    "type": "def",
    "signature": "Heap.isEmpty : Heap α → Bool",
    "docstring": "`O(1)`. Is the heap empty?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 41,
    "source": "batteries",
    "description": "`O(1)`. Is the heap empty?"
  },
  "Heap.toListUnordered": {
    "name": "Heap.toListUnordered",
    "type": "def",
    "signature": "Heap.toListUnordered : List α",
    "docstring": "`O(n)`. Convert the heap to a list in arbitrary order.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 204,
    "source": "batteries",
    "description": "`O(n)`. Convert the heap to a list in arbitrary order."
  },
  "Heap.toArrayUnordered": {
    "name": "Heap.toArrayUnordered",
    "type": "def",
    "signature": "Heap.toArrayUnordered : Array α",
    "docstring": "`O(n)`. Convert the heap to an array in arbitrary order.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 208,
    "source": "batteries",
    "description": "`O(n)`. Convert the heap to an array in arbitrary order."
  },
  "Heap.NodeWF": {
    "name": "Heap.NodeWF",
    "type": "def",
    "signature": "Heap.NodeWF : Heap α → Prop",
    "docstring": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 217,
    "source": "batteries",
    "description": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved)"
  },
  "Heap.noSibling_merge": {
    "name": "Heap.noSibling_merge",
    "type": "theorem",
    "signature": "Heap.noSibling_merge : (s₁.merge le s₂).NoSibling",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 93,
    "source": "batteries",
    "description": "Proves that merging two heaps results in a heap that maintains the no-sibling property."
  },
  "Heap.noSibling_combine": {
    "name": "Heap.noSibling_combine",
    "type": "theorem",
    "signature": "Heap.noSibling_combine : (s.combine le).NoSibling",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 98,
    "source": "batteries",
    "description": "Proves that the combination operation in a heap does not create sibling nodes."
  },
  "Heap.noSibling_tail": {
    "name": "Heap.noSibling_tail",
    "type": "theorem",
    "signature": "Heap.noSibling_tail : (s.tail le).NoSibling",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 116,
    "source": "batteries",
    "description": "Proves that the tail of a heap does not have a sibling, ensuring structural integrity in heap representation."
  },
  "Heap.WF.singleton": {
    "name": "Heap.WF.singleton",
    "type": "theorem",
    "signature": "Heap.WF.singleton : (Heap.singleton a).WF le",
    "docstring": "There is exactly one tree and it is a `le`-min-heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 232,
    "source": "batteries",
    "description": "There is exactly one tree and it is a `le`-min-heap."
  },
  "Heap.WF.merge_node": {
    "name": "Heap.WF.merge_node",
    "type": "theorem",
    "signature": "Heap.WF.merge_node : (merge le (.node a₁ c₁ s₁) (.node a₂ c₂ s₂)).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 234,
    "source": "batteries",
    "description": "Proves that merging two nodes in a heap maintains the well-formed property with respect to the given order."
  },
  "Heap.WF.merge": {
    "name": "Heap.WF.merge",
    "type": "theorem",
    "signature": "Heap.WF.merge : (merge le s₁ s₂).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 241,
    "source": "batteries",
    "description": "Proves that merging two well-formed heaps preserves the well-formedness property."
  },
  "Heap.WF.combine": {
    "name": "Heap.WF.combine",
    "type": "theorem",
    "signature": "Heap.WF.combine : (combine le s).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 249,
    "source": "batteries",
    "description": "Proves that combining two well-formed heaps maintains the well-formed property under the given order."
  },
  "Heap.WF.tail": {
    "name": "Heap.WF.tail",
    "type": "theorem",
    "signature": "Heap.WF.tail : (s.tail le).WF le",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 265,
    "source": "batteries",
    "description": "Proves that the tail of a well-formed heap maintains the well-formed property under a given relation."
  },
  "Heap": {
    "name": "Heap",
    "type": "inductive",
    "signature": "Heap",
    "docstring": "A `Heap` is the nodes of the pairing heap. Each node have two pointers: `child` going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 24,
    "source": "batteries",
    "description": "A `Heap` is the nodes of the pairing heap. Each node have two pointers: `child` going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it."
  },
  "Heap.NoSibling": {
    "name": "Heap.NoSibling",
    "type": "inductive",
    "signature": "Heap.NoSibling : Heap α → Prop",
    "docstring": "A predicate says there is no more than one tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 82,
    "source": "batteries",
    "description": "A predicate says there is no more than one tree."
  },
  "Heap.WF": {
    "name": "Heap.WF",
    "type": "inductive",
    "signature": "Heap.WF : Heap α → Prop",
    "docstring": "The well formedness predicate for a pairing heap. It asserts that: * There is no more than one tree. * It is a `le`-min-heap (if `le` is well-behaved)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/PairingHeap.lean",
    "line_number": 227,
    "source": "batteries",
    "description": "The well formedness predicate for a pairing heap. It asserts that: * There is no more than one tree. * It is a `le`-min-heap (if `le` is well-behaved)"
  },
  "maxChild": {
    "name": "maxChild",
    "type": "def",
    "signature": "maxChild : Option (Fin sz)",
    "docstring": "`O(1)`. Get data array for a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 18,
    "source": "batteries",
    "description": "`O(1)`. Get data array for a `BinaryHeap`."
  },
  "heapifyDown": {
    "name": "heapifyDown",
    "type": "def",
    "signature": "heapifyDown : Vector α sz",
    "docstring": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` down to restore the max-heap property.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` down to restore the max-heap property."
  },
  "mkHeap": {
    "name": "mkHeap",
    "type": "def",
    "signature": "mkHeap : Vector α sz",
    "docstring": "Core operation for binary heaps, expressed directly on arrays. Construct a heap from an unsorted array, by heapifying all the elements.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 54,
    "source": "batteries",
    "description": "Core operation for binary heaps, expressed directly on arrays. Construct a heap from an unsorted array, by heapifying all the elements."
  },
  "heapifyUp": {
    "name": "heapifyUp",
    "type": "def",
    "signature": "heapifyUp : Vector α sz",
    "docstring": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` up to restore the max-heap property.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 66,
    "source": "batteries",
    "description": "Core operation for binary heaps, expressed directly on arrays. Given an array which is a max-heap, push item `i` up to restore the max-heap property."
  },
  "empty": {
    "name": "empty",
    "type": "def",
    "signature": "empty : BinaryHeap α lt",
    "docstring": "`O(1)`. Build a new empty heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 77,
    "source": "batteries",
    "description": "`O(1)`. Build a new empty heap."
  },
  "singleton": {
    "name": "singleton",
    "type": "def",
    "signature": "singleton : BinaryHeap α lt",
    "docstring": "`O(1)`. Build a one-element heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 83,
    "source": "batteries",
    "description": "`O(1)`. Build a one-element heap."
  },
  "size": {
    "name": "size",
    "type": "def",
    "signature": "size : Nat",
    "docstring": "`O(1)`. Get the number of elements in a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 86,
    "source": "batteries",
    "description": "`O(1)`. Get the number of elements in a `BinaryHeap`."
  },
  "vector": {
    "name": "vector",
    "type": "def",
    "signature": "vector : Vector α self.size",
    "docstring": "`O(1)`. Get data vector of a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 89,
    "source": "batteries",
    "description": "`O(1)`. Get data vector of a `BinaryHeap`."
  },
  "insert": {
    "name": "insert",
    "type": "def",
    "signature": "insert : BinaryHeap α lt where",
    "docstring": "`O(log n)`. Insert an element into a `BinaryHeap`, preserving the max-heap property.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 95,
    "source": "batteries",
    "description": "`O(log n)`. Insert an element into a `BinaryHeap`, preserving the max-heap property."
  },
  "max": {
    "name": "max",
    "type": "def",
    "signature": "max : Option α",
    "docstring": "`O(1)`. Get the maximum element in a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 103,
    "source": "batteries",
    "description": "`O(1)`. Get the maximum element in a `BinaryHeap`."
  },
  "popMax": {
    "name": "popMax",
    "type": "def",
    "signature": "popMax : BinaryHeap α lt",
    "docstring": "`O(log n)`. Remove the maximum element from a `BinaryHeap`. Call `max` first to actually retrieve the maximum element.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 107,
    "source": "batteries",
    "description": "`O(log n)`. Remove the maximum element from a `BinaryHeap`. Call `max` first to actually retrieve the maximum element."
  },
  "extractMax": {
    "name": "extractMax",
    "type": "def",
    "signature": "extractMax : Option α × BinaryHeap α lt",
    "docstring": "`O(log n)`. Return and remove the maximum element from a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "`O(log n)`. Return and remove the maximum element from a `BinaryHeap`."
  },
  "insertExtractMax": {
    "name": "insertExtractMax",
    "type": "def",
    "signature": "insertExtractMax : α × BinaryHeap α lt",
    "docstring": "`O(log n)`. Equivalent to `extractMax (self.insert x)`, except that extraction cannot fail.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 135,
    "source": "batteries",
    "description": "`O(log n)`. Equivalent to `extractMax (self.insert x)`, except that extraction cannot fail."
  },
  "replaceMax": {
    "name": "replaceMax",
    "type": "def",
    "signature": "replaceMax : Option α × BinaryHeap α lt",
    "docstring": "`O(log n)`. Equivalent to `(self.max, self.popMax.insert x)`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 145,
    "source": "batteries",
    "description": "`O(log n)`. Equivalent to `(self.max, self.popMax.insert x)`."
  },
  "decreaseKey": {
    "name": "decreaseKey",
    "type": "def",
    "signature": "decreaseKey : BinaryHeap α lt where",
    "docstring": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `x ≤ self.get i`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `x ≤ self.get i`."
  },
  "increaseKey": {
    "name": "increaseKey",
    "type": "def",
    "signature": "increaseKey : BinaryHeap α lt where",
    "docstring": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `self.get i ≤ x`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 157,
    "source": "batteries",
    "description": "`O(log n)`. Replace the value at index `i` by `x`. Assumes that `self.get i ≤ x`."
  },
  "Batteries.Vector.toBinaryHeap": {
    "name": "Batteries.Vector.toBinaryHeap",
    "type": "def",
    "signature": "Batteries.Vector.toBinaryHeap : Batteries.BinaryHeap α lt where",
    "docstring": "`O(n)`. Convert an unsorted vector to a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 163,
    "source": "batteries",
    "description": "`O(n)`. Convert an unsorted vector to a `BinaryHeap`."
  },
  "Array.toBinaryHeap": {
    "name": "Array.toBinaryHeap",
    "type": "def",
    "signature": "Array.toBinaryHeap : Batteries.BinaryHeap α lt where",
    "docstring": "`O(n)`. Convert an unsorted array to a `BinaryHeap`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 169,
    "source": "batteries",
    "description": "`O(n)`. Convert an unsorted array to a `BinaryHeap`."
  },
  "BinaryHeap": {
    "name": "BinaryHeap",
    "type": "structure",
    "signature": "BinaryHeap",
    "docstring": "A max-heap data structure.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinaryHeap.lean",
    "line_number": 13,
    "source": "batteries",
    "description": "A max-heap data structure."
  },
  "isEmpty": {
    "name": "isEmpty",
    "type": "def",
    "signature": "isEmpty : AssocList α β → Bool",
    "docstring": "`O(1)`. Is the list empty?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 43,
    "source": "batteries",
    "description": "`O(1)`. Is the list empty?"
  },
  "length": {
    "name": "length",
    "type": "def",
    "signature": "length : Nat",
    "docstring": "The number of entries in an `AssocList`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "The number of entries in an `AssocList`."
  },
  "toListTR": {
    "name": "toListTR",
    "type": "def",
    "signature": "toListTR : List (α × β)",
    "docstring": "Optimized version of `toList`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 80,
    "source": "batteries",
    "description": "Optimized version of `toList`."
  },
  "All": {
    "name": "All",
    "type": "def",
    "signature": "All : Prop",
    "docstring": "Returns true if every entry in the list satisfies `p`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 166,
    "source": "batteries",
    "description": "Returns true if every entry in the list satisfies `p`."
  },
  "AssocList": {
    "name": "AssocList",
    "type": "inductive",
    "signature": "AssocList",
    "docstring": "`AssocList α β` is \"the same as\" `List (α × β)`, but flattening the structure leads to one fewer pointer indirection (in the current code generator). It is mainly intended as a component of `HashMap`, but it can also be used as a plain key-value map.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/AssocList.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "`AssocList α β` is \"the same as\" `List (α × β)`, but flattening the structure leads to one fewer pointer indirection (in the current code generator). It is mainly intended as a component of `HashMap`, but it can also be used as a plain key-value map."
  },
  "AlternativeMonad": {
    "name": "AlternativeMonad",
    "type": "class",
    "signature": "AlternativeMonad",
    "docstring": "`AlternativeMonad m` means that `m` has both a `Monad` and `Alternative` instance, which both share the same underlying `Applicative` instance. The main example is `Option`, but many monad transformers also preserve or add this structure.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/AlternativeMonad.lean",
    "line_number": 50,
    "source": "batteries",
    "description": "`AlternativeMonad m` means that `m` has both a `Monad` and `Alternative` instance, which both share the same underlying `Applicative` instance. The main example is `Option`, but many monad transformers also preserve or add this structure."
  },
  "LawfulAlternative": {
    "name": "LawfulAlternative",
    "type": "class",
    "signature": "LawfulAlternative",
    "docstring": "`LawfulAlternative m` means that the `failure` operation on `m` behaves naturally with respect to `map`, `seq`, and `orElse` operators.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/AlternativeMonad.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "`LawfulAlternative m` means that the `failure` operation on `m` behaves naturally with respect to `map`, `seq`, and `orElse` operators."
  },
  "LawfulAlternativeLift": {
    "name": "LawfulAlternativeLift",
    "type": "class",
    "signature": "LawfulAlternativeLift",
    "docstring": "Type-class for monad lifts that preserve the `Alternative` operations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/AlternativeMonad.lean",
    "line_number": 114,
    "source": "batteries",
    "description": "Type-class for monad lifts that preserve the `Alternative` operations."
  },
  "get_bind_get": {
    "name": "get_bind_get",
    "type": "theorem",
    "signature": "get_bind_get : (do let _ ← get (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 82,
    "source": "batteries",
    "description": "Proves that retrieving a value from a monadic context after binding it yields the same result as directly getting the value."
  },
  "modifyGetThe_eq": {
    "name": "modifyGetThe_eq",
    "type": "theorem",
    "signature": "modifyGetThe_eq : modifyGetThe σ (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Proves that modifying a state with a function preserves the equality of the state when accessed through a specific lens."
  },
  "modify_eq": {
    "name": "modify_eq",
    "type": "theorem",
    "signature": "modify_eq : modify (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 114,
    "source": "batteries",
    "description": "Proves that modifying a monadic value results in an equivalent state transformation."
  },
  "modifyThe_eq": {
    "name": "modifyThe_eq",
    "type": "theorem",
    "signature": "modifyThe_eq : modifyThe σ (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 117,
    "source": "batteries",
    "description": "Proves that modifying a state with a function yields an equivalent state under certain conditions."
  },
  "getModify_eq": {
    "name": "getModify_eq",
    "type": "theorem",
    "signature": "getModify_eq : getModify (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 120,
    "source": "batteries",
    "description": "Proves that retrieving a value after modifying a map with a specific key yields the modified value."
  },
  "modify_bind_get": {
    "name": "modify_bind_get",
    "type": "theorem",
    "signature": "modify_bind_get : (do modify (m",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 171,
    "source": "batteries",
    "description": "Proves that modifying a state monad and then retrieving the state yields the same result as directly retrieving the state after the modification."
  },
  "LawfulMonadStateOf": {
    "name": "LawfulMonadStateOf",
    "type": "class",
    "signature": "LawfulMonadStateOf",
    "docstring": "Class for well behaved state monads, extending the base `MonadState` type. Requires that `modifyGet` is equal to the same definition with only `get` and `set`, that `get` is idempotent if the result isn't used, and that `get` after `set` returns exactly the value that was previously `set`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/LawfulMonadState.lean",
    "line_number": 48,
    "source": "batteries",
    "description": "Class for well behaved state monads, extending the base `MonadState` type. Requires that `modifyGet` is equal to the same definition with only `get` and `set`, that `get` is idempotent if the result isn't used, and that `get` after `set` returns exactly the value that was previously `set`."
  },
  "isAutoDecl": {
    "name": "isAutoDecl",
    "type": "def",
    "signature": "isAutoDecl : CoreM Bool",
    "docstring": "Returns true if `decl` is an automatically generated declaration. Also returns true if `decl` is an internal name or created during macro expansion.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Returns true if `decl` is an automatically generated declaration. Also returns true if `decl` is an internal name or created during macro expansion."
  },
  "getLinter": {
    "name": "getLinter",
    "type": "def",
    "signature": "getLinter : CoreM NamedLinter",
    "docstring": "Gets a linter by declaration name.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "Gets a linter by declaration name."
  },
  "Linter": {
    "name": "Linter",
    "type": "structure",
    "signature": "Linter",
    "docstring": "A linting test for the `#lint` command.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 60,
    "source": "batteries",
    "description": "A linting test for the `#lint` command."
  },
  "NamedLinter": {
    "name": "NamedLinter",
    "type": "structure",
    "signature": "NamedLinter",
    "docstring": "A `NamedLinter` is a linter associated to a particular declaration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Basic.lean",
    "line_number": 72,
    "source": "batteries",
    "description": "A `NamedLinter` is a linter associated to a particular declaration."
  },
  "isCondition": {
    "name": "isCondition",
    "type": "def",
    "signature": "isCondition : MetaM Bool",
    "docstring": "Is this hypothesis a condition that might turn into a `simp` side-goal? i.e. is it a proposition that isn't marked as instance implicit?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 40,
    "source": "batteries",
    "description": "Is this hypothesis a condition that might turn into a `simp` side-goal? i.e. is it a proposition that isn't marked as instance implicit?"
  },
  "withSimpTheoremInfos": {
    "name": "withSimpTheoremInfos",
    "type": "def",
    "signature": "withSimpTheoremInfos : MetaM (Array α)",
    "docstring": "Runs the continuation on all the simp theorems encoded in the given type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 46,
    "source": "batteries",
    "description": "Runs the continuation on all the simp theorems encoded in the given type."
  },
  "isSimpEq": {
    "name": "isSimpEq",
    "type": "def",
    "signature": "isSimpEq : MetaM Bool",
    "docstring": "Checks whether two expressions are equal for the simplifier. That is, they are reducibly-definitional equal, and they have the same head symbol.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 56,
    "source": "batteries",
    "description": "Checks whether two expressions are equal for the simplifier. That is, they are reducibly-definitional equal, and they have the same head symbol."
  },
  "checkAllSimpTheoremInfos": {
    "name": "checkAllSimpTheoremInfos",
    "type": "def",
    "signature": "checkAllSimpTheoremInfos : MetaM (Option MessageData)",
    "docstring": "Constructs a message from all the simp theorems encoded in the given type.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 63,
    "source": "batteries",
    "description": "Constructs a message from all the simp theorems encoded in the given type."
  },
  "isSimpTheorem": {
    "name": "isSimpTheorem",
    "type": "def",
    "signature": "isSimpTheorem : MetaM Bool",
    "docstring": "Returns true if this is a `@[simp]` declaration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 72,
    "source": "batteries",
    "description": "Returns true if this is a `@[simp]` declaration."
  },
  "decorateError": {
    "name": "decorateError",
    "type": "def",
    "signature": "decorateError : MetaM α",
    "docstring": "Add message `msg` to any errors thrown inside `k`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 86,
    "source": "batteries",
    "description": "Add message `msg` to any errors thrown inside `k`."
  },
  "formatLemmas": {
    "name": "formatLemmas",
    "type": "def",
    "signature": "formatLemmas : MetaM MessageData",
    "docstring": "Render the list of simp lemmas.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 90,
    "source": "batteries",
    "description": "Render the list of simp lemmas."
  },
  "SimpTheoremInfo": {
    "name": "SimpTheoremInfo",
    "type": "structure",
    "signature": "SimpTheoremInfo",
    "docstring": "The data associated to a simp theorem.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Simp.lean",
    "line_number": 30,
    "source": "batteries",
    "description": "The data associated to a simp theorem."
  },
  "getChecks": {
    "name": "getChecks",
    "type": "def",
    "signature": "getChecks : CoreM (Array NamedLinter)",
    "docstring": "`getChecks slow runOnly runAlways` produces a list of linters. `runOnly` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, only these linters are run (regardless of the default configuration). `runAlways` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, these linters are always run (regardless of their configuration). Specifying a linter in `runAlways` but not `runOnly` is an error. Otherwise, it uses all enabled linters in the environment tagged with `@[env_linter]`. If `slow` is false, it only uses the fast default tests.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 78,
    "source": "batteries",
    "description": "`getChecks slow runOnly runAlways` produces a list of linters. `runOnly` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, only these linters are run (regardless of the default configuration). `runAlways` is an optional list of names that should resolve to declarations with type `NamedLinter`. If populated, these linters are always run (regardless of their configuration). Specifying a linter in `runAlways` but not `runOnly` is an error. Otherwise, it uses all enabled linters in the environment tagged with `@[env_linter]`. If `slow` is false, it only uses the fast default tests."
  },
  "lintCore": {
    "name": "lintCore",
    "type": "def",
    "signature": "lintCore : CoreM (Array (NamedLinter × Std.HashMap Name MessageData))",
    "docstring": "Runs all the specified linters on all the specified declarations in parallel, producing a list of results.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 98,
    "source": "batteries",
    "description": "Runs all the specified linters on all the specified declarations in parallel, producing a list of results."
  },
  "sortResults": {
    "name": "sortResults",
    "type": "def",
    "signature": "sortResults : CoreM <| Array (Name × α)",
    "docstring": "Sorts a map with declaration keys as names by line number.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 123,
    "source": "batteries",
    "description": "Sorts a map with declaration keys as names by line number."
  },
  "groupedByFilename": {
    "name": "groupedByFilename",
    "type": "def",
    "signature": "groupedByFilename : CoreM MessageData",
    "docstring": "Formats a map of linter warnings grouped by filename with `-- filename` comments. The first `drop_fn_chars` characters are stripped from the filename.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 152,
    "source": "batteries",
    "description": "Formats a map of linter warnings grouped by filename with `-- filename` comments. The first `drop_fn_chars` characters are stripped from the filename."
  },
  "getDeclsInCurrModule": {
    "name": "getDeclsInCurrModule",
    "type": "def",
    "signature": "getDeclsInCurrModule : CoreM (Array Name)",
    "docstring": "Get the list of declarations in the current module.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 206,
    "source": "batteries",
    "description": "Get the list of declarations in the current module."
  },
  "getAllDecls": {
    "name": "getAllDecls",
    "type": "def",
    "signature": "getAllDecls : CoreM (Array Name)",
    "docstring": "Get the list of all declarations in the environment.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 210,
    "source": "batteries",
    "description": "Get the list of all declarations in the environment."
  },
  "getDeclsInPackage": {
    "name": "getDeclsInPackage",
    "type": "def",
    "signature": "getDeclsInPackage : CoreM (Array Name)",
    "docstring": "Get the list of all declarations in the specified package.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 214,
    "source": "batteries",
    "description": "Get the list of all declarations in the specified package."
  },
  "LintVerbosity": {
    "name": "LintVerbosity",
    "type": "inductive",
    "signature": "LintVerbosity",
    "docstring": "Verbosity for the linter output.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Frontend.lean",
    "line_number": 61,
    "source": "batteries",
    "description": "Verbosity for the linter output."
  },
  "univParamsGrouped": {
    "name": "univParamsGrouped",
    "type": "def",
    "signature": "univParamsGrouped : Std.HashSet (Array Name)",
    "docstring": "`univParamsGrouped e` computes for each `level` `u` of `e` the parameters that occur in `u`, and returns the corresponding set of lists of parameters. In pseudo-mathematical form, this returns `{{p : parameter | p ∈ u} | (u : level) ∈ e}` FIXME: We use `Array Name` instead of `HashSet Name`, since `HashSet` does not have an equality instance. It will ignore `nm₀.proof_i` declarations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Misc.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "`univParamsGrouped e` computes for each `level` `u` of `e` the parameters that occur in `u`, and returns the corresponding set of lists of parameters. In pseudo-mathematical form, this returns `{{p : parameter | p ∈ u} | (u : level) ∈ e}` FIXME: We use `Array Name` instead of `HashSet Name`, since `HashSet` does not have an equality instance. It will ignore `nm₀.proof_i` declarations."
  },
  "findUnusedHaves": {
    "name": "findUnusedHaves",
    "type": "def",
    "signature": "findUnusedHaves : MetaM (Array MessageData)",
    "docstring": "Return a list of unused `let_fun` terms in an expression that introduce proofs.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Tactic/Lint/Misc.lean",
    "line_number": 238,
    "source": "batteries",
    "description": "Return a list of unused `let_fun` terms in an expression that introduce proofs."
  },
  "runMetaM": {
    "name": "runMetaM",
    "type": "def",
    "signature": "runMetaM : MetaM (α × Meta.SavedState)",
    "docstring": "Run the action `x` in state `s`. Returns the result of `x` and the state after `x` was executed. The global state remains unchanged.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/SavedState.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Run the action `x` in state `s`. Returns the result of `x` and the state after `x` was executed. The global state remains unchanged."
  },
  "getIntroducedExprMVars": {
    "name": "getIntroducedExprMVars",
    "type": "def",
    "signature": "getIntroducedExprMVars : MetaM (Array MVarId)",
    "docstring": "Returns the mvars that are not declared in `preState`, but declared and unassigned in `postState`. Delayed-assigned mvars are considered assigned.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/SavedState.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Returns the mvars that are not declared in `preState`, but declared and unassigned in `postState`. Delayed-assigned mvars are considered assigned."
  },
  "getAssignedExprMVars": {
    "name": "getAssignedExprMVars",
    "type": "def",
    "signature": "getAssignedExprMVars : MetaM (Array MVarId)",
    "docstring": "Returns the mvars that are declared but unassigned in `preState`, and assigned in `postState`. Delayed-assigned mvars are considered assigned.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/SavedState.lean",
    "line_number": 47,
    "source": "batteries",
    "description": "Returns the mvars that are declared but unassigned in `preState`, and assigned in `postState`. Delayed-assigned mvars are considered assigned."
  },
  "isExprMVarDeclared": {
    "name": "isExprMVarDeclared",
    "type": "def",
    "signature": "isExprMVarDeclared : Bool",
    "docstring": "Check whether a metavariable is declared in the given `MetavarContext`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 64,
    "source": "batteries",
    "description": "Check whether a metavariable is declared in the given `MetavarContext`."
  },
  "eraseExprMVarAssignment": {
    "name": "eraseExprMVarAssignment",
    "type": "def",
    "signature": "eraseExprMVarAssignment : MetavarContext",
    "docstring": "Erase any assignment or delayed assignment of the given metavariable.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 70,
    "source": "batteries",
    "description": "Erase any assignment or delayed assignment of the given metavariable."
  },
  "unassignedExprMVars": {
    "name": "unassignedExprMVars",
    "type": "def",
    "signature": "unassignedExprMVars : Array MVarId",
    "docstring": "Obtain all unassigned metavariables from the given `MetavarContext`. If `includeDelayed` is `true`, delayed-assigned metavariables are considered unassigned.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 81,
    "source": "batteries",
    "description": "Obtain all unassigned metavariables from the given `MetavarContext`. If `includeDelayed` is `true`, delayed-assigned metavariables are considered unassigned."
  },
  "synthInstance": {
    "name": "synthInstance",
    "type": "def",
    "signature": "synthInstance : MetaM Unit",
    "docstring": "Solve a goal by synthesizing an instance.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 109,
    "source": "batteries",
    "description": "Solve a goal by synthesizing an instance."
  },
  "getTypeCleanup": {
    "name": "getTypeCleanup",
    "type": "def",
    "signature": "getTypeCleanup : MetaM Expr",
    "docstring": "Get the type the given metavariable after instantiating metavariables and cleaning up annotations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Basic.lean",
    "line_number": 114,
    "source": "batteries",
    "description": "Get the type the given metavariable after instantiating metavariables and cleaning up annotations."
  },
  "mkEqSymm": {
    "name": "mkEqSymm",
    "type": "def",
    "signature": "mkEqSymm : MetaM Simp.Result",
    "docstring": "Flip the proof in a `Simp.Result`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Simp.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "Flip the proof in a `Simp.Result`."
  },
  "mkCast": {
    "name": "mkCast",
    "type": "def",
    "signature": "mkCast : MetaM Expr",
    "docstring": "Construct the `Expr` `cast h e`, from a `Simp.Result` with proof `h`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Simp.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Construct the `Expr` `cast h e`, from a `Simp.Result` with proof `h`."
  },
  "Lean.LocalContext.inaccessibleFVars": {
    "name": "Lean.LocalContext.inaccessibleFVars",
    "type": "def",
    "signature": "Lean.LocalContext.inaccessibleFVars : Array LocalDecl",
    "docstring": "Obtain the inaccessible fvars from the given local context. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Inaccessible.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Obtain the inaccessible fvars from the given local context. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name."
  },
  "Lean.MVarId.renameInaccessibleFVars": {
    "name": "Lean.MVarId.renameInaccessibleFVars",
    "type": "def",
    "signature": "Lean.MVarId.renameInaccessibleFVars : MetaM (MVarId × Array FVarId)",
    "docstring": "Rename all inaccessible fvars. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name. This function gives all inaccessible fvars a unique, accessible user name. It returns the new goal and the fvars that were renamed.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/Inaccessible.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "Rename all inaccessible fvars. An fvar is inaccessible if (a) its user name is inaccessible or (b) it is shadowed by a later fvar with the same user name. This function gives all inaccessible fvars a unique, accessible user name. It returns the new goal and the fvars that were renamed."
  },
  "parseIndexSuffix": {
    "name": "parseIndexSuffix",
    "type": "def",
    "signature": "parseIndexSuffix : Option Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 15,
    "source": "batteries",
    "description": "Parses an index suffix and returns an optional natural number if a valid suffix is found."
  },
  "matchUpToIndexSuffix": {
    "name": "matchUpToIndexSuffix",
    "type": "def",
    "signature": "matchUpToIndexSuffix : MatchUpToIndexSuffix",
    "docstring": "Succeeds if `n` is equal to `query`, except `n` may have an additional `_i` suffix for some natural number `i`. More specifically: - If `n = query`, the result is `exactMatch`. - If `n = query ++ \"_i\"` for some natural number `i`, the result is `suffixMatch i`. - Otherwise the result is `noMatch`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Succeeds if `n` is equal to `query`, except `n` may have an additional `_i` suffix for some natural number `i`. More specifically: - If `n = query`, the result is `exactMatch`. - If `n = query ++ \"_i\"` for some natural number `i`, the result is `suffixMatch i`. - Otherwise the result is `noMatch`."
  },
  "getUnusedUserNameIndex": {
    "name": "getUnusedUserNameIndex",
    "type": "def",
    "signature": "getUnusedUserNameIndex : Option Nat",
    "docstring": "Obtain the least natural number `i` such that `suggestion ++ \"_i\"` is an unused name in the given local context. If `suggestion` itself is unused, the result is `none`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 73,
    "source": "batteries",
    "description": "Obtain the least natural number `i` such that `suggestion ++ \"_i\"` is an unused name in the given local context. If `suggestion` itself is unused, the result is `none`."
  },
  "getUnusedUserName": {
    "name": "getUnusedUserName",
    "type": "def",
    "signature": "getUnusedUserName : Name",
    "docstring": "Obtain a name `n` such that `n` is unused in the given local context and `suggestion` is a prefix of `n`. This is similar to `getUnusedName` but uses a different algorithm which may or may not be faster.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 97,
    "source": "batteries",
    "description": "Obtain a name `n` such that `n` is unused in the given local context and `suggestion` is a prefix of `n`. This is similar to `getUnusedName` but uses a different algorithm which may or may not be faster."
  },
  "getUnusedUserNames": {
    "name": "getUnusedUserNames",
    "type": "def",
    "signature": "getUnusedUserNames : Array Name",
    "docstring": "Obtain `n` distinct names such that each name is unused in the given local context and `suggestion` is a prefix of each name.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 107,
    "source": "batteries",
    "description": "Obtain `n` distinct names such that each name is unused in the given local context and `suggestion` is a prefix of each name."
  },
  "MatchUpToIndexSuffix": {
    "name": "MatchUpToIndexSuffix",
    "type": "inductive",
    "signature": "MatchUpToIndexSuffix",
    "docstring": "Result type of `Lean.Name.matchUpToIndexSuffix`. See there for details.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/UnusedNames.lean",
    "line_number": 27,
    "source": "batteries",
    "description": "Result type of `Lean.Name.matchUpToIndexSuffix`. See there for details."
  },
  "cmp": {
    "name": "cmp",
    "type": "def",
    "signature": "cmp : Key → Key → Ordering",
    "docstring": "Compare two `Key`s. The ordering is total but otherwise arbitrary. (It uses `Name.quickCmp` internally.)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/DiscrTree.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "Compare two `Key`s. The ordering is total but otherwise arbitrary. (It uses `Name.quickCmp` internally.)"
  },
  "mergePreservingDuplicates": {
    "name": "mergePreservingDuplicates",
    "type": "def",
    "signature": "mergePreservingDuplicates : DiscrTree α",
    "docstring": "Merge two `DiscrTree`s. Duplicate values are preserved.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/Meta/DiscrTree.lean",
    "line_number": 58,
    "source": "batteries",
    "description": "Merge two `DiscrTree`s. Duplicate values are preserved."
  },
  "List.waitAll": {
    "name": "List.waitAll",
    "type": "def",
    "signature": "List.waitAll : Task (List α)",
    "docstring": "Given a list of tasks, create the task returning the list of results, by waiting for each.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Lean/System/IO.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "Given a list of tasks, create the task returning the list of results, by waiting for each."
  },
  "HeapNode.singleton": {
    "name": "HeapNode.singleton",
    "type": "def",
    "signature": "HeapNode.singleton : HeapNode α",
    "docstring": "A node containing a single element `a`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 47,
    "source": "batteries",
    "description": "A node containing a single element `a`."
  },
  "HeapNode.rank": {
    "name": "HeapNode.rank",
    "type": "def",
    "signature": "HeapNode.rank : HeapNode α → Nat",
    "docstring": "`O(log n)`. The rank, or the number of trees in the forest. It is also the depth of the forest.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 53,
    "source": "batteries",
    "description": "`O(log n)`. The rank, or the number of trees in the forest. It is also the depth of the forest."
  },
  "Heap.rankGT": {
    "name": "Heap.rankGT",
    "type": "def",
    "signature": "Heap.rankGT : Heap α → Nat → Prop",
    "docstring": "`O(1)`. Auxiliary for `Heap.merge`: Is the minimum rank in `Heap` strictly larger than `n`?",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 106,
    "source": "batteries",
    "description": "`O(1)`. Auxiliary for `Heap.merge`: Is the minimum rank in `Heap` strictly larger than `n`?"
  },
  "HeapNode.toHeap": {
    "name": "HeapNode.toHeap",
    "type": "def",
    "signature": "HeapNode.toHeap : Heap α",
    "docstring": "`O(log n)`. Convert a `HeapNode` to a `Heap` by reversing the order of the nodes along the `sibling` spine.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 152,
    "source": "batteries",
    "description": "`O(log n)`. Convert a `HeapNode` to a `Heap` by reversing the order of the nodes along the `sibling` spine."
  },
  "Heap.deleteMin": {
    "name": "Heap.deleteMin",
    "type": "def",
    "signature": "Heap.deleteMin : Heap α → Option (α × Heap α)",
    "docstring": "`O(log n)`. Find and remove the the minimum element from the binomial heap.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 196,
    "source": "batteries",
    "description": "`O(log n)`. Find and remove the the minimum element from the binomial heap."
  },
  "FindMin.HasSize": {
    "name": "FindMin.HasSize",
    "type": "def",
    "signature": "FindMin.HasSize : Prop",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 226,
    "source": "batteries",
    "description": "A property that asserts the existence of a minimum element in a structure with a defined size."
  },
  "HeapNode.WF": {
    "name": "HeapNode.WF",
    "type": "def",
    "signature": "HeapNode.WF : HeapNode α → Nat → Prop",
    "docstring": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved) * When interpreting `child` and `sibling` as left and right children of a binary tree, it is a perfect binary tree with depth `r`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 336,
    "source": "batteries",
    "description": "The well formedness predicate for a heap node. It asserts that: * If `a` is added at the top to make the forest into a tree, the resulting tree is a `le`-min-heap (if `le` is well-behaved) * When interpreting `child` and `sibling` as left and right children of a binary tree, it is a perfect binary tree with depth `r`"
  },
  "Heap.WF.nil": {
    "name": "Heap.WF.nil",
    "type": "theorem",
    "signature": "Heap.WF.nil : Heap.nil.WF le n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 349,
    "source": "batteries",
    "description": "Proves that the empty heap satisfies the well-formedness condition with respect to a given relation."
  },
  "Heap.WF.of_rankGT": {
    "name": "Heap.WF.of_rankGT",
    "type": "theorem",
    "signature": "Heap.WF.of_rankGT : s.WF le (n+1)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 353,
    "source": "batteries",
    "description": "Proves that if a heap has a rank greater than n, it satisfies the well-formedness condition with respect to the less-than-or-equal relation."
  },
  "Heap.WF.of_le": {
    "name": "Heap.WF.of_le",
    "type": "theorem",
    "signature": "Heap.WF.of_le : s.WF le n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 358,
    "source": "batteries",
    "description": "Proves that a heap is well-formed with respect to a given less-than-or-equal relation."
  },
  "Heap.rankGT.of_le": {
    "name": "Heap.rankGT.of_le",
    "type": "theorem",
    "signature": "Heap.rankGT.of_le : s.rankGT n'",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 363,
    "source": "batteries",
    "description": "Proves that if a heap's rank is less than or equal to a given value, then it satisfies the rank greater than condition."
  },
  "Heap.WF.rankGT": {
    "name": "Heap.WF.rankGT",
    "type": "theorem",
    "signature": "Heap.WF.rankGT : s.rankGT n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 368,
    "source": "batteries",
    "description": "Proves that the rank of a heap satisfies a specific property related to its structure and ordering."
  },
  "FindMin": {
    "name": "FindMin",
    "type": "structure",
    "signature": "FindMin",
    "docstring": "The return type of `FindMin`, which encodes various quantities needed to reconstruct the tree in `deleteMin`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 172,
    "source": "batteries",
    "description": "The return type of `FindMin`, which encodes various quantities needed to reconstruct the tree in `deleteMin`."
  },
  "FindMin.WF": {
    "name": "FindMin.WF",
    "type": "structure",
    "signature": "FindMin.WF",
    "docstring": "The well formedness predicate for a `FindMin` value. This is not actually a predicate, as it contains an additional data value `rank` corresponding to the rank of the returned node, which is omitted from `findMin`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 430,
    "source": "batteries",
    "description": "The well formedness predicate for a `FindMin` value. This is not actually a predicate, as it contains an additional data value `rank` corresponding to the rank of the returned node, which is omitted from `findMin`."
  },
  "HeapNode": {
    "name": "HeapNode",
    "type": "inductive",
    "signature": "HeapNode",
    "docstring": "A `HeapNode` is one of the internal nodes of the binomial heap. It is always a perfect binary tree, with the depth of the tree stored in the `Heap`. However the interpretation of the two pointers is different: we view the `child` as going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/BinomialHeap/Basic.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "A `HeapNode` is one of the internal nodes of the binomial heap. It is always a perfect binary tree, with the depth of the tree stored in the `Heap`. However the interpretation of the two pointers is different: we view the `child` as going to the first child of this node, and `sibling` goes to the next sibling of this tree. So it actually encodes a forest where each node has children `node.child`, `node.child.sibling`, `node.child.sibling.sibling`, etc. Each edge in this forest denotes a `le a b` relation that has been checked, so the root is smaller than everything else under it."
  },
  "cons": {
    "name": "cons",
    "type": "def",
    "signature": "cons : α → DList α → DList α",
    "docstring": "`O(1)` (`apply` is `O(1)`). Prepend `a` on a `DList α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "`O(1)` (`apply` is `O(1)`). Prepend `a` on a `DList α`."
  },
  "append": {
    "name": "append",
    "type": "def",
    "signature": "append : DList α → DList α → DList α",
    "docstring": "`O(1)` (`apply` is `O(1)`). Append two `DList α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 58,
    "source": "batteries",
    "description": "`O(1)` (`apply` is `O(1)`). Append two `DList α`."
  },
  "push": {
    "name": "push",
    "type": "def",
    "signature": "push : DList α → α → DList α",
    "docstring": "`O(1)` (`apply` is `O(1)`). Append an element at the end of a `DList α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 68,
    "source": "batteries",
    "description": "`O(1)` (`apply` is `O(1)`). Append an element at the end of a `DList α`."
  },
  "ofThunk": {
    "name": "ofThunk",
    "type": "def",
    "signature": "ofThunk : DList α",
    "docstring": "Convert a lazily-evaluated `List` to a `DList`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 81,
    "source": "batteries",
    "description": "Convert a lazily-evaluated `List` to a `DList`"
  },
  "DList": {
    "name": "DList",
    "type": "structure",
    "signature": "DList",
    "docstring": "A difference List is a Function that, given a List, returns the original contents of the difference List prepended to the given List. This structure supports `O(1)` `append` and `push` operations on lists, making it useful for append-heavy uses such as logging and pretty printing.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/DList/Basic.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "A difference List is a Function that, given a List, returns the original contents of the difference List prepended to the given List. This structure supports `O(1)` `append` and `push` operations on lists, making it useful for append-heavy uses such as logging and pretty printing."
  },
  "beqCaseInsensitiveAsciiOnly": {
    "name": "beqCaseInsensitiveAsciiOnly",
    "type": "def",
    "signature": "beqCaseInsensitiveAsciiOnly : Bool",
    "docstring": "Bool-valued comparison of two `Char`s for *ASCII*-case insensitive equality. ``` #eval beqCaseInsensitiveAsciiOnly 'a' 'A' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'a' -- true #eval beqCaseInsensitiveAsciiOnly '$' '$' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'b' -- false #eval beqCaseInsensitiveAsciiOnly 'γ' 'Γ' -- false #eval beqCaseInsensitiveAsciiOnly 'ä' 'Ä' -- false ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 175,
    "source": "batteries",
    "description": "Bool-valued comparison of two `Char`s for *ASCII*-case insensitive equality. ``` #eval beqCaseInsensitiveAsciiOnly 'a' 'A' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'a' -- true #eval beqCaseInsensitiveAsciiOnly '$' '$' -- true #eval beqCaseInsensitiveAsciiOnly 'a' 'b' -- false #eval beqCaseInsensitiveAsciiOnly 'γ' 'Γ' -- false #eval beqCaseInsensitiveAsciiOnly 'ä' 'Ä' -- false ```"
  },
  "beqCaseInsensitiveAsciiOnly.isSetoid": {
    "name": "beqCaseInsensitiveAsciiOnly.isSetoid",
    "type": "def",
    "signature": "beqCaseInsensitiveAsciiOnly.isSetoid : Setoid Char",
    "docstring": "Setoid structure on `Char` using `beqCaseInsensitiveAsciiOnly`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 186,
    "source": "batteries",
    "description": "Setoid structure on `Char` using `beqCaseInsensitiveAsciiOnly`"
  },
  "cmpCaseInsensitiveAsciiOnly": {
    "name": "cmpCaseInsensitiveAsciiOnly",
    "type": "def",
    "signature": "cmpCaseInsensitiveAsciiOnly : Ordering",
    "docstring": "ASCII-case insensitive implementation comparison returning an `Ordering`. Useful for sorting. ``` #eval cmpCaseInsensitiveAsciiOnly 'a' 'A' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'a' -- eq #eval cmpCaseInsensitiveAsciiOnly '$' '$' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'b' -- lt #eval cmpCaseInsensitiveAsciiOnly 'γ' 'Γ' -- gt #eval cmpCaseInsensitiveAsciiOnly 'ä' 'Ä' -- gt ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 201,
    "source": "batteries",
    "description": "ASCII-case insensitive implementation comparison returning an `Ordering`. Useful for sorting. ``` #eval cmpCaseInsensitiveAsciiOnly 'a' 'A' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'a' -- eq #eval cmpCaseInsensitiveAsciiOnly '$' '$' -- eq #eval cmpCaseInsensitiveAsciiOnly 'a' 'b' -- lt #eval cmpCaseInsensitiveAsciiOnly 'γ' 'Γ' -- gt #eval cmpCaseInsensitiveAsciiOnly 'ä' 'Ä' -- gt ```"
  },
  "beqCaseInsensitiveAsciiOnly.eqv": {
    "name": "beqCaseInsensitiveAsciiOnly.eqv",
    "type": "theorem",
    "signature": "beqCaseInsensitiveAsciiOnly.eqv : Equivalence (beqCaseInsensitiveAsciiOnly · ·)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 177,
    "source": "batteries",
    "description": "Proves that the case-insensitive ASCII equality function is an equivalence relation, satisfying reflexivity, symmetry, and transitivity."
  },
  "caseFoldAsciiOnly": {
    "name": "caseFoldAsciiOnly",
    "type": "abbrev",
    "signature": "caseFoldAsciiOnly",
    "docstring": "Case folding for ASCII characters only. Alphabetic ASCII characters are mapped to their lowercase form, all other characters are left unchanged. This agrees with the Unicode case folding algorithm for ASCII characters. ``` #eval caseFoldAsciiOnly 'A' == 'a' #eval caseFoldAsciiOnly 'a' == 'a' #eval caseFoldAsciiOnly 'À' == 'À' #eval caseFoldAsciiOnly 'à' == 'à' #eval caseFoldAsciiOnly '$' == '$' ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/AsciiCasing.lean",
    "line_number": 161,
    "source": "batteries",
    "description": "Case folding for ASCII characters only. Alphabetic ASCII characters are mapped to their lowercase form, all other characters are left unchanged. This agrees with the Unicode case folding algorithm for ASCII characters. ``` #eval caseFoldAsciiOnly 'A' == 'a' #eval caseFoldAsciiOnly 'a' == 'a' #eval caseFoldAsciiOnly 'À' == 'À' #eval caseFoldAsciiOnly 'à' == 'à' #eval caseFoldAsciiOnly '$' == '$' ```"
  },
  "List.mem_finRange": {
    "name": "List.mem_finRange",
    "type": "theorem",
    "signature": "List.mem_finRange : x ∈ finRange n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 14,
    "source": "batteries",
    "description": "Proves that an element x belongs to the finite range of natural numbers from 0 to n-1."
  },
  "of_all_eq_true_aux": {
    "name": "of_all_eq_true_aux",
    "type": "theorem",
    "signature": "of_all_eq_true_aux : p (.ofNatAux n hn)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 76,
    "source": "batteries",
    "description": "Proves that a property holds for a natural number represented by a specific auxiliary function."
  },
  "eq_true_of_all_eq_true": {
    "name": "eq_true_of_all_eq_true",
    "type": "theorem",
    "signature": "eq_true_of_all_eq_true : p c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 87,
    "source": "batteries",
    "description": "Proves that if a proposition holds for all cases, then it is true."
  },
  "maxSurrogate": {
    "name": "maxSurrogate",
    "type": "abbrev",
    "signature": "maxSurrogate",
    "docstring": "Maximum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 46,
    "source": "batteries",
    "description": "Maximum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)"
  },
  "minSurrogate": {
    "name": "minSurrogate",
    "type": "abbrev",
    "signature": "minSurrogate",
    "docstring": "Minimum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 52,
    "source": "batteries",
    "description": "Minimum surrogate code point. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)"
  },
  "count": {
    "name": "count",
    "type": "abbrev",
    "signature": "count",
    "docstring": "Number of valid character code points. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Char/Basic.lean",
    "line_number": 58,
    "source": "batteries",
    "description": "Number of valid character code points. (See [unicode scalar value](https://www.unicode.org/glossary/#unicode_scalar_value).)"
  },
  "clamp": {
    "name": "clamp",
    "type": "def",
    "signature": "clamp : Fin (m + 1)",
    "docstring": "`min n m` as an element of `Fin (m + 1)`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 15,
    "source": "batteries",
    "description": "`min n m` as an element of `Fin (m + 1)`"
  },
  "divNat": {
    "name": "divNat",
    "type": "def",
    "signature": "divNat : Fin m",
    "docstring": "Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 121,
    "source": "batteries",
    "description": "Compute `i / n`, where `n` is a `Nat` and inferred the type of `i`."
  },
  "modNat": {
    "name": "modNat",
    "type": "def",
    "signature": "modNat : Fin n",
    "docstring": "Compute `i % n`, where `n` is a `Nat` and inferred the type of `i`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "Compute `i % n`, where `n` is a `Nat` and inferred the type of `i`."
  },
  "mkDivMod": {
    "name": "mkDivMod",
    "type": "def",
    "signature": "mkDivMod : Fin (m * n)",
    "docstring": "Compute the element of `Fin (m * n)` with quotient `i : Fin m` and remainder `j : Fin n` when divided by `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Fin/Basic.lean",
    "line_number": 132,
    "source": "batteries",
    "description": "Compute the element of `Fin (m * n)` with quotient `i : Fin m` and remainder `j : Fin n` when divided by `n`."
  },
  "ofTaskList": {
    "name": "ofTaskList",
    "type": "def",
    "signature": "ofTaskList : MLList BaseIO α",
    "docstring": "Give a list of tasks, return the monadic lazy list which returns the values as they become available.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/MLList/IO.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "Give a list of tasks, return the monadic lazy list which returns the values as they become available."
  },
  "MLList": {
    "name": "MLList",
    "type": "def",
    "signature": "MLList : Type u",
    "docstring": "A monadic lazy list, controlled by an arbitrary monad.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/MLList/Basic.lean",
    "line_number": 76,
    "source": "batteries",
    "description": "A monadic lazy list, controlled by an arbitrary monad."
  },
  "squash": {
    "name": "squash",
    "type": "def",
    "signature": "squash : (Unit → m (MLList m α)) → MLList m α",
    "docstring": "Lift a monadic lazy list inside the monad to a monadic lazy list.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/MLList/Basic.lean",
    "line_number": 92,
    "source": "batteries",
    "description": "Lift a monadic lazy list inside the monad to a monadic lazy list."
  },
  "Pairwise": {
    "name": "Pairwise",
    "type": "def",
    "signature": "Pairwise : Prop",
    "docstring": "`Pairwise R as` means that all the elements of the array `as` are `R`-related to all elements with larger indices. `Pairwise R #[1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3` For example `as.Pairwise (· ≠ ·)` asserts that `as` has no duplicates, `as.Pairwise (· < ·)` asserts that `as` is strictly sorted and `as.Pairwise (· ≤ ·)` asserts that `as` is weakly sorted.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`Pairwise R as` means that all the elements of the array `as` are `R`-related to all elements with larger indices. `Pairwise R #[1, 2, 3] ↔ R 1 2 ∧ R 1 3 ∧ R 2 3` For example `as.Pairwise (· ≠ ·)` asserts that `as` has no duplicates, `as.Pairwise (· < ·)` asserts that `as` is strictly sorted and `as.Pairwise (· ≤ ·)` asserts that `as` is weakly sorted."
  },
  "pairwise_empty": {
    "name": "pairwise_empty",
    "type": "theorem",
    "signature": "pairwise_empty : #[].Pairwise R",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 40,
    "source": "batteries",
    "description": "Proves that the empty list satisfies the pairwise condition for any relation R."
  },
  "pairwise_singleton": {
    "name": "pairwise_singleton",
    "type": "theorem",
    "signature": "pairwise_singleton : #[a].Pairwise R",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Proves that a singleton set satisfies the pairwise relation for any binary relation R."
  },
  "pairwise_pair": {
    "name": "pairwise_pair",
    "type": "theorem",
    "signature": "pairwise_pair : #[a, b].Pairwise R ↔ R a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Pairwise.lean",
    "line_number": 48,
    "source": "batteries",
    "description": "Establishes that a relation R holds for a pair of elements a and b if and only if the pairwise condition for R is satisfied."
  },
  "PrefixTable": {
    "name": "PrefixTable",
    "type": "structure",
    "signature": "PrefixTable",
    "docstring": "Prefix table for the Knuth-Morris-Pratt matching algorithm This is an array of the form `t = [(x₀,n₀), (x₁,n₁), (x₂, n₂), ...]` where for each `i`, `nᵢ` is the length of the longest proper prefix of `xs = [x₀,x₁,...,xᵢ]` which is also a suffix of `xs`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Match.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Prefix table for the Knuth-Morris-Pratt matching algorithm This is an array of the form `t = [(x₀,n₀), (x₁,n₁), (x₂, n₂), ...]` where for each `i`, `nᵢ` is the length of the longest proper prefix of `xs = [x₀,x₁,...,xᵢ]` which is also a suffix of `xs`."
  },
  "Matcher": {
    "name": "Matcher",
    "type": "structure",
    "signature": "Matcher",
    "docstring": "KMP matcher structure",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Match.lean",
    "line_number": 77,
    "source": "batteries",
    "description": "KMP matcher structure"
  },
  "Iterator": {
    "name": "Iterator",
    "type": "structure",
    "signature": "Iterator",
    "docstring": "Iterator transformer for KMP matcher.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Array/Match.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Iterator transformer for KMP matcher."
  },
  "equiv_find": {
    "name": "equiv_find",
    "type": "theorem",
    "signature": "equiv_find : Equiv (self.find x).1 a b ↔ Equiv self a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Lemmas.lean",
    "line_number": 116,
    "source": "batteries",
    "description": "Proves the equivalence between finding an element in a structure and the equivalence of the structure itself."
  },
  "parentD": {
    "name": "parentD",
    "type": "def",
    "signature": "parentD : Nat",
    "docstring": "Parent of a union-find node, defaults to self when the node is a root",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 26,
    "source": "batteries",
    "description": "Parent of a union-find node, defaults to self when the node is a root"
  },
  "rankD": {
    "name": "rankD",
    "type": "def",
    "signature": "rankD : Nat",
    "docstring": "Rank of a union-find node, defaults to 0 when the node is a root",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 30,
    "source": "batteries",
    "description": "Rank of a union-find node, defaults to 0 when the node is a root"
  },
  "mkEmpty": {
    "name": "mkEmpty",
    "type": "def",
    "signature": "mkEmpty : UnionFind where",
    "docstring": "Create an empty union-find structure with specific capacity",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Create an empty union-find structure with specific capacity"
  },
  "root": {
    "name": "root",
    "type": "def",
    "signature": "root : Fin self.size",
    "docstring": "Root of a union-find node.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 175,
    "source": "batteries",
    "description": "Root of a union-find node."
  },
  "rootN": {
    "name": "rootN",
    "type": "def",
    "signature": "rootN : Fin n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 185,
    "source": "batteries",
    "description": "Represents the nth root of a natural number, where n is a finite natural number."
  },
  "rootD": {
    "name": "rootD",
    "type": "def",
    "signature": "rootD : Nat",
    "docstring": "Root of a union-find node. Returns input if index is out of bounds.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 193,
    "source": "batteries",
    "description": "Root of a union-find node. Returns input if index is out of bounds."
  },
  "findAux": {
    "name": "findAux",
    "type": "def",
    "signature": "findAux : FindAux self.size",
    "docstring": "Auxiliary function for find operation",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 267,
    "source": "batteries",
    "description": "Auxiliary function for find operation"
  },
  "findN": {
    "name": "findN",
    "type": "def",
    "signature": "findN : UnionFind × Fin n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 388,
    "source": "batteries",
    "description": "Finds the root of the set containing the element indexed by a finite number, using a union-find data structure."
  },
  "findD": {
    "name": "findD",
    "type": "def",
    "signature": "findD : UnionFind × Nat",
    "docstring": "Find root of a union-find node, updating the structure using path compression. Returns inputs unchanged when index is out of bounds.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 401,
    "source": "batteries",
    "description": "Find root of a union-find node, updating the structure using path compression. Returns inputs unchanged when index is out of bounds."
  },
  "linkAux": {
    "name": "linkAux",
    "type": "def",
    "signature": "linkAux : Array UFNode",
    "docstring": "Link two union-find nodes",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 439,
    "source": "batteries",
    "description": "Link two union-find nodes"
  },
  "link": {
    "name": "link",
    "type": "def",
    "signature": "link : UnionFind where",
    "docstring": "Link a union-find node to a root node.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 492,
    "source": "batteries",
    "description": "Link a union-find node to a root node."
  },
  "linkN": {
    "name": "linkN",
    "type": "def",
    "signature": "linkN : UnionFind",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 524,
    "source": "batteries",
    "description": "Represents a union-find data structure for efficiently managing and merging disjoint sets."
  },
  "union": {
    "name": "union",
    "type": "def",
    "signature": "union : UnionFind",
    "docstring": "Link two union-find nodes, uniting their respective classes.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 535,
    "source": "batteries",
    "description": "Link two union-find nodes, uniting their respective classes."
  },
  "unionN": {
    "name": "unionN",
    "type": "def",
    "signature": "unionN : UnionFind",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 546,
    "source": "batteries",
    "description": "Creates a union-find data structure for efficiently managing and merging disjoint sets."
  },
  "checkEquiv": {
    "name": "checkEquiv",
    "type": "def",
    "signature": "checkEquiv : UnionFind × Bool",
    "docstring": "Check whether two union-find nodes are equivalent, updating structure using path compression.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 558,
    "source": "batteries",
    "description": "Check whether two union-find nodes are equivalent, updating structure using path compression."
  },
  "checkEquivN": {
    "name": "checkEquivN",
    "type": "def",
    "signature": "checkEquivN : UnionFind × Bool",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 564,
    "source": "batteries",
    "description": "Checks the equivalence of elements in a union-find structure, returning a boolean indicating if they are in the same set."
  },
  "checkEquivD": {
    "name": "checkEquivD",
    "type": "def",
    "signature": "checkEquivD : UnionFind × Bool",
    "docstring": "Check whether two union-find nodes are equivalent with path compression, returns `x == y` if either index is out of bounds",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 577,
    "source": "batteries",
    "description": "Check whether two union-find nodes are equivalent with path compression, returns `x == y` if either index is out of bounds"
  },
  "Equiv": {
    "name": "Equiv",
    "type": "def",
    "signature": "Equiv : Prop",
    "docstring": "Equivalence relation from a `UnionFind` structure",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 583,
    "source": "batteries",
    "description": "Equivalence relation from a `UnionFind` structure"
  },
  "lt_of_parentD": {
    "name": "lt_of_parentD",
    "type": "theorem",
    "signature": "lt_of_parentD : parentD arr i ≠ i → i < arr.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 39,
    "source": "batteries",
    "description": "If the parent of an index in an array is not itself, then that index is less than the size of the array."
  },
  "parent_lt": {
    "name": "parent_lt",
    "type": "theorem",
    "signature": "parent_lt : self.parent i < self.size ↔ i < self.size",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 126,
    "source": "batteries",
    "description": "Proves that the parent index of a node is less than the size of the structure if and only if the node index is also less than the size."
  },
  "rankD_lt_rankMax": {
    "name": "rankD_lt_rankMax",
    "type": "theorem",
    "signature": "rankD_lt_rankMax : rankD self.arr i < self.rankMax",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 149,
    "source": "batteries",
    "description": "Proves that the rank of an array at index `i` is less than the maximum rank of the array."
  },
  "lt_rankMax": {
    "name": "lt_rankMax",
    "type": "theorem",
    "signature": "lt_rankMax : self.rank i < self.rankMax",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "Proves that the rank of an element is always less than the maximum rank in a given structure."
  },
  "UFNode": {
    "name": "UFNode",
    "type": "structure",
    "signature": "UFNode",
    "docstring": "Union-find node type",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Union-find node type"
  },
  "using": {
    "name": "using",
    "type": "structure",
    "signature": "using",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "A structure that provides a way to manage resources or contexts, often used for resource management in Lean."
  },
  "UnionFind": {
    "name": "UnionFind",
    "type": "structure",
    "signature": "UnionFind",
    "docstring": "### Union-find data structure The `UnionFind` structure is an implementation of disjoint-set data structure that uses path compression to make the primary operations run in amortized nearly linear time. The nodes of a `UnionFind` structure `s` are natural numbers smaller than `s.size`. The structure associates with a canonical representative from its equivalence class. The structure can be extended using the `push` operation and equivalence classes can be updated using the `union` operation. The main operations for `UnionFind` are: * `empty`/`mkEmpty` are used to create a new empty structure. * `size` returns the size of the data structure. * `push` adds a new node to a structure, unlinked to any other node. * `union` links two nodes of the data structure, joining their equivalence classes, and performs path compression. * `find` returns the canonical representative of a node and updates the data structure using path compression. * `root` returns the canonical representative of a node without altering the data structure. * `checkEquiv` checks whether two nodes have the same canonical representative and updates the structure using path compression. Most use cases should prefer `find` over `root` to benefit from the speedup from path-compression. The main operations use `Fin s.size` to represent nodes of the union-find structure. Some alternatives are provided: * `unionN`, `findN`, `rootN`, `checkEquivN` use `Fin n` with a proof that `n = s.size`. * `union!`, `find!`, `root!`, `checkEquiv!` use `Nat` and panic when the indices are out of bounds. * `findD`, `rootD`, `checkEquivD` use `Nat` and treat out of bound indices as isolated nodes. The noncomputable relation `UnionFind.Equiv` is provided to use the equivalence relation from a `UnionFind` structure in the context of proofs.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 97,
    "source": "batteries",
    "description": "### Union-find data structure The `UnionFind` structure is an implementation of disjoint-set data structure that uses path compression to make the primary operations run in amortized nearly linear time. The nodes of a `UnionFind` structure `s` are natural numbers smaller than `s.size`. The structure associates with a canonical representative from its equivalence class. The structure can be extended using the `push` operation and equivalence classes can be updated using the `union` operation. The main operations for `UnionFind` are: * `empty`/`mkEmpty` are used to create a new empty structure. * `size` returns the size of the data structure. * `push` adds a new node to a structure, unlinked to any other node. * `union` links two nodes of the data structure, joining their equivalence classes, and performs path compression. * `find` returns the canonical representative of a node and updates the data structure using path compression. * `root` returns the canonical representative of a node without altering the data structure. * `checkEquiv` checks whether two nodes have the same canonical representative and updates the structure using path compression. Most use cases should prefer `find` over `root` to benefit from the speedup from path-compression. The main operations use `Fin s.size` to represent nodes of the union-find structure. Some alternatives are provided: * `unionN`, `findN`, `rootN`, `checkEquivN` use `Fin n` with a proof that `n = s.size`. * `union!`, `find!`, `root!`, `checkEquiv!` use `Nat` and panic when the indices are out of bounds. * `findD`, `rootD`, `checkEquivD` use `Nat` and treat out of bound indices as isolated nodes. The noncomputable relation `UnionFind.Equiv` is provided to use the equivalence relation from a `UnionFind` structure in the context of proofs."
  },
  "FindAux": {
    "name": "FindAux",
    "type": "structure",
    "signature": "FindAux",
    "docstring": "Auxiliary data structure for find operation",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/UnionFind/Basic.lean",
    "line_number": 258,
    "source": "batteries",
    "description": "Auxiliary data structure for find operation"
  },
  "lt_sum_ge": {
    "name": "lt_sum_ge",
    "type": "def",
    "signature": "lt_sum_ge : a < b ⊕' b ≤ a",
    "docstring": "Strong case analysis on `a < b ∨ b ≤ a`",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Lemmas.lean",
    "line_number": 146,
    "source": "batteries",
    "description": "Strong case analysis on `a < b ∨ b ≤ a`"
  },
  "ofBits_lt_two_pow": {
    "name": "ofBits_lt_two_pow",
    "type": "theorem",
    "signature": "ofBits_lt_two_pow : ofBits f < 2 ^ n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Lemmas.lean",
    "line_number": 175,
    "source": "batteries",
    "description": "Proves that the value represented by the bit representation `f` is less than `2` raised to the power of `n`."
  },
  "isDigit_of_mem_toDigitsCore": {
    "name": "isDigit_of_mem_toDigitsCore",
    "type": "theorem",
    "signature": "isDigit_of_mem_toDigitsCore : c.isDigit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Digits.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "Proves that an element is a digit if it belongs to the set of digits generated by the toDigitsCore function."
  },
  "isDigit_of_mem_toDigits": {
    "name": "isDigit_of_mem_toDigits",
    "type": "theorem",
    "signature": "isDigit_of_mem_toDigits : c.isDigit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Digits.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Proves that if a character is a member of the set of digits, then it is classified as a digit."
  },
  "sqrt": {
    "name": "sqrt",
    "type": "def",
    "signature": "sqrt : Nat",
    "docstring": "Integer square root function. Implemented via Newton's method.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Basic.lean",
    "line_number": 95,
    "source": "batteries",
    "description": "Integer square root function. Implemented via Newton's method."
  },
  "avg_le_left": {
    "name": "avg_le_left",
    "type": "theorem",
    "signature": "avg_le_left : avg a b ≤ a",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 19,
    "source": "batteries",
    "description": "Proves that the average of two numbers is less than or equal to the first number."
  },
  "avg_le_right": {
    "name": "avg_le_right",
    "type": "theorem",
    "signature": "avg_le_right : avg a b ≤ b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 22,
    "source": "batteries",
    "description": "Proves that the average of two numbers is less than or equal to the larger number."
  },
  "avg_lt_left": {
    "name": "avg_lt_left",
    "type": "theorem",
    "signature": "avg_lt_left : avg a b < a",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "Proves that the average of two numbers is less than the first number if the second number is less than the first."
  },
  "avg_lt_right": {
    "name": "avg_lt_right",
    "type": "theorem",
    "signature": "avg_lt_right : avg a b < b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Proves that the average of two numbers a and b is less than b when a is less than b."
  },
  "le_avg_left": {
    "name": "le_avg_left",
    "type": "theorem",
    "signature": "le_avg_left : a ≤ avg a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 31,
    "source": "batteries",
    "description": "Proves that a number is less than or equal to the average of itself and another number."
  },
  "le_avg_right": {
    "name": "le_avg_right",
    "type": "theorem",
    "signature": "le_avg_right : b ≤ avg a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 34,
    "source": "batteries",
    "description": "Proves that a number is less than or equal to the average of itself and another number."
  },
  "le_add_one_of_avg_eq_left": {
    "name": "le_add_one_of_avg_eq_left",
    "type": "theorem",
    "signature": "le_add_one_of_avg_eq_left : b ≤ a + 1",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "Proves that if the average of two numbers equals the left number, then the second number is less than or equal to the left number plus one."
  },
  "le_add_one_of_avg_eq_right": {
    "name": "le_add_one_of_avg_eq_right",
    "type": "theorem",
    "signature": "le_add_one_of_avg_eq_right : a ≤ b + 1",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Nat/Bisect.lean",
    "line_number": 46,
    "source": "batteries",
    "description": "Proves that if the average of two numbers equals the right number, then the first number is less than or equal to the right number plus one."
  },
  "toFloat": {
    "name": "toFloat",
    "type": "def",
    "signature": "toFloat : Float",
    "docstring": "Convert this rational number to a `Float` value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Rat/Float.lean",
    "line_number": 17,
    "source": "batteries",
    "description": "Convert this rational number to a `Float` value."
  },
  "_root_.Float.toRat0": {
    "name": "_root_.Float.toRat0",
    "type": "def",
    "signature": "_root_.Float.toRat0 : Rat",
    "docstring": "Convert this floating point number to a rational value, mapping non-finite values (`inf`, `-inf`, `nan`) to 0.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Rat/Float.lean",
    "line_number": 28,
    "source": "batteries",
    "description": "Convert this floating point number to a rational value, mapping non-finite values (`inf`, `-inf`, `nan`) to 0."
  },
  "sumEven": {
    "name": "sumEven",
    "type": "def",
    "signature": "sumEven : Except String Nat",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 209,
    "source": "batteries",
    "description": "Calculates the sum of all even natural numbers, returning either the result or an error message."
  },
  "checkEven": {
    "name": "checkEven",
    "type": "def",
    "signature": "checkEven : Except String Unit",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 261,
    "source": "batteries",
    "description": "Checks if a condition is met and returns either an error message or a success indication."
  },
  "toList": {
    "name": "toList",
    "type": "def",
    "signature": "toList : List (α × β)",
    "docstring": "Converts the map into a list of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toList ~ [(\"one\", 1), (\"two\", 2)] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 278,
    "source": "batteries",
    "description": "Converts the map into a list of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toList ~ [(\"one\", 1), (\"two\", 2)] ```"
  },
  "toArray": {
    "name": "toArray",
    "type": "def",
    "signature": "toArray : Array (α × β)",
    "docstring": "Converts the map into an array of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toArray.data ~ #[(\"one\", 1), (\"two\", 2)].data ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 287,
    "source": "batteries",
    "description": "Converts the map into an array of key-value pairs. ``` open List (ofList [(\"one\", 1), (\"two\", 2)]).toArray.data ~ #[(\"one\", 1), (\"two\", 2)].data ```"
  },
  "numBuckets": {
    "name": "numBuckets",
    "type": "def",
    "signature": "numBuckets : Nat",
    "docstring": "The number of buckets in the hash map.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 290,
    "source": "batteries",
    "description": "The number of buckets in the hash map."
  },
  "_root_.Batteries.HashMap": {
    "name": "_root_.Batteries.HashMap",
    "type": "structure",
    "signature": "_root_.Batteries.HashMap",
    "docstring": "`HashMap α β` is a key-value map which stores elements in an array using a hash function to find the values. This allows it to have very good performance for lookups (average `O(1)` for a perfectly random hash function), but it is not a persistent data structure, meaning that one should take care to use the map linearly when performing updates. Copies are `O(n)`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/HashMap/Basic.lean",
    "line_number": 59,
    "source": "batteries",
    "description": "`HashMap α β` is a key-value map which stores elements in an array using a hash function to find the values. This allows it to have very good performance for lookups (average `O(1)` for a perfectly random hash function), but it is not a persistent data structure, meaning that one should take care to use the map linearly when performing updates. Copies are `O(n)`."
  },
  "disjoint_symm": {
    "name": "disjoint_symm",
    "type": "theorem",
    "signature": "disjoint_symm : Disjoint l₂ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 147,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint, then their order can be reversed while maintaining disjointness."
  },
  "disjoint_comm": {
    "name": "disjoint_comm",
    "type": "theorem",
    "signature": "disjoint_comm : Disjoint l₁ l₂ ↔ Disjoint l₂ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 149,
    "source": "batteries",
    "description": "Proves that the disjointness of two lists is symmetric; if one list is disjoint from another, the reverse is also true."
  },
  "disjoint_left": {
    "name": "disjoint_left",
    "type": "theorem",
    "signature": "disjoint_left : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₁ → a ∉ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 151,
    "source": "batteries",
    "description": "Proves that two lists are disjoint if and only if no element of the first list is present in the second list."
  },
  "disjoint_right": {
    "name": "disjoint_right",
    "type": "theorem",
    "signature": "disjoint_right : Disjoint l₁ l₂ ↔ ∀ ⦃a⦄, a ∈ l₂ → a ∉ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 153,
    "source": "batteries",
    "description": "Proves that two lists are disjoint if and only if no element of the second list is present in the first list."
  },
  "disjoint_iff_ne": {
    "name": "disjoint_iff_ne",
    "type": "theorem",
    "signature": "disjoint_iff_ne : Disjoint l₁ l₂ ↔ ∀ a ∈ l₁, ∀ b ∈ l₂, a ≠ b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 155,
    "source": "batteries",
    "description": "States that two lists are disjoint if and only if all elements in one list are different from all elements in the other list."
  },
  "disjoint_of_subset_left": {
    "name": "disjoint_of_subset_left",
    "type": "theorem",
    "signature": "disjoint_of_subset_left : Disjoint l₁ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 158,
    "source": "batteries",
    "description": "Proves that if one list is a subset of another, then the two lists are disjoint."
  },
  "disjoint_of_subset_right": {
    "name": "disjoint_of_subset_right",
    "type": "theorem",
    "signature": "disjoint_of_subset_right : Disjoint l₁ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 161,
    "source": "batteries",
    "description": "Proves that if one list is a subset of another, then the two lists are disjoint."
  },
  "disjoint_of_disjoint_append_left_left": {
    "name": "disjoint_of_disjoint_append_left_left",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_left_left : Disjoint l₁ l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 192,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint and one is appended to the left of another, the result remains disjoint from the first list."
  },
  "disjoint_of_disjoint_append_left_right": {
    "name": "disjoint_of_disjoint_append_left_right",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_left_right : Disjoint l₂ l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 195,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint when appended, then each list is disjoint from the other."
  },
  "disjoint_of_disjoint_append_right_left": {
    "name": "disjoint_of_disjoint_append_right_left",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_right_left : Disjoint l l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 198,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint, appending one list to the other maintains their disjoint property."
  },
  "disjoint_of_disjoint_append_right_right": {
    "name": "disjoint_of_disjoint_append_right_right",
    "type": "theorem",
    "signature": "disjoint_of_disjoint_append_right_right : Disjoint l l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 201,
    "source": "batteries",
    "description": "Proves that if two lists are disjoint and one is appended to the right of the other, the resulting lists remain disjoint."
  },
  "diff_subset": {
    "name": "diff_subset",
    "type": "theorem",
    "signature": "diff_subset : l₁.diff l₂ ⊆ l₁",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 300,
    "source": "batteries",
    "description": "Proves that the difference of two lists is a subset of the first list."
  },
  "rel_of_isChain_cons_cons": {
    "name": "rel_of_isChain_cons_cons",
    "type": "theorem",
    "signature": "rel_of_isChain_cons_cons : R a b",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 354,
    "source": "batteries",
    "description": "Proves that if a relation holds for a chain of elements, it also holds for the first two elements of that chain."
  },
  "isChain_of_isChain_cons": {
    "name": "isChain_of_isChain_cons",
    "type": "theorem",
    "signature": "isChain_of_isChain_cons : IsChain R l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 366,
    "source": "batteries",
    "description": "Proves that if a list is a chain under a relation R, then it satisfies the properties of being a chain."
  },
  "isChain_of_isChain_cons_cons": {
    "name": "isChain_of_isChain_cons_cons",
    "type": "theorem",
    "signature": "isChain_of_isChain_cons_cons : IsChain R l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Lemmas.lean",
    "line_number": 372,
    "source": "batteries",
    "description": "Proves that a list is a chain if it can be constructed by consing elements to an existing chain."
  },
  "toArrayMap": {
    "name": "toArrayMap",
    "type": "def",
    "signature": "toArrayMap : Array β",
    "docstring": "This function is provided as a more efficient runtime alternative to `(l.map f).toArray`. (It avoids the intermediate memory allocation of creating an intermediate list first.) For verification purposes, we immediately simplify it to that form.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/ArrayMap.lean",
    "line_number": 20,
    "source": "batteries",
    "description": "This function is provided as a more efficient runtime alternative to `(l.map f).toArray`. (It avoids the intermediate memory allocation of creating an intermediate list first.) For verification purposes, we immediately simplify it to that form."
  },
  "Subperm.filter": {
    "name": "Subperm.filter",
    "type": "theorem",
    "signature": "Subperm.filter : filter p l <+~ filter p l'",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 70,
    "source": "batteries",
    "description": "Shows that filtering a list with a predicate preserves the subpermutation relation between the filtered lists."
  },
  "subperm_of_subset": {
    "name": "subperm_of_subset",
    "type": "theorem",
    "signature": "subperm_of_subset : l₁ <+~ l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 140,
    "source": "batteries",
    "description": "Proves that if list l₁ is a subpermutation of list l₂, then l₁ is a subset of l₂."
  },
  "erase_subperm": {
    "name": "erase_subperm",
    "type": "theorem",
    "signature": "erase_subperm : l.erase a <+~ l",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 180,
    "source": "batteries",
    "description": "Proves that removing an element from a list results in a subpermutation of the original list."
  },
  "Perm.union_left": {
    "name": "Perm.union_left",
    "type": "theorem",
    "signature": "Perm.union_left : l ∪ t₁ ~ l ∪ t₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 288,
    "source": "batteries",
    "description": "Proves that the union of a list with two permutations is equivalent, showing that the order of elements does not affect the union."
  },
  "Perm.insertP": {
    "name": "Perm.insertP",
    "type": "theorem",
    "signature": "Perm.insertP : insertP p a l₁ ~ insertP p a l₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Perm.lean",
    "line_number": 319,
    "source": "batteries",
    "description": "Proves that inserting an element into two lists at the same position results in lists that are permutation-equivalent."
  },
  "splitAtD": {
    "name": "splitAtD",
    "type": "def",
    "signature": "splitAtD : List α × List α",
    "docstring": "Split a list at an index. Ensures the left list always has the specified length by right padding with the provided default element. ``` splitAtD 2 [a, b, c] x = ([a, b], [c]) splitAtD 4 [a, b, c] x = ([a, b, c, x], []) ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 98,
    "source": "batteries",
    "description": "Split a list at an index. Ensures the left list always has the specified length by right padding with the provided default element. ``` splitAtD 2 [a, b, c] x = ([a, b], [c]) splitAtD 4 [a, b, c] x = ([a, b, c, x], []) ```"
  },
  "splitOnP": {
    "name": "splitOnP",
    "type": "def",
    "signature": "splitOnP : List (List α)",
    "docstring": "Split a list at every element satisfying a predicate. The separators are not in the result. ``` [1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 112,
    "source": "batteries",
    "description": "Split a list at every element satisfying a predicate. The separators are not in the result. ``` [1, 1, 2, 3, 2, 4, 4].splitOnP (· == 2) = [[1, 1], [3], [4, 4]] ```"
  },
  "takeD": {
    "name": "takeD",
    "type": "def",
    "signature": "takeD : Nat → List α → α → List α",
    "docstring": "Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l` elements `x`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 157,
    "source": "batteries",
    "description": "Take `n` elements from a list `l`. If `l` has less than `n` elements, append `n - length l` elements `x`."
  },
  "takeDTR": {
    "name": "takeDTR",
    "type": "def",
    "signature": "takeDTR : List α",
    "docstring": "Tail-recursive version of `takeD`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 169,
    "source": "batteries",
    "description": "Tail-recursive version of `takeD`."
  },
  "scanr": {
    "name": "scanr",
    "type": "def",
    "signature": "scanr : List β",
    "docstring": "Fold a function `f` over the list from the right, returning the list of partial results. ``` scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 214,
    "source": "batteries",
    "description": "Fold a function `f` over the list from the right, returning the list of partial results. ``` scanr (+) 0 [1, 2, 3] = [6, 5, 3, 0] ```"
  },
  "initsTR": {
    "name": "initsTR",
    "type": "def",
    "signature": "initsTR : List (List α)",
    "docstring": "Tail-recursive version of `inits`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 279,
    "source": "batteries",
    "description": "Tail-recursive version of `inits`."
  },
  "tailsTR": {
    "name": "tailsTR",
    "type": "def",
    "signature": "tailsTR : List (List α)",
    "docstring": "Tail-recursive version of `tails`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 296,
    "source": "batteries",
    "description": "Tail-recursive version of `tails`."
  },
  "sublists": {
    "name": "sublists",
    "type": "def",
    "signature": "sublists : List (List α)",
    "docstring": "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'` for a different ordering. ``` sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 329,
    "source": "batteries",
    "description": "`sublists l` is the list of all (non-contiguous) sublists of `l`; cf. `sublists'` for a different ordering. ``` sublists [1, 2, 3] = [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] ```"
  },
  "sublistsFast": {
    "name": "sublistsFast",
    "type": "def",
    "signature": "sublistsFast : List (List α)",
    "docstring": "A version of `List.sublists` that has faster runtime performance but worse kernel performance",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 333,
    "source": "batteries",
    "description": "A version of `List.sublists` that has faster runtime performance but worse kernel performance"
  },
  "all₂": {
    "name": "all₂",
    "type": "def",
    "signature": "all₂ : List α → List β → Bool",
    "docstring": "Check for all elements `a`, `b`, where `a` and `b` are the nth element of the first and second List respectively, that `r a b = true`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 370,
    "source": "batteries",
    "description": "Check for all elements `a`, `b`, where `a` and `b` are the nth element of the first and second List respectively, that `r a b = true`."
  },
  "transpose": {
    "name": "transpose",
    "type": "def",
    "signature": "transpose : List (List α)",
    "docstring": "Transpose of a list of lists, treated as a matrix. ``` transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 399,
    "source": "batteries",
    "description": "Transpose of a list of lists, treated as a matrix. ``` transpose [[1, 2], [3, 4], [5, 6]] = [[1, 3, 5], [2, 4, 6]] ```"
  },
  "sectionsTR": {
    "name": "sectionsTR",
    "type": "def",
    "signature": "sectionsTR : List (List α)",
    "docstring": "Optimized version of `sections`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 431,
    "source": "batteries",
    "description": "Optimized version of `sections`."
  },
  "extractP": {
    "name": "extractP",
    "type": "def",
    "signature": "extractP : Option α × List α",
    "docstring": "`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate `p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 459,
    "source": "batteries",
    "description": "`extractP p l` returns a pair of an element `a` of `l` satisfying the predicate `p`, and `l`, with `a` removed. If there is no such element `a` it returns `(none, l)`."
  },
  "revzip": {
    "name": "revzip",
    "type": "def",
    "signature": "revzip : List (α × α)",
    "docstring": "`revzip l` returns a list of pairs of the elements of `l` paired with the elements of `l` in reverse order. ``` revzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 474,
    "source": "batteries",
    "description": "`revzip l` returns a list of pairs of the elements of `l` paired with the elements of `l` in reverse order. ``` revzip [1, 2, 3, 4, 5] = [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)] ```"
  },
  "product": {
    "name": "product",
    "type": "def",
    "signature": "product : List (α × β)",
    "docstring": "`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`. ``` product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 482,
    "source": "batteries",
    "description": "`product l₁ l₂` is the list of pairs `(a, b)` where `a ∈ l₁` and `b ∈ l₂`. ``` product [1, 2] [5, 6] = [(1, 5), (1, 6), (2, 5), (2, 6)] ```"
  },
  "productTR": {
    "name": "productTR",
    "type": "def",
    "signature": "productTR : List (α × β)",
    "docstring": "Optimized version of `product`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 485,
    "source": "batteries",
    "description": "Optimized version of `product`."
  },
  "Disjoint": {
    "name": "Disjoint",
    "type": "def",
    "signature": "Disjoint : Prop",
    "docstring": "`Disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 514,
    "source": "batteries",
    "description": "`Disjoint l₁ l₂` means that `l₁` and `l₂` have no elements in common."
  },
  "takeWhile₂": {
    "name": "takeWhile₂",
    "type": "def",
    "signature": "takeWhile₂ : List α → List β → List α × List β",
    "docstring": "Returns the longest initial prefix of two lists such that they are pairwise related by `R`. ``` takeWhile₂ (· < ·) [1, 2, 4, 5] [5, 4, 3, 6] = ([1, 2], [5, 4]) ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 523,
    "source": "batteries",
    "description": "Returns the longest initial prefix of two lists such that they are pairwise related by `R`. ``` takeWhile₂ (· < ·) [1, 2, 4, 5] [5, 4, 3, 6] = ([1, 2], [5, 4]) ```"
  },
  "pwFilter": {
    "name": "pwFilter",
    "type": "def",
    "signature": "pwFilter : List α",
    "docstring": "`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`. `pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds a maximal increasing subsequence in `l`. For example, ``` pwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4] ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 558,
    "source": "batteries",
    "description": "`pwFilter R l` is a maximal sublist of `l` which is `Pairwise R`. `pwFilter (·≠·)` is the erase duplicates function (cf. `eraseDup`), and `pwFilter (·<·)` finds a maximal increasing subsequence in `l`. For example, ``` pwFilter (·<·) [0, 1, 5, 2, 6, 3, 4] = [0, 1, 2, 3, 4] ```"
  },
  "Chain": {
    "name": "Chain",
    "type": "def",
    "signature": "Chain : (α → α → Prop) → α → List α → Prop",
    "docstring": "`Chain R a l` means that `R` holds between adjacent elements of `a::l`. ``` Chain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 592,
    "source": "batteries",
    "description": "`Chain R a l` means that `R` holds between adjacent elements of `a::l`. ``` Chain R a [b, c, d] ↔ R a b ∧ R b c ∧ R c d ```"
  },
  "zipWith₃": {
    "name": "zipWith₃",
    "type": "def",
    "signature": "zipWith₃ : List α → List β → List γ → List δ",
    "docstring": "Ternary version of `List.zipWith`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 955,
    "source": "batteries",
    "description": "Ternary version of `List.zipWith`."
  },
  "zipWith₄": {
    "name": "zipWith₄",
    "type": "def",
    "signature": "zipWith₄ : List α → List β → List γ → List δ → List ε",
    "docstring": "Quaternary version of `List.zipWith`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 960,
    "source": "batteries",
    "description": "Quaternary version of `List.zipWith`."
  },
  "zipWith₅": {
    "name": "zipWith₅",
    "type": "def",
    "signature": "zipWith₅ : List α → List β → List γ → List δ → List ε → List ζ",
    "docstring": "Quinary version of `List.zipWith`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 965,
    "source": "batteries",
    "description": "Quinary version of `List.zipWith`."
  },
  "Subperm": {
    "name": "Subperm",
    "type": "def",
    "signature": "Subperm : Prop",
    "docstring": "`Subperm l₁ l₂`, denoted `l₁ <+~ l₂`, means that `l₁` is a sublist of a permutation of `l₂`. This is an analogue of `l₁ ⊆ l₂` which respects multiplicities of elements, and is used for the `≤` relation on multisets.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 1009,
    "source": "batteries",
    "description": "`Subperm l₁ l₂`, denoted `l₁ <+~ l₂`, means that `l₁` is a sublist of a permutation of `l₂`. This is an analogue of `l₁ ⊆ l₂` which respects multiplicities of elements, and is used for the `≤` relation on multisets."
  },
  "insertP": {
    "name": "insertP",
    "type": "def",
    "signature": "insertP : List α",
    "docstring": "`O(|l|)`. Inserts `a` in `l` right before the first element such that `p` is true, or at the end of the list if `p` always false on `l`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 1023,
    "source": "batteries",
    "description": "`O(|l|)`. Inserts `a` in `l` right before the first element such that `p` is true, or at the end of the list if `p` always false on `l`."
  },
  "Forall₂": {
    "name": "Forall₂",
    "type": "inductive",
    "signature": "Forall₂ : List α → List β → Prop",
    "docstring": "`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length, and whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`, then `R a b` is satisfied.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 353,
    "source": "batteries",
    "description": "`Forall₂ R l₁ l₂` means that `l₁` and `l₂` have the same length, and whenever `a` is the nth element of `l₁`, and `b` is the nth element of `l₂`, then `R a b` is satisfied."
  },
  "IsChain": {
    "name": "IsChain",
    "type": "inductive",
    "signature": "IsChain : List α → Prop",
    "docstring": "`IsChain R l` means that `R` holds between adjacent elements of `l`. ``` IsChain R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d ```",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/List/Basic.lean",
    "line_number": 565,
    "source": "batteries",
    "description": "`IsChain R l` means that `R` holds between adjacent elements of `l`. ``` IsChain R [a, b, c, d] ↔ R a b ∧ R b c ∧ R c d ```"
  },
  "Valid": {
    "name": "Valid",
    "type": "def",
    "signature": "Valid : Prop",
    "docstring": "Validity for a string iterator.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 531,
    "source": "batteries",
    "description": "Validity for a string iterator."
  },
  "add_utf8Size_pos": {
    "name": "add_utf8Size_pos",
    "type": "theorem",
    "signature": "add_utf8Size_pos : 0 < i + Char.utf8Size c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 38,
    "source": "batteries",
    "description": "Proves that the sum of a non-negative integer and the UTF-8 size of a character is positive."
  },
  "ne_add_utf8Size_add_self": {
    "name": "ne_add_utf8Size_add_self",
    "type": "theorem",
    "signature": "ne_add_utf8Size_add_self : i ≠ n + Char.utf8Size c + i",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 41,
    "source": "batteries",
    "description": "Proves that adding the UTF-8 size of a character to an integer does not equal the original integer."
  },
  "ne_self_add_add_utf8Size": {
    "name": "ne_self_add_add_utf8Size",
    "type": "theorem",
    "signature": "ne_self_add_add_utf8Size : i ≠ i + (n + Char.utf8Size c)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 44,
    "source": "batteries",
    "description": "Proves that a natural number is not equal to itself plus the size of a UTF-8 character."
  },
  "utf8Len_le_of_sublist": {
    "name": "utf8Len_le_of_sublist",
    "type": "theorem",
    "signature": "utf8Len_le_of_sublist : ∀ {cs₁ cs₂}, cs₁ <+ cs₂ → utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 81,
    "source": "batteries",
    "description": "If one list is a sublist of another, then the UTF-8 length of the first list is less than or equal to that of the second."
  },
  "utf8Len_le_of_infix": {
    "name": "utf8Len_le_of_infix",
    "type": "theorem",
    "signature": "utf8Len_le_of_infix : utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 85,
    "source": "batteries",
    "description": "Proves that the UTF-8 length of a list of characters is less than or equal to that of another list when one is an infix of the other."
  },
  "utf8Len_le_of_suffix": {
    "name": "utf8Len_le_of_suffix",
    "type": "theorem",
    "signature": "utf8Len_le_of_suffix : utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 88,
    "source": "batteries",
    "description": "Proves that the length of a UTF-8 encoded string is less than or equal to the length of its suffix."
  },
  "utf8Len_le_of_prefix": {
    "name": "utf8Len_le_of_prefix",
    "type": "theorem",
    "signature": "utf8Len_le_of_prefix : utf8Len cs₁ ≤ utf8Len cs₂",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 91,
    "source": "batteries",
    "description": "If `cs₁` is a prefix of `cs₂`, then the length of `cs₁` in UTF-8 encoding is less than or equal to that of `cs₂`."
  },
  "lt_addChar": {
    "name": "lt_addChar",
    "type": "theorem",
    "signature": "lt_addChar : p < p + c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Proves that adding a character to a value p results in a value greater than p."
  },
  "Valid.le_endPos": {
    "name": "Valid.le_endPos",
    "type": "theorem",
    "signature": "Valid.le_endPos : ∀ {s p}, Valid s p → p ≤ endPos s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 139,
    "source": "batteries",
    "description": "Proves that if a state `s` is valid for position `p`, then `p` is less than or equal to the end position of `s`."
  },
  "findAux_of_valid": {
    "name": "findAux_of_valid",
    "type": "theorem",
    "signature": "findAux_of_valid : ∀ l m r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 320,
    "source": "batteries",
    "description": "Proves that the auxiliary function findAux behaves correctly when the input list is valid."
  },
  "revFindAux_of_valid": {
    "name": "revFindAux_of_valid",
    "type": "theorem",
    "signature": "revFindAux_of_valid : ∀ l r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 343,
    "source": "batteries",
    "description": "Proves that the auxiliary function `revFindAux` is valid for a given list and a result, ensuring correct behavior in its application."
  },
  "valid": {
    "name": "valid",
    "type": "theorem",
    "signature": "valid : ∀ {it}, ValidFor l r it → Valid it",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 542,
    "source": "batteries",
    "description": "Proves that if an item is valid for a list and a relation, then the item is valid."
  },
  "_root_.String.validFor_mkIterator": {
    "name": "_root_.String.validFor_mkIterator",
    "type": "theorem",
    "signature": "_root_.String.validFor_mkIterator : (mkIterator s).ValidFor [] s.data",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 560,
    "source": "batteries",
    "description": "Proves that the iterator created from a string is valid for the string's data."
  },
  "prev_nil": {
    "name": "prev_nil",
    "type": "theorem",
    "signature": "prev_nil : ∀ {it}, ValidFor [] r it → ValidFor [] r it.prev",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 598,
    "source": "batteries",
    "description": "Proves that if a list is valid for a relation, then its previous element is also valid for the same relation."
  },
  "hasNext": {
    "name": "hasNext",
    "type": "theorem",
    "signature": "hasNext : ∀ {it}, ValidFor l r it → (it.hasNext ↔ r ≠ [])",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 610,
    "source": "batteries",
    "description": "Proves that an iterator has a next element if and only if the right list is not empty."
  },
  "hasPrev": {
    "name": "hasPrev",
    "type": "theorem",
    "signature": "hasPrev : ∀ {it}, ValidFor l r it → (it.hasPrev ↔ l ≠ [])",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 613,
    "source": "batteries",
    "description": "Proves that an iterator has a previous element if and only if the list is not empty."
  },
  "toEnd": {
    "name": "toEnd",
    "type": "theorem",
    "signature": "toEnd : ValidFor (r.reverse ++ l) [] it.toEnd",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 628,
    "source": "batteries",
    "description": "Proves that appending a reversed list to another list results in a valid transformation to the end of the list."
  },
  "nextn": {
    "name": "nextn",
    "type": "theorem",
    "signature": "nextn : ∀ {it}, ValidFor l r it →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 652,
    "source": "batteries",
    "description": "Proves that a certain condition holds for the next element in a sequence given its validity in a list."
  },
  "prevn": {
    "name": "prevn",
    "type": "theorem",
    "signature": "prevn : ∀ {it}, ValidFor l r it →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 660,
    "source": "batteries",
    "description": "Proves a property related to the validity of a certain condition for indices in a list or sequence."
  },
  "validFor": {
    "name": "validFor",
    "type": "theorem",
    "signature": "validFor : ∀ {it}, Valid it → ∃ l r, ValidFor l r it",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 672,
    "source": "batteries",
    "description": "Proves that if an item is valid, then there exist left and right components that also satisfy the validity condition."
  },
  "_root_.String.valid_mkIterator": {
    "name": "_root_.String.valid_mkIterator",
    "type": "theorem",
    "signature": "_root_.String.valid_mkIterator : (mkIterator s).Valid",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 676,
    "source": "batteries",
    "description": "Proves that the iterator created from a string is valid, ensuring it can be used correctly for traversal."
  },
  "remainingBytes_le": {
    "name": "remainingBytes_le",
    "type": "theorem",
    "signature": "remainingBytes_le : ∀ {it}, Valid it → it.remainingBytes ≤ utf8ByteSize it.s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 678,
    "source": "batteries",
    "description": "Proves that the remaining bytes in a valid input are less than or equal to the UTF-8 byte size of its string representation."
  },
  "next": {
    "name": "next",
    "type": "theorem",
    "signature": "next : ∀ {it}, Valid it → it.hasNext → Valid it.next",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 683,
    "source": "batteries",
    "description": "Proves that if an iterator is valid and has a next element, then the next element is also valid."
  },
  "prev": {
    "name": "prev",
    "type": "theorem",
    "signature": "prev : ∀ {it}, Valid it → Valid it.prev",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 689,
    "source": "batteries",
    "description": "Proves that if a state is valid, then its predecessor state is also valid."
  },
  "setCurr": {
    "name": "setCurr",
    "type": "theorem",
    "signature": "setCurr : ∀ {it}, Valid it → Valid (it.setCurr c)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 695,
    "source": "batteries",
    "description": "Proves that setting the current element in a valid structure maintains its validity."
  },
  "offsetOfPosAux_of_valid": {
    "name": "offsetOfPosAux_of_valid",
    "type": "theorem",
    "signature": "offsetOfPosAux_of_valid : ∀ l m r n,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 717,
    "source": "batteries",
    "description": "Proves a property related to the validity of offsets in a data structure, involving parameters l, m, r, and n."
  },
  "foldlAux_of_valid": {
    "name": "foldlAux_of_valid",
    "type": "theorem",
    "signature": "foldlAux_of_valid : ∀ l m r a,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 732,
    "source": "batteries",
    "description": "Proves that a certain auxiliary function maintains validity when folding over a list with given parameters."
  },
  "anyAux_of_valid": {
    "name": "anyAux_of_valid",
    "type": "theorem",
    "signature": "anyAux_of_valid : ∀ l m r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 760,
    "source": "batteries",
    "description": "Proves a property related to the validity of a structure involving lists and auxiliary elements."
  },
  "any_iff": {
    "name": "any_iff",
    "type": "theorem",
    "signature": "any_iff : any s p ↔ ∃ c ∈ s.data, p c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 774,
    "source": "batteries",
    "description": "States that a predicate holds for any element in a set if and only if there exists at least one element in the set satisfying the predicate."
  },
  "all_iff": {
    "name": "all_iff",
    "type": "theorem",
    "signature": "all_iff : all s p ↔ ∀ c ∈ s.data, p c",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 779,
    "source": "batteries",
    "description": "States that a property holds for all elements in a set if and only if it holds for every element in the set's data."
  },
  "contains_iff": {
    "name": "contains_iff",
    "type": "theorem",
    "signature": "contains_iff : contains s c ↔ c ∈ s.data",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 781,
    "source": "batteries",
    "description": "States that a set contains an element if and only if that element is in the set's data."
  },
  "takeWhileAux_of_valid": {
    "name": "takeWhileAux_of_valid",
    "type": "theorem",
    "signature": "takeWhileAux_of_valid : ∀ l m r,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 805,
    "source": "batteries",
    "description": "Proves that the auxiliary function `takeWhileAux` maintains validity for a given list and its parameters."
  },
  "Valid_default": {
    "name": "Valid_default",
    "type": "theorem",
    "signature": "Valid_default : Valid default",
    "docstring": "The stop position of a substring is at least the start.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 848,
    "source": "batteries",
    "description": "The stop position of a substring is at least the start."
  },
  "of_eq": {
    "name": "of_eq",
    "type": "theorem",
    "signature": "of_eq : ∀ s,",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 861,
    "source": "batteries",
    "description": "Proves that if two values are equal, they can be substituted for one another in any context."
  },
  "_root_.String.validFor_toSubstring": {
    "name": "_root_.String.validFor_toSubstring",
    "type": "theorem",
    "signature": "_root_.String.validFor_toSubstring : ValidFor [] s.data [] s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 870,
    "source": "batteries",
    "description": "Proves that a substring of a string is valid if the original string is valid and the substring is derived from it."
  },
  "toIterator": {
    "name": "toIterator",
    "type": "theorem",
    "signature": "toIterator : ∀ {s}, ValidFor l m r s → s.toIterator.ValidFor l.reverse (m ++ r)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 891,
    "source": "batteries",
    "description": "Proves that if a sequence is valid for certain parameters, its iterator is valid for the reversed left parameters and the concatenated middle and right parameters."
  },
  "drop": {
    "name": "drop",
    "type": "theorem",
    "signature": "drop : ∀ {s}, ValidFor l m r s → ∀ n, ValidFor (l ++ m.take n) (m.drop n) r (s.drop n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 955,
    "source": "batteries",
    "description": "Proves that if a sequence is valid, dropping elements from the middle preserves the validity of the modified sequence."
  },
  "take": {
    "name": "take",
    "type": "theorem",
    "signature": "take : ∀ {s}, ValidFor l m r s → ∀ n, ValidFor l (m.take n) (m.drop n ++ r) (s.take n)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 967,
    "source": "batteries",
    "description": "Proves that taking the first n elements from a valid sequence maintains validity for the modified sequence."
  },
  "extract": {
    "name": "extract",
    "type": "theorem",
    "signature": "extract : ∀ {s}, ValidFor l m r s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 999,
    "source": "batteries",
    "description": "Proves a property related to the validity of a structure given certain parameters."
  },
  "contains": {
    "name": "contains",
    "type": "theorem",
    "signature": "contains : ∀ {s}, ValidFor l m r s → (s.contains c ↔ c ∈ m)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1021,
    "source": "batteries",
    "description": "Proves that an element is contained in a set if and only if it is part of a specified mapping, given the validity of certain conditions."
  },
  "takeWhile": {
    "name": "takeWhile",
    "type": "theorem",
    "signature": "takeWhile : ∀ {s}, ValidFor l m r s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1024,
    "source": "batteries",
    "description": "Proves that the takeWhile function correctly extracts elements from a sequence based on a specified predicate."
  },
  "dropWhile": {
    "name": "dropWhile",
    "type": "theorem",
    "signature": "dropWhile : ∀ {s}, ValidFor l m r s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1031,
    "source": "batteries",
    "description": "Proves that the dropWhile function maintains validity for a sequence after dropping elements that satisfy a given condition."
  },
  "_root_.String.valid_toSubstring": {
    "name": "_root_.String.valid_toSubstring",
    "type": "theorem",
    "signature": "_root_.String.valid_toSubstring : Valid s",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1064,
    "source": "batteries",
    "description": "Proves that a valid string can be used to create a substring."
  },
  "toString_extract": {
    "name": "toString_extract",
    "type": "theorem",
    "signature": "toString_extract : ∀ {s}, Valid s → Valid ⟨s.toString, b, e⟩ →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1137,
    "source": "batteries",
    "description": "Proves that if a string is valid, then its string representation is also valid within a specified context."
  },
  "data_takeWhile": {
    "name": "data_takeWhile",
    "type": "theorem",
    "signature": "data_takeWhile : ∀ {s}, Valid s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1164,
    "source": "batteries",
    "description": "Proves that the function `data_takeWhile` correctly processes valid data structures based on a specified condition."
  },
  "data_dropWhile": {
    "name": "data_dropWhile",
    "type": "theorem",
    "signature": "data_dropWhile : ∀ {s}, Valid s →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 1171,
    "source": "batteries",
    "description": "Proves that the dropWhile function maintains validity for a given structure when applied to a valid sequence."
  },
  "ValidFor": {
    "name": "ValidFor",
    "type": "inductive",
    "signature": "ValidFor : Iterator → Prop",
    "docstring": "`it.ValidFor l r` means that `it` is a string iterator whose underlying string is `l.reverse ++ r`, and where the cursor is pointing at the end of `l.reverse`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Lemmas.lean",
    "line_number": 535,
    "source": "batteries",
    "description": "`it.ValidFor l r` means that `it` is a string iterator whose underlying string is `l.reverse ++ r`, and where the cursor is pointing at the end of `l.reverse`."
  },
  "toAsciiByteArray": {
    "name": "toAsciiByteArray",
    "type": "def",
    "signature": "toAsciiByteArray : ByteArray",
    "docstring": "Convert a string of assumed-ASCII characters into a byte array. (If any characters are non-ASCII they will be reduced modulo 256.) Note: if you just need the underlying `ByteArray` of a non-ASCII string, use `String.toUTF8`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/String/Basic.lean",
    "line_number": 25,
    "source": "batteries",
    "description": "Convert a string of assumed-ASCII characters into a byte array. (If any characters are non-ASCII they will be reduced modulo 256.) Note: if you just need the underlying `ByteArray` of a non-ASCII string, use `String.toUTF8`."
  },
  "mt19937": {
    "name": "mt19937",
    "type": "def",
    "signature": "mt19937 : Config where",
    "docstring": "32 bit Mersenne Twister (MT19937) configuration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Random/MersenneTwister.lean",
    "line_number": 139,
    "source": "batteries",
    "description": "32 bit Mersenne Twister (MT19937) configuration."
  },
  "mt19937_64": {
    "name": "mt19937_64",
    "type": "def",
    "signature": "mt19937_64 : Config where",
    "docstring": "64 bit Mersenne Twister (MT19937-64) configuration.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Random/MersenneTwister.lean",
    "line_number": 151,
    "source": "batteries",
    "description": "64 bit Mersenne Twister (MT19937-64) configuration."
  },
  "Config": {
    "name": "Config",
    "type": "structure",
    "signature": "Config",
    "docstring": "Mersenne Twister configuration. Letters in parentheses correspond to variable names used by Matsumoto and Nishimura (1998) and Nishimura (2000).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/Random/MersenneTwister.lean",
    "line_number": 54,
    "source": "batteries",
    "description": "Mersenne Twister configuration. Letters in parentheses correspond to variable names used by Matsumoto and Nishimura (1998) and Nishimura (2000)."
  },
  "depth": {
    "name": "depth",
    "type": "def",
    "signature": "depth : RBNode α → Nat",
    "docstring": "`O(n)`. `depth t` is the maximum number of nodes on any path to a leaf. It is an upper bound on most tree operations.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 23,
    "source": "batteries",
    "description": "`O(n)`. `depth t` is the maximum number of nodes on any path to a leaf. It is an upper bound on most tree operations."
  },
  "depthLB": {
    "name": "depthLB",
    "type": "def",
    "signature": "depthLB : RBColor → Nat → Nat",
    "docstring": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 40,
    "source": "batteries",
    "description": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthUB": {
    "name": "depthUB",
    "type": "def",
    "signature": "depthUB : RBColor → Nat → Nat",
    "docstring": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 52,
    "source": "batteries",
    "description": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthLB_le": {
    "name": "depthLB_le",
    "type": "theorem",
    "signature": "depthLB_le : ∀ c n, n ≤ depthLB c n",
    "docstring": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 43,
    "source": "batteries",
    "description": "`depthLB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthUB_le": {
    "name": "depthUB_le",
    "type": "theorem",
    "signature": "depthUB_le : ∀ c n, depthUB c n ≤ 2 * n + 1",
    "docstring": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 55,
    "source": "batteries",
    "description": "`depthUB c n` is the best upper bound on the depth of any balanced red-black tree with root colored `c` and black-height `n`."
  },
  "depthUB_le_two_depthLB": {
    "name": "depthUB_le_two_depthLB",
    "type": "theorem",
    "signature": "depthUB_le_two_depthLB : ∀ c n, depthUB c n ≤ 2 * depthLB c n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 59,
    "source": "batteries",
    "description": "Proves that the upper bound of depth is at most twice the lower bound for any given context and natural number."
  },
  "Balanced.depth_le": {
    "name": "Balanced.depth_le",
    "type": "theorem",
    "signature": "Balanced.depth_le : @Balanced α t c n → t.depth ≤ depthUB c n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 63,
    "source": "batteries",
    "description": "Proves that the depth of a balanced tree is less than or equal to the upper bound on depth given its configuration parameters."
  },
  "Balanced.le_size": {
    "name": "Balanced.le_size",
    "type": "theorem",
    "signature": "Balanced.le_size : @Balanced α t c n → 2 ^ depthLB c n ≤ t.size + 1",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 69,
    "source": "batteries",
    "description": "Proves that the size of a balanced tree is at least \\(2^{\\text{depthLB}(c, n)} - 1\\), ensuring efficient space usage."
  },
  "Balanced.depth_bound": {
    "name": "Balanced.depth_bound",
    "type": "theorem",
    "signature": "Balanced.depth_bound : t.depth ≤ 2 * (t.size + 1).log2",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Depth.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "Proves that the depth of a balanced tree is bounded by twice the logarithm of its size plus one."
  },
  "setRoot": {
    "name": "setRoot",
    "type": "def",
    "signature": "setRoot : RBNode α → RBNode α",
    "docstring": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 373,
    "source": "batteries",
    "description": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary."
  },
  "delRoot": {
    "name": "delRoot",
    "type": "def",
    "signature": "delRoot : RBNode α → RBNode α",
    "docstring": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 380,
    "source": "batteries",
    "description": "Auxiliary definition for `zoom_ins`: set the root of the tree to `v`, creating a node if necessary."
  },
  "AllL": {
    "name": "AllL",
    "type": "def",
    "signature": "AllL : Path α → Prop",
    "docstring": "Asserts that `p` holds on all elements to the left of the hole.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 740,
    "source": "batteries",
    "description": "Asserts that `p` holds on all elements to the left of the hole."
  },
  "AllR": {
    "name": "AllR",
    "type": "def",
    "signature": "AllR : Path α → Prop",
    "docstring": "Asserts that `p` holds on all elements to the right of the hole.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 746,
    "source": "batteries",
    "description": "Asserts that `p` holds on all elements to the right of the hole."
  },
  "mem_toList_insert_self": {
    "name": "mem_toList_insert_self",
    "type": "theorem",
    "signature": "mem_toList_insert_self : v ∈ toList (t.insert v)",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 922,
    "source": "batteries",
    "description": "Proves that an element inserted into a tree is included in the list representation of that tree."
  },
  "IsCut": {
    "name": "IsCut",
    "type": "class",
    "signature": "IsCut",
    "docstring": "A cut is like a homomorphism of orderings: it is a monotonic predicate with respect to `cmp`, but it can make things that are distinguished by `cmp` equal. This is sufficient for `find?` to locate an element on which `cut` returns `.eq`, but there may be other elements, not returned by `find?`, on which `cut` also returns `.eq`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 85,
    "source": "batteries",
    "description": "A cut is like a homomorphism of orderings: it is a monotonic predicate with respect to `cmp`, but it can make things that are distinguished by `cmp` equal. This is sufficient for `find?` to locate an element on which `cut` returns `.eq`, but there may be other elements, not returned by `find?`, on which `cut` also returns `.eq`."
  },
  "IsStrictCut": {
    "name": "IsStrictCut",
    "type": "class",
    "signature": "IsStrictCut",
    "docstring": "`IsStrictCut` upgrades the `IsCut` property to ensure that at most one element of the tree can match the cut, and hence `find?` will return the unique such element if one exists.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Lemmas.lean",
    "line_number": 122,
    "source": "batteries",
    "description": "`IsStrictCut` upgrades the `IsCut` property to ensure that at most one element of the tree can match the cut, and hence `find?` will return the unique such element if one exists."
  },
  "Any": {
    "name": "Any",
    "type": "def",
    "signature": "Any : RBNode α → Prop",
    "docstring": "Asserts that `p` holds on some element of the tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 188,
    "source": "batteries",
    "description": "Asserts that `p` holds on some element of the tree."
  },
  "EMem": {
    "name": "EMem",
    "type": "def",
    "signature": "EMem : Prop",
    "docstring": "True if `x` is an element of `t` \"exactly\", i.e. up to equality, not the `cmp` relation.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 199,
    "source": "batteries",
    "description": "True if `x` is an element of `t` \"exactly\", i.e. up to equality, not the `cmp` relation."
  },
  "MemP": {
    "name": "MemP",
    "type": "def",
    "signature": "MemP : Prop",
    "docstring": "True if the specified `cut` matches at least one element of of `t`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 205,
    "source": "batteries",
    "description": "True if the specified `cut` matches at least one element of of `t`."
  },
  "cmpLT": {
    "name": "cmpLT",
    "type": "def",
    "signature": "cmpLT : Prop",
    "docstring": "We say that `x < y` under the comparator `cmp` if `cmp x y = .lt`. * In order to avoid assuming the comparator is always lawful, we use a local `∀ [Std.TransCmp cmp]` binder in the relation so that the ordering properties of the tree only need to hold if the comparator is lawful. * The `Nonempty` wrapper is a no-op because this is already a proposition, but it prevents the `[Std.TransCmp cmp]` binder from being introduced when we don't want it.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 244,
    "source": "batteries",
    "description": "We say that `x < y` under the comparator `cmp` if `cmp x y = .lt`. * In order to avoid assuming the comparator is always lawful, we use a local `∀ [Std.TransCmp cmp]` binder in the relation so that the ordering properties of the tree only need to hold if the comparator is lawful. * The `Nonempty` wrapper is a no-op because this is already a proposition, but it prevents the `[Std.TransCmp cmp]` binder from being introduced when we don't want it."
  },
  "cmpEq": {
    "name": "cmpEq",
    "type": "def",
    "signature": "cmpEq : Prop",
    "docstring": "We say that `x ≈ y` under the comparator `cmp` if `cmp x y = .eq`. See also `cmpLT`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 253,
    "source": "batteries",
    "description": "We say that `x ≈ y` under the comparator `cmp` if `cmp x y = .eq`. See also `cmpLT`."
  },
  "setBlack": {
    "name": "setBlack",
    "type": "def",
    "signature": "setBlack : RBNode α → RBNode α",
    "docstring": "Changes the color of the root to `black`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 296,
    "source": "batteries",
    "description": "Changes the color of the root to `black`."
  },
  "setRed": {
    "name": "setRed",
    "type": "def",
    "signature": "setRed : RBNode α → RBNode α",
    "docstring": "Recolor the root of the tree to `red` if possible.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 339,
    "source": "batteries",
    "description": "Recolor the root of the tree to `red` if possible."
  },
  "balLeft": {
    "name": "balLeft",
    "type": "def",
    "signature": "balLeft : RBNode α",
    "docstring": "Rebalancing a tree which has shrunk on the left.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 344,
    "source": "batteries",
    "description": "Rebalancing a tree which has shrunk on the left."
  },
  "balRight": {
    "name": "balRight",
    "type": "def",
    "signature": "balRight : RBNode α",
    "docstring": "Rebalancing a tree which has shrunk on the right.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 353,
    "source": "batteries",
    "description": "Rebalancing a tree which has shrunk on the right."
  },
  "Path.fill": {
    "name": "Path.fill",
    "type": "def",
    "signature": "Path.fill : Path α → RBNode α → RBNode α",
    "docstring": "Fills the `Path` with a subtree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 467,
    "source": "batteries",
    "description": "Fills the `Path` with a subtree."
  },
  "Path.ins": {
    "name": "Path.ins",
    "type": "def",
    "signature": "Path.ins : Path α → RBNode α → RBNode α",
    "docstring": "This function does the second part of `RBNode.ins`, which unwinds the stack and rebuilds the tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 488,
    "source": "batteries",
    "description": "This function does the second part of `RBNode.ins`, which unwinds the stack and rebuilds the tree."
  },
  "Path.insert": {
    "name": "Path.insert",
    "type": "def",
    "signature": "Path.insert : RBNode α",
    "docstring": "`path.insert t v` inserts element `v` into the tree, assuming that `(t, path)` was the result of a previous `zoom` operation (so either the root of `t` is equivalent to `v` or it is empty).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 506,
    "source": "batteries",
    "description": "`path.insert t v` inserts element `v` into the tree, assuming that `(t, path)` was the result of a previous `zoom` operation (so either the root of `t` is equivalent to `v` or it is empty)."
  },
  "Path.del": {
    "name": "Path.del",
    "type": "def",
    "signature": "Path.del : Path α → RBNode α → RBColor → RBNode α",
    "docstring": "`path.del t c` does the second part of `RBNode.del`, which unwinds the stack and rebuilds the tree. The `c` argument is the color of the node before the deletion (we used `t₀.isBlack` for this in `RBNode.del` but the original tree is no longer available in this formulation).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 517,
    "source": "batteries",
    "description": "`path.del t c` does the second part of `RBNode.del`, which unwinds the stack and rebuilds the tree. The `c` argument is the color of the node before the deletion (we used `t₀.isBlack` for this in `RBNode.del` but the original tree is no longer available in this formulation)."
  },
  "Path.erase": {
    "name": "Path.erase",
    "type": "def",
    "signature": "Path.erase : RBNode α",
    "docstring": "`path.erase t v` removes the root element of `t` from the tree, assuming that `(t, path)` was the result of a previous `zoom` operation.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 528,
    "source": "batteries",
    "description": "`path.erase t v` removes the root element of `t` from the tree, assuming that `(t, path)` was the result of a previous `zoom` operation."
  },
  "Ordered": {
    "name": "Ordered",
    "type": "def",
    "signature": "Ordered : RBNode α → Prop",
    "docstring": "The ordering invariant of a red-black tree, which is a binary search tree. This says that every element of a left subtree is less than the root, and every element in the right subtree is greater than the root, where the less than relation `x < y` is understood to mean `cmp x y = .lt`. Because we do not assume that `cmp` is lawful when stating this property, we write it in such a way that if `cmp` is not lawful then the condition holds trivially. That way we can prove the ordering invariants without assuming `cmp` is lawful.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 576,
    "source": "batteries",
    "description": "The ordering invariant of a red-black tree, which is a binary search tree. This says that every element of a left subtree is less than the root, and every element in the right subtree is greater than the root, where the less than relation `x < y` is understood to mean `cmp x y = .lt`. Because we do not assume that `cmp` is lawful when stating this property, we write it in such a way that if `cmp` is not lawful then the condition holds trivially. That way we can prove the ordering invariants without assuming `cmp` is lawful."
  },
  "RBSet": {
    "name": "RBSet",
    "type": "def",
    "signature": "RBSet : Type u",
    "docstring": "An `RBSet` is a self-balancing binary search tree. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 630,
    "source": "batteries",
    "description": "An `RBSet` is a self-balancing binary search tree. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior."
  },
  "Mem": {
    "name": "Mem",
    "type": "def",
    "signature": "Mem : Prop",
    "docstring": "True if `x` is equivalent to an element of `t`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 774,
    "source": "batteries",
    "description": "True if `x` is equivalent to an element of `t`."
  },
  "filter": {
    "name": "filter",
    "type": "def",
    "signature": "filter : RBSet α cmp",
    "docstring": "`O(n * log n)`. Constructs the set of all elements satisfying `p`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 883,
    "source": "batteries",
    "description": "`O(n * log n)`. Constructs the set of all elements satisfying `p`."
  },
  "sdiff": {
    "name": "sdiff",
    "type": "def",
    "signature": "sdiff : RBSet α cmp",
    "docstring": "`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 896,
    "source": "batteries",
    "description": "`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`."
  },
  "RBMap": {
    "name": "RBMap",
    "type": "def",
    "signature": "RBMap : Type (max u v)",
    "docstring": "An `RBMap` is a self-balancing binary search tree, used to store a key-value map. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 909,
    "source": "batteries",
    "description": "An `RBMap` is a self-balancing binary search tree, used to store a key-value map. The `cmp` function is the comparator that will be used for performing searches; it should satisfy the requirements of `TransCmp` for it to have sensible behavior."
  },
  "Keys.toStream": {
    "name": "Keys.toStream",
    "type": "def",
    "signature": "Keys.toStream : Keys.Stream α β",
    "docstring": "A stream over the iterator.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 990,
    "source": "batteries",
    "description": "A stream over the iterator."
  },
  "Values.toStream": {
    "name": "Values.toStream",
    "type": "def",
    "signature": "Values.toStream : Values.Stream α β",
    "docstring": "A stream over the iterator.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 1039,
    "source": "batteries",
    "description": "A stream over the iterator."
  },
  "ModifyWF": {
    "name": "ModifyWF",
    "type": "class",
    "signature": "ModifyWF",
    "docstring": "The predicate asserting that the result of `modifyP` is safe to construct.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 820,
    "source": "batteries",
    "description": "The predicate asserting that the result of `modifyP` is safe to construct."
  },
  "AlterWF": {
    "name": "AlterWF",
    "type": "class",
    "signature": "AlterWF",
    "docstring": "The predicate asserting that the result of `alterP` is safe to construct.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 836,
    "source": "batteries",
    "description": "The predicate asserting that the result of `alterP` is safe to construct."
  },
  "RBColor": {
    "name": "RBColor",
    "type": "inductive",
    "signature": "RBColor",
    "docstring": "In a red-black tree, every node has a color which is either \"red\" or \"black\" (this particular choice of colors is conventional). A nil node is considered black.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 37,
    "source": "batteries",
    "description": "In a red-black tree, every node has a color which is either \"red\" or \"black\" (this particular choice of colors is conventional). A nil node is considered black."
  },
  "RBNode": {
    "name": "RBNode",
    "type": "inductive",
    "signature": "RBNode",
    "docstring": "A red-black tree. (This is an internal implementation detail of the `RBSet` type, which includes the invariants of the tree.) This is a binary search tree augmented with a \"color\" field which is either red or black for each node and used to implement the re-balancing operations. See: [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 51,
    "source": "batteries",
    "description": "A red-black tree. (This is an internal implementation detail of the `RBSet` type, which includes the invariants of the tree.) This is a binary search tree augmented with a \"color\" field which is either red or black for each node and used to implement the re-balancing operations. See: [Red–black tree](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)"
  },
  "Stream": {
    "name": "Stream",
    "type": "inductive",
    "signature": "Stream",
    "docstring": "An auxiliary data structure (an iterator) over an `RBNode` which lazily pulls elements from the left.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 125,
    "source": "batteries",
    "description": "An auxiliary data structure (an iterator) over an `RBNode` which lazily pulls elements from the left."
  },
  "Path": {
    "name": "Path",
    "type": "inductive",
    "signature": "Path",
    "docstring": "A `RBNode.Path α` is a \"cursor\" into an `RBNode` which represents the path from the root to a subtree. Note that the path goes from the target subtree up to the root, which is reversed from the normal way data is stored in the tree. See [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)) for more information.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 458,
    "source": "batteries",
    "description": "A `RBNode.Path α` is a \"cursor\" into an `RBNode` which represents the path from the root to a subtree. Note that the path goes from the target subtree up to the root, which is reversed from the normal way data is stored in the tree. See [Zipper](https://en.wikipedia.org/wiki/Zipper_(data_structure)) for more information."
  },
  "Balanced": {
    "name": "Balanced",
    "type": "inductive",
    "signature": "Balanced : RBNode α → RBColor → Nat → Prop",
    "docstring": "The red-black balance invariant. `Balanced t c n` says that the color of the root node is `c`, and the black-height (the number of black nodes on any path from the root) of the tree is `n`. Additionally, every red node must have black children.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 595,
    "source": "batteries",
    "description": "The red-black balance invariant. `Balanced t c n` says that the color of the root node is `c`, and the black-height (the number of black nodes on any path from the root) of the tree is `n`. Additionally, every red node must have black children."
  },
  "WF": {
    "name": "WF",
    "type": "inductive",
    "signature": "WF : RBNode α → Prop",
    "docstring": "The well-formedness invariant for a red-black tree. The first constructor is the real invariant, and the others allow us to \"cheat\" in this file and define `insert` and `erase`, which have more complex proofs that are delayed to `Batteries.Data.RBMap.Lemmas`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Basic.lean",
    "line_number": 610,
    "source": "batteries",
    "description": "The well-formedness invariant for a red-black tree. The first constructor is the real invariant, and the others allow us to \"cheat\" in this file and define `insert` and `erase`, which have more complex proofs that are delayed to `Batteries.Data.RBMap.Lemmas`."
  },
  "OnRoot": {
    "name": "OnRoot",
    "type": "def",
    "signature": "OnRoot : RBNode α → Prop",
    "docstring": "Asserts that property `p` holds on the root of the tree, if any.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 29,
    "source": "batteries",
    "description": "Asserts that property `p` holds on the root of the tree, if any."
  },
  "Zoomed": {
    "name": "Zoomed",
    "type": "def",
    "signature": "Zoomed : Path α → Prop",
    "docstring": "The property of a path returned by `t.zoom cut`. Each of the parents visited along the path have the appropriate ordering relation to the cut.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 136,
    "source": "batteries",
    "description": "The property of a path returned by `t.zoom cut`. Each of the parents visited along the path have the appropriate ordering relation to the cut."
  },
  "RootOrdered": {
    "name": "RootOrdered",
    "type": "def",
    "signature": "RootOrdered : Path α → α → Prop",
    "docstring": "`path.RootOrdered cmp v` is true if `v` would be able to fit into the hole without violating the ordering invariant.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 155,
    "source": "batteries",
    "description": "`path.RootOrdered cmp v` is true if `v` would be able to fit into the hole without violating the ordering invariant."
  },
  "modify": {
    "name": "modify",
    "type": "def",
    "signature": "modify : RBMap α β cmp",
    "docstring": "`O(log n)`. In-place replace the corresponding to key `k`. This takes the element out of the tree while `f` runs, so it uses the element linearly if `t` is unshared.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 347,
    "source": "batteries",
    "description": "`O(log n)`. In-place replace the corresponding to key `k`. This takes the element out of the tree while `f` runs, so it uses the element linearly if `t` is unshared."
  },
  "alter.adapt": {
    "name": "alter.adapt",
    "type": "def",
    "signature": "alter.adapt : Option (α × β) → Option (α × β)",
    "docstring": "Auxiliary definition for `alter`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 352,
    "source": "batteries",
    "description": "Auxiliary definition for `alter`."
  },
  "_root_.Batteries.RBNode.Balanced.zoom": {
    "name": "_root_.Batteries.RBNode.Balanced.zoom",
    "type": "theorem",
    "signature": "_root_.Batteries.RBNode.Balanced.zoom : t.Balanced c n → path.Balanced c₀ n₀ c n →",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/Alter.lean",
    "line_number": 79,
    "source": "batteries",
    "description": "Proves that a balanced red-black tree can be transformed into a balanced path while preserving its properties."
  },
  "DelProp": {
    "name": "DelProp",
    "type": "def",
    "signature": "DelProp : Prop",
    "docstring": "The invariant of the `del` function. * If the input tree is black, then the result of deletion is a red-red tree with black-height lowered by 1. * If the input tree is red or nil, then the result of deletion is a balanced tree with some color and the same black-height.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 444,
    "source": "batteries",
    "description": "The invariant of the `del` function. * If the input tree is black, then the result of deletion is a red-red tree with black-height lowered by 1. * If the input tree is red or nil, then the result of deletion is a balanced tree with some color and the same black-height."
  },
  "mapVal": {
    "name": "mapVal",
    "type": "def",
    "signature": "mapVal : RBMap α γ cmp",
    "docstring": "`O(n)`. Map a function on the values in the map.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 594,
    "source": "batteries",
    "description": "`O(n)`. Map a function on the values in the map."
  },
  "cmpLT.flip": {
    "name": "cmpLT.flip",
    "type": "theorem",
    "signature": "cmpLT.flip : cmpLT (flip cmp) y x",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 33,
    "source": "batteries",
    "description": "Proves that flipping the comparison function `cmp` reverses the order of comparison for two elements `x` and `y`."
  },
  "cmpLT.trans": {
    "name": "cmpLT.trans",
    "type": "theorem",
    "signature": "cmpLT.trans : cmpLT cmp x z",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 36,
    "source": "batteries",
    "description": "Proves that if x is less than y and y is less than z, then x is less than z in a comparison context."
  },
  "cmpEq.lt_congr_left": {
    "name": "cmpEq.lt_congr_left",
    "type": "theorem",
    "signature": "cmpEq.lt_congr_left : cmpLT cmp x z ↔ cmpLT cmp y z",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 45,
    "source": "batteries",
    "description": "If two comparisons are equal, then the left side of the comparison can be changed without affecting the result."
  },
  "cmpEq.lt_congr_right": {
    "name": "cmpEq.lt_congr_right",
    "type": "theorem",
    "signature": "cmpEq.lt_congr_right : cmpLT cmp x y ↔ cmpLT cmp x z",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 48,
    "source": "batteries",
    "description": "If two comparisons are equal, then the result of comparing one element with two others is equivalent, preserving the order."
  },
  "Balanced.setBlack": {
    "name": "Balanced.setBlack",
    "type": "theorem",
    "signature": "Balanced.setBlack : t.Balanced c n → ∃ n', (setBlack t).Balanced black n'",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 116,
    "source": "batteries",
    "description": "Proves that setting a node to black in a balanced tree results in another balanced tree with a potentially different size."
  },
  "Ordered.insert": {
    "name": "Ordered.insert",
    "type": "theorem",
    "signature": "Ordered.insert : (insert cmp t v).Ordered cmp",
    "docstring": "The `insert` function preserves the ordering invariants.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 167,
    "source": "batteries",
    "description": "The `insert` function preserves the ordering invariants."
  },
  "RedRed.of_false": {
    "name": "RedRed.of_false",
    "type": "theorem",
    "signature": "RedRed.of_false : RedRed p t n → ∃ c, Balanced t c n",
    "docstring": "When `p` is false, the red-red case is impossible so the tree is balanced.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 185,
    "source": "batteries",
    "description": "When `p` is false, the red-red case is impossible so the tree is balanced."
  },
  "RedRed.of_red": {
    "name": "RedRed.of_red",
    "type": "theorem",
    "signature": "RedRed.of_red : RedRed p (node red a x b) n →",
    "docstring": "A `red` node with the red-red invariant has balanced children.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 190,
    "source": "batteries",
    "description": "A `red` node with the red-red invariant has balanced children."
  },
  "RedRed.imp": {
    "name": "RedRed.imp",
    "type": "theorem",
    "signature": "RedRed.imp : RedRed p t n → RedRed q t n",
    "docstring": "The red-red invariant is monotonic in `p`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 195,
    "source": "batteries",
    "description": "The red-red invariant is monotonic in `p`."
  },
  "RedRed.reverse": {
    "name": "RedRed.reverse",
    "type": "theorem",
    "signature": "RedRed.reverse : RedRed p t n → RedRed p t.reverse n",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 198,
    "source": "batteries",
    "description": "Proves that reversing a RedRed tree maintains its RedRed properties."
  },
  "RedRed.setBlack": {
    "name": "RedRed.setBlack",
    "type": "theorem",
    "signature": "RedRed.setBlack : t.RedRed p n → ∃ n', (setBlack t).Balanced black n'",
    "docstring": "If `t` has the red-red invariant, then setting the root to black yields a balanced tree.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 204,
    "source": "batteries",
    "description": "If `t` has the red-red invariant, then setting the root to black yields a balanced tree."
  },
  "All.balLeft": {
    "name": "All.balLeft",
    "type": "theorem",
    "signature": "All.balLeft : (balLeft l v r).All p",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 298,
    "source": "batteries",
    "description": "Proves that if a tree is balanced to the left with a value and two subtrees, then all elements in the tree satisfy property p."
  },
  "All.balRight": {
    "name": "All.balRight",
    "type": "theorem",
    "signature": "All.balRight : (balRight l v r).All p",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 332,
    "source": "batteries",
    "description": "Proves that if a binary tree is balanced to the right, then all elements in the tree satisfy a given property p."
  },
  "All.append": {
    "name": "All.append",
    "type": "theorem",
    "signature": "All.append : (append l r).All p",
    "docstring": null,
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 352,
    "source": "batteries",
    "description": "Proves that if a property holds for all elements in two lists, it also holds for the concatenated list."
  },
  "IsMonotone": {
    "name": "IsMonotone",
    "type": "class",
    "signature": "IsMonotone",
    "docstring": "The property of a map function `f` which ensures the `map` operation is valid.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 536,
    "source": "batteries",
    "description": "The property of a map function `f` which ensures the `map` operation is valid."
  },
  "RedRed": {
    "name": "RedRed",
    "type": "inductive",
    "signature": "RedRed : RBNode α → Nat → Prop",
    "docstring": "The red-red invariant is a weakening of the red-black balance invariant which allows the root to be red with red children, but does not allow any other violations. It occurs as a temporary condition in the `insert` and `erase` functions. The `p` parameter allows the `.redred` case to be dependent on an additional condition. If it is false, then this is equivalent to the usual red-black invariant.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Data/RBMap/WF.lean",
    "line_number": 178,
    "source": "batteries",
    "description": "The red-red invariant is a weakening of the red-black balance invariant which allows the root to be red with red children, but does not allow any other violations. It occurs as a temporary condition in the `insert` and `erase` functions. The `p` parameter allows the `.redred` case to be dependent on an additional condition. If it is false, then this is equivalent to the usual red-black invariant."
  },
  "nil": {
    "name": "nil",
    "type": "def",
    "signature": "nil : Nondet m α",
    "docstring": "The empty nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 64,
    "source": "batteries",
    "description": "The empty nondeterministic value."
  },
  "singletonM": {
    "name": "singletonM",
    "type": "def",
    "signature": "singletonM : Nondet m α",
    "docstring": "Convert any value in the monad to the singleton nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 89,
    "source": "batteries",
    "description": "Convert any value in the monad to the singleton nondeterministic value."
  },
  "ofListM": {
    "name": "ofListM",
    "type": "def",
    "signature": "ofListM : Nondet m α",
    "docstring": "Lift a list of monadic values to a nondeterministic value. We ensure that each monadic value is evaluated with the same backtrackable state.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 111,
    "source": "batteries",
    "description": "Lift a list of monadic values to a nondeterministic value. We ensure that each monadic value is evaluated with the same backtrackable state."
  },
  "mapM": {
    "name": "mapM",
    "type": "def",
    "signature": "mapM : Nondet m β",
    "docstring": "Apply a function which returns values in the monad to every alternative of a `Nondet m α`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 127,
    "source": "batteries",
    "description": "Apply a function which returns values in the monad to every alternative of a `Nondet m α`."
  },
  "ofOptionM": {
    "name": "ofOptionM",
    "type": "def",
    "signature": "ofOptionM : Nondet m α",
    "docstring": "Convert a monadic optional value to a nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 135,
    "source": "batteries",
    "description": "Convert a monadic optional value to a nondeterministic value."
  },
  "ofOption": {
    "name": "ofOption",
    "type": "def",
    "signature": "ofOption : Nondet m α",
    "docstring": "Convert an optional value to a nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 141,
    "source": "batteries",
    "description": "Convert an optional value to a nondeterministic value."
  },
  "filterMapM": {
    "name": "filterMapM",
    "type": "def",
    "signature": "filterMapM : Nondet m β",
    "docstring": "Filter and map a nondeterministic value using a monadic function which may return `none`.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 144,
    "source": "batteries",
    "description": "Filter and map a nondeterministic value using a monadic function which may return `none`."
  },
  "filterMap": {
    "name": "filterMap",
    "type": "def",
    "signature": "filterMap : Nondet m β",
    "docstring": "Filter and map a nondeterministic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 148,
    "source": "batteries",
    "description": "Filter and map a nondeterministic value."
  },
  "filterM": {
    "name": "filterM",
    "type": "def",
    "signature": "filterM : Nondet m α",
    "docstring": "Filter a nondeterministic value using a monadic predicate.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 152,
    "source": "batteries",
    "description": "Filter a nondeterministic value using a monadic predicate."
  },
  "head": {
    "name": "head",
    "type": "def",
    "signature": "head : m α",
    "docstring": "Find the first alternative in a nondeterministic value, as a monadic value.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 194,
    "source": "batteries",
    "description": "Find the first alternative in a nondeterministic value, as a monadic value."
  },
  "firstM": {
    "name": "firstM",
    "type": "def",
    "signature": "firstM : m β",
    "docstring": "Find the value of a monadic function on the first alternative in a nondeterministic value where the function succeeds.",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 203,
    "source": "batteries",
    "description": "Find the value of a monadic function on the first alternative in a nondeterministic value where the function succeeds."
  },
  "Nondet": {
    "name": "Nondet",
    "type": "structure",
    "signature": "Nondet",
    "docstring": "`Nondet m α` is variation on `MLList m α` suitable for use with backtrackable monads `m`. We think of `Nondet m α` as a nondeterministic value in `α`, with the possible alternatives stored in a monadic lazy list. Along with each `a : α` we store the backtrackable state, and ensure that monadic operations on alternatives run with the appropriate state. Operations on the nondeterministic value via `bind`, `mapM`, and `filterMapM` run with the appropriate backtrackable state, and are responsible for updating the state themselves (typically this doesn't need to be done explicitly, but just happens as a side effect in the monad `m`).",
    "file_path": "Users/silveregangloff/Desktop/Tactic generation/tactics_generation/.lake/packages/batteries/Batteries/Control/Nondet/Basic.lean",
    "line_number": 50,
    "source": "batteries",
    "description": "`Nondet m α` is variation on `MLList m α` suitable for use with backtrackable monads `m`. We think of `Nondet m α` as a nondeterministic value in `α`, with the possible alternatives stored in a monadic lazy list. Along with each `a : α` we store the backtrackable state, and ensure that monadic operations on alternatives run with the appropriate state. Operations on the nondeterministic value via `bind`, `mapM`, and `filterMapM` run with the appropriate backtrackable state, and are responsible for updating the state themselves (typically this doesn't need to be done explicitly, but just happens as a side effect in the monad `m`)."
  }
}